; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdpostct.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdpostct.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdpostct.crf GUI\JPEG\jdpostct.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  post_process_2pass PROC
;;;203    METHODDEF(void)
;;;204    post_process_2pass (j_decompress_ptr cinfo,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;205    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;206    		    JDIMENSION in_row_groups_avail,
;;;207    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;208    		    JDIMENSION out_rows_avail)
;;;209    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  469b              MOV      r11,r3
00000c  f8dd802c          LDR      r8,[sp,#0x2c]
;;;210      my_post_ptr post = (my_post_ptr) cinfo->post;
000010  f8d641b0          LDR      r4,[r6,#0x1b0]
;;;211      JDIMENSION num_rows, max_rows;
;;;212    
;;;213      GUI_USE_PARA(in_row_groups_avail);
000014  bf00              NOP      
;;;214      GUI_USE_PARA(in_row_group_ctr);
000016  bf00              NOP      
;;;215      GUI_USE_PARA(input_buf);
000018  bf00              NOP      
;;;216      /* Reposition virtual buffer if at start of strip. */
;;;217      if (post->next_row == 0) {
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  b950              CBNZ     r0,|L1.52|
;;;218        post->buffer = (*cinfo->mem->access_virt_sarray)
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
000022  e9d43204          LDRD     r3,r2,[r4,#0x10]
000026  68a1              LDR      r1,[r4,#8]
000028  6870              LDR      r0,[r6,#4]
00002a  f8d0c01c          LDR      r12,[r0,#0x1c]
00002e  4630              MOV      r0,r6
000030  47e0              BLX      r12
000032  60e0              STR      r0,[r4,#0xc]
                  |L1.52|
;;;219    	((j_common_ptr) cinfo, post->whole_image,
;;;220    	 post->starting_row, post->strip_height, FALSE);
;;;221      }
;;;222    
;;;223      /* Determine number of rows to emit. */
;;;224      num_rows = post->strip_height - post->next_row; /* available in strip */
000034  69a1              LDR      r1,[r4,#0x18]
000036  6920              LDR      r0,[r4,#0x10]
000038  eba00501          SUB      r5,r0,r1
;;;225      max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
00003c  f8d81000          LDR      r1,[r8,#0]
000040  980c              LDR      r0,[sp,#0x30]
000042  eba00701          SUB      r7,r0,r1
;;;226      if (num_rows > max_rows)
000046  42bd              CMP      r5,r7
000048  d900              BLS      |L1.76|
;;;227        num_rows = max_rows;
00004a  463d              MOV      r5,r7
                  |L1.76|
;;;228      /* We have to check bottom of image here, can't depend on upsampler. */
;;;229      max_rows = cinfo->output_height - post->starting_row;
00004c  6f70              LDR      r0,[r6,#0x74]
00004e  6961              LDR      r1,[r4,#0x14]
000050  eba00701          SUB      r7,r0,r1
;;;230      if (num_rows > max_rows)
000054  42bd              CMP      r5,r7
000056  d900              BLS      |L1.90|
;;;231        num_rows = max_rows;
000058  463d              MOV      r5,r7
                  |L1.90|
;;;232    
;;;233      /* Quantize and emit data. */
;;;234      (*cinfo->cquantize->color_quantize) (cinfo,
00005a  69a3              LDR      r3,[r4,#0x18]
00005c  68e0              LDR      r0,[r4,#0xc]
00005e  eb000183          ADD      r1,r0,r3,LSL #2
000062  f8d83000          LDR      r3,[r8,#0]
000066  980a              LDR      r0,[sp,#0x28]
000068  eb000283          ADD      r2,r0,r3,LSL #2
00006c  f8d601cc          LDR      r0,[r6,#0x1cc]
000070  462b              MOV      r3,r5
000072  f8d0c004          LDR      r12,[r0,#4]
000076  4630              MOV      r0,r6
000078  47e0              BLX      r12
;;;235    		post->buffer + post->next_row, output_buf + *out_row_ctr,
;;;236    		(int) num_rows);
;;;237      *out_row_ctr += num_rows;
00007a  f8d80000          LDR      r0,[r8,#0]
00007e  4428              ADD      r0,r0,r5
000080  f8c80000          STR      r0,[r8,#0]
;;;238    
;;;239      /* Advance if we filled the strip. */
;;;240      post->next_row += num_rows;
000084  69a0              LDR      r0,[r4,#0x18]
000086  4428              ADD      r0,r0,r5
000088  61a0              STR      r0,[r4,#0x18]
;;;241      if (post->next_row >= post->strip_height) {
00008a  6921              LDR      r1,[r4,#0x10]
00008c  69a0              LDR      r0,[r4,#0x18]
00008e  4288              CMP      r0,r1
000090  d306              BCC      |L1.160|
;;;242        post->starting_row += post->strip_height;
000092  e9d41004          LDRD     r1,r0,[r4,#0x10]
000096  4408              ADD      r0,r0,r1
000098  6160              STR      r0,[r4,#0x14]
;;;243        post->next_row = 0;
00009a  f04f0000          MOV      r0,#0
00009e  61a0              STR      r0,[r4,#0x18]
                  |L1.160|
;;;244      }
;;;245    }
0000a0  e8bd8ff8          POP      {r3-r11,pc}
;;;246    
                          ENDP

                  post_process_prepass PROC
;;;157    METHODDEF(void)
;;;158    post_process_prepass (j_decompress_ptr cinfo,
0000a4  e92d4fff          PUSH     {r0-r11,lr}
;;;159    		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;160    		      JDIMENSION in_row_groups_avail,
;;;161    		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;162    		      JDIMENSION out_rows_avail)
;;;163    {
0000a8  b083              SUB      sp,sp,#0xc
0000aa  4605              MOV      r5,r0
0000ac  468b              MOV      r11,r1
0000ae  e9dd8a11          LDRD     r8,r10,[sp,#0x44]
0000b2  f8dd9040          LDR      r9,[sp,#0x40]
;;;164      my_post_ptr post = (my_post_ptr) cinfo->post;
0000b6  f8d541b0          LDR      r4,[r5,#0x1b0]
;;;165      JDIMENSION old_next_row, num_rows;
;;;166    
;;;167      GUI_USE_PARA(out_rows_avail);
0000ba  bf00              NOP      
;;;168      GUI_USE_PARA(output_buf);
0000bc  bf00              NOP      
;;;169      /* Reposition virtual buffer if at start of strip. */
;;;170      if (post->next_row == 0) {
0000be  69a0              LDR      r0,[r4,#0x18]
0000c0  b950              CBNZ     r0,|L1.216|
;;;171        post->buffer = (*cinfo->mem->access_virt_sarray)
0000c2  2001              MOVS     r0,#1
0000c4  9000              STR      r0,[sp,#0]
0000c6  e9d43204          LDRD     r3,r2,[r4,#0x10]
0000ca  68a1              LDR      r1,[r4,#8]
0000cc  6868              LDR      r0,[r5,#4]
0000ce  f8d0c01c          LDR      r12,[r0,#0x1c]
0000d2  4628              MOV      r0,r5
0000d4  47e0              BLX      r12
0000d6  60e0              STR      r0,[r4,#0xc]
                  |L1.216|
;;;172    	((j_common_ptr) cinfo, post->whole_image,
;;;173    	 post->starting_row, post->strip_height, TRUE);
;;;174      }
;;;175    
;;;176      /* Upsample some data (up to a strip height's worth). */
;;;177      old_next_row = post->next_row;
0000d8  69a6              LDR      r6,[r4,#0x18]
;;;178      (*cinfo->upsample->upsample) (cinfo,
0000da  f1040118          ADD      r1,r4,#0x18
0000de  e9d42003          LDRD     r2,r0,[r4,#0xc]
0000e2  e9cd2100          STRD     r2,r1,[sp,#0]
0000e6  9002              STR      r0,[sp,#8]
0000e8  f8d501c4          LDR      r0,[r5,#0x1c4]
0000ec  f8d0c004          LDR      r12,[r0,#4]
0000f0  4659              MOV      r1,r11
0000f2  4628              MOV      r0,r5
0000f4  e9dd2305          LDRD     r2,r3,[sp,#0x14]
0000f8  47e0              BLX      r12
;;;179    		input_buf, in_row_group_ctr, in_row_groups_avail,
;;;180    		post->buffer, &post->next_row, post->strip_height);
;;;181    
;;;182      /* Allow quantizer to scan new data.  No data is emitted, */
;;;183      /* but we advance out_row_ctr so outer loop can tell when we're done. */
;;;184      if (post->next_row > old_next_row) {
0000fa  69a0              LDR      r0,[r4,#0x18]
0000fc  42b0              CMP      r0,r6
0000fe  d913              BLS      |L1.296|
;;;185        num_rows = post->next_row - old_next_row;
000100  69a0              LDR      r0,[r4,#0x18]
000102  eba00706          SUB      r7,r0,r6
;;;186        (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
000106  68e0              LDR      r0,[r4,#0xc]
000108  eb000186          ADD      r1,r0,r6,LSL #2
00010c  f8d501cc          LDR      r0,[r5,#0x1cc]
000110  463b              MOV      r3,r7
000112  f04f0200          MOV      r2,#0
000116  f8d0c004          LDR      r12,[r0,#4]
00011a  4628              MOV      r0,r5
00011c  47e0              BLX      r12
;;;187    					 (JSAMPARRAY) NULL, (int) num_rows);
;;;188        *out_row_ctr += num_rows;
00011e  f8d80000          LDR      r0,[r8,#0]
000122  4438              ADD      r0,r0,r7
000124  f8c80000          STR      r0,[r8,#0]
                  |L1.296|
;;;189      }
;;;190    
;;;191      /* Advance if we filled the strip. */
;;;192      if (post->next_row >= post->strip_height) {
000128  6921              LDR      r1,[r4,#0x10]
00012a  69a0              LDR      r0,[r4,#0x18]
00012c  4288              CMP      r0,r1
00012e  d306              BCC      |L1.318|
;;;193        post->starting_row += post->strip_height;
000130  e9d41004          LDRD     r1,r0,[r4,#0x10]
000134  4408              ADD      r0,r0,r1
000136  6160              STR      r0,[r4,#0x14]
;;;194        post->next_row = 0;
000138  f04f0000          MOV      r0,#0
00013c  61a0              STR      r0,[r4,#0x18]
                  |L1.318|
;;;195      }
;;;196    }
00013e  b007              ADD      sp,sp,#0x1c
000140  e8bd8ff0          POP      {r4-r11,pc}
;;;197    
                          ENDP

                  post_process_1pass PROC
;;;125    METHODDEF(void)
;;;126    post_process_1pass (j_decompress_ptr cinfo,
000144  e92d4fff          PUSH     {r0-r11,lr}
;;;127    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;128    		    JDIMENSION in_row_groups_avail,
;;;129    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;130    		    JDIMENSION out_rows_avail)
;;;131    {
000148  b085              SUB      sp,sp,#0x14
00014a  4604              MOV      r4,r0
00014c  4688              MOV      r8,r1
00014e  4693              MOV      r11,r2
000150  e9dd5a13          LDRD     r5,r10,[sp,#0x4c]
000154  f8dd9048          LDR      r9,[sp,#0x48]
;;;132      my_post_ptr post = (my_post_ptr) cinfo->post;
000158  f8d461b0          LDR      r6,[r4,#0x1b0]
;;;133      JDIMENSION num_rows, max_rows;
;;;134    
;;;135      /* Fill the buffer, but not more than what we can dump out in one go. */
;;;136      /* Note we rely on the upsampler to detect bottom of image. */
;;;137      max_rows = out_rows_avail - *out_row_ctr;
00015c  6828              LDR      r0,[r5,#0]
00015e  ebaa0700          SUB      r7,r10,r0
;;;138      if (max_rows > post->strip_height)
000162  6930              LDR      r0,[r6,#0x10]
000164  42b8              CMP      r0,r7
000166  d200              BCS      |L1.362|
;;;139        max_rows = post->strip_height;
000168  6937              LDR      r7,[r6,#0x10]
                  |L1.362|
;;;140      num_rows = 0;
00016a  f04f0000          MOV      r0,#0
00016e  9004              STR      r0,[sp,#0x10]
;;;141      (*cinfo->upsample->upsample) (cinfo,
000170  a904              ADD      r1,sp,#0x10
000172  68f0              LDR      r0,[r6,#0xc]
000174  e88d0083          STM      sp,{r0,r1,r7}
000178  f8d401c4          LDR      r0,[r4,#0x1c4]
00017c  f8d0c004          LDR      r12,[r0,#4]
000180  465a              MOV      r2,r11
000182  4641              MOV      r1,r8
000184  4620              MOV      r0,r4
000186  9b08              LDR      r3,[sp,#0x20]
000188  47e0              BLX      r12
;;;142    		input_buf, in_row_group_ctr, in_row_groups_avail,
;;;143    		post->buffer, &num_rows, max_rows);
;;;144      /* Quantize and emit data. */
;;;145      (*cinfo->cquantize->color_quantize) (cinfo,
00018a  6828              LDR      r0,[r5,#0]
00018c  eb090280          ADD      r2,r9,r0,LSL #2
000190  68f1              LDR      r1,[r6,#0xc]
000192  f8d401cc          LDR      r0,[r4,#0x1cc]
000196  f8d0c004          LDR      r12,[r0,#4]
00019a  4620              MOV      r0,r4
00019c  9b04              LDR      r3,[sp,#0x10]
00019e  47e0              BLX      r12
;;;146    		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
;;;147      *out_row_ctr += num_rows;
0001a0  6828              LDR      r0,[r5,#0]
0001a2  9904              LDR      r1,[sp,#0x10]
0001a4  4408              ADD      r0,r0,r1
0001a6  6028              STR      r0,[r5,#0]
;;;148    }
0001a8  b009              ADD      sp,sp,#0x24
0001aa  e8bd8ff0          POP      {r4-r11,pc}
;;;149    
                          ENDP

                  start_pass_dpost PROC
;;;72     METHODDEF(void)
;;;73     start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
0001ae  b5f8              PUSH     {r3-r7,lr}
;;;74     {
0001b0  4605              MOV      r5,r0
0001b2  460e              MOV      r6,r1
;;;75       my_post_ptr post = (my_post_ptr) cinfo->post;
0001b4  f8d541b0          LDR      r4,[r5,#0x1b0]
;;;76     
;;;77       switch (pass_mode) {
0001b8  b126              CBZ      r6,|L1.452|
0001ba  2e02              CMP      r6,#2
0001bc  d025              BEQ      |L1.522|
0001be  2e03              CMP      r6,#3
0001c0  d130              BNE      |L1.548|
0001c2  e015              B        |L1.496|
                  |L1.452|
;;;78       case JBUF_PASS_THRU:
;;;79         if (cinfo->quantize_colors) {
0001c4  6d68              LDR      r0,[r5,#0x54]
0001c6  b170              CBZ      r0,|L1.486|
;;;80           /* Single-pass processing with color quantization. */
;;;81           post->pub.post_process_data = post_process_1pass;
0001c8  483c              LDR      r0,|L1.700|
0001ca  6060              STR      r0,[r4,#4]
;;;82           /* We could be doing buffered-image output before starting a 2-pass
;;;83            * color quantization; in that case, jinit_d_post_controller did not
;;;84            * allocate a strip buffer.  Use the virtual-array buffer as workspace.
;;;85            */
;;;86           if (post->buffer == NULL) {
0001cc  68e0              LDR      r0,[r4,#0xc]
0001ce  b970              CBNZ     r0,|L1.494|
;;;87     	post->buffer = (*cinfo->mem->access_virt_sarray)
0001d0  2001              MOVS     r0,#1
0001d2  9000              STR      r0,[sp,#0]
0001d4  6923              LDR      r3,[r4,#0x10]
0001d6  68a1              LDR      r1,[r4,#8]
0001d8  6868              LDR      r0,[r5,#4]
0001da  2200              MOVS     r2,#0
0001dc  69c7              LDR      r7,[r0,#0x1c]
0001de  4628              MOV      r0,r5
0001e0  47b8              BLX      r7
0001e2  60e0              STR      r0,[r4,#0xc]
0001e4  e003              B        |L1.494|
                  |L1.486|
;;;88     	  ((j_common_ptr) cinfo, post->whole_image,
;;;89     	   (JDIMENSION) 0, post->strip_height, TRUE);
;;;90           }
;;;91         } else {
;;;92           /* For single-pass processing without color quantization,
;;;93            * I have no work to do; just call the upsampler directly.
;;;94            */
;;;95           post->pub.post_process_data = cinfo->upsample->upsample;
0001e6  f8d501c4          LDR      r0,[r5,#0x1c4]
0001ea  6840              LDR      r0,[r0,#4]
0001ec  6060              STR      r0,[r4,#4]
                  |L1.494|
;;;96         }
;;;97         break;
0001ee  e022              B        |L1.566|
                  |L1.496|
;;;98     #ifdef QUANT_2PASS_SUPPORTED
;;;99       case JBUF_SAVE_AND_PASS:
;;;100        /* First pass of 2-pass quantization */
;;;101        if (post->whole_image == NULL)
0001f0  68a0              LDR      r0,[r4,#8]
0001f2  b938              CBNZ     r0,|L1.516|
;;;102          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
0001f4  f04f0004          MOV      r0,#4
0001f8  6829              LDR      r1,[r5,#0]
0001fa  6148              STR      r0,[r1,#0x14]
0001fc  6828              LDR      r0,[r5,#0]
0001fe  6801              LDR      r1,[r0,#0]
000200  4628              MOV      r0,r5
000202  4788              BLX      r1
                  |L1.516|
;;;103        post->pub.post_process_data = post_process_prepass;
000204  482e              LDR      r0,|L1.704|
000206  6060              STR      r0,[r4,#4]
;;;104        break;
000208  e015              B        |L1.566|
                  |L1.522|
;;;105      case JBUF_CRANK_DEST:
;;;106        /* Second pass of 2-pass quantization */
;;;107        if (post->whole_image == NULL)
00020a  68a0              LDR      r0,[r4,#8]
00020c  b938              CBNZ     r0,|L1.542|
;;;108          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
00020e  f04f0004          MOV      r0,#4
000212  6829              LDR      r1,[r5,#0]
000214  6148              STR      r0,[r1,#0x14]
000216  6828              LDR      r0,[r5,#0]
000218  6801              LDR      r1,[r0,#0]
00021a  4628              MOV      r0,r5
00021c  4788              BLX      r1
                  |L1.542|
;;;109        post->pub.post_process_data = post_process_2pass;
00021e  4829              LDR      r0,|L1.708|
000220  6060              STR      r0,[r4,#4]
;;;110        break;
000222  e008              B        |L1.566|
                  |L1.548|
;;;111    #endif /* QUANT_2PASS_SUPPORTED */
;;;112      default:
;;;113        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000224  f04f0004          MOV      r0,#4
000228  6829              LDR      r1,[r5,#0]
00022a  6148              STR      r0,[r1,#0x14]
00022c  6828              LDR      r0,[r5,#0]
00022e  6801              LDR      r1,[r0,#0]
000230  4628              MOV      r0,r5
000232  4788              BLX      r1
;;;114        break;
000234  bf00              NOP      
                  |L1.566|
000236  bf00              NOP                            ;97
;;;115      }
;;;116      post->starting_row = post->next_row = 0;
000238  f04f0000          MOV      r0,#0
00023c  61a0              STR      r0,[r4,#0x18]
00023e  6160              STR      r0,[r4,#0x14]
;;;117    }
000240  bdf8              POP      {r3-r7,pc}
;;;118    
                          ENDP

                  jinit_d_post_controller PROC
;;;254    GLOBAL(void)
;;;255    jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
000242  e92d41fc          PUSH     {r2-r8,lr}
;;;256    {
000246  4604              MOV      r4,r0
000248  460e              MOV      r6,r1
;;;257      my_post_ptr post;
;;;258    
;;;259      post = (my_post_ptr)
00024a  6860              LDR      r0,[r4,#4]
00024c  f04f021c          MOV      r2,#0x1c
000250  f04f0101          MOV      r1,#1
000254  6803              LDR      r3,[r0,#0]
000256  4620              MOV      r0,r4
000258  4798              BLX      r3
00025a  4605              MOV      r5,r0
;;;260        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;261    				SIZEOF(my_post_controller));
;;;262      cinfo->post = (struct jpeg_d_post_controller *) post;
00025c  f8c451b0          STR      r5,[r4,#0x1b0]
;;;263      post->pub.start_pass = start_pass_dpost;
000260  4819              LDR      r0,|L1.712|
000262  6028              STR      r0,[r5,#0]
;;;264      post->whole_image = NULL;	/* flag for no virtual arrays */
000264  f04f0000          MOV      r0,#0
000268  60a8              STR      r0,[r5,#8]
;;;265      post->buffer = NULL;		/* flag for no strip buffer */
00026a  60e8              STR      r0,[r5,#0xc]
;;;266    
;;;267      /* Create the quantization buffer, if needed */
;;;268      if (cinfo->quantize_colors) {
00026c  6d60              LDR      r0,[r4,#0x54]
00026e  b318              CBZ      r0,|L1.696|
;;;269        /* The buffer strip height is max_v_samp_factor, which is typically
;;;270         * an efficient number of rows for upsampling to return.
;;;271         * (In the presence of output rescaling, we might want to be smarter?)
;;;272         */
;;;273        post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
000270  f8d40138          LDR      r0,[r4,#0x138]
000274  6128              STR      r0,[r5,#0x10]
;;;274        if (need_full_buffer) {
000276  b1a6              CBZ      r6,|L1.674|
;;;275          /* Two-pass color quantization: need full-image storage. */
;;;276          /* We round up the number of rows to a multiple of the strip height. */
;;;277    #ifdef QUANT_2PASS_SUPPORTED
;;;278          post->whole_image = (*cinfo->mem->request_virt_sarray)
000278  6929              LDR      r1,[r5,#0x10]
00027a  6f60              LDR      r0,[r4,#0x74]
00027c  f7fffffe          BL       jround_up
000280  4607              MOV      r7,r0
000282  6928              LDR      r0,[r5,#0x10]
000284  e9cd7000          STRD     r7,r0,[sp,#0]
000288  6fa1              LDR      r1,[r4,#0x78]
00028a  6f20              LDR      r0,[r4,#0x70]
00028c  fb00f301          MUL      r3,r0,r1
000290  6860              LDR      r0,[r4,#4]
000292  2200              MOVS     r2,#0
000294  2101              MOVS     r1,#1
000296  f8d0c010          LDR      r12,[r0,#0x10]
00029a  4620              MOV      r0,r4
00029c  47e0              BLX      r12
00029e  60a8              STR      r0,[r5,#8]
0002a0  e00a              B        |L1.696|
                  |L1.674|
;;;279    	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
;;;280    	 cinfo->output_width * cinfo->out_color_components,
;;;281    	 (JDIMENSION) jround_up((long) cinfo->output_height,
;;;282    				(long) post->strip_height),
;;;283    	 post->strip_height);
;;;284    #else
;;;285          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
;;;286    #endif /* QUANT_2PASS_SUPPORTED */
;;;287        } else {
;;;288          /* One-pass color quantization: just make a strip buffer. */
;;;289          post->buffer = (*cinfo->mem->alloc_sarray)
0002a2  6fa1              LDR      r1,[r4,#0x78]
0002a4  6f20              LDR      r0,[r4,#0x70]
0002a6  fb00f201          MUL      r2,r0,r1
0002aa  692b              LDR      r3,[r5,#0x10]
0002ac  6860              LDR      r0,[r4,#4]
0002ae  2101              MOVS     r1,#1
0002b0  6887              LDR      r7,[r0,#8]
0002b2  4620              MOV      r0,r4
0002b4  47b8              BLX      r7
0002b6  60e8              STR      r0,[r5,#0xc]
                  |L1.696|
;;;290    	((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;291    	 cinfo->output_width * cinfo->out_color_components,
;;;292    	 post->strip_height);
;;;293        }
;;;294      }
;;;295    }
0002b8  e8bd81fc          POP      {r2-r8,pc}
                          ENDP

                  |L1.700|
                          DCD      post_process_1pass
                  |L1.704|
                          DCD      post_process_prepass
                  |L1.708|
                          DCD      post_process_2pass
                  |L1.712|
                          DCD      start_pass_dpost
