; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\usb_pwr.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\MALLOC -I.\TFT -I.\EMWIN\EMWIN_INC -I.\EMWIN\DEMO -I.\PNG -I.\FATFS -I.\SDIO -I.\USB\inc -I.\USBCFG\inc -IE:\material\GUI\8.STM32·Ü¶·°å-emwin+fatfs+usb\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0 -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\usb_pwr.crf USBCFG\scr\usb_pwr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;48     *******************************************************************************/
;;;49     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;50     {
;;;51     #ifndef STM32F10X_CL
;;;52       u16 wRegVal;
;;;53       
;;;54       /*** cable plugged-in ? ***/
;;;55       /*while(!CablePluggedIn());*/
;;;56       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;57     
;;;58       /*** CNTR_PWDN = 0 ***/
;;;59       wRegVal = CNTR_FRES;
000008  2401              MOVS     r4,#1
;;;60       _SetCNTR(wRegVal);
00000a  484c              LDR      r0,|L1.316|
00000c  6004              STR      r4,[r0,#0]
;;;61     
;;;62       /*** CNTR_FRES = 0 ***/
;;;63       wInterrupt_Mask = 0;
00000e  2000              MOVS     r0,#0
000010  494b              LDR      r1,|L1.320|
000012  8008              STRH     r0,[r1,#0]
;;;64       _SetCNTR(wInterrupt_Mask);
000014  4608              MOV      r0,r1
000016  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
000018  4948              LDR      r1,|L1.316|
00001a  6008              STR      r0,[r1,#0]
;;;65       /*** Clear pending interrupts ***/
;;;66       _SetISTR(0);
00001c  2000              MOVS     r0,#0
00001e  1d09              ADDS     r1,r1,#4
000020  6008              STR      r0,[r1,#0]
;;;67       /*** Set interrupt mask ***/
;;;68       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000022  f44f50e0          MOV      r0,#0x1c00
000026  4946              LDR      r1,|L1.320|
000028  8008              STRH     r0,[r1,#0]
;;;69       _SetCNTR(wInterrupt_Mask);
00002a  4608              MOV      r0,r1
00002c  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
00002e  4943              LDR      r1,|L1.316|
000030  6008              STR      r0,[r1,#0]
;;;70     #endif /* STM32F10X_CL */
;;;71       
;;;72       return USB_SUCCESS;
000032  2000              MOVS     r0,#0
;;;73     }
000034  bd10              POP      {r4,pc}
;;;74     
                          ENDP

                  PowerOff PROC
;;;81     *******************************************************************************/
;;;82     RESULT PowerOff()
000036  b510              PUSH     {r4,lr}
;;;83     {
;;;84     #ifndef STM32F10X_CL  
;;;85       /* disable all ints and force USB reset */
;;;86       _SetCNTR(CNTR_FRES);
000038  2001              MOVS     r0,#1
00003a  4940              LDR      r1,|L1.316|
00003c  6008              STR      r0,[r1,#0]
;;;87       /* clear interrupt status register */
;;;88       _SetISTR(0);
00003e  2000              MOVS     r0,#0
000040  1d09              ADDS     r1,r1,#4
000042  6008              STR      r0,[r1,#0]
;;;89       /* Disable the Pull-Up*/
;;;90       USB_Cable_Config(DISABLE);
000044  f7fffffe          BL       USB_Cable_Config
;;;91       /* switch-off device */
;;;92       _SetCNTR(CNTR_FRES + CNTR_PDWN);
000048  2003              MOVS     r0,#3
00004a  493c              LDR      r1,|L1.316|
00004c  6008              STR      r0,[r1,#0]
;;;93       /* sw variables reset */
;;;94       /* ... */
;;;95     #endif /* STM32F10X_CL */
;;;96     
;;;97       return USB_SUCCESS;
00004e  2000              MOVS     r0,#0
;;;98     }
000050  bd10              POP      {r4,pc}
;;;99     
                          ENDP

                  Suspend PROC
;;;106    *******************************************************************************/
;;;107    void Suspend(void)
000052  b510              PUSH     {r4,lr}
;;;108    {
;;;109    
;;;110      /* suspend preparation */
;;;111      /* ... */
;;;112      
;;;113    #ifndef STM32F10X_CL
;;;114      uint16_t wCNTR;
;;;115    
;;;116      /* macrocell enters suspend mode */
;;;117      wCNTR = _GetCNTR();
000054  4839              LDR      r0,|L1.316|
000056  6800              LDR      r0,[r0,#0]
000058  b284              UXTH     r4,r0
;;;118      wCNTR |= CNTR_FSUSP;
00005a  f0440408          ORR      r4,r4,#8
;;;119      _SetCNTR(wCNTR);
00005e  4837              LDR      r0,|L1.316|
000060  6004              STR      r4,[r0,#0]
;;;120    #endif /* STM32F10X_CL */
;;;121      
;;;122      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;123      /* power reduction */
;;;124      /* ... on connected devices */
;;;125    
;;;126    #ifndef STM32F10X_CL
;;;127      /* force low-power mode in the macrocell */
;;;128      wCNTR = _GetCNTR();
000062  6800              LDR      r0,[r0,#0]
000064  b284              UXTH     r4,r0
;;;129      wCNTR |= CNTR_LPMODE;
000066  f0440404          ORR      r4,r4,#4
;;;130      _SetCNTR(wCNTR);
00006a  4834              LDR      r0,|L1.316|
00006c  6004              STR      r4,[r0,#0]
;;;131    #endif /* STM32F10X_CL */
;;;132    
;;;133      /* switch-off the clocks */
;;;134      /* ... */
;;;135      Enter_LowPowerMode();
00006e  f7fffffe          BL       Enter_LowPowerMode
;;;136    }
000072  bd10              POP      {r4,pc}
;;;137    
                          ENDP

                  Resume_Init PROC
;;;144    *******************************************************************************/
;;;145    void Resume_Init(void)
000074  b510              PUSH     {r4,lr}
;;;146    {
;;;147      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;148      /* restart the clocks */
;;;149      /* ...  */
;;;150    #ifndef STM32F10X_CL
;;;151      u16 wCNTR;
;;;152      
;;;153      /* CNTR_LPMODE = 0 */
;;;154      wCNTR = _GetCNTR();
000076  4831              LDR      r0,|L1.316|
000078  6800              LDR      r0,[r0,#0]
00007a  b284              UXTH     r4,r0
;;;155      wCNTR &= (~CNTR_LPMODE);
00007c  f0240404          BIC      r4,r4,#4
;;;156      _SetCNTR(wCNTR);
000080  482e              LDR      r0,|L1.316|
000082  6004              STR      r4,[r0,#0]
;;;157    #endif /* STM32F10X_CL */
;;;158      
;;;159      /* restore full power */
;;;160      /* ... on connected devices */
;;;161      Leave_LowPowerMode();
000084  f7fffffe          BL       Leave_LowPowerMode
;;;162    
;;;163    #ifndef STM32F10X_CL
;;;164      /* reset FSUSP bit */
;;;165      _SetCNTR(IMR_MSK);
000088  f44f4004          MOV      r0,#0x8400
00008c  492b              LDR      r1,|L1.316|
00008e  6008              STR      r0,[r1,#0]
;;;166    #endif /* STM32F10X_CL */
;;;167      
;;;168      /* reverse suspend preparation */
;;;169      /* ... */
;;;170    }
000090  bd10              POP      {r4,pc}
;;;171    
                          ENDP

                  Resume PROC
;;;183    *******************************************************************************/
;;;184    void Resume(RESUME_STATE eResumeSetVal)
000092  b570              PUSH     {r4-r6,lr}
;;;185    {
000094  4605              MOV      r5,r0
;;;186    #ifndef STM32F10X_CL
;;;187      u16 wCNTR;
;;;188    #endif /* STM32F10X_CL */
;;;189    
;;;190      if (eResumeSetVal != RESUME_ESOF)
000096  2d07              CMP      r5,#7
000098  d001              BEQ      |L1.158|
;;;191        ResumeS.eState = eResumeSetVal;
00009a  482a              LDR      r0,|L1.324|
00009c  7005              STRB     r5,[r0,#0]
                  |L1.158|
;;;192    
;;;193      switch (ResumeS.eState)
00009e  4829              LDR      r0,|L1.324|
0000a0  7800              LDRB     r0,[r0,#0]  ; ResumeS
0000a2  2808              CMP      r0,#8
0000a4  d241              BCS      |L1.298|
0000a6  e8dff000          TBB      [pc,r0]
0000aa  040a              DCB      0x04,0x0a
0000ac  1016212e          DCB      0x10,0x16,0x21,0x2e
0000b0  4142              DCB      0x41,0x42
;;;194      {
;;;195        case RESUME_EXTERNAL:
;;;196          Resume_Init();
0000b2  f7fffffe          BL       Resume_Init
;;;197          ResumeS.eState = RESUME_OFF;
0000b6  2006              MOVS     r0,#6
0000b8  4922              LDR      r1,|L1.324|
0000ba  7008              STRB     r0,[r1,#0]
;;;198          break;
0000bc  e03b              B        |L1.310|
;;;199        case RESUME_INTERNAL:
;;;200          Resume_Init();
0000be  f7fffffe          BL       Resume_Init
;;;201          ResumeS.eState = RESUME_START;
0000c2  2004              MOVS     r0,#4
0000c4  491f              LDR      r1,|L1.324|
0000c6  7008              STRB     r0,[r1,#0]
;;;202          break;
0000c8  e035              B        |L1.310|
;;;203        case RESUME_LATER:
;;;204          ResumeS.bESOFcnt = 2;
0000ca  2002              MOVS     r0,#2
0000cc  491d              LDR      r1,|L1.324|
0000ce  7048              STRB     r0,[r1,#1]
;;;205          ResumeS.eState = RESUME_WAIT;
0000d0  2003              MOVS     r0,#3
0000d2  7008              STRB     r0,[r1,#0]
;;;206          break;
0000d4  e02f              B        |L1.310|
;;;207        case RESUME_WAIT:
;;;208          ResumeS.bESOFcnt--;
0000d6  481b              LDR      r0,|L1.324|
0000d8  7840              LDRB     r0,[r0,#1]  ; ResumeS
0000da  1e40              SUBS     r0,r0,#1
0000dc  4919              LDR      r1,|L1.324|
0000de  7048              STRB     r0,[r1,#1]
;;;209          if (ResumeS.bESOFcnt == 0)
0000e0  4608              MOV      r0,r1
0000e2  7840              LDRB     r0,[r0,#1]  ; ResumeS
0000e4  b908              CBNZ     r0,|L1.234|
;;;210            ResumeS.eState = RESUME_START;
0000e6  2004              MOVS     r0,#4
0000e8  7008              STRB     r0,[r1,#0]
                  |L1.234|
;;;211          break;
0000ea  e024              B        |L1.310|
;;;212        case RESUME_START:
;;;213         #ifdef STM32F10X_CL
;;;214          OTGD_FS_Dev_SetRemoteWakeup();
;;;215         #else 
;;;216          wCNTR = _GetCNTR();
0000ec  4813              LDR      r0,|L1.316|
0000ee  6800              LDR      r0,[r0,#0]
0000f0  b284              UXTH     r4,r0
;;;217          wCNTR |= CNTR_RESUME;
0000f2  f0440410          ORR      r4,r4,#0x10
;;;218          _SetCNTR(wCNTR);
0000f6  4811              LDR      r0,|L1.316|
0000f8  6004              STR      r4,[r0,#0]
;;;219         #endif /* STM32F10X_CL */
;;;220          ResumeS.eState = RESUME_ON;
0000fa  2005              MOVS     r0,#5
0000fc  4911              LDR      r1,|L1.324|
0000fe  7008              STRB     r0,[r1,#0]
;;;221          ResumeS.bESOFcnt = 10;
000100  200a              MOVS     r0,#0xa
000102  7048              STRB     r0,[r1,#1]
;;;222          break;
000104  e017              B        |L1.310|
;;;223        case RESUME_ON:
;;;224        #ifndef STM32F10X_CL      
;;;225          ResumeS.bESOFcnt--;
000106  480f              LDR      r0,|L1.324|
000108  7840              LDRB     r0,[r0,#1]  ; ResumeS
00010a  1e40              SUBS     r0,r0,#1
00010c  490d              LDR      r1,|L1.324|
00010e  7048              STRB     r0,[r1,#1]
;;;226          if (ResumeS.bESOFcnt == 0)
000110  4608              MOV      r0,r1
000112  7840              LDRB     r0,[r0,#1]  ; ResumeS
000114  b940              CBNZ     r0,|L1.296|
;;;227          {
;;;228         #endif /* STM32F10X_CL */    
;;;229           #ifdef STM32F10X_CL
;;;230            OTGD_FS_Dev_ResetRemoteWakeup();
;;;231           #else
;;;232            wCNTR = _GetCNTR();
000116  4809              LDR      r0,|L1.316|
000118  6800              LDR      r0,[r0,#0]
00011a  b284              UXTH     r4,r0
;;;233            wCNTR &= (~CNTR_RESUME);
00011c  f0240410          BIC      r4,r4,#0x10
;;;234            _SetCNTR(wCNTR);
000120  4806              LDR      r0,|L1.316|
000122  6004              STR      r4,[r0,#0]
;;;235           #endif /* STM32F10X_CL */
;;;236            ResumeS.eState = RESUME_OFF;
000124  2006              MOVS     r0,#6
000126  7008              STRB     r0,[r1,#0]
                  |L1.296|
;;;237         #ifndef STM32F10X_CL
;;;238          }
;;;239         #endif /* STM32F10X_CL */
;;;240          break;
000128  e005              B        |L1.310|
                  |L1.298|
;;;241        case RESUME_OFF:
00012a  bf00              NOP      
;;;242        case RESUME_ESOF:
00012c  bf00              NOP      
;;;243        default:
;;;244          ResumeS.eState = RESUME_OFF;
00012e  2006              MOVS     r0,#6
000130  4904              LDR      r1,|L1.324|
000132  7008              STRB     r0,[r1,#0]
;;;245          break;
000134  bf00              NOP      
                  |L1.310|
000136  bf00              NOP                            ;198
;;;246      }
;;;247    }
000138  bd70              POP      {r4-r6,pc}
;;;248    
                          ENDP

00013a  0000              DCW      0x0000
                  |L1.316|
                          DCD      0x40005c40
                  |L1.320|
                          DCD      wInterrupt_Mask
                  |L1.324|
                          DCD      ResumeS

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000
                  fSuspendEnabled
000004  01                DCB      0x01
                  ResumeS
000005  0000              DCB      0x00,0x00
