; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdmainct.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdmainct.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdmainct.crf GUI\JPEG\jdmainct.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  alloc_funny_pointers PROC
;;;156    LOCAL(void)
;;;157    alloc_funny_pointers (j_decompress_ptr cinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;158    /* Allocate space for the funny pointer lists.
;;;159     * This is done only once, not once per pass.
;;;160     */
;;;161    {
000004  4604              MOV      r4,r0
;;;162      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000006  f8d451a8          LDR      r5,[r4,#0x1a8]
;;;163      int ci, rgroup;
;;;164      int M = cinfo->min_DCT_scaled_size;
00000a  f8d4a13c          LDR      r10,[r4,#0x13c]
;;;165      jpeg_component_info *compptr;
;;;166      JSAMPARRAY xbuf;
;;;167    
;;;168      /* Get top-level space for component array pointers.
;;;169       * We alloc both arrays with one call to save a few cycles.
;;;170       */
;;;171      pMain->xbuffer[0] = (JSAMPIMAGE)
00000e  6a60              LDR      r0,[r4,#0x24]
000010  ea4f02c0          LSL      r2,r0,#3
000014  6860              LDR      r0,[r4,#4]
000016  f04f0101          MOV      r1,#1
00001a  6803              LDR      r3,[r0,#0]
00001c  4620              MOV      r0,r4
00001e  4798              BLX      r3
000020  6228              STR      r0,[r5,#0x20]
;;;172        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;173    				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
;;;174      pMain->xbuffer[1] = pMain->xbuffer[0] + cinfo->num_components;
000022  6a28              LDR      r0,[r5,#0x20]
000024  6a61              LDR      r1,[r4,#0x24]
000026  eb000181          ADD      r1,r0,r1,LSL #2
00002a  6269              STR      r1,[r5,#0x24]
;;;175    
;;;176      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00002c  f04f0600          MOV      r6,#0
000030  f8d490d8          LDR      r9,[r4,#0xd8]
000034  e024              B        |L1.128|
                  |L1.54|
;;;177           ci++, compptr++) {
;;;178        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
000036  f8d91024          LDR      r1,[r9,#0x24]
00003a  f8d9000c          LDR      r0,[r9,#0xc]
00003e  4348              MULS     r0,r1,r0
000040  f8d4113c          LDR      r1,[r4,#0x13c]
000044  fb90f7f1          SDIV     r7,r0,r1
;;;179          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;180        /* Get space for pointer lists --- M+4 row groups in each list.
;;;181         * We alloc both pointer lists with one call to save a few cycles.
;;;182         */
;;;183        xbuf = (JSAMPARRAY)
000048  f10a0004          ADD      r0,r10,#4
00004c  4378              MULS     r0,r7,r0
00004e  00c2              LSLS     r2,r0,#3
000050  6860              LDR      r0,[r4,#4]
000052  2101              MOVS     r1,#1
000054  6803              LDR      r3,[r0,#0]
000056  4620              MOV      r0,r4
000058  4798              BLX      r3
00005a  4680              MOV      r8,r0
;;;184          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;185    				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
;;;186        xbuf += rgroup;		/* want one row group at negative offsets */
00005c  eb080887          ADD      r8,r8,r7,LSL #2
;;;187        pMain->xbuffer[0][ci] = xbuf;
000060  6a28              LDR      r0,[r5,#0x20]
000062  f8408026          STR      r8,[r0,r6,LSL #2]
;;;188        xbuf += rgroup * (M + 4);
000066  f10a0004          ADD      r0,r10,#4
00006a  fb07f000          MUL      r0,r7,r0
00006e  eb080880          ADD      r8,r8,r0,LSL #2
;;;189        pMain->xbuffer[1][ci] = xbuf;
000072  6a68              LDR      r0,[r5,#0x24]
000074  f8408026          STR      r8,[r0,r6,LSL #2]
000078  f1060601          ADD      r6,r6,#1              ;177
00007c  f1090954          ADD      r9,r9,#0x54           ;177
                  |L1.128|
000080  6a60              LDR      r0,[r4,#0x24]         ;176
000082  42b0              CMP      r0,r6                 ;176
000084  dcd7              BGT      |L1.54|
;;;190      }
;;;191    }
000086  e8bd87f0          POP      {r4-r10,pc}
;;;192    
                          ENDP

                  make_funny_pointers PROC
;;;194    LOCAL(void)
;;;195    make_funny_pointers (j_decompress_ptr cinfo)
00008a  e92d47f0          PUSH     {r4-r10,lr}
;;;196    /* Create the funny pointer lists discussed in the comments above.
;;;197     * The actual workspace is already allocated (in pMain->buffer),
;;;198     * and the space for the pointer lists is allocated too.
;;;199     * This routine just fills in the curiously ordered lists.
;;;200     * This will be repeated at the beginning of each pass.
;;;201     */
;;;202    {
00008e  4602              MOV      r2,r0
;;;203      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000090  f8d2c1a8          LDR      r12,[r2,#0x1a8]
;;;204      int ci, i, rgroup;
;;;205      int M = cinfo->min_DCT_scaled_size;
000094  f8d2413c          LDR      r4,[r2,#0x13c]
;;;206      jpeg_component_info *compptr;
;;;207      JSAMPARRAY buf, xbuf0, xbuf1;
;;;208    
;;;209      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000098  f04f0300          MOV      r3,#0
00009c  f8d280d8          LDR      r8,[r2,#0xd8]
0000a0  e053              B        |L1.330|
                  |L1.162|
;;;210           ci++, compptr++) {
;;;211        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
0000a2  f8d8a024          LDR      r10,[r8,#0x24]
0000a6  f8d8900c          LDR      r9,[r8,#0xc]
0000aa  fb09f90a          MUL      r9,r9,r10
0000ae  f8d2a13c          LDR      r10,[r2,#0x13c]
0000b2  fb99f1fa          SDIV     r1,r9,r10
;;;212          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;213        xbuf0 = pMain->xbuffer[0][ci];
0000b6  f8dc9020          LDR      r9,[r12,#0x20]
0000ba  f8596023          LDR      r6,[r9,r3,LSL #2]
;;;214        xbuf1 = pMain->xbuffer[1][ci];
0000be  f8dc9024          LDR      r9,[r12,#0x24]
0000c2  f8597023          LDR      r7,[r9,r3,LSL #2]
;;;215        /* First copy the workspace pointers as-is */
;;;216        buf = pMain->buffer[ci];
0000c6  f10c0908          ADD      r9,r12,#8
0000ca  f8595023          LDR      r5,[r9,r3,LSL #2]
;;;217        for (i = 0; i < rgroup * (M + 2); i++) {
0000ce  f04f0000          MOV      r0,#0
0000d2  e007              B        |L1.228|
                  |L1.212|
;;;218          xbuf0[i] = xbuf1[i] = buf[i];
0000d4  f8559020          LDR      r9,[r5,r0,LSL #2]
0000d8  f8479020          STR      r9,[r7,r0,LSL #2]
0000dc  f8469020          STR      r9,[r6,r0,LSL #2]
0000e0  f1000001          ADD      r0,r0,#1              ;217
                  |L1.228|
0000e4  f1040902          ADD      r9,r4,#2              ;217
0000e8  fb01f909          MUL      r9,r1,r9              ;217
0000ec  4581              CMP      r9,r0                 ;217
0000ee  dcf1              BGT      |L1.212|
;;;219        }
;;;220        /* In the second list, put the last four row groups in swapped order */
;;;221        for (i = 0; i < rgroup * 2; i++) {
0000f0  f04f0000          MOV      r0,#0
0000f4  e015              B        |L1.290|
                  |L1.246|
;;;222          xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
0000f6  fb010904          MLA      r9,r1,r4,r0
0000fa  f855a029          LDR      r10,[r5,r9,LSL #2]
0000fe  f1a40902          SUB      r9,r4,#2
000102  fb010909          MLA      r9,r1,r9,r0
000106  f847a029          STR      r10,[r7,r9,LSL #2]
;;;223          xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
00010a  f1a40902          SUB      r9,r4,#2
00010e  fb010909          MLA      r9,r1,r9,r0
000112  f8559029          LDR      r9,[r5,r9,LSL #2]
000116  fb010a04          MLA      r10,r1,r4,r0
00011a  f847902a          STR      r9,[r7,r10,LSL #2]
00011e  f1000001          ADD      r0,r0,#1              ;221
                  |L1.290|
000122  ebb00f41          CMP      r0,r1,LSL #1          ;221
000126  dbe6              BLT      |L1.246|
;;;224        }
;;;225        /* The wraparound pointers at top and bottom will be filled later
;;;226         * (see set_wraparound_pointers, below).  Initially we want the "above"
;;;227         * pointers to duplicate the first actual data line.  This only needs
;;;228         * to happen in xbuffer[0].
;;;229         */
;;;230        for (i = 0; i < rgroup; i++) {
000128  f04f0000          MOV      r0,#0
00012c  e007              B        |L1.318|
                  |L1.302|
;;;231          xbuf0[i - rgroup] = xbuf0[0];
00012e  eba00a01          SUB      r10,r0,r1
000132  f8d69000          LDR      r9,[r6,#0]
000136  f846902a          STR      r9,[r6,r10,LSL #2]
00013a  f1000001          ADD      r0,r0,#1              ;230
                  |L1.318|
00013e  4288              CMP      r0,r1                 ;230
000140  dbf5              BLT      |L1.302|
000142  f1030301          ADD      r3,r3,#1              ;210
000146  f1080854          ADD      r8,r8,#0x54           ;210
                  |L1.330|
00014a  f8d29024          LDR      r9,[r2,#0x24]         ;209
00014e  4599              CMP      r9,r3                 ;209
000150  dca7              BGT      |L1.162|
;;;232        }
;;;233      }
;;;234    }
000152  e8bd87f0          POP      {r4-r10,pc}
;;;235    
                          ENDP

                  set_wraparound_pointers PROC
;;;237    LOCAL(void)
;;;238    set_wraparound_pointers (j_decompress_ptr cinfo)
000156  e92d43f0          PUSH     {r4-r9,lr}
;;;239    /* Set up the "wraparound" pointers at top and bottom of the pointer lists.
;;;240     * This changes the pointer list state from top-of-image to the normal state.
;;;241     */
;;;242    {
00015a  4602              MOV      r2,r0
;;;243      my_main_ptr pMain = (my_main_ptr) cinfo->main;
00015c  f8d2c1a8          LDR      r12,[r2,#0x1a8]
;;;244      int ci, i, rgroup;
;;;245      int M = cinfo->min_DCT_scaled_size;
000160  f8d2613c          LDR      r6,[r2,#0x13c]
;;;246      jpeg_component_info *compptr;
;;;247      JSAMPARRAY xbuf0, xbuf1;
;;;248    
;;;249      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000164  f04f0500          MOV      r5,#0
000168  f8d270d8          LDR      r7,[r2,#0xd8]
00016c  e040              B        |L1.496|
                  |L1.366|
;;;250           ci++, compptr++) {
;;;251        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
00016e  f8d79024          LDR      r9,[r7,#0x24]
000172  f8d7800c          LDR      r8,[r7,#0xc]
000176  fb08f809          MUL      r8,r8,r9
00017a  f8d2913c          LDR      r9,[r2,#0x13c]
00017e  fb98f1f9          SDIV     r1,r8,r9
;;;252          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;253        xbuf0 = pMain->xbuffer[0][ci];
000182  f8dc8020          LDR      r8,[r12,#0x20]
000186  f8583025          LDR      r3,[r8,r5,LSL #2]
;;;254        xbuf1 = pMain->xbuffer[1][ci];
00018a  f8dc8024          LDR      r8,[r12,#0x24]
00018e  f8584025          LDR      r4,[r8,r5,LSL #2]
;;;255        for (i = 0; i < rgroup; i++) {
000192  f04f0000          MOV      r0,#0
000196  e025              B        |L1.484|
                  |L1.408|
;;;256          xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
000198  f1060801          ADD      r8,r6,#1
00019c  fb010808          MLA      r8,r1,r8,r0
0001a0  f8538028          LDR      r8,[r3,r8,LSL #2]
0001a4  eba00901          SUB      r9,r0,r1
0001a8  f8438029          STR      r8,[r3,r9,LSL #2]
;;;257          xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
0001ac  f1060801          ADD      r8,r6,#1
0001b0  fb010808          MLA      r8,r1,r8,r0
0001b4  f8548028          LDR      r8,[r4,r8,LSL #2]
0001b8  eba00901          SUB      r9,r0,r1
0001bc  f8448029          STR      r8,[r4,r9,LSL #2]
;;;258          xbuf0[rgroup*(M+2) + i] = xbuf0[i];
0001c0  f8539020          LDR      r9,[r3,r0,LSL #2]
0001c4  f1060802          ADD      r8,r6,#2
0001c8  fb010808          MLA      r8,r1,r8,r0
0001cc  f8439028          STR      r9,[r3,r8,LSL #2]
;;;259          xbuf1[rgroup*(M+2) + i] = xbuf1[i];
0001d0  f8549020          LDR      r9,[r4,r0,LSL #2]
0001d4  f1060802          ADD      r8,r6,#2
0001d8  fb010808          MLA      r8,r1,r8,r0
0001dc  f8449028          STR      r9,[r4,r8,LSL #2]
0001e0  f1000001          ADD      r0,r0,#1              ;255
                  |L1.484|
0001e4  4288              CMP      r0,r1                 ;255
0001e6  dbd7              BLT      |L1.408|
0001e8  f1050501          ADD      r5,r5,#1              ;250
0001ec  f1070754          ADD      r7,r7,#0x54           ;250
                  |L1.496|
0001f0  f8d28024          LDR      r8,[r2,#0x24]         ;249
0001f4  45a8              CMP      r8,r5                 ;249
0001f6  dcba              BGT      |L1.366|
;;;260        }
;;;261      }
;;;262    }
0001f8  e8bd83f0          POP      {r4-r9,pc}
;;;263    
                          ENDP

                  set_bottom_pointers PROC
;;;265    LOCAL(void)
;;;266    set_bottom_pointers (j_decompress_ptr cinfo)
0001fc  e92d43f0          PUSH     {r4-r9,lr}
;;;267    /* Change the pointer lists to duplicate the last sample row at the bottom
;;;268     * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
;;;269     * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
;;;270     */
;;;271    {
;;;272      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000200  f8d071a8          LDR      r7,[r0,#0x1a8]
;;;273      int ci, i, rgroup, iMCUheight, rows_left;
;;;274      jpeg_component_info *compptr;
;;;275      JSAMPARRAY xbuf;
;;;276    
;;;277      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000204  f04f0100          MOV      r1,#0
000208  f8d050d8          LDR      r5,[r0,#0xd8]
00020c  e036              B        |L1.636|
                  |L1.526|
;;;278           ci++, compptr++) {
;;;279        /* Count sample rows in one iMCU row and in one row group */
;;;280        iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
00020e  f8d59024          LDR      r9,[r5,#0x24]
000212  f8d5800c          LDR      r8,[r5,#0xc]
000216  fb08f309          MUL      r3,r8,r9
;;;281        rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
00021a  f8d0813c          LDR      r8,[r0,#0x13c]
00021e  fb93f2f8          SDIV     r2,r3,r8
;;;282        /* Count nondummy sample rows remaining for this component */
;;;283        rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
000222  f8d5802c          LDR      r8,[r5,#0x2c]
000226  fbb8f9f3          UDIV     r9,r8,r3
00022a  fb038419          MLS      r4,r3,r9,r8
;;;284        if (rows_left == 0) rows_left = iMCUheight;
00022e  b904              CBNZ     r4,|L1.562|
000230  461c              MOV      r4,r3
                  |L1.562|
;;;285        /* Count nondummy row groups.  Should get same answer for each component,
;;;286         * so we need only do it once.
;;;287         */
;;;288        if (ci == 0) {
000232  b939              CBNZ     r1,|L1.580|
;;;289          pMain->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
000234  f1a40801          SUB      r8,r4,#1
000238  fb98f8f2          SDIV     r8,r8,r2
00023c  f1080801          ADD      r8,r8,#1
000240  f8c78030          STR      r8,[r7,#0x30]
                  |L1.580|
;;;290        }
;;;291        /* Duplicate the last real sample row rgroup*2 times; this pads out the
;;;292         * last partial rowgroup and ensures at least one full rowgroup of context.
;;;293         */
;;;294        xbuf = pMain->xbuffer[pMain->whichptr][ci];
000244  f1070820          ADD      r8,r7,#0x20
000248  f8d79028          LDR      r9,[r7,#0x28]
00024c  f8588029          LDR      r8,[r8,r9,LSL #2]
000250  f8586021          LDR      r6,[r8,r1,LSL #2]
;;;295        for (i = 0; i < rgroup * 2; i++) {
000254  f04f0c00          MOV      r12,#0
000258  e009              B        |L1.622|
                  |L1.602|
;;;296          xbuf[rows_left + i] = xbuf[rows_left-1];
00025a  f1a40801          SUB      r8,r4,#1
00025e  f8568028          LDR      r8,[r6,r8,LSL #2]
000262  eb04090c          ADD      r9,r4,r12
000266  f8468029          STR      r8,[r6,r9,LSL #2]
00026a  f10c0c01          ADD      r12,r12,#1            ;295
                  |L1.622|
00026e  ebbc0f42          CMP      r12,r2,LSL #1         ;295
000272  dbf2              BLT      |L1.602|
000274  f1010101          ADD      r1,r1,#1              ;278
000278  f1050554          ADD      r5,r5,#0x54           ;278
                  |L1.636|
00027c  f8d08024          LDR      r8,[r0,#0x24]         ;277
000280  4588              CMP      r8,r1                 ;277
000282  dcc4              BGT      |L1.526|
;;;297        }
;;;298      }
;;;299    }
000284  e8bd83f0          POP      {r4-r9,pc}
;;;300    
                          ENDP

                  process_data_crank_post PROC
;;;458    METHODDEF(void)
;;;459    process_data_crank_post (j_decompress_ptr cinfo,
000288  b5fe              PUSH     {r1-r7,lr}
;;;460    			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;461    			 JDIMENSION out_rows_avail)
;;;462    {
00028a  4604              MOV      r4,r0
00028c  460d              MOV      r5,r1
00028e  4616              MOV      r6,r2
000290  461f              MOV      r7,r3
;;;463      (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
000292  e88d00e0          STM      sp,{r5-r7}
000296  f8d401b0          LDR      r0,[r4,#0x1b0]
00029a  f04f0300          MOV      r3,#0
00029e  461a              MOV      r2,r3
0002a0  4619              MOV      r1,r3
0002a2  f8d0c004          LDR      r12,[r0,#4]
0002a6  4620              MOV      r0,r4
0002a8  47e0              BLX      r12
;;;464    				     (JDIMENSION *) NULL, (JDIMENSION) 0,
;;;465    				     output_buf, out_row_ctr, out_rows_avail);
;;;466    }
0002aa  bdfe              POP      {r1-r7,pc}
;;;467    
                          ENDP

                  process_data_simple_main PROC
;;;344    METHODDEF(void)
;;;345    process_data_simple_main (j_decompress_ptr cinfo,
0002ac  e92d43fe          PUSH     {r1-r9,lr}
;;;346    			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;347    			  JDIMENSION out_rows_avail)
;;;348    {
0002b0  4605              MOV      r5,r0
0002b2  460f              MOV      r7,r1
0002b4  4690              MOV      r8,r2
0002b6  4699              MOV      r9,r3
;;;349      my_main_ptr pMain = (my_main_ptr) cinfo->main;
0002b8  f8d541a8          LDR      r4,[r5,#0x1a8]
;;;350      JDIMENSION rowgroups_avail;
;;;351    
;;;352      /* Read input data if we haven't filled the main buffer yet */
;;;353      if (! pMain->buffer_full) {
0002bc  69a0              LDR      r0,[r4,#0x18]
0002be  b960              CBNZ     r0,|L1.730|
;;;354        if (! (*cinfo->coef->decompress_data) (cinfo, pMain->buffer))
0002c0  f8d501ac          LDR      r0,[r5,#0x1ac]
0002c4  f1040108          ADD      r1,r4,#8
0002c8  68c2              LDR      r2,[r0,#0xc]
0002ca  4628              MOV      r0,r5
0002cc  4790              BLX      r2
0002ce  b908              CBNZ     r0,|L1.724|
                  |L1.720|
;;;355          return;			/* suspension forced, can do nothing more */
;;;356        pMain->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
;;;357      }
;;;358    
;;;359      /* There are always min_DCT_scaled_size row groups in an iMCU row. */
;;;360      rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
;;;361      /* Note: at the bottom of the image, we may pass extra garbage row groups
;;;362       * to the postprocessor.  The postprocessor has to check for bottom
;;;363       * of image anyway (at row resolution), so no point in us doing it too.
;;;364       */
;;;365    
;;;366      /* Feed the postprocessor */
;;;367      (*cinfo->post->post_process_data) (cinfo, pMain->buffer,
;;;368    				     &pMain->rowgroup_ctr, rowgroups_avail,
;;;369    				     output_buf, out_row_ctr, out_rows_avail);
;;;370    
;;;371      /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
;;;372      if (pMain->rowgroup_ctr >= rowgroups_avail) {
;;;373        pMain->buffer_full = FALSE;
;;;374        pMain->rowgroup_ctr = 0;
;;;375      }
;;;376    }
0002d0  e8bd83fe          POP      {r1-r9,pc}
                  |L1.724|
0002d4  f04f0001          MOV      r0,#1                 ;356
0002d8  61a0              STR      r0,[r4,#0x18]         ;356
                  |L1.730|
0002da  f8d5613c          LDR      r6,[r5,#0x13c]        ;360
0002de  e88d0380          STM      sp,{r7-r9}            ;367
0002e2  f8d501b0          LDR      r0,[r5,#0x1b0]        ;367
0002e6  4633              MOV      r3,r6                 ;367
0002e8  f104021c          ADD      r2,r4,#0x1c           ;367
0002ec  f1040108          ADD      r1,r4,#8              ;367
0002f0  f8d0c004          LDR      r12,[r0,#4]           ;367
0002f4  4628              MOV      r0,r5                 ;367
0002f6  47e0              BLX      r12                   ;367
0002f8  69e0              LDR      r0,[r4,#0x1c]         ;372
0002fa  42b0              CMP      r0,r6                 ;372
0002fc  d303              BCC      |L1.774|
0002fe  f04f0000          MOV      r0,#0                 ;373
000302  61a0              STR      r0,[r4,#0x18]         ;373
000304  61e0              STR      r0,[r4,#0x1c]         ;374
                  |L1.774|
000306  bf00              NOP      
000308  e7e2              B        |L1.720|
;;;377    
                          ENDP

                  process_data_context_main PROC
;;;384    METHODDEF(void)
;;;385    process_data_context_main (j_decompress_ptr cinfo,
00030a  e92d43fe          PUSH     {r1-r9,lr}
;;;386    			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;387    			   JDIMENSION out_rows_avail)
;;;388    {
00030e  4605              MOV      r5,r0
000310  4688              MOV      r8,r1
000312  4616              MOV      r6,r2
000314  461f              MOV      r7,r3
;;;389      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000316  f8d541a8          LDR      r4,[r5,#0x1a8]
;;;390    
;;;391      /* Read input data if we haven't filled the main buffer yet */
;;;392      if (! pMain->buffer_full) {
00031a  69a0              LDR      r0,[r4,#0x18]
00031c  b998              CBNZ     r0,|L1.838|
;;;393        if (! (*cinfo->coef->decompress_data) (cinfo,
00031e  f1040020          ADD      r0,r4,#0x20
000322  6aa3              LDR      r3,[r4,#0x28]
000324  f8501023          LDR      r1,[r0,r3,LSL #2]
000328  f8d501ac          LDR      r0,[r5,#0x1ac]
00032c  68c2              LDR      r2,[r0,#0xc]
00032e  4628              MOV      r0,r5
000330  4790              BLX      r2
000332  b908              CBNZ     r0,|L1.824|
                  |L1.820|
;;;394    					   pMain->xbuffer[pMain->whichptr]))
;;;395          return;			/* suspension forced, can do nothing more */
;;;396        pMain->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
;;;397        pMain->iMCU_row_ctr++;	/* count rows received */
;;;398      }
;;;399    
;;;400      /* Postprocessor typically will not swallow all the input data it is handed
;;;401       * in one call (due to filling the output buffer first).  Must be prepared
;;;402       * to exit and restart.  This switch lets us keep track of how far we got.
;;;403       * Note that each case falls through to the next on successful completion.
;;;404       */
;;;405      switch (pMain->context_state) {
;;;406      case CTX_POSTPONED_ROW:
;;;407        /* Call postprocessor using previously set pointers for postponed row */
;;;408        (*cinfo->post->post_process_data) (cinfo, pMain->xbuffer[pMain->whichptr],
;;;409    			&pMain->rowgroup_ctr, pMain->rowgroups_avail,
;;;410    			output_buf, out_row_ctr, out_rows_avail);
;;;411        if (pMain->rowgroup_ctr < pMain->rowgroups_avail)
;;;412          return;			/* Need to suspend */
;;;413        pMain->context_state = CTX_PREPARE_FOR_IMCU;
;;;414        if (*out_row_ctr >= out_rows_avail)
;;;415          return;			/* Postprocessor exactly filled output buf */
;;;416        /*FALLTHROUGH*/
;;;417      case CTX_PREPARE_FOR_IMCU:
;;;418        /* Prepare to process first M-1 row groups of this iMCU row */
;;;419        pMain->rowgroup_ctr = 0;
;;;420        pMain->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
;;;421        /* Check for bottom of image: if so, tweak pointers to "duplicate"
;;;422         * the last sample row, and adjust rowgroups_avail to ignore padding rows.
;;;423         */
;;;424        if (pMain->iMCU_row_ctr == cinfo->total_iMCU_rows)
;;;425          set_bottom_pointers(cinfo);
;;;426        pMain->context_state = CTX_PROCESS_IMCU;
;;;427        /*FALLTHROUGH*/
;;;428      case CTX_PROCESS_IMCU:
;;;429        /* Call postprocessor using previously set pointers */
;;;430        (*cinfo->post->post_process_data) (cinfo, pMain->xbuffer[pMain->whichptr],
;;;431    			&pMain->rowgroup_ctr, pMain->rowgroups_avail,
;;;432    			output_buf, out_row_ctr, out_rows_avail);
;;;433        if (pMain->rowgroup_ctr < pMain->rowgroups_avail)
;;;434          return;			/* Need to suspend */
;;;435        /* After the first iMCU, change wraparound pointers to normal state */
;;;436        if (pMain->iMCU_row_ctr == 1)
;;;437          set_wraparound_pointers(cinfo);
;;;438        /* Prepare to load new iMCU row using other xbuffer list */
;;;439        pMain->whichptr ^= 1;	/* 0=>1 or 1=>0 */
;;;440        pMain->buffer_full = FALSE;
;;;441        /* Still need to process last row group of this iMCU row, */
;;;442        /* which is saved at index M+1 of the other xbuffer */
;;;443        pMain->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
;;;444        pMain->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
;;;445        pMain->context_state = CTX_POSTPONED_ROW;
;;;446      }
;;;447    }
000334  e8bd83fe          POP      {r1-r9,pc}
                  |L1.824|
000338  f04f0001          MOV      r0,#1                 ;396
00033c  61a0              STR      r0,[r4,#0x18]         ;396
00033e  6b60              LDR      r0,[r4,#0x34]         ;397
000340  f1000001          ADD      r0,r0,#1              ;397
000344  6360              STR      r0,[r4,#0x34]         ;397
                  |L1.838|
000346  6ae0              LDR      r0,[r4,#0x2c]         ;405
000348  b308              CBZ      r0,|L1.910|
00034a  2801              CMP      r0,#1                 ;405
00034c  d033              BEQ      |L1.950|
00034e  2802              CMP      r0,#2                 ;405
000350  d162              BNE      |L1.1048|
000352  e9cd8600          STRD     r8,r6,[sp,#0]         ;408
000356  9702              STR      r7,[sp,#8]            ;408
000358  f1040020          ADD      r0,r4,#0x20           ;408
00035c  6aa2              LDR      r2,[r4,#0x28]         ;408
00035e  f8501022          LDR      r1,[r0,r2,LSL #2]     ;408
000362  6b23              LDR      r3,[r4,#0x30]         ;408
000364  f8d501b0          LDR      r0,[r5,#0x1b0]        ;408
000368  f104021c          ADD      r2,r4,#0x1c           ;408
00036c  f8d0c004          LDR      r12,[r0,#4]           ;408
000370  4628              MOV      r0,r5                 ;408
000372  47e0              BLX      r12                   ;408
000374  6b21              LDR      r1,[r4,#0x30]         ;411
000376  69e0              LDR      r0,[r4,#0x1c]         ;411
000378  4288              CMP      r0,r1                 ;411
00037a  d200              BCS      |L1.894|
00037c  e7da              B        |L1.820|
                  |L1.894|
00037e  f04f0000          MOV      r0,#0                 ;413
000382  62e0              STR      r0,[r4,#0x2c]         ;413
000384  6830              LDR      r0,[r6,#0]            ;414
000386  42b8              CMP      r0,r7                 ;414
000388  d300              BCC      |L1.908|
00038a  e7d3              B        |L1.820|
                  |L1.908|
00038c  bf00              NOP                            ;417
                  |L1.910|
00038e  f04f0000          MOV      r0,#0                 ;419
000392  61e0              STR      r0,[r4,#0x1c]         ;419
000394  f8d5013c          LDR      r0,[r5,#0x13c]        ;420
000398  f1a00001          SUB      r0,r0,#1              ;420
00039c  6320              STR      r0,[r4,#0x30]         ;420
00039e  6b60              LDR      r0,[r4,#0x34]         ;424
0003a0  f8d51140          LDR      r1,[r5,#0x140]        ;424
0003a4  4288              CMP      r0,r1                 ;424
0003a6  d102              BNE      |L1.942|
0003a8  4628              MOV      r0,r5                 ;425
0003aa  f7fffffe          BL       set_bottom_pointers
                  |L1.942|
0003ae  f04f0001          MOV      r0,#1                 ;426
0003b2  62e0              STR      r0,[r4,#0x2c]         ;426
0003b4  bf00              NOP                            ;428
                  |L1.950|
0003b6  e9cd8600          STRD     r8,r6,[sp,#0]         ;430
0003ba  9702              STR      r7,[sp,#8]            ;430
0003bc  f1040020          ADD      r0,r4,#0x20           ;430
0003c0  6aa2              LDR      r2,[r4,#0x28]         ;430
0003c2  f8501022          LDR      r1,[r0,r2,LSL #2]     ;430
0003c6  6b23              LDR      r3,[r4,#0x30]         ;430
0003c8  f8d501b0          LDR      r0,[r5,#0x1b0]        ;430
0003cc  f104021c          ADD      r2,r4,#0x1c           ;430
0003d0  f8d0c004          LDR      r12,[r0,#4]           ;430
0003d4  4628              MOV      r0,r5                 ;430
0003d6  47e0              BLX      r12                   ;430
0003d8  6b21              LDR      r1,[r4,#0x30]         ;433
0003da  69e0              LDR      r0,[r4,#0x1c]         ;433
0003dc  4288              CMP      r0,r1                 ;433
0003de  d200              BCS      |L1.994|
0003e0  e7a8              B        |L1.820|
                  |L1.994|
0003e2  6b60              LDR      r0,[r4,#0x34]         ;436
0003e4  2801              CMP      r0,#1                 ;436
0003e6  d102              BNE      |L1.1006|
0003e8  4628              MOV      r0,r5                 ;437
0003ea  f7fffffe          BL       set_wraparound_pointers
                  |L1.1006|
0003ee  6aa0              LDR      r0,[r4,#0x28]         ;439
0003f0  f0800001          EOR      r0,r0,#1              ;439
0003f4  62a0              STR      r0,[r4,#0x28]         ;439
0003f6  f04f0000          MOV      r0,#0                 ;440
0003fa  61a0              STR      r0,[r4,#0x18]         ;440
0003fc  f8d5013c          LDR      r0,[r5,#0x13c]        ;443
000400  f1000001          ADD      r0,r0,#1              ;443
000404  61e0              STR      r0,[r4,#0x1c]         ;443
000406  f8d5013c          LDR      r0,[r5,#0x13c]        ;444
00040a  f1000002          ADD      r0,r0,#2              ;444
00040e  6320              STR      r0,[r4,#0x30]         ;444
000410  f04f0002          MOV      r0,#2                 ;445
000414  62e0              STR      r0,[r4,#0x2c]         ;445
000416  bf00              NOP                            ;405
                  |L1.1048|
000418  bf00              NOP                            ;405
00041a  bf00              NOP      
00041c  e78a              B        |L1.820|
;;;448    
                          ENDP

                  start_pass_main PROC
;;;306    METHODDEF(void)
;;;307    start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
00041e  b570              PUSH     {r4-r6,lr}
;;;308    {
000420  4605              MOV      r5,r0
000422  460e              MOV      r6,r1
;;;309      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000424  f8d541a8          LDR      r4,[r5,#0x1a8]
;;;310    
;;;311      switch (pass_mode) {
000428  b116              CBZ      r6,|L1.1072|
00042a  2e02              CMP      r6,#2
00042c  d119              BNE      |L1.1122|
00042e  e015              B        |L1.1116|
                  |L1.1072|
;;;312      case JBUF_PASS_THRU:
;;;313        if (cinfo->upsample->need_context_rows) {
000430  f8d501c4          LDR      r0,[r5,#0x1c4]
000434  6880              LDR      r0,[r0,#8]
000436  b150              CBZ      r0,|L1.1102|
;;;314          pMain->pub.process_data = process_data_context_main;
000438  483d              LDR      r0,|L1.1328|
00043a  6060              STR      r0,[r4,#4]
;;;315          make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
00043c  4628              MOV      r0,r5
00043e  f7fffffe          BL       make_funny_pointers
;;;316          pMain->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
000442  f04f0000          MOV      r0,#0
000446  62a0              STR      r0,[r4,#0x28]
;;;317          pMain->context_state = CTX_PREPARE_FOR_IMCU;
000448  62e0              STR      r0,[r4,#0x2c]
;;;318          pMain->iMCU_row_ctr = 0;
00044a  6360              STR      r0,[r4,#0x34]
00044c  e001              B        |L1.1106|
                  |L1.1102|
;;;319        } else {
;;;320          /* Simple case with no context needed */
;;;321          pMain->pub.process_data = process_data_simple_main;
00044e  4839              LDR      r0,|L1.1332|
000450  6060              STR      r0,[r4,#4]
                  |L1.1106|
;;;322        }
;;;323        pMain->buffer_full = FALSE;	/* Mark buffer empty */
000452  f04f0000          MOV      r0,#0
000456  61a0              STR      r0,[r4,#0x18]
;;;324        pMain->rowgroup_ctr = 0;
000458  61e0              STR      r0,[r4,#0x1c]
;;;325        break;
00045a  e00b              B        |L1.1140|
                  |L1.1116|
;;;326    #ifdef QUANT_2PASS_SUPPORTED
;;;327      case JBUF_CRANK_DEST:
;;;328        /* For last pass of 2-pass quantization, just crank the postprocessor */
;;;329        pMain->pub.process_data = process_data_crank_post;
00045c  4836              LDR      r0,|L1.1336|
00045e  6060              STR      r0,[r4,#4]
;;;330        break;
000460  e008              B        |L1.1140|
                  |L1.1122|
;;;331    #endif
;;;332      default:
;;;333        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000462  f04f0004          MOV      r0,#4
000466  6829              LDR      r1,[r5,#0]
000468  6148              STR      r0,[r1,#0x14]
00046a  6828              LDR      r0,[r5,#0]
00046c  6801              LDR      r1,[r0,#0]
00046e  4628              MOV      r0,r5
000470  4788              BLX      r1
;;;334        break;
000472  bf00              NOP      
                  |L1.1140|
000474  bf00              NOP                            ;325
;;;335      }
;;;336    }
000476  bd70              POP      {r4-r6,pc}
;;;337    
                          ENDP

                  jinit_d_main_controller PROC
;;;475    GLOBAL(void)
;;;476    jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
000478  e92d47f0          PUSH     {r4-r10,lr}
;;;477    {
00047c  4604              MOV      r4,r0
00047e  4689              MOV      r9,r1
;;;478      my_main_ptr pMain;
;;;479      int ci, rgroup, ngroups;
;;;480      jpeg_component_info *compptr;
;;;481    
;;;482      pMain = (my_main_ptr)
000480  6860              LDR      r0,[r4,#4]
000482  f04f0238          MOV      r2,#0x38
000486  f04f0101          MOV      r1,#1
00048a  6803              LDR      r3,[r0,#0]
00048c  4620              MOV      r0,r4
00048e  4798              BLX      r3
000490  4607              MOV      r7,r0
;;;483        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;484    				SIZEOF(my_main_controller));
;;;485      cinfo->main = (struct jpeg_d_main_controller *) pMain;
000492  f8c471a8          STR      r7,[r4,#0x1a8]
;;;486      pMain->pub.start_pass = start_pass_main;
000496  4829              LDR      r0,|L1.1340|
000498  6038              STR      r0,[r7,#0]
;;;487    
;;;488      if (need_full_buffer)		/* shouldn't happen */
00049a  f1b90f00          CMP      r9,#0
00049e  d007              BEQ      |L1.1200|
;;;489        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
0004a0  f04f0004          MOV      r0,#4
0004a4  6821              LDR      r1,[r4,#0]
0004a6  6148              STR      r0,[r1,#0x14]
0004a8  6820              LDR      r0,[r4,#0]
0004aa  6801              LDR      r1,[r0,#0]
0004ac  4620              MOV      r0,r4
0004ae  4788              BLX      r1
                  |L1.1200|
;;;490    
;;;491      /* Allocate the workspace.
;;;492       * ngroups is the number of row groups we need.
;;;493       */
;;;494      if (cinfo->upsample->need_context_rows) {
0004b0  f8d401c4          LDR      r0,[r4,#0x1c4]
0004b4  6880              LDR      r0,[r0,#8]
0004b6  b198              CBZ      r0,|L1.1248|
;;;495        if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
0004b8  f8d4013c          LDR      r0,[r4,#0x13c]
0004bc  2802              CMP      r0,#2
0004be  da07              BGE      |L1.1232|
;;;496          ERREXIT(cinfo, JERR_NOTIMPL);
0004c0  f04f002f          MOV      r0,#0x2f
0004c4  6821              LDR      r1,[r4,#0]
0004c6  6148              STR      r0,[r1,#0x14]
0004c8  6820              LDR      r0,[r4,#0]
0004ca  6801              LDR      r1,[r0,#0]
0004cc  4620              MOV      r0,r4
0004ce  4788              BLX      r1
                  |L1.1232|
;;;497        alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
0004d0  4620              MOV      r0,r4
0004d2  f7fffffe          BL       alloc_funny_pointers
;;;498        ngroups = cinfo->min_DCT_scaled_size + 2;
0004d6  f8d4013c          LDR      r0,[r4,#0x13c]
0004da  f1000802          ADD      r8,r0,#2
0004de  e001              B        |L1.1252|
                  |L1.1248|
;;;499      } else {
;;;500        ngroups = cinfo->min_DCT_scaled_size;
0004e0  f8d4813c          LDR      r8,[r4,#0x13c]
                  |L1.1252|
;;;501      }
;;;502    
;;;503      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
0004e4  f04f0600          MOV      r6,#0
0004e8  f8d450d8          LDR      r5,[r4,#0xd8]
0004ec  e01a              B        |L1.1316|
                  |L1.1262|
;;;504           ci++, compptr++) {
;;;505        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
0004ee  6a69              LDR      r1,[r5,#0x24]
0004f0  68e8              LDR      r0,[r5,#0xc]
0004f2  4348              MULS     r0,r1,r0
0004f4  f8d4113c          LDR      r1,[r4,#0x13c]
0004f8  fb90faf1          SDIV     r10,r0,r1
;;;506          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;507        pMain->buffer[ci] = (*cinfo->mem->alloc_sarray)
0004fc  6a69              LDR      r1,[r5,#0x24]
0004fe  69e8              LDR      r0,[r5,#0x1c]
000500  fb00f201          MUL      r2,r0,r1
000504  fb0af308          MUL      r3,r10,r8
000508  6860              LDR      r0,[r4,#4]
00050a  2101              MOVS     r1,#1
00050c  f8d0c008          LDR      r12,[r0,#8]
000510  4620              MOV      r0,r4
000512  47e0              BLX      r12
000514  f1070108          ADD      r1,r7,#8
000518  f8410026          STR      r0,[r1,r6,LSL #2]
00051c  f1060601          ADD      r6,r6,#1              ;504
000520  f1050554          ADD      r5,r5,#0x54           ;504
                  |L1.1316|
000524  6a60              LDR      r0,[r4,#0x24]         ;503
000526  42b0              CMP      r0,r6                 ;503
000528  dce1              BGT      |L1.1262|
;;;508    			((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;509    			 compptr->width_in_blocks * compptr->DCT_scaled_size,
;;;510    			 (JDIMENSION) (rgroup * ngroups));
;;;511      }
;;;512    }
00052a  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

00052e  0000              DCW      0x0000
                  |L1.1328|
                          DCD      process_data_context_main
                  |L1.1332|
                          DCD      process_data_simple_main
                  |L1.1336|
                          DCD      process_data_crank_post
                  |L1.1340|
                          DCD      start_pass_main
