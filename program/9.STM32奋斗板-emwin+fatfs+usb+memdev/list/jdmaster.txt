; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdmaster.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdmaster.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdmaster.crf GUI\JPEG\jdmaster.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  use_merged_upsample PROC
;;;43     LOCAL(boolean)
;;;44     use_merged_upsample (j_decompress_ptr cinfo)
000000  4601              MOV      r1,r0
;;;45     {
;;;46     #ifdef UPSAMPLE_MERGING_SUPPORTED
;;;47       /* Merging is the equivalent of plain box-filter upsampling */
;;;48       if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
000002  6cc8              LDR      r0,[r1,#0x4c]
000004  b910              CBNZ     r0,|L1.12|
000006  f8d1012c          LDR      r0,[r1,#0x12c]
00000a  b108              CBZ      r0,|L1.16|
                  |L1.12|
;;;49         return FALSE;
00000c  2000              MOVS     r0,#0
                  |L1.14|
;;;50       /* jdmerge.c only supports YCC=>RGB color conversion */
;;;51       if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
;;;52           cinfo->out_color_space != JCS_RGB ||
;;;53           cinfo->out_color_components != RGB_PIXELSIZE)
;;;54         return FALSE;
;;;55       /* and it only handles 2h1v or 2h2v sampling ratios */
;;;56       if (cinfo->comp_info[0].h_samp_factor != 2 ||
;;;57           cinfo->comp_info[1].h_samp_factor != 1 ||
;;;58           cinfo->comp_info[2].h_samp_factor != 1 ||
;;;59           cinfo->comp_info[0].v_samp_factor >  2 ||
;;;60           cinfo->comp_info[1].v_samp_factor != 1 ||
;;;61           cinfo->comp_info[2].v_samp_factor != 1)
;;;62         return FALSE;
;;;63       /* furthermore, it doesn't work if we've scaled the IDCTs differently */
;;;64       if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
;;;65           cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
;;;66           cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)
;;;67         return FALSE;
;;;68       /* ??? also need to test for upsample-time rescaling, when & if supported */
;;;69       return TRUE;			/* by golly, it'll work... */
;;;70     #else
;;;71       return FALSE;
;;;72     #endif
;;;73     }
00000e  4770              BX       lr
                  |L1.16|
000010  f8910028          LDRB     r0,[r1,#0x28]         ;51
000014  2803              CMP      r0,#3                 ;51
000016  d109              BNE      |L1.44|
000018  6a48              LDR      r0,[r1,#0x24]         ;51
00001a  2803              CMP      r0,#3                 ;51
00001c  d106              BNE      |L1.44|
00001e  f8910029          LDRB     r0,[r1,#0x29]         ;52
000022  2802              CMP      r0,#2                 ;52
000024  d102              BNE      |L1.44|
000026  6f88              LDR      r0,[r1,#0x78]         ;53
000028  2803              CMP      r0,#3                 ;53
00002a  d001              BEQ      |L1.48|
                  |L1.44|
00002c  2000              MOVS     r0,#0                 ;54
00002e  e7ee              B        |L1.14|
                  |L1.48|
000030  f8d100d8          LDR      r0,[r1,#0xd8]         ;56
000034  6880              LDR      r0,[r0,#8]            ;56
000036  2802              CMP      r0,#2                 ;56
000038  d11a              BNE      |L1.112|
00003a  f8d100d8          LDR      r0,[r1,#0xd8]         ;57
00003e  6dc0              LDR      r0,[r0,#0x5c]         ;57
000040  2801              CMP      r0,#1                 ;57
000042  d115              BNE      |L1.112|
000044  f8d100d8          LDR      r0,[r1,#0xd8]         ;58
000048  f8d000b0          LDR      r0,[r0,#0xb0]         ;58
00004c  2801              CMP      r0,#1                 ;58
00004e  d10f              BNE      |L1.112|
000050  f8d100d8          LDR      r0,[r1,#0xd8]         ;59
000054  68c0              LDR      r0,[r0,#0xc]          ;59
000056  2802              CMP      r0,#2                 ;59
000058  dc0a              BGT      |L1.112|
00005a  f8d100d8          LDR      r0,[r1,#0xd8]         ;60
00005e  6e00              LDR      r0,[r0,#0x60]         ;60
000060  2801              CMP      r0,#1                 ;60
000062  d105              BNE      |L1.112|
000064  f8d100d8          LDR      r0,[r1,#0xd8]         ;61
000068  f8d000b4          LDR      r0,[r0,#0xb4]         ;61
00006c  2801              CMP      r0,#1                 ;61
00006e  d001              BEQ      |L1.116|
                  |L1.112|
000070  2000              MOVS     r0,#0                 ;62
000072  e7cc              B        |L1.14|
                  |L1.116|
000074  f8d100d8          LDR      r0,[r1,#0xd8]         ;64
000078  6a40              LDR      r0,[r0,#0x24]         ;64
00007a  f8d1213c          LDR      r2,[r1,#0x13c]        ;64
00007e  4290              CMP      r0,r2                 ;64
000080  d10e              BNE      |L1.160|
000082  f8d100d8          LDR      r0,[r1,#0xd8]         ;65
000086  6f80              LDR      r0,[r0,#0x78]         ;65
000088  f8d1213c          LDR      r2,[r1,#0x13c]        ;65
00008c  4290              CMP      r0,r2                 ;65
00008e  d107              BNE      |L1.160|
000090  f8d100d8          LDR      r0,[r1,#0xd8]         ;66
000094  f8d000cc          LDR      r0,[r0,#0xcc]         ;66
000098  f8d1213c          LDR      r2,[r1,#0x13c]        ;66
00009c  4290              CMP      r0,r2                 ;66
00009e  d001              BEQ      |L1.164|
                  |L1.160|
0000a0  2000              MOVS     r0,#0                 ;67
0000a2  e7b4              B        |L1.14|
                  |L1.164|
0000a4  2001              MOVS     r0,#1                 ;69
0000a6  e7b2              B        |L1.14|
;;;74     
                          ENDP

                  jpeg_calc_output_dimensions PROC
;;;83     GLOBAL(void)
;;;84     jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
0000a8  b510              PUSH     {r4,lr}
;;;85     /* Do computations that are needed before master selection phase */
;;;86     {
0000aa  4604              MOV      r4,r0
;;;87     #ifdef IDCT_SCALING_SUPPORTED
;;;88       int ci;
;;;89       jpeg_component_info *compptr;
;;;90     #endif
;;;91     
;;;92       /* Prevent application from calling me at wrong times */
;;;93       if (cinfo->global_state != DSTATE_READY)
0000ac  6960              LDR      r0,[r4,#0x14]
0000ae  28ca              CMP      r0,#0xca
0000b0  d00a              BEQ      |L1.200|
;;;94         ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
0000b2  f04f0014          MOV      r0,#0x14
0000b6  6821              LDR      r1,[r4,#0]
0000b8  6148              STR      r0,[r1,#0x14]
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6960              LDR      r0,[r4,#0x14]
0000be  6188              STR      r0,[r1,#0x18]
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6801              LDR      r1,[r0,#0]
0000c4  4620              MOV      r0,r4
0000c6  4788              BLX      r1
                  |L1.200|
;;;95     
;;;96     #ifdef IDCT_SCALING_SUPPORTED
;;;97     
;;;98       /* Compute actual output image dimensions and DCT scaling choices. */
;;;99       if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
;;;100        /* Provide 1/8 scaling */
;;;101        cinfo->output_width = (JDIMENSION)
;;;102          jdiv_round_up((long) cinfo->image_width, 8L);
;;;103        cinfo->output_height = (JDIMENSION)
;;;104          jdiv_round_up((long) cinfo->image_height, 8L);
;;;105        cinfo->min_DCT_scaled_size = 1;
;;;106      } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
;;;107        /* Provide 1/4 scaling */
;;;108        cinfo->output_width = (JDIMENSION)
;;;109          jdiv_round_up((long) cinfo->image_width, 4L);
;;;110        cinfo->output_height = (JDIMENSION)
;;;111          jdiv_round_up((long) cinfo->image_height, 4L);
;;;112        cinfo->min_DCT_scaled_size = 2;
;;;113      } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
;;;114        /* Provide 1/2 scaling */
;;;115        cinfo->output_width = (JDIMENSION)
;;;116          jdiv_round_up((long) cinfo->image_width, 2L);
;;;117        cinfo->output_height = (JDIMENSION)
;;;118          jdiv_round_up((long) cinfo->image_height, 2L);
;;;119        cinfo->min_DCT_scaled_size = 4;
;;;120      } else {
;;;121        /* Provide 1/1 scaling */
;;;122        cinfo->output_width = cinfo->image_width;
;;;123        cinfo->output_height = cinfo->image_height;
;;;124        cinfo->min_DCT_scaled_size = DCTSIZE;
;;;125      }
;;;126      /* In selecting the actual DCT scaling for each component, we try to
;;;127       * scale up the chroma components via IDCT scaling rather than upsampling.
;;;128       * This saves time if the upsampler gets to use 1:1 scaling.
;;;129       * Note this code assumes that the supported DCT scalings are powers of 2.
;;;130       */
;;;131      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;132           ci++, compptr++) {
;;;133        int ssize = cinfo->min_DCT_scaled_size;
;;;134        while (ssize < DCTSIZE &&
;;;135    	   (compptr->h_samp_factor * ssize * 2 <=
;;;136    	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
;;;137    	   (compptr->v_samp_factor * ssize * 2 <=
;;;138    	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
;;;139          ssize = ssize * 2;
;;;140        }
;;;141        compptr->DCT_scaled_size = ssize;
;;;142      }
;;;143    
;;;144      /* Recompute downsampled dimensions of components;
;;;145       * application needs to know these if using raw downsampled data.
;;;146       */
;;;147      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;148           ci++, compptr++) {
;;;149        /* Size in samples, after IDCT scaling */
;;;150        compptr->downsampled_width = (JDIMENSION)
;;;151          jdiv_round_up((long) cinfo->image_width *
;;;152    		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
;;;153    		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
;;;154        compptr->downsampled_height = (JDIMENSION)
;;;155          jdiv_round_up((long) cinfo->image_height *
;;;156    		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
;;;157    		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
;;;158      }
;;;159    
;;;160    #else /* !IDCT_SCALING_SUPPORTED */
;;;161    
;;;162      /* Hardwire it to "no scaling" */
;;;163      cinfo->output_width = cinfo->image_width;
0000c8  69e0              LDR      r0,[r4,#0x1c]
0000ca  6720              STR      r0,[r4,#0x70]
;;;164      cinfo->output_height = cinfo->image_height;
0000cc  6a20              LDR      r0,[r4,#0x20]
0000ce  6760              STR      r0,[r4,#0x74]
;;;165      /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,
;;;166       * and has computed unscaled downsampled_width and downsampled_height.
;;;167       */
;;;168    
;;;169    #endif /* IDCT_SCALING_SUPPORTED */
;;;170    
;;;171      /* Report number of components in selected colorspace. */
;;;172      /* Probably this should be in the color conversion module... */
;;;173      switch (cinfo->out_color_space) {
0000d0  f8940029          LDRB     r0,[r4,#0x29]
0000d4  2806              CMP      r0,#6
0000d6  d212              BCS      |L1.254|
0000d8  e8dff000          TBB      [pc,r0]
0000dc  11030708          DCB      0x11,0x03,0x07,0x08
0000e0  0c0d              DCB      0x0c,0x0d
;;;174      case JCS_GRAYSCALE:
;;;175        cinfo->out_color_components = 1;
0000e2  f04f0001          MOV      r0,#1
0000e6  67a0              STR      r0,[r4,#0x78]
;;;176        break;
0000e8  e00c              B        |L1.260|
;;;177      case JCS_RGB:
;;;178    #if RGB_PIXELSIZE != 3
;;;179        cinfo->out_color_components = RGB_PIXELSIZE;
;;;180        break;
;;;181    #endif /* else share code with YCbCr */
;;;182      case JCS_YCbCr:
0000ea  bf00              NOP      
;;;183        cinfo->out_color_components = 3;
0000ec  f04f0003          MOV      r0,#3
0000f0  67a0              STR      r0,[r4,#0x78]
;;;184        break;
0000f2  e007              B        |L1.260|
;;;185      case JCS_CMYK:
;;;186      case JCS_YCCK:
0000f4  bf00              NOP      
;;;187        cinfo->out_color_components = 4;
0000f6  f04f0004          MOV      r0,#4
0000fa  67a0              STR      r0,[r4,#0x78]
;;;188        break;
0000fc  e002              B        |L1.260|
                  |L1.254|
;;;189      default:			/* else must be same colorspace as in file */
;;;190        cinfo->out_color_components = cinfo->num_components;
0000fe  6a60              LDR      r0,[r4,#0x24]
000100  67a0              STR      r0,[r4,#0x78]
;;;191        break;
000102  bf00              NOP      
                  |L1.260|
000104  bf00              NOP                            ;176
;;;192      }
;;;193      cinfo->output_components = (cinfo->quantize_colors ? 1 :
000106  6d60              LDR      r0,[r4,#0x54]
000108  b110              CBZ      r0,|L1.272|
00010a  f04f0001          MOV      r0,#1
00010e  e000              B        |L1.274|
                  |L1.272|
;;;194    			      cinfo->out_color_components);
000110  6fa0              LDR      r0,[r4,#0x78]
                  |L1.274|
000112  67e0              STR      r0,[r4,#0x7c]
;;;195    
;;;196      /* See if upsampler will want to emit more than one row at a time */
;;;197      if (use_merged_upsample(cinfo))
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       use_merged_upsample
00011a  b120              CBZ      r0,|L1.294|
;;;198        cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
00011c  f8d40138          LDR      r0,[r4,#0x138]
000120  f8c40080          STR      r0,[r4,#0x80]
000124  e003              B        |L1.302|
                  |L1.294|
;;;199      else
;;;200        cinfo->rec_outbuf_height = 1;
000126  f04f0001          MOV      r0,#1
00012a  f8c40080          STR      r0,[r4,#0x80]
                  |L1.302|
;;;201    }
00012e  bd10              POP      {r4,pc}
;;;202    
                          ENDP

                  prepare_range_limit_table PROC
;;;247    LOCAL(void)
;;;248    prepare_range_limit_table (j_decompress_ptr cinfo)
000130  b570              PUSH     {r4-r6,lr}
;;;249    /* Allocate and fill in the sample_range_limit table */
;;;250    {
000132  4606              MOV      r6,r0
;;;251      JSAMPLE * table;
;;;252      int i;
;;;253    
;;;254      table = (JSAMPLE *)
000134  6870              LDR      r0,[r6,#4]
000136  f44f62b0          MOV      r2,#0x580
00013a  f04f0101          MOV      r1,#1
00013e  6803              LDR      r3,[r0,#0]
000140  4630              MOV      r0,r6
000142  4798              BLX      r3
000144  4604              MOV      r4,r0
;;;255        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;256    		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
;;;257      table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
000146  f5047480          ADD      r4,r4,#0x100
;;;258      cinfo->sample_range_limit = table;
00014a  f8c64144          STR      r4,[r6,#0x144]
;;;259      /* First segment of "simple" table: limit[x] = 0 for x < 0 */
;;;260      MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
00014e  f5a47080          SUB      r0,r4,#0x100
000152  f44f7180          MOV      r1,#0x100
000156  f7fffffe          BL       __aeabi_memclr
;;;261      /* Main part of "simple" table: limit[x] = x */
;;;262      for (i = 0; i <= MAXJSAMPLE; i++)
00015a  f04f0500          MOV      r5,#0
00015e  e002              B        |L1.358|
                  |L1.352|
;;;263        table[i] = (JSAMPLE) i;
000160  5565              STRB     r5,[r4,r5]
000162  f1050501          ADD      r5,r5,#1              ;262
                  |L1.358|
000166  2dff              CMP      r5,#0xff              ;262
000168  ddfa              BLE      |L1.352|
;;;264      table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
00016a  f1040480          ADD      r4,r4,#0x80
;;;265      /* End of simple table, rest of first half of post-IDCT table */
;;;266      for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
00016e  f04f0580          MOV      r5,#0x80
000172  e004              B        |L1.382|
                  |L1.372|
;;;267        table[i] = MAXJSAMPLE;
000174  f04f00ff          MOV      r0,#0xff
000178  5560              STRB     r0,[r4,r5]
00017a  f1050501          ADD      r5,r5,#1              ;266
                  |L1.382|
00017e  f5b57f00          CMP      r5,#0x200             ;266
000182  dbf7              BLT      |L1.372|
;;;268      /* Second half of post-IDCT table */
;;;269      MEMZERO(table + (2 * (MAXJSAMPLE+1)),
000184  f44f71c0          MOV      r1,#0x180
000188  f5047000          ADD      r0,r4,#0x200
00018c  f7fffffe          BL       __aeabi_memclr
;;;270    	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
;;;271      MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
000190  2280              MOVS     r2,#0x80
000192  f5047060          ADD      r0,r4,#0x380
000196  f8d61144          LDR      r1,[r6,#0x144]
00019a  f7fffffe          BL       __aeabi_memcpy
;;;272    	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
;;;273    }
00019e  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP

                  master_selection PROC
;;;287    LOCAL(void)
;;;288    master_selection (j_decompress_ptr cinfo)
0001a0  e92d41f0          PUSH     {r4-r8,lr}
;;;289    {
0001a4  4604              MOV      r4,r0
;;;290      my_master_ptr master = (my_master_ptr) cinfo->master;
0001a6  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;291      boolean use_c_buffer;
;;;292      long samplesperrow;
;;;293      JDIMENSION jd_samplesperrow;
;;;294    
;;;295      /* Initialize dimensions and other stuff */
;;;296      jpeg_calc_output_dimensions(cinfo);
0001aa  4620              MOV      r0,r4
0001ac  f7fffffe          BL       jpeg_calc_output_dimensions
;;;297      prepare_range_limit_table(cinfo);
0001b0  4620              MOV      r0,r4
0001b2  f7fffffe          BL       prepare_range_limit_table
;;;298    
;;;299      /* Width of an output scanline must be representable as JDIMENSION. */
;;;300      samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
0001b6  6fa1              LDR      r1,[r4,#0x78]
0001b8  6f20              LDR      r0,[r4,#0x70]
0001ba  fb00f601          MUL      r6,r0,r1
;;;301      jd_samplesperrow = (JDIMENSION) samplesperrow;
0001be  4637              MOV      r7,r6
;;;302      if ((long) jd_samplesperrow != samplesperrow)
0001c0  42b7              CMP      r7,r6
0001c2  d007              BEQ      |L1.468|
;;;303        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
0001c4  f04f0046          MOV      r0,#0x46
0001c8  6821              LDR      r1,[r4,#0]
0001ca  6148              STR      r0,[r1,#0x14]
0001cc  6820              LDR      r0,[r4,#0]
0001ce  6801              LDR      r1,[r0,#0]
0001d0  4620              MOV      r0,r4
0001d2  4788              BLX      r1
                  |L1.468|
;;;304    
;;;305      /* Initialize my private state */
;;;306      master->pass_number = 0;
0001d4  f04f0000          MOV      r0,#0
0001d8  60e8              STR      r0,[r5,#0xc]
;;;307      master->using_merged_upsample = use_merged_upsample(cinfo);
0001da  4620              MOV      r0,r4
0001dc  f7fffffe          BL       use_merged_upsample
0001e0  6128              STR      r0,[r5,#0x10]
;;;308    
;;;309      /* Color quantizer selection */
;;;310      master->quantizer_1pass = NULL;
0001e2  f04f0000          MOV      r0,#0
0001e6  6168              STR      r0,[r5,#0x14]
;;;311      master->quantizer_2pass = NULL;
0001e8  61a8              STR      r0,[r5,#0x18]
;;;312      /* No mode changes if not using buffered-image mode. */
;;;313      if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
0001ea  6d60              LDR      r0,[r4,#0x54]
0001ec  b108              CBZ      r0,|L1.498|
0001ee  6c20              LDR      r0,[r4,#0x40]
0001f0  b920              CBNZ     r0,|L1.508|
                  |L1.498|
;;;314        cinfo->enable_1pass_quant = FALSE;
0001f2  f04f0000          MOV      r0,#0
0001f6  6660              STR      r0,[r4,#0x64]
;;;315        cinfo->enable_external_quant = FALSE;
0001f8  66a0              STR      r0,[r4,#0x68]
;;;316        cinfo->enable_2pass_quant = FALSE;
0001fa  66e0              STR      r0,[r4,#0x6c]
                  |L1.508|
;;;317      }
;;;318      if (cinfo->quantize_colors) {
0001fc  6d60              LDR      r0,[r4,#0x54]
0001fe  2800              CMP      r0,#0
000200  d038              BEQ      |L1.628|
;;;319        if (cinfo->raw_data_out)
000202  6c60              LDR      r0,[r4,#0x44]
000204  b138              CBZ      r0,|L1.534|
;;;320          ERREXIT(cinfo, JERR_NOTIMPL);
000206  f04f002f          MOV      r0,#0x2f
00020a  6821              LDR      r1,[r4,#0]
00020c  6148              STR      r0,[r1,#0x14]
00020e  6820              LDR      r0,[r4,#0]
000210  6801              LDR      r1,[r0,#0]
000212  4620              MOV      r0,r4
000214  4788              BLX      r1
                  |L1.534|
;;;321        /* 2-pass quantizer only works in 3-component color space. */
;;;322        if (cinfo->out_color_components != 3) {
000216  6fa0              LDR      r0,[r4,#0x78]
000218  2803              CMP      r0,#3
00021a  d009              BEQ      |L1.560|
;;;323          cinfo->enable_1pass_quant = TRUE;
00021c  f04f0001          MOV      r0,#1
000220  6660              STR      r0,[r4,#0x64]
;;;324          cinfo->enable_external_quant = FALSE;
000222  f04f0000          MOV      r0,#0
000226  66a0              STR      r0,[r4,#0x68]
;;;325          cinfo->enable_2pass_quant = FALSE;
000228  66e0              STR      r0,[r4,#0x6c]
;;;326          cinfo->colormap = NULL;
00022a  f8c40088          STR      r0,[r4,#0x88]
00022e  e00f              B        |L1.592|
                  |L1.560|
;;;327        } else if (cinfo->colormap != NULL) {
000230  f8d40088          LDR      r0,[r4,#0x88]
000234  b118              CBZ      r0,|L1.574|
;;;328          cinfo->enable_external_quant = TRUE;
000236  f04f0001          MOV      r0,#1
00023a  66a0              STR      r0,[r4,#0x68]
00023c  e008              B        |L1.592|
                  |L1.574|
;;;329        } else if (cinfo->two_pass_quantize) {
00023e  6de0              LDR      r0,[r4,#0x5c]
000240  b118              CBZ      r0,|L1.586|
;;;330          cinfo->enable_2pass_quant = TRUE;
000242  f04f0001          MOV      r0,#1
000246  66e0              STR      r0,[r4,#0x6c]
000248  e002              B        |L1.592|
                  |L1.586|
;;;331        } else {
;;;332          cinfo->enable_1pass_quant = TRUE;
00024a  f04f0001          MOV      r0,#1
00024e  6660              STR      r0,[r4,#0x64]
                  |L1.592|
;;;333        }
;;;334    
;;;335        if (cinfo->enable_1pass_quant) {
000250  6e60              LDR      r0,[r4,#0x64]
000252  b128              CBZ      r0,|L1.608|
;;;336    #ifdef QUANT_1PASS_SUPPORTED
;;;337          jinit_1pass_quantizer(cinfo);
000254  4620              MOV      r0,r4
000256  f7fffffe          BL       jinit_1pass_quantizer
;;;338          master->quantizer_1pass = cinfo->cquantize;
00025a  f8d401cc          LDR      r0,[r4,#0x1cc]
00025e  6168              STR      r0,[r5,#0x14]
                  |L1.608|
;;;339    #else
;;;340          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;341    #endif
;;;342        }
;;;343    
;;;344        /* We use the 2-pass code to map to external colormaps. */
;;;345        if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
000260  6ee0              LDR      r0,[r4,#0x6c]
000262  b908              CBNZ     r0,|L1.616|
000264  6ea0              LDR      r0,[r4,#0x68]
000266  b128              CBZ      r0,|L1.628|
                  |L1.616|
;;;346    #ifdef QUANT_2PASS_SUPPORTED
;;;347          jinit_2pass_quantizer(cinfo);
000268  4620              MOV      r0,r4
00026a  f7fffffe          BL       jinit_2pass_quantizer
;;;348          master->quantizer_2pass = cinfo->cquantize;
00026e  f8d401cc          LDR      r0,[r4,#0x1cc]
000272  61a8              STR      r0,[r5,#0x18]
                  |L1.628|
;;;349    #else
;;;350          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;351    #endif
;;;352        }
;;;353        /* If both quantizers are initialized, the 2-pass one is left active;
;;;354         * this is necessary for starting with quantization to an external map.
;;;355         */
;;;356      }
;;;357    
;;;358      /* Post-processing: in particular, color conversion first */
;;;359      if (! cinfo->raw_data_out) {
000274  6c60              LDR      r0,[r4,#0x44]
000276  b978              CBNZ     r0,|L1.664|
;;;360        if (master->using_merged_upsample) {
000278  6928              LDR      r0,[r5,#0x10]
00027a  b118              CBZ      r0,|L1.644|
;;;361    #ifdef UPSAMPLE_MERGING_SUPPORTED
;;;362          jinit_merged_upsampler(cinfo); /* does color conversion too */
00027c  4620              MOV      r0,r4
00027e  f7fffffe          BL       jinit_merged_upsampler
000282  e005              B        |L1.656|
                  |L1.644|
;;;363    #else
;;;364          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;365    #endif
;;;366        } else {
;;;367          jinit_color_deconverter(cinfo);
000284  4620              MOV      r0,r4
000286  f7fffffe          BL       jinit_color_deconverter
;;;368          jinit_upsampler(cinfo);
00028a  4620              MOV      r0,r4
00028c  f7fffffe          BL       jinit_upsampler
                  |L1.656|
;;;369        }
;;;370        jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
000290  4620              MOV      r0,r4
000292  6ee1              LDR      r1,[r4,#0x6c]
000294  f7fffffe          BL       jinit_d_post_controller
                  |L1.664|
;;;371      }
;;;372      /* Inverse DCT */
;;;373      jinit_inverse_dct(cinfo);
000298  4620              MOV      r0,r4
00029a  f7fffffe          BL       jinit_inverse_dct
;;;374      /* Entropy decoding: either Huffman or arithmetic coding. */
;;;375      if (cinfo->arith_code) {
00029e  f8d400e0          LDR      r0,[r4,#0xe0]
0002a2  b140              CBZ      r0,|L1.694|
;;;376        ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
0002a4  f04f0001          MOV      r0,#1
0002a8  6821              LDR      r1,[r4,#0]
0002aa  6148              STR      r0,[r1,#0x14]
0002ac  6820              LDR      r0,[r4,#0]
0002ae  6801              LDR      r1,[r0,#0]
0002b0  4620              MOV      r0,r4
0002b2  4788              BLX      r1
0002b4  e009              B        |L1.714|
                  |L1.694|
;;;377      } else {
;;;378        if (cinfo->progressive_mode) {
0002b6  f8d400dc          LDR      r0,[r4,#0xdc]
0002ba  b118              CBZ      r0,|L1.708|
;;;379    #ifdef D_PROGRESSIVE_SUPPORTED
;;;380          jinit_phuff_decoder(cinfo);
0002bc  4620              MOV      r0,r4
0002be  f7fffffe          BL       jinit_phuff_decoder
0002c2  e002              B        |L1.714|
                  |L1.708|
;;;381    #else
;;;382          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;383    #endif
;;;384        } else
;;;385          jinit_huff_decoder(cinfo);
0002c4  4620              MOV      r0,r4
0002c6  f7fffffe          BL       jinit_huff_decoder
                  |L1.714|
;;;386      }
;;;387    
;;;388      /* Initialize principal buffer controllers. */
;;;389      use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
0002ca  f8d401b4          LDR      r0,[r4,#0x1b4]
0002ce  6900              LDR      r0,[r0,#0x10]
0002d0  b908              CBNZ     r0,|L1.726|
0002d2  6c20              LDR      r0,[r4,#0x40]
0002d4  b110              CBZ      r0,|L1.732|
                  |L1.726|
0002d6  f04f0001          MOV      r0,#1
0002da  e001              B        |L1.736|
                  |L1.732|
0002dc  f04f0000          MOV      r0,#0
                  |L1.736|
0002e0  4680              MOV      r8,r0
;;;390      jinit_d_coef_controller(cinfo, use_c_buffer);
0002e2  4641              MOV      r1,r8
0002e4  4620              MOV      r0,r4
0002e6  f7fffffe          BL       jinit_d_coef_controller
;;;391    
;;;392      if (! cinfo->raw_data_out)
0002ea  6c60              LDR      r0,[r4,#0x44]
0002ec  b918              CBNZ     r0,|L1.758|
;;;393        jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
0002ee  2100              MOVS     r1,#0
0002f0  4620              MOV      r0,r4
0002f2  f7fffffe          BL       jinit_d_main_controller
                  |L1.758|
;;;394    
;;;395      /* We can now tell the memory manager to allocate virtual arrays. */
;;;396      (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
0002f6  6860              LDR      r0,[r4,#4]
0002f8  6981              LDR      r1,[r0,#0x18]
0002fa  4620              MOV      r0,r4
0002fc  4788              BLX      r1
;;;397    
;;;398      /* Initialize input side of decompressor to consume first scan. */
;;;399      (*cinfo->inputctl->start_input_pass) (cinfo);
0002fe  f8d401b4          LDR      r0,[r4,#0x1b4]
000302  6881              LDR      r1,[r0,#8]
000304  4620              MOV      r0,r4
000306  4788              BLX      r1
;;;400    
;;;401    #ifdef D_MULTISCAN_FILES_SUPPORTED
;;;402      /* If jpeg_start_decompress will read the whole file, initialize
;;;403       * progress monitoring appropriately.  The input step is counted
;;;404       * as one pass.
;;;405       */
;;;406      if (cinfo->progress != NULL && ! cinfo->buffered_image &&
000308  68a0              LDR      r0,[r4,#8]
00030a  b358              CBZ      r0,|L1.868|
00030c  6c20              LDR      r0,[r4,#0x40]
00030e  bb48              CBNZ     r0,|L1.868|
;;;407          cinfo->inputctl->has_multiple_scans) {
000310  f8d401b4          LDR      r0,[r4,#0x1b4]
000314  6900              LDR      r0,[r0,#0x10]
000316  b328              CBZ      r0,|L1.868|
;;;408        int nscans;
;;;409        /* Estimate number of scans to set pass_limit. */
;;;410        if (cinfo->progressive_mode) {
000318  f8d410dc          LDR      r1,[r4,#0xdc]
00031c  b129              CBZ      r1,|L1.810|
;;;411          /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
;;;412          nscans = 2 + 3 * cinfo->num_components;
00031e  6a61              LDR      r1,[r4,#0x24]
000320  eb010141          ADD      r1,r1,r1,LSL #1
000324  f1010002          ADD      r0,r1,#2
000328  e000              B        |L1.812|
                  |L1.810|
;;;413        } else {
;;;414          /* For a nonprogressive multiscan file, estimate 1 scan per component. */
;;;415          nscans = cinfo->num_components;
00032a  6a60              LDR      r0,[r4,#0x24]
                  |L1.812|
;;;416        }
;;;417        cinfo->progress->pass_counter = 0L;
00032c  f04f0100          MOV      r1,#0
000330  68a2              LDR      r2,[r4,#8]
000332  6051              STR      r1,[r2,#4]
;;;418        cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
000334  f8d41140          LDR      r1,[r4,#0x140]
000338  fb01f100          MUL      r1,r1,r0
00033c  68a2              LDR      r2,[r4,#8]
00033e  6091              STR      r1,[r2,#8]
;;;419        cinfo->progress->completed_passes = 0;
000340  f04f0100          MOV      r1,#0
000344  68a2              LDR      r2,[r4,#8]
000346  60d1              STR      r1,[r2,#0xc]
;;;420        cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
000348  6ee1              LDR      r1,[r4,#0x6c]
00034a  b111              CBZ      r1,|L1.850|
00034c  f04f0103          MOV      r1,#3
000350  e001              B        |L1.854|
                  |L1.850|
000352  f04f0102          MOV      r1,#2
                  |L1.854|
000356  68a2              LDR      r2,[r4,#8]
000358  6111              STR      r1,[r2,#0x10]
;;;421        /* Count the input pass as done */
;;;422        master->pass_number++;
00035a  68e9              LDR      r1,[r5,#0xc]
00035c  f1010101          ADD      r1,r1,#1
000360  60e9              STR      r1,[r5,#0xc]
;;;423      }
000362  bf00              NOP      
                  |L1.868|
;;;424    #endif /* D_MULTISCAN_FILES_SUPPORTED */
;;;425    }
000364  e8bd81f0          POP      {r4-r8,pc}
;;;426    
                          ENDP

                  prepare_for_output_pass PROC
;;;437    METHODDEF(void)
;;;438    prepare_for_output_pass (j_decompress_ptr cinfo)
000368  b570              PUSH     {r4-r6,lr}
;;;439    {
00036a  4604              MOV      r4,r0
;;;440      my_master_ptr master = (my_master_ptr) cinfo->master;
00036c  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;441    
;;;442      if (master->pub.is_dummy_pass) {
000370  68a8              LDR      r0,[r5,#8]
000372  b1b0              CBZ      r0,|L1.930|
;;;443    #ifdef QUANT_2PASS_SUPPORTED
;;;444        /* Final pass of 2-pass quantization */
;;;445        master->pub.is_dummy_pass = FALSE;
000374  f04f0000          MOV      r0,#0
000378  60a8              STR      r0,[r5,#8]
;;;446        (*cinfo->cquantize->start_pass) (cinfo, FALSE);
00037a  f8d401cc          LDR      r0,[r4,#0x1cc]
00037e  f04f0100          MOV      r1,#0
000382  6802              LDR      r2,[r0,#0]
000384  4620              MOV      r0,r4
000386  4790              BLX      r2
;;;447        (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
000388  f8d401b0          LDR      r0,[r4,#0x1b0]
00038c  2102              MOVS     r1,#2
00038e  6802              LDR      r2,[r0,#0]
000390  4620              MOV      r0,r4
000392  4790              BLX      r2
;;;448        (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
000394  f8d401a8          LDR      r0,[r4,#0x1a8]
000398  2102              MOVS     r1,#2
00039a  6802              LDR      r2,[r0,#0]
00039c  4620              MOV      r0,r4
00039e  4790              BLX      r2
0003a0  e04e              B        |L1.1088|
                  |L1.930|
;;;449    #else
;;;450        ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;451    #endif /* QUANT_2PASS_SUPPORTED */
;;;452      } else {
;;;453        if (cinfo->quantize_colors && cinfo->colormap == NULL) {
0003a2  6d60              LDR      r0,[r4,#0x54]
0003a4  b1d8              CBZ      r0,|L1.990|
0003a6  f8d40088          LDR      r0,[r4,#0x88]
0003aa  b9c0              CBNZ     r0,|L1.990|
;;;454          /* Select new quantization method */
;;;455          if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
0003ac  6de0              LDR      r0,[r4,#0x5c]
0003ae  b140              CBZ      r0,|L1.962|
0003b0  6ee0              LDR      r0,[r4,#0x6c]
0003b2  b130              CBZ      r0,|L1.962|
;;;456    	cinfo->cquantize = master->quantizer_2pass;
0003b4  69a8              LDR      r0,[r5,#0x18]
0003b6  f8c401cc          STR      r0,[r4,#0x1cc]
;;;457    	master->pub.is_dummy_pass = TRUE;
0003ba  f04f0001          MOV      r0,#1
0003be  60a8              STR      r0,[r5,#8]
0003c0  e00d              B        |L1.990|
                  |L1.962|
;;;458          } else if (cinfo->enable_1pass_quant) {
0003c2  6e60              LDR      r0,[r4,#0x64]
0003c4  b118              CBZ      r0,|L1.974|
;;;459    	cinfo->cquantize = master->quantizer_1pass;
0003c6  6968              LDR      r0,[r5,#0x14]
0003c8  f8c401cc          STR      r0,[r4,#0x1cc]
0003cc  e007              B        |L1.990|
                  |L1.974|
;;;460          } else {
;;;461    	ERREXIT(cinfo, JERR_MODE_CHANGE);
0003ce  f04f002e          MOV      r0,#0x2e
0003d2  6821              LDR      r1,[r4,#0]
0003d4  6148              STR      r0,[r1,#0x14]
0003d6  6820              LDR      r0,[r4,#0]
0003d8  6801              LDR      r1,[r0,#0]
0003da  4620              MOV      r0,r4
0003dc  4788              BLX      r1
                  |L1.990|
;;;462          }
;;;463        }
;;;464        (*cinfo->idct->start_pass) (cinfo);
0003de  f8d401c0          LDR      r0,[r4,#0x1c0]
0003e2  6801              LDR      r1,[r0,#0]
0003e4  4620              MOV      r0,r4
0003e6  4788              BLX      r1
;;;465        (*cinfo->coef->start_output_pass) (cinfo);
0003e8  f8d401ac          LDR      r0,[r4,#0x1ac]
0003ec  6881              LDR      r1,[r0,#8]
0003ee  4620              MOV      r0,r4
0003f0  4788              BLX      r1
;;;466        if (! cinfo->raw_data_out) {
0003f2  6c60              LDR      r0,[r4,#0x44]
0003f4  bb20              CBNZ     r0,|L1.1088|
;;;467          if (! master->using_merged_upsample)
0003f6  6928              LDR      r0,[r5,#0x10]
0003f8  b920              CBNZ     r0,|L1.1028|
;;;468    	(*cinfo->cconvert->start_pass) (cinfo);
0003fa  f8d401c8          LDR      r0,[r4,#0x1c8]
0003fe  6801              LDR      r1,[r0,#0]
000400  4620              MOV      r0,r4
000402  4788              BLX      r1
                  |L1.1028|
;;;469          (*cinfo->upsample->start_pass) (cinfo);
000404  f8d401c4          LDR      r0,[r4,#0x1c4]
000408  6801              LDR      r1,[r0,#0]
00040a  4620              MOV      r0,r4
00040c  4788              BLX      r1
;;;470          if (cinfo->quantize_colors)
00040e  6d60              LDR      r0,[r4,#0x54]
000410  b128              CBZ      r0,|L1.1054|
;;;471    	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
000412  68a9              LDR      r1,[r5,#8]
000414  f8d401cc          LDR      r0,[r4,#0x1cc]
000418  6802              LDR      r2,[r0,#0]
00041a  4620              MOV      r0,r4
00041c  4790              BLX      r2
                  |L1.1054|
;;;472          (*cinfo->post->start_pass) (cinfo,
00041e  68a8              LDR      r0,[r5,#8]
000420  b108              CBZ      r0,|L1.1062|
;;;473    	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
000422  2003              MOVS     r0,#3
000424  e000              B        |L1.1064|
                  |L1.1062|
000426  2000              MOVS     r0,#0
                  |L1.1064|
000428  4601              MOV      r1,r0
00042a  f8d401b0          LDR      r0,[r4,#0x1b0]
00042e  6802              LDR      r2,[r0,#0]
000430  4620              MOV      r0,r4
000432  4790              BLX      r2
;;;474          (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
000434  f8d401a8          LDR      r0,[r4,#0x1a8]
000438  2100              MOVS     r1,#0
00043a  6802              LDR      r2,[r0,#0]
00043c  4620              MOV      r0,r4
00043e  4790              BLX      r2
                  |L1.1088|
;;;475        }
;;;476      }
;;;477    
;;;478      /* Set up progress monitor's pass info if present */
;;;479      if (cinfo->progress != NULL) {
000440  68a0              LDR      r0,[r4,#8]
000442  b1f8              CBZ      r0,|L1.1156|
;;;480        cinfo->progress->completed_passes = master->pass_number;
000444  68e8              LDR      r0,[r5,#0xc]
000446  68a1              LDR      r1,[r4,#8]
000448  60c8              STR      r0,[r1,#0xc]
;;;481        cinfo->progress->total_passes = master->pass_number +
00044a  e9d51002          LDRD     r1,r0,[r5,#8]
00044e  b111              CBZ      r1,|L1.1110|
;;;482    				    (master->pub.is_dummy_pass ? 2 : 1);
000450  f04f0102          MOV      r1,#2
000454  e001              B        |L1.1114|
                  |L1.1110|
000456  f04f0101          MOV      r1,#1
                  |L1.1114|
00045a  4408              ADD      r0,r0,r1
00045c  68a1              LDR      r1,[r4,#8]
00045e  6108              STR      r0,[r1,#0x10]
;;;483        /* In buffered-image mode, we assume one more output pass if EOI not
;;;484         * yet reached, but no more passes if EOI has been reached.
;;;485         */
;;;486        if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
000460  6c20              LDR      r0,[r4,#0x40]
000462  b178              CBZ      r0,|L1.1156|
000464  f8d401b4          LDR      r0,[r4,#0x1b4]
000468  6940              LDR      r0,[r0,#0x14]
00046a  b958              CBNZ     r0,|L1.1156|
;;;487          cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
00046c  68a0              LDR      r0,[r4,#8]
00046e  6900              LDR      r0,[r0,#0x10]
000470  6ee1              LDR      r1,[r4,#0x6c]
000472  b111              CBZ      r1,|L1.1146|
000474  f04f0102          MOV      r1,#2
000478  e001              B        |L1.1150|
                  |L1.1146|
00047a  f04f0101          MOV      r1,#1
                  |L1.1150|
00047e  4408              ADD      r0,r0,r1
000480  68a1              LDR      r1,[r4,#8]
000482  6108              STR      r0,[r1,#0x10]
                  |L1.1156|
;;;488        }
;;;489      }
;;;490    }
000484  bd70              POP      {r4-r6,pc}
;;;491    
                          ENDP

                  finish_output_pass PROC
;;;497    METHODDEF(void)
;;;498    finish_output_pass (j_decompress_ptr cinfo)
000486  b570              PUSH     {r4-r6,lr}
;;;499    {
000488  4604              MOV      r4,r0
;;;500      my_master_ptr master = (my_master_ptr) cinfo->master;
00048a  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;501    
;;;502      if (cinfo->quantize_colors)
00048e  6d60              LDR      r0,[r4,#0x54]
000490  b120              CBZ      r0,|L1.1180|
;;;503        (*cinfo->cquantize->finish_pass) (cinfo);
000492  f8d401cc          LDR      r0,[r4,#0x1cc]
000496  6881              LDR      r1,[r0,#8]
000498  4620              MOV      r0,r4
00049a  4788              BLX      r1
                  |L1.1180|
;;;504      master->pass_number++;
00049c  68e8              LDR      r0,[r5,#0xc]
00049e  f1000001          ADD      r0,r0,#1
0004a2  60e8              STR      r0,[r5,#0xc]
;;;505    }
0004a4  bd70              POP      {r4-r6,pc}
;;;506    
                          ENDP

                  jpeg_new_colormap PROC
;;;514    GLOBAL(void)
;;;515    jpeg_new_colormap (j_decompress_ptr cinfo)
0004a6  b570              PUSH     {r4-r6,lr}
;;;516    {
0004a8  4604              MOV      r4,r0
;;;517      my_master_ptr master = (my_master_ptr) cinfo->master;
0004aa  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;518    
;;;519      /* Prevent application from calling me at wrong times */
;;;520      if (cinfo->global_state != DSTATE_BUFIMAGE)
0004ae  6960              LDR      r0,[r4,#0x14]
0004b0  28cf              CMP      r0,#0xcf
0004b2  d00a              BEQ      |L1.1226|
;;;521        ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
0004b4  f04f0014          MOV      r0,#0x14
0004b8  6821              LDR      r1,[r4,#0]
0004ba  6148              STR      r0,[r1,#0x14]
0004bc  6821              LDR      r1,[r4,#0]
0004be  6960              LDR      r0,[r4,#0x14]
0004c0  6188              STR      r0,[r1,#0x18]
0004c2  6820              LDR      r0,[r4,#0]
0004c4  6801              LDR      r1,[r0,#0]
0004c6  4620              MOV      r0,r4
0004c8  4788              BLX      r1
                  |L1.1226|
;;;522    
;;;523      if (cinfo->quantize_colors && cinfo->enable_external_quant &&
0004ca  6d60              LDR      r0,[r4,#0x54]
0004cc  b180              CBZ      r0,|L1.1264|
0004ce  6ea0              LDR      r0,[r4,#0x68]
0004d0  b170              CBZ      r0,|L1.1264|
;;;524          cinfo->colormap != NULL) {
0004d2  f8d40088          LDR      r0,[r4,#0x88]
0004d6  b158              CBZ      r0,|L1.1264|
;;;525        /* Select 2-pass quantizer for external colormap use */
;;;526        cinfo->cquantize = master->quantizer_2pass;
0004d8  69a8              LDR      r0,[r5,#0x18]
0004da  f8c401cc          STR      r0,[r4,#0x1cc]
;;;527        /* Notify quantizer of colormap change */
;;;528        (*cinfo->cquantize->new_color_map) (cinfo);
0004de  f8d401cc          LDR      r0,[r4,#0x1cc]
0004e2  68c1              LDR      r1,[r0,#0xc]
0004e4  4620              MOV      r0,r4
0004e6  4788              BLX      r1
;;;529        master->pub.is_dummy_pass = FALSE; /* just in case */
0004e8  f04f0000          MOV      r0,#0
0004ec  60a8              STR      r0,[r5,#8]
0004ee  e007              B        |L1.1280|
                  |L1.1264|
;;;530      } else
;;;531        ERREXIT(cinfo, JERR_MODE_CHANGE);
0004f0  f04f002e          MOV      r0,#0x2e
0004f4  6821              LDR      r1,[r4,#0]
0004f6  6148              STR      r0,[r1,#0x14]
0004f8  6820              LDR      r0,[r4,#0]
0004fa  6801              LDR      r1,[r0,#0]
0004fc  4620              MOV      r0,r4
0004fe  4788              BLX      r1
                  |L1.1280|
;;;532    }
000500  bd70              POP      {r4-r6,pc}
;;;533    
                          ENDP

                  jinit_master_decompress PROC
;;;542    GLOBAL(void)
;;;543    jinit_master_decompress (j_decompress_ptr cinfo)
000502  b570              PUSH     {r4-r6,lr}
;;;544    {
000504  4605              MOV      r5,r0
;;;545      my_master_ptr master;
;;;546    
;;;547      master = (my_master_ptr)
000506  6868              LDR      r0,[r5,#4]
000508  f04f021c          MOV      r2,#0x1c
00050c  f04f0101          MOV      r1,#1
000510  6803              LDR      r3,[r0,#0]
000512  4628              MOV      r0,r5
000514  4798              BLX      r3
000516  4604              MOV      r4,r0
;;;548          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;549    				  SIZEOF(my_decomp_master));
;;;550      cinfo->master = (struct jpeg_decomp_master *) master;
000518  f8c541a4          STR      r4,[r5,#0x1a4]
;;;551      master->pub.prepare_for_output_pass = prepare_for_output_pass;
00051c  4805              LDR      r0,|L1.1332|
00051e  6020              STR      r0,[r4,#0]
;;;552      master->pub.finish_output_pass = finish_output_pass;
000520  4805              LDR      r0,|L1.1336|
000522  6060              STR      r0,[r4,#4]
;;;553    
;;;554      master->pub.is_dummy_pass = FALSE;
000524  f04f0000          MOV      r0,#0
000528  60a0              STR      r0,[r4,#8]
;;;555    
;;;556      master_selection(cinfo);
00052a  4628              MOV      r0,r5
00052c  f7fffffe          BL       master_selection
;;;557    }
000530  bd70              POP      {r4-r6,pc}
                          ENDP

000532  0000              DCW      0x0000
                  |L1.1332|
                          DCD      prepare_for_output_pass
                  |L1.1336|
                          DCD      finish_output_pass
