; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\guidev.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\guidev.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\guidev.crf GUI\MemDev\GUIDEV.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__GetRect PROC
;;;43     */
;;;44     void GUI_MEMDEV__GetRect(GUI_RECT* pRect) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;45       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  49fe              LDR      r1,|L1.1024|
000006  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
;;;46       pRect->x0 = pDev->x0;
000010  8820              LDRH     r0,[r4,#0]
000012  8028              STRH     r0,[r5,#0]
;;;47       pRect->y0 = pDev->y0;
000014  8860              LDRH     r0,[r4,#2]
000016  8068              STRH     r0,[r5,#2]
;;;48       pRect->x1 = pDev->x0 + pDev->XSize-1;
000018  8820              LDRH     r0,[r4,#0]
00001a  88a1              LDRH     r1,[r4,#4]
00001c  4408              ADD      r0,r0,r1
00001e  f1a00001          SUB      r0,r0,#1
000022  b200              SXTH     r0,r0
000024  80a8              STRH     r0,[r5,#4]
;;;49       pRect->y1 = pDev->y0 + pDev->YSize-1;
000026  8860              LDRH     r0,[r4,#2]
000028  88e1              LDRH     r1,[r4,#6]
00002a  4408              ADD      r0,r0,r1
00002c  f1a00001          SUB      r0,r0,#1
000030  b200              SXTH     r0,r0
000032  80e8              STRH     r0,[r5,#6]
;;;50     }
000034  bd70              POP      {r4-r6,pc}
;;;51     
                          ENDP

                  GUI_MEMDEV__Color2Index PROC
;;;55     */
;;;56     unsigned int GUI_MEMDEV__Color2Index(LCD_COLOR Color) {
000036  b570              PUSH     {r4-r6,lr}
000038  4604              MOV      r4,r0
;;;57       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
00003a  49f1              LDR      r1,|L1.1024|
00003c  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
000040  f7fffffe          BL       GUI_ALLOC_h2p
000044  4605              MOV      r5,r0
;;;58       return pDev->pfColor2Index(Color);
000046  4620              MOV      r0,r4
000048  69e9              LDR      r1,[r5,#0x1c]
00004a  4788              BLX      r1
;;;59     }
00004c  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

                  GUI_MEMDEV__Index2Color PROC
;;;64     */
;;;65     LCD_COLOR GUI_MEMDEV__Index2Color(int Index) {
00004e  b570              PUSH     {r4-r6,lr}
000050  4604              MOV      r4,r0
;;;66       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000052  49eb              LDR      r1,|L1.1024|
000054  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
000058  f7fffffe          BL       GUI_ALLOC_h2p
00005c  4605              MOV      r5,r0
;;;67       return pDev->pfIndex2Color(Index);
00005e  4620              MOV      r0,r4
000060  6a29              LDR      r1,[r5,#0x20]
000062  4788              BLX      r1
;;;68     }
000064  bd70              POP      {r4-r6,pc}
;;;69     
                          ENDP

                  GUI_MEMDEV__GetIndexMask PROC
;;;73     */
;;;74     unsigned int GUI_MEMDEV__GetIndexMask(void) {
000066  b510              PUSH     {r4,lr}
;;;75       GUI_MEMDEV * pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000068  49e5              LDR      r1,|L1.1024|
00006a  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
00006e  f7fffffe          BL       GUI_ALLOC_h2p
000072  4604              MOV      r4,r0
;;;76       return pDev->pfGetIndexMask();
000074  6a60              LDR      r0,[r4,#0x24]
000076  4780              BLX      r0
;;;77     }
000078  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  GUI_MEMDEV_Delete PROC
;;;88     */
;;;89     void GUI_MEMDEV_Delete(GUI_MEMDEV_Handle hMemDev) {
00007a  b570              PUSH     {r4-r6,lr}
00007c  4605              MOV      r5,r0
;;;90     /* Make sure memory device is not used */
;;;91       GUI_LOCK();
;;;92       if (hMemDev) {
00007e  b1a5              CBZ      r5,|L1.170|
;;;93         GUI_MEMDEV* pDev;
;;;94         if (GUI_Context.hDevData == hMemDev) {
000080  48df              LDR      r0,|L1.1024|
000082  f9b0004c          LDRSH    r0,[r0,#0x4c]  ; GUI_Context
000086  42a8              CMP      r0,r5
000088  d101              BNE      |L1.142|
;;;95     	    GUI_SelectLCD();
00008a  f7fffffe          BL       GUI_SelectLCD
                  |L1.142|
;;;96         }
;;;97         pDev = GUI_MEMDEV_H2P(hMemDev);
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       GUI_ALLOC_h2p
000094  4604              MOV      r4,r0
;;;98         /* Delete the associated usage device */
;;;99         if (pDev->hUsage)
000096  8b20              LDRH     r0,[r4,#0x18]
000098  b118              CBZ      r0,|L1.162|
;;;100          GUI_USAGE_DecUseCnt(pDev->hUsage);
00009a  f9b40018          LDRSH    r0,[r4,#0x18]
00009e  f7fffffe          BL       GUI_USAGE_DecUseCnt
                  |L1.162|
;;;101        GUI_ALLOC_Free(hMemDev);
0000a2  4628              MOV      r0,r5
0000a4  f7fffffe          BL       GUI_ALLOC_Free
;;;102      }
0000a8  bf00              NOP      
                  |L1.170|
;;;103      GUI_UNLOCK();
;;;104    }
0000aa  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP

                  GUI_MEMDEV__CreateFixed PROC
;;;109    */
;;;110    GUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xsize, int ysize, int Flags
0000ac  e92d4fff          PUSH     {r0-r11,lr}
;;;111                                            ,const tLCDDEV_APIList * pMemDevAPI
;;;112                                            ,tLCDDEV_Color2Index*        pfColor2Index
;;;113                                            ,tLCDDEV_Index2Color*        pfIndex2Color
;;;114                                            ,tLCDDEV_GetIndexMask*       pfGetIndexMask) {
0000b0  b083              SUB      sp,sp,#0xc
0000b2  4690              MOV      r8,r2
0000b4  461d              MOV      r5,r3
0000b6  f8dd9040          LDR      r9,[sp,#0x40]
;;;115      I32 MemSize;
;;;116      GUI_USAGE_Handle hUsage = 0;
0000ba  f04f0a00          MOV      r10,#0
;;;117      unsigned int BitsPerPixel, BytesPerLine;
;;;118      GUI_MEMDEV_Handle hMemDev;
;;;119      BitsPerPixel = pMemDevAPI->BitsPerPixel;
0000be  9811              LDR      r0,[sp,#0x44]
0000c0  6c00              LDR      r0,[r0,#0x40]
0000c2  9002              STR      r0,[sp,#8]
;;;120      BytesPerLine = (xsize * BitsPerPixel + 7) >> 3;     /* Note: This code works with 8 and 16 bit memory devices. If other BPPs are introduced for MemDevs, it needs to be changed */
0000c4  9902              LDR      r1,[sp,#8]
0000c6  fb08f001          MUL      r0,r8,r1
0000ca  f1000007          ADD      r0,r0,#7
0000ce  ea4f0bd0          LSR      r11,r0,#3
;;;121      /* Calc available MemSize */
;;;122      MemSize = GUI_ALLOC_GetMaxSize();
0000d2  f7fffffe          BL       GUI_ALLOC_GetMaxSize
0000d6  4606              MOV      r6,r0
;;;123      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
0000d8  f0190f01          TST      r9,#1
0000dc  d108              BNE      |L1.240|
;;;124        MemSize = (MemSize / 4) * 3;   /* We need to reserve some memory for usage object ... TBD: This can be optimized as we do not use memory perfectly. */
0000de  4630              MOV      r0,r6
0000e0  ea4f71e6          ASR      r1,r6,#31
0000e4  eb067191          ADD      r1,r6,r1,LSR #30
0000e8  ea4f01a1          ASR      r1,r1,#2
0000ec  eb010641          ADD      r6,r1,r1,LSL #1
                  |L1.240|
;;;125      }
;;;126      if (ysize<=0) {
0000f0  2d00              CMP      r5,#0
0000f2  dc0d              BGT      |L1.272|
;;;127        int MaxLines = (MemSize - sizeof(GUI_MEMDEV)) / BytesPerLine;
0000f4  f1a6012c          SUB      r1,r6,#0x2c
0000f8  fbb1f0fb          UDIV     r0,r1,r11
;;;128        ysize = (MaxLines > -ysize) ? -ysize : MaxLines;
0000fc  f1c50100          RSB      r1,r5,#0
000100  4288              CMP      r0,r1
000102  dd02              BLE      |L1.266|
000104  f1c50100          RSB      r1,r5,#0
000108  e000              B        |L1.268|
                  |L1.266|
00010a  4601              MOV      r1,r0
                  |L1.268|
00010c  460d              MOV      r5,r1
;;;129      }
00010e  bf00              NOP      
                  |L1.272|
;;;130      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
000110  f0190f01          TST      r9,#1
000114  d108              BNE      |L1.296|
;;;131        /* Create the usage map */
;;;132        hUsage = GUI_USAGE_BM_Create(x0, y0, xsize, ysize, 0);
000116  2000              MOVS     r0,#0
000118  462b              MOV      r3,r5
00011a  4642              MOV      r2,r8
00011c  9000              STR      r0,[sp,#0]
00011e  e9dd0103          LDRD     r0,r1,[sp,#0xc]
000122  f7fffffe          BL       GUI_USAGE_BM_Create
000126  4682              MOV      r10,r0
                  |L1.296|
;;;133      }
;;;134      /* Check if we can alloc sufficient memory */
;;;135      if (ysize <= 0) {
000128  2d00              CMP      r5,#0
00012a  dc03              BGT      |L1.308|
;;;136        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Too little memory");
;;;137        GUI_UNLOCK();
;;;138        return 0;    
00012c  2000              MOVS     r0,#0
                  |L1.302|
;;;139      }
;;;140      MemSize = ysize * BytesPerLine + sizeof(GUI_MEMDEV);
;;;141      if (Flags & GUI_MEMDEV_NOTRANS) {
;;;142        hMemDev = GUI_ALLOC_AllocNoInit(MemSize);
;;;143      } else {
;;;144        hMemDev = GUI_ALLOC_AllocZero(MemSize);
;;;145      }
;;;146      if (hMemDev) {
;;;147        GUI_MEMDEV* pDevData;
;;;148        pDevData = GUI_MEMDEV_H2P(hMemDev);
;;;149        pDevData->x0            = x0;
;;;150        pDevData->y0            = y0;
;;;151        pDevData->XSize         = xsize;
;;;152        pDevData->YSize         = ysize;
;;;153        pDevData->NumColors     = 
;;;154        #if GUI_NUM_LAYERS == 1
;;;155          LCD_GET_NUMCOLORS();
;;;156        #else
;;;157          LCD_GetNumColorsEx(GUI_Context.SelLayer);
;;;158        #endif
;;;159        pDevData->BytesPerLine  = BytesPerLine;
;;;160        pDevData->hUsage        = hUsage;
;;;161        /* Set color conversion routine pointers */
;;;162        pDevData->pfColor2Index = pfColor2Index;    /* LCD_L0_Color2Index; */
;;;163        pDevData->pfIndex2Color = pfIndex2Color;    /* LCD_L0_Index2Color; */
;;;164        pDevData->pfGetIndexMask= pfGetIndexMask;   /* LCD_L0_GetIndexMask */
;;;165    
;;;166        pDevData->pAPIList      = pMemDevAPI;
;;;167        pDevData->BitsPerPixel  = BitsPerPixel;
;;;168        #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;169          pDevData->LayerIndex  = GUI_Context.SelLayer;
;;;170        #else
;;;171          pDevData->LayerIndex  = 0;
;;;172        #endif
;;;173      } else {
;;;174        if (hUsage) {
;;;175          GUI_ALLOC_Free(hUsage);
;;;176        }
;;;177        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Alloc failed");
;;;178      }
;;;179      return hMemDev;
;;;180    }
00012e  b007              ADD      sp,sp,#0x1c
000130  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.308|
000134  fb05f00b          MUL      r0,r5,r11             ;140
000138  f100062c          ADD      r6,r0,#0x2c           ;140
00013c  f0190f01          TST      r9,#1                 ;141
000140  d004              BEQ      |L1.332|
000142  b230              SXTH     r0,r6                 ;142
000144  f7fffffe          BL       GUI_ALLOC_AllocNoInit
000148  4607              MOV      r7,r0                 ;142
00014a  e003              B        |L1.340|
                  |L1.332|
00014c  b230              SXTH     r0,r6                 ;144
00014e  f7fffffe          BL       GUI_ALLOC_AllocZero
000152  4607              MOV      r7,r0                 ;144
                  |L1.340|
000154  b31f              CBZ      r7,|L1.414|
000156  4638              MOV      r0,r7                 ;148
000158  f7fffffe          BL       GUI_ALLOC_h2p
00015c  4604              MOV      r4,r0                 ;148
00015e  9803              LDR      r0,[sp,#0xc]          ;149
000160  b200              SXTH     r0,r0                 ;149
000162  8020              STRH     r0,[r4,#0]            ;149
000164  9804              LDR      r0,[sp,#0x10]         ;150
000166  b200              SXTH     r0,r0                 ;150
000168  8060              STRH     r0,[r4,#2]            ;150
00016a  fa0ff088          SXTH     r0,r8                 ;151
00016e  80a0              STRH     r0,[r4,#4]            ;151
000170  b228              SXTH     r0,r5                 ;152
000172  80e0              STRH     r0,[r4,#6]            ;152
000174  f7fffffe          BL       LCD_GetNumColors
000178  60a0              STR      r0,[r4,#8]            ;153
00017a  f8c4b00c          STR      r11,[r4,#0xc]         ;159
00017e  f8a4a018          STRH     r10,[r4,#0x18]        ;160
000182  9812              LDR      r0,[sp,#0x48]         ;162
000184  61e0              STR      r0,[r4,#0x1c]         ;162
000186  9813              LDR      r0,[sp,#0x4c]         ;163
000188  6220              STR      r0,[r4,#0x20]         ;163
00018a  9814              LDR      r0,[sp,#0x50]         ;164
00018c  6260              STR      r0,[r4,#0x24]         ;164
00018e  9811              LDR      r0,[sp,#0x44]         ;166
000190  62a0              STR      r0,[r4,#0x28]         ;166
000192  9802              LDR      r0,[sp,#8]            ;167
000194  6120              STR      r0,[r4,#0x10]         ;167
000196  f04f0000          MOV      r0,#0                 ;171
00019a  6160              STR      r0,[r4,#0x14]         ;171
00019c  e005              B        |L1.426|
                  |L1.414|
00019e  f1ba0f00          CMP      r10,#0                ;174
0001a2  d002              BEQ      |L1.426|
0001a4  4650              MOV      r0,r10                ;175
0001a6  f7fffffe          BL       GUI_ALLOC_Free
                  |L1.426|
0001aa  4638              MOV      r0,r7                 ;179
0001ac  e7bf              B        |L1.302|
;;;181    
                          ENDP

                  GUI_MEMDEV_CreateEx PROC
;;;185    */
;;;186    GUI_MEMDEV_Handle GUI_MEMDEV_CreateEx(int x0, int y0, int xSize, int ySize, int Flags) {
0001ae  e92d4fff          PUSH     {r0-r11,lr}
0001b2  b085              SUB      sp,sp,#0x14
0001b4  4681              MOV      r9,r0
0001b6  468a              MOV      r10,r1
;;;187      GUI_MEMDEV_Handle hMemDev;
;;;188      const tLCDDEV_APIList * pDeviceAPI;
;;;189      tLCDDEV_Color2Index   * pfColor2Index;
;;;190      tLCDDEV_Index2Color   * pfIndex2Color;
;;;191      tLCDDEV_GetIndexMask  * pfGetIndexMask;
;;;192      GUI_LOCK();
;;;193      #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;194        pDeviceAPI = LCD_aAPI[GUI_Context.SelLayer];
;;;195      #else
;;;196        pDeviceAPI = LCD_aAPI[0];
0001b8  4892              LDR      r0,|L1.1028|
0001ba  f8d0b000          LDR      r11,[r0,#0]  ; LCD_aAPI
;;;197      #endif
;;;198      if (GUI_Context.hDevData == 0) {
0001be  4890              LDR      r0,|L1.1024|
0001c0  f8b0004c          LDRH     r0,[r0,#0x4c]  ; GUI_Context
0001c4  b948              CBNZ     r0,|L1.474|
;;;199        pfColor2Index = GUI_Context.pDeviceAPI->pfColor2Index;    /* LCD_L0_Color2Index; */
0001c6  488e              LDR      r0,|L1.1024|
0001c8  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
0001ca  6804              LDR      r4,[r0,#0]
;;;200        pfIndex2Color = GUI_Context.pDeviceAPI->pfIndex2Color;    /* LCD_L0_Index2Color; */
0001cc  488c              LDR      r0,|L1.1024|
0001ce  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
0001d0  6845              LDR      r5,[r0,#4]
;;;201        pfGetIndexMask= GUI_Context.pDeviceAPI->pfGetIndexMask;   /* LCD_L0_GetIndexMask */
0001d2  488b              LDR      r0,|L1.1024|
0001d4  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
0001d6  6886              LDR      r6,[r0,#8]
0001d8  e009              B        |L1.494|
                  |L1.474|
;;;202      } else {
;;;203        /* If a memory device is already selected, we create a compatible one by copying its data */
;;;204        GUI_MEMDEV* pDevSel;
;;;205        pDevSel = GUI_MEMDEV_H2P(GUI_Context.hDevData);
0001da  4989              LDR      r1,|L1.1024|
0001dc  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
0001e0  f7fffffe          BL       GUI_ALLOC_h2p
0001e4  4607              MOV      r7,r0
;;;206        pfColor2Index = pDevSel->pfColor2Index;
0001e6  69fc              LDR      r4,[r7,#0x1c]
;;;207        pfIndex2Color = pDevSel->pfIndex2Color;
0001e8  6a3d              LDR      r5,[r7,#0x20]
;;;208        pfGetIndexMask= pDevSel->pfGetIndexMask;
0001ea  6a7e              LDR      r6,[r7,#0x24]
;;;209      }
0001ec  bf00              NOP      
                  |L1.494|
;;;210      hMemDev = GUI_MEMDEV__CreateFixed(x0, y0, xSize, ySize, Flags, pDeviceAPI->pMemDevAPI, 
0001ee  f8db003c          LDR      r0,[r11,#0x3c]
0001f2  a901              ADD      r1,sp,#4
0001f4  c171              STM      r1!,{r0,r4-r6}
0001f6  9812              LDR      r0,[sp,#0x48]
0001f8  9000              STR      r0,[sp,#0]
0001fa  4651              MOV      r1,r10
0001fc  4648              MOV      r0,r9
0001fe  e9dd2307          LDRD     r2,r3,[sp,#0x1c]
000202  f7fffffe          BL       GUI_MEMDEV__CreateFixed
000206  4680              MOV      r8,r0
;;;211                                        pfColor2Index, pfIndex2Color ,pfGetIndexMask);
;;;212      GUI_UNLOCK();
;;;213      return hMemDev;
000208  4640              MOV      r0,r8
;;;214    }
00020a  b009              ADD      sp,sp,#0x24
00020c  e8bd8ff0          POP      {r4-r11,pc}
;;;215    /*********************************************************************
                          ENDP

                  GUI_MEMDEV_Create PROC
;;;218    */
;;;219    GUI_MEMDEV_Handle GUI_MEMDEV_Create(int x0, int y0, int xsize, int ysize) {
000210  b5f8              PUSH     {r3-r7,lr}
000212  4604              MOV      r4,r0
000214  460d              MOV      r5,r1
000216  4616              MOV      r6,r2
000218  461f              MOV      r7,r3
;;;220      return GUI_MEMDEV_CreateEx(x0, y0, xsize, ysize, GUI_MEMDEV_HASTRANS);
00021a  f04f0000          MOV      r0,#0
00021e  463b              MOV      r3,r7
000220  4632              MOV      r2,r6
000222  4629              MOV      r1,r5
000224  9000              STR      r0,[sp,#0]
000226  4620              MOV      r0,r4
000228  f7fffffe          BL       GUI_MEMDEV_CreateEx
;;;221    }
00022c  bdf8              POP      {r3-r7,pc}
;;;222    
                          ENDP

                  GUI_MEMDEV_Select PROC
;;;226    */
;;;227    GUI_MEMDEV_Handle GUI_MEMDEV_Select(GUI_MEMDEV_Handle hMem) {
00022e  b570              PUSH     {r4-r6,lr}
000230  4604              MOV      r4,r0
;;;228      GUI_MEMDEV_Handle r;
;;;229      GUI_LOCK();
;;;230      r = GUI_Context.hDevData;
000232  4873              LDR      r0,|L1.1024|
000234  f9b0504c          LDRSH    r5,[r0,#0x4c]  ; GUI_Context
;;;231      if (hMem == 0) {
000238  b914              CBNZ     r4,|L1.576|
;;;232        GUI_SelectLCD();
00023a  f7fffffe          BL       GUI_SelectLCD
00023e  e01a              B        |L1.630|
                  |L1.576|
;;;233      } else {
;;;234        GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
000240  4620              MOV      r0,r4
000242  f7fffffe          BL       GUI_ALLOC_h2p
000246  4606              MOV      r6,r0
;;;235        #if GUI_WINSUPPORT
;;;236          WM_Deactivate();
000248  f7fffffe          BL       WM_Deactivate
;;;237        #endif
;;;238        /* If LCD was selected Save cliprect */
;;;239        if (GUI_Context.hDevData == 0) {
00024c  486c              LDR      r0,|L1.1024|
00024e  f8b0004c          LDRH     r0,[r0,#0x4c]  ; GUI_Context
000252  b938              CBNZ     r0,|L1.612|
;;;240          GUI_Context.ClipRectPrev = GUI_Context.ClipRect;
000254  486a              LDR      r0,|L1.1024|
000256  4601              MOV      r1,r0
000258  688a              LDR      r2,[r1,#8]  ; GUI_Context
00025a  f8c0204e          STR      r2,[r0,#0x4e]  ; GUI_Context
00025e  68c9              LDR      r1,[r1,#0xc]  ; GUI_Context
000260  f8c01052          STR      r1,[r0,#0x52]  ; GUI_Context
                  |L1.612|
;;;241        }
;;;242        GUI_Context.hDevData = hMem;
000264  4866              LDR      r0,|L1.1024|
000266  f8a0404c          STRH     r4,[r0,#0x4c]
;;;243        GUI_Context.pDeviceAPI = pDev->pAPIList;
00026a  4965              LDR      r1,|L1.1024|
00026c  6ab0              LDR      r0,[r6,#0x28]
00026e  6488              STR      r0,[r1,#0x48]  ; GUI_Context
;;;244        LCD_SetClipRectMax();
000270  f7fffffe          BL       LCD_SetClipRectMax
;;;245      }
000274  bf00              NOP      
                  |L1.630|
;;;246      GUI_UNLOCK();
;;;247      return r;
000276  4628              MOV      r0,r5
;;;248    }
000278  bd70              POP      {r4-r6,pc}
;;;249    
                          ENDP

                  GUI_MEMDEV__WriteToActiveAt PROC
;;;253    */
;;;254    void GUI_MEMDEV__WriteToActiveAt(GUI_MEMDEV_Handle hMem,int x, int y) {
00027a  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
00027e  b08c              SUB      sp,sp,#0x30
000280  4692              MOV      r10,r2
;;;255      GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
000282  980c              LDR      r0,[sp,#0x30]
000284  f7fffffe          BL       GUI_ALLOC_h2p
000288  4605              MOV      r5,r0
;;;256      GUI_USAGE_h hUsage = pDev->hUsage; 
00028a  f9b50018          LDRSH    r0,[r5,#0x18]
00028e  900b              STR      r0,[sp,#0x2c]
;;;257      GUI_USAGE*  pUsage;
;;;258      int YSize = pDev->YSize;
000290  f9b50006          LDRSH    r0,[r5,#6]
000294  900a              STR      r0,[sp,#0x28]
;;;259      int yi;
;;;260      unsigned int BytesPerLine = pDev->BytesPerLine;
000296  68ef              LDR      r7,[r5,#0xc]
;;;261      unsigned int BitsPerPixel = pDev->BitsPerPixel;
000298  f8d5b010          LDR      r11,[r5,#0x10]
;;;262      int BytesPerPixel = BitsPerPixel >> 3;
00029c  ea4f00db          LSR      r0,r11,#3
0002a0  9009              STR      r0,[sp,#0x24]
;;;263      U8* pData = (U8*)(pDev+1);
0002a2  f105082c          ADD      r8,r5,#0x2c
;;;264      if (hUsage) {
0002a6  980b              LDR      r0,[sp,#0x2c]
0002a8  2800              CMP      r0,#0
0002aa  d065              BEQ      |L1.888|
;;;265        pUsage = GUI_USAGE_H2P(hUsage);
0002ac  980b              LDR      r0,[sp,#0x2c]
0002ae  f7fffffe          BL       GUI_ALLOC_h2p
0002b2  4606              MOV      r6,r0
;;;266        for (yi = 0; yi < YSize; yi++) {
0002b4  f04f0400          MOV      r4,#0
0002b8  e05a              B        |L1.880|
                  |L1.698|
;;;267          int xOff = 0;
0002ba  f04f0000          MOV      r0,#0
0002be  9008              STR      r0,[sp,#0x20]
;;;268          int XSize;
;;;269          XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
0002c0  68b0              LDR      r0,[r6,#8]
0002c2  4622              MOV      r2,r4
0002c4  a908              ADD      r1,sp,#0x20
0002c6  6943              LDR      r3,[r0,#0x14]
0002c8  4630              MOV      r0,r6
0002ca  4798              BLX      r3
0002cc  4681              MOV      r9,r0
;;;270          if (XSize == pDev->XSize) {
0002ce  f9b50004          LDRSH    r0,[r5,#4]
0002d2  4548              CMP      r0,r9
0002d4  d126              BNE      |L1.804|
;;;271            /* If the entire line is affected, calculate the number of entire lines */
;;;272            int y0 = yi;
0002d6  9407              STR      r4,[sp,#0x1c]
;;;273            while ((GUI_USAGE_GetNextDirty(pUsage, &xOff, yi + 1)) == XSize) {
0002d8  e001              B        |L1.734|
                  |L1.730|
;;;274              yi++;
0002da  f1040401          ADD      r4,r4,#1
                  |L1.734|
0002de  68b0              LDR      r0,[r6,#8]            ;273
0002e0  1c62              ADDS     r2,r4,#1              ;273
0002e2  a908              ADD      r1,sp,#0x20           ;273
0002e4  6943              LDR      r3,[r0,#0x14]         ;273
0002e6  4630              MOV      r0,r6                 ;273
0002e8  4798              BLX      r3                    ;273
0002ea  4548              CMP      r0,r9                 ;273
0002ec  d0f5              BEQ      |L1.730|
;;;275            }
;;;276    		    LCD_DrawBitmap(x, y + y0, pDev->XSize, yi - y0 + 1, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
0002ee  2000              MOVS     r0,#0
0002f0  e9cdb702          STRD     r11,r7,[sp,#8]
0002f4  e9cd8004          STRD     r8,r0,[sp,#0x10]
0002f8  2001              MOVS     r0,#1
0002fa  9000              STR      r0,[sp,#0]
0002fc  9001              STR      r0,[sp,#4]
0002fe  9807              LDR      r0,[sp,#0x1c]
000300  1a20              SUBS     r0,r4,r0
000302  1c43              ADDS     r3,r0,#1
000304  f9b52004          LDRSH    r2,[r5,#4]
000308  9807              LDR      r0,[sp,#0x1c]
00030a  eb0a0100          ADD      r1,r10,r0
00030e  980d              LDR      r0,[sp,#0x34]
000310  f7fffffe          BL       LCD_DrawBitmap
;;;277            pData += (yi - y0 + 1) * BytesPerLine;
000314  9807              LDR      r0,[sp,#0x1c]
000316  eba40000          SUB      r0,r4,r0
00031a  f1000001          ADD      r0,r0,#1
00031e  fb008807          MLA      r8,r0,r7,r8
;;;278          } else {
000322  e023              B        |L1.876|
                  |L1.804|
;;;279            /* Draw the partial line which needs to be drawn */
;;;280            for (; XSize; ) {
000324  e01e              B        |L1.868|
                  |L1.806|
;;;281              LCD_DrawBitmap(x + xOff, y + yi, XSize, 1, 1, 1, BitsPerPixel, BytesPerLine, pData + xOff * BytesPerPixel, NULL);
000326  2100              MOVS     r1,#0
000328  e9dd2008          LDRD     r2,r0,[sp,#0x20]
00032c  fb028000          MLA      r0,r2,r0,r8
000330  e9cdb702          STRD     r11,r7,[sp,#8]
000334  e9cd0104          STRD     r0,r1,[sp,#0x10]
000338  2001              MOVS     r0,#1
00033a  9000              STR      r0,[sp,#0]
00033c  eb0a0104          ADD      r1,r10,r4
000340  9001              STR      r0,[sp,#4]
000342  9b08              LDR      r3,[sp,#0x20]
000344  9a0d              LDR      r2,[sp,#0x34]
000346  18d0              ADDS     r0,r2,r3
000348  2301              MOVS     r3,#1
00034a  464a              MOV      r2,r9
00034c  f7fffffe          BL       LCD_DrawBitmap
;;;282              xOff += XSize;
000350  9808              LDR      r0,[sp,#0x20]
000352  4448              ADD      r0,r0,r9
000354  9008              STR      r0,[sp,#0x20]
;;;283              XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
000356  68b0              LDR      r0,[r6,#8]
000358  4622              MOV      r2,r4
00035a  a908              ADD      r1,sp,#0x20
00035c  6943              LDR      r3,[r0,#0x14]
00035e  4630              MOV      r0,r6
000360  4798              BLX      r3
000362  4681              MOV      r9,r0
                  |L1.868|
000364  f1b90f00          CMP      r9,#0                 ;280
000368  d1dd              BNE      |L1.806|
;;;284            }
;;;285            pData += BytesPerLine;
00036a  44b8              ADD      r8,r8,r7
                  |L1.876|
00036c  f1040401          ADD      r4,r4,#1              ;266
                  |L1.880|
000370  980a              LDR      r0,[sp,#0x28]         ;266
000372  4284              CMP      r4,r0                 ;266
000374  dba1              BLT      |L1.698|
000376  e00e              B        |L1.918|
                  |L1.888|
;;;286          }
;;;287        }
;;;288      } else {
;;;289    		LCD_DrawBitmap(x, y, pDev->XSize, YSize, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
000378  2000              MOVS     r0,#0
00037a  e9cdb702          STRD     r11,r7,[sp,#8]
00037e  e9cd8004          STRD     r8,r0,[sp,#0x10]
000382  2001              MOVS     r0,#1
000384  9000              STR      r0,[sp,#0]
000386  9001              STR      r0,[sp,#4]
000388  f9b52004          LDRSH    r2,[r5,#4]
00038c  4651              MOV      r1,r10
00038e  9b0a              LDR      r3,[sp,#0x28]
000390  980d              LDR      r0,[sp,#0x34]
000392  f7fffffe          BL       LCD_DrawBitmap
                  |L1.918|
;;;290      }
;;;291    }
000396  b00f              ADD      sp,sp,#0x3c
000398  e8bd8ff0          POP      {r4-r11,pc}
;;;292    
                          ENDP

                  GUI_MEMDEV_CopyToLCDAt PROC
;;;296    */
;;;297    void GUI_MEMDEV_CopyToLCDAt(GUI_MEMDEV_Handle hMem, int x, int y) {
00039c  e92d41fc          PUSH     {r2-r8,lr}
0003a0  4606              MOV      r6,r0
0003a2  460d              MOV      r5,r1
0003a4  4617              MOV      r7,r2
;;;298      if (hMem) {
0003a6  b37e              CBZ      r6,|L1.1032|
;;;299        GUI_MEMDEV_Handle hMemPrev;
;;;300        GUI_MEMDEV* pDevData;
;;;301      #if (GUI_WINSUPPORT)
;;;302        GUI_RECT r;
;;;303      #endif
;;;304      #if GUI_NUM_LAYERS > 1
;;;305        int PrevLayer;
;;;306      #endif
;;;307        GUI_LOCK();
;;;308        hMemPrev = GUI_Context.hDevData;
0003a8  4815              LDR      r0,|L1.1024|
0003aa  f9b0804c          LDRSH    r8,[r0,#0x4c]  ; GUI_Context
;;;309        pDevData = (GUI_MEMDEV*) GUI_ALLOC_h2p(hMem);  /* Convert to pointer */
0003ae  4630              MOV      r0,r6
0003b0  f7fffffe          BL       GUI_ALLOC_h2p
0003b4  4604              MOV      r4,r0
;;;310        /* Make sure LCD is selected as device */
;;;311      #if GUI_NUM_LAYERS > 1
;;;312        PrevLayer = GUI_SelectLayer(pDevData->LayerIndex);
;;;313      #else
;;;314        GUI_SelectLCD();  /* Activate LCD */
0003b6  f7fffffe          BL       GUI_SelectLCD
;;;315      #endif
;;;316        if (x == GUI_POS_AUTO) {
0003ba  f64070ff          MOV      r0,#0xfff
0003be  1940              ADDS     r0,r0,r5
0003c0  d103              BNE      |L1.970|
;;;317          x = pDevData->x0;
0003c2  f9b45000          LDRSH    r5,[r4,#0]
;;;318          y = pDevData->y0;
0003c6  f9b47002          LDRSH    r7,[r4,#2]
                  |L1.970|
;;;319        }
;;;320      #if (GUI_WINSUPPORT)
;;;321        /* Calculate rectangle */
;;;322        r.x1 = (r.x0 = x) + pDevData->XSize-1;
0003ca  b228              SXTH     r0,r5
0003cc  f8ad0000          STRH     r0,[sp,#0]
0003d0  88a1              LDRH     r1,[r4,#4]
0003d2  4408              ADD      r0,r0,r1
0003d4  f1a00001          SUB      r0,r0,#1
0003d8  b200              SXTH     r0,r0
0003da  f8ad0004          STRH     r0,[sp,#4]
;;;323        r.y1 = (r.y0 = y) + pDevData->YSize-1;;
0003de  b238              SXTH     r0,r7
0003e0  f8ad0002          STRH     r0,[sp,#2]
0003e4  88e1              LDRH     r1,[r4,#6]
0003e6  4408              ADD      r0,r0,r1
0003e8  f1a00001          SUB      r0,r0,#1
0003ec  b200              SXTH     r0,r0
0003ee  f8ad0006          STRH     r0,[sp,#6]
;;;324        /* Do the drawing. Window manager has to be on */
;;;325        WM_Activate();
0003f2  f7fffffe          BL       WM_Activate
;;;326        WM_ITERATE_START(&r) {
0003f6  4668              MOV      r0,sp
0003f8  f7fffffe          BL       WM__InitIVRSearch
0003fc  b178              CBZ      r0,|L1.1054|
0003fe  e004              B        |L1.1034|
                  |L1.1024|
                          DCD      GUI_Context
                  |L1.1028|
                          DCD      LCD_aAPI
                  |L1.1032|
000408  e00d              B        |L1.1062|
                  |L1.1034|
00040a  bf00              NOP      
                  |L1.1036|
;;;327      #endif
;;;328        GUI_MEMDEV__WriteToActiveAt(hMem, x, y);
00040c  463a              MOV      r2,r7
00040e  4629              MOV      r1,r5
000410  4630              MOV      r0,r6
000412  f7fffffe          BL       GUI_MEMDEV__WriteToActiveAt
;;;329      #if (GUI_WINSUPPORT)
;;;330        } WM_ITERATE_END();
000416  f7fffffe          BL       WM__GetNextIVR
00041a  2800              CMP      r0,#0
00041c  d1f6              BNE      |L1.1036|
                  |L1.1054|
;;;331      #endif
;;;332      #if GUI_NUM_LAYERS > 1
;;;333        GUI_SelectLayer(PrevLayer);
;;;334      #endif
;;;335        /* Reactivate previously used device */
;;;336        GUI_MEMDEV_Select(hMemPrev);
00041e  4640              MOV      r0,r8
000420  f7fffffe          BL       GUI_MEMDEV_Select
;;;337        GUI_UNLOCK();
;;;338      }
000424  bf00              NOP      
                  |L1.1062|
;;;339    }
000426  e8bd81fc          POP      {r2-r8,pc}
;;;340    
                          ENDP

                  GUI_MEMDEV_CopyToLCD PROC
;;;344    */
;;;345    void GUI_MEMDEV_CopyToLCD(GUI_MEMDEV_Handle hMem) {
00042a  b510              PUSH     {r4,lr}
00042c  4604              MOV      r4,r0
;;;346      GUI_MEMDEV_CopyToLCDAt(hMem, GUI_POS_AUTO, GUI_POS_AUTO);
00042e  4a03              LDR      r2,|L1.1084|
000430  4611              MOV      r1,r2
000432  4620              MOV      r0,r4
000434  f7fffffe          BL       GUI_MEMDEV_CopyToLCDAt
;;;347    }
000438  bd10              POP      {r4,pc}
;;;348    
                          ENDP

00043a  0000              DCW      0x0000
                  |L1.1084|
                          DCD      0xfffff001
