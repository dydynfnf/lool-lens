; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdinput.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdinput.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdinput.crf GUI\JPEG\jdinput.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  initial_setup PROC
;;;38     LOCAL(void)
;;;39     initial_setup (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;40     /* Called once, when first SOS marker is reached */
;;;41     {
000002  4604              MOV      r4,r0
;;;42       int ci;
;;;43       jpeg_component_info *compptr;
;;;44     
;;;45       /* Make sure image isn't bigger than I can handle */
;;;46       if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
000004  f64f71dc          MOV      r1,#0xffdc
000008  6a20              LDR      r0,[r4,#0x20]
00000a  4288              CMP      r0,r1
00000c  dc02              BGT      |L1.20|
;;;47           (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  4288              CMP      r0,r1
000012  dd0b              BLE      |L1.44|
                  |L1.20|
;;;48         ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
000014  f04f0029          MOV      r0,#0x29
000018  6821              LDR      r1,[r4,#0]
00001a  6148              STR      r0,[r1,#0x14]
00001c  f64f70dc          MOV      r0,#0xffdc
000020  6821              LDR      r1,[r4,#0]
000022  6188              STR      r0,[r1,#0x18]
000024  6820              LDR      r0,[r4,#0]
000026  6801              LDR      r1,[r0,#0]
000028  4620              MOV      r0,r4
00002a  4788              BLX      r1
                  |L1.44|
;;;49     
;;;50       /* For now, precision must match compiled-in value... */
;;;51       if (cinfo->data_precision != BITS_IN_JSAMPLE)
00002c  f8d400d4          LDR      r0,[r4,#0xd4]
000030  2808              CMP      r0,#8
000032  d00b              BEQ      |L1.76|
;;;52         ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
000034  f04f000f          MOV      r0,#0xf
000038  6821              LDR      r1,[r4,#0]
00003a  6148              STR      r0,[r1,#0x14]
00003c  6821              LDR      r1,[r4,#0]
00003e  f8d400d4          LDR      r0,[r4,#0xd4]
000042  6188              STR      r0,[r1,#0x18]
000044  6820              LDR      r0,[r4,#0]
000046  6801              LDR      r1,[r0,#0]
000048  4620              MOV      r0,r4
00004a  4788              BLX      r1
                  |L1.76|
;;;53     
;;;54       /* Check that number of components won't exceed internal array sizes */
;;;55       if (cinfo->num_components > MAX_COMPONENTS)
00004c  6a60              LDR      r0,[r4,#0x24]
00004e  2804              CMP      r0,#4
000050  dd0e              BLE      |L1.112|
;;;56         ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
000052  f04f001a          MOV      r0,#0x1a
000056  6821              LDR      r1,[r4,#0]
000058  6148              STR      r0,[r1,#0x14]
00005a  6821              LDR      r1,[r4,#0]
00005c  6a60              LDR      r0,[r4,#0x24]
00005e  6188              STR      r0,[r1,#0x18]
000060  f04f0104          MOV      r1,#4
000064  6820              LDR      r0,[r4,#0]
000066  61c1              STR      r1,[r0,#0x1c]
000068  6820              LDR      r0,[r4,#0]
00006a  6801              LDR      r1,[r0,#0]
00006c  4620              MOV      r0,r4
00006e  4788              BLX      r1
                  |L1.112|
;;;57     	     MAX_COMPONENTS);
;;;58     
;;;59       /* Compute maximum sampling factors; check factor validity */
;;;60       cinfo->max_h_samp_factor = 1;
000070  f04f0001          MOV      r0,#1
000074  f10404d8          ADD      r4,r4,#0xd8
000078  65e0              STR      r0,[r4,#0x5c]
;;;61       cinfo->max_v_samp_factor = 1;
00007a  6620              STR      r0,[r4,#0x60]
;;;62       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00007c  f04f0600          MOV      r6,#0
000080  f85459d8          LDR      r5,[r4],#-0xd8
000084  e02d              B        |L1.226|
                  |L1.134|
;;;63            ci++, compptr++) {
;;;64         if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
000086  68a8              LDR      r0,[r5,#8]
000088  2800              CMP      r0,#0
00008a  dd08              BLE      |L1.158|
00008c  68a8              LDR      r0,[r5,#8]
00008e  2804              CMP      r0,#4
000090  dc05              BGT      |L1.158|
;;;65     	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
000092  68e8              LDR      r0,[r5,#0xc]
000094  2800              CMP      r0,#0
000096  dd02              BLE      |L1.158|
000098  68e8              LDR      r0,[r5,#0xc]
00009a  2804              CMP      r0,#4
00009c  dd07              BLE      |L1.174|
                  |L1.158|
;;;66           ERREXIT(cinfo, JERR_BAD_SAMPLING);
00009e  f04f0012          MOV      r0,#0x12
0000a2  6821              LDR      r1,[r4,#0]
0000a4  6148              STR      r0,[r1,#0x14]
0000a6  6820              LDR      r0,[r4,#0]
0000a8  6801              LDR      r1,[r0,#0]
0000aa  4620              MOV      r0,r4
0000ac  4788              BLX      r1
                  |L1.174|
;;;67         cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
0000ae  f8d40134          LDR      r0,[r4,#0x134]
0000b2  68a9              LDR      r1,[r5,#8]
0000b4  4288              CMP      r0,r1
0000b6  dd02              BLE      |L1.190|
0000b8  f8d40134          LDR      r0,[r4,#0x134]
0000bc  e000              B        |L1.192|
                  |L1.190|
0000be  68a8              LDR      r0,[r5,#8]
                  |L1.192|
0000c0  f8c40134          STR      r0,[r4,#0x134]
;;;68     				   compptr->h_samp_factor);
;;;69         cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
0000c4  f8d40138          LDR      r0,[r4,#0x138]
0000c8  68e9              LDR      r1,[r5,#0xc]
0000ca  4288              CMP      r0,r1
0000cc  dd02              BLE      |L1.212|
0000ce  f8d40138          LDR      r0,[r4,#0x138]
0000d2  e000              B        |L1.214|
                  |L1.212|
0000d4  68e8              LDR      r0,[r5,#0xc]
                  |L1.214|
0000d6  f8c40138          STR      r0,[r4,#0x138]
0000da  f1060601          ADD      r6,r6,#1              ;63
0000de  f1050554          ADD      r5,r5,#0x54           ;63
                  |L1.226|
0000e2  6a60              LDR      r0,[r4,#0x24]         ;62
0000e4  42b0              CMP      r0,r6                 ;62
0000e6  dcce              BGT      |L1.134|
;;;70     				   compptr->v_samp_factor);
;;;71       }
;;;72     
;;;73       /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE.
;;;74        * In the full decompressor, this will be overridden by jdmaster.c;
;;;75        * but in the transcoder, jdmaster.c is not used, so we must do it here.
;;;76        */
;;;77       cinfo->min_DCT_scaled_size = DCTSIZE;
0000e8  f04f0008          MOV      r0,#8
0000ec  f8c4013c          STR      r0,[r4,#0x13c]
;;;78     
;;;79       /* Compute dimensions of components */
;;;80       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
0000f0  f04f0600          MOV      r6,#0
0000f4  f8d450d8          LDR      r5,[r4,#0xd8]
0000f8  e033              B        |L1.354|
                  |L1.250|
;;;81            ci++, compptr++) {
;;;82         compptr->DCT_scaled_size = DCTSIZE;
0000fa  f04f0008          MOV      r0,#8
0000fe  6268              STR      r0,[r5,#0x24]
;;;83         /* Size in DCT blocks */
;;;84         compptr->width_in_blocks = (JDIMENSION)
000100  69e2              LDR      r2,[r4,#0x1c]
000102  68ab              LDR      r3,[r5,#8]
000104  fb02f003          MUL      r0,r2,r3
000108  f8d42134          LDR      r2,[r4,#0x134]
00010c  ea4f01c2          LSL      r1,r2,#3
000110  f7fffffe          BL       jdiv_round_up
000114  61e8              STR      r0,[r5,#0x1c]
;;;85           jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
;;;86     		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
;;;87         compptr->height_in_blocks = (JDIMENSION)
000116  6a22              LDR      r2,[r4,#0x20]
000118  68eb              LDR      r3,[r5,#0xc]
00011a  fb02f003          MUL      r0,r2,r3
00011e  f8d42138          LDR      r2,[r4,#0x138]
000122  00d1              LSLS     r1,r2,#3
000124  f7fffffe          BL       jdiv_round_up
000128  6228              STR      r0,[r5,#0x20]
;;;88           jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
;;;89     		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
;;;90         /* downsampled_width and downsampled_height will also be overridden by
;;;91          * jdmaster.c if we are doing full decompression.  The transcoder library
;;;92          * doesn't use these values, but the calling application might.
;;;93          */
;;;94         /* Size in samples */
;;;95         compptr->downsampled_width = (JDIMENSION)
00012a  69e2              LDR      r2,[r4,#0x1c]
00012c  68ab              LDR      r3,[r5,#8]
00012e  fb02f003          MUL      r0,r2,r3
000132  f8d41134          LDR      r1,[r4,#0x134]
000136  f7fffffe          BL       jdiv_round_up
00013a  62a8              STR      r0,[r5,#0x28]
;;;96           jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
;;;97     		    (long) cinfo->max_h_samp_factor);
;;;98         compptr->downsampled_height = (JDIMENSION)
00013c  6a22              LDR      r2,[r4,#0x20]
00013e  68eb              LDR      r3,[r5,#0xc]
000140  fb02f003          MUL      r0,r2,r3
000144  f8d41138          LDR      r1,[r4,#0x138]
000148  f7fffffe          BL       jdiv_round_up
00014c  62e8              STR      r0,[r5,#0x2c]
;;;99           jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
;;;100    		    (long) cinfo->max_v_samp_factor);
;;;101        /* Mark component needed, until color conversion says otherwise */
;;;102        compptr->component_needed = TRUE;
00014e  f04f0001          MOV      r0,#1
000152  6328              STR      r0,[r5,#0x30]
;;;103        /* Mark no quantization table yet saved for component */
;;;104        compptr->quant_table = NULL;
000154  f04f0000          MOV      r0,#0
000158  64e8              STR      r0,[r5,#0x4c]
00015a  f1060601          ADD      r6,r6,#1              ;81
00015e  f1050554          ADD      r5,r5,#0x54           ;81
                  |L1.354|
000162  6a60              LDR      r0,[r4,#0x24]         ;80
000164  42b0              CMP      r0,r6                 ;80
000166  dcc8              BGT      |L1.250|
;;;105      }
;;;106    
;;;107      /* Compute number of fully interleaved MCU rows. */
;;;108      cinfo->total_iMCU_rows = (JDIMENSION)
000168  f8d42138          LDR      r2,[r4,#0x138]
00016c  00d1              LSLS     r1,r2,#3
00016e  6a20              LDR      r0,[r4,#0x20]
000170  f7fffffe          BL       jdiv_round_up
000174  f8c40140          STR      r0,[r4,#0x140]
;;;109        jdiv_round_up((long) cinfo->image_height,
;;;110    		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
;;;111    
;;;112      /* Decide whether file contains multiple scans */
;;;113      if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
000178  6a61              LDR      r1,[r4,#0x24]
00017a  f8d40148          LDR      r0,[r4,#0x148]
00017e  4288              CMP      r0,r1
000180  db02              BLT      |L1.392|
000182  f8d400dc          LDR      r0,[r4,#0xdc]
000186  b128              CBZ      r0,|L1.404|
                  |L1.392|
;;;114        cinfo->inputctl->has_multiple_scans = TRUE;
000188  f04f0001          MOV      r0,#1
00018c  f8d411b4          LDR      r1,[r4,#0x1b4]
000190  6108              STR      r0,[r1,#0x10]
000192  e004              B        |L1.414|
                  |L1.404|
;;;115      else
;;;116        cinfo->inputctl->has_multiple_scans = FALSE;
000194  f04f0000          MOV      r0,#0
000198  f8d411b4          LDR      r1,[r4,#0x1b4]
00019c  6108              STR      r0,[r1,#0x10]
                  |L1.414|
;;;117    }
00019e  bd70              POP      {r4-r6,pc}
;;;118    
                          ENDP

                  per_scan_setup PROC
;;;120    LOCAL(void)
;;;121    per_scan_setup (j_decompress_ptr cinfo)
0001a0  e92d41f0          PUSH     {r4-r8,lr}
;;;122    /* Do computations that are needed before processing a JPEG scan */
;;;123    /* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
;;;124    {
0001a4  4605              MOV      r5,r0
;;;125      int ci, mcublks, tmp;
;;;126      jpeg_component_info *compptr;
;;;127      
;;;128      if (cinfo->comps_in_scan == 1) {
0001a6  f8d50148          LDR      r0,[r5,#0x148]
0001aa  2801              CMP      r0,#1
0001ac  d123              BNE      |L1.502|
;;;129        
;;;130        /* Noninterleaved (single-component) scan */
;;;131        compptr = cinfo->cur_comp_info[0];
0001ae  f8d5414c          LDR      r4,[r5,#0x14c]
;;;132        
;;;133        /* Overall image size in MCUs */
;;;134        cinfo->MCUs_per_row = compptr->width_in_blocks;
0001b2  69e0              LDR      r0,[r4,#0x1c]
0001b4  f8c5015c          STR      r0,[r5,#0x15c]
;;;135        cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
0001b8  6a20              LDR      r0,[r4,#0x20]
0001ba  f8c50160          STR      r0,[r5,#0x160]
;;;136        
;;;137        /* For noninterleaved scan, always one block per MCU */
;;;138        compptr->MCU_width = 1;
0001be  f04f0001          MOV      r0,#1
0001c2  6360              STR      r0,[r4,#0x34]
;;;139        compptr->MCU_height = 1;
0001c4  63a0              STR      r0,[r4,#0x38]
;;;140        compptr->MCU_blocks = 1;
0001c6  63e0              STR      r0,[r4,#0x3c]
;;;141        compptr->MCU_sample_width = compptr->DCT_scaled_size;
0001c8  6a60              LDR      r0,[r4,#0x24]
0001ca  6420              STR      r0,[r4,#0x40]
;;;142        compptr->last_col_width = 1;
0001cc  f04f0001          MOV      r0,#1
0001d0  6460              STR      r0,[r4,#0x44]
;;;143        /* For noninterleaved scans, it is convenient to define last_row_height
;;;144         * as the number of block rows present in the last iMCU row.
;;;145         */
;;;146        tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
0001d2  68e1              LDR      r1,[r4,#0xc]
0001d4  6a20              LDR      r0,[r4,#0x20]
0001d6  fbb0f2f1          UDIV     r2,r0,r1
0001da  fb010612          MLS      r6,r1,r2,r0
;;;147        if (tmp == 0) tmp = compptr->v_samp_factor;
0001de  b906              CBNZ     r6,|L1.482|
0001e0  68e6              LDR      r6,[r4,#0xc]
                  |L1.482|
;;;148        compptr->last_row_height = tmp;
0001e2  64a6              STR      r6,[r4,#0x48]
;;;149        
;;;150        /* Prepare array describing MCU composition */
;;;151        cinfo->blocks_in_MCU = 1;
0001e4  f04f0001          MOV      r0,#1
0001e8  f8c50164          STR      r0,[r5,#0x164]
;;;152        cinfo->MCU_membership[0] = 0;
0001ec  f04f0000          MOV      r0,#0
0001f0  f8c50168          STR      r0,[r5,#0x168]
0001f4  e078              B        |L1.744|
                  |L1.502|
;;;153        
;;;154      } else {
;;;155        
;;;156        /* Interleaved (multi-component) scan */
;;;157        if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
0001f6  f8d50148          LDR      r0,[r5,#0x148]
0001fa  2800              CMP      r0,#0
0001fc  dd03              BLE      |L1.518|
0001fe  f8d50148          LDR      r0,[r5,#0x148]
000202  2804              CMP      r0,#4
000204  dd0f              BLE      |L1.550|
                  |L1.518|
;;;158          ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
000206  f04f001a          MOV      r0,#0x1a
00020a  6829              LDR      r1,[r5,#0]
00020c  6148              STR      r0,[r1,#0x14]
00020e  6829              LDR      r1,[r5,#0]
000210  f8d50148          LDR      r0,[r5,#0x148]
000214  6188              STR      r0,[r1,#0x18]
000216  f04f0104          MOV      r1,#4
00021a  6828              LDR      r0,[r5,#0]
00021c  61c1              STR      r1,[r0,#0x1c]
00021e  6828              LDR      r0,[r5,#0]
000220  6801              LDR      r1,[r0,#0]
000222  4628              MOV      r0,r5
000224  4788              BLX      r1
                  |L1.550|
;;;159    	       MAX_COMPS_IN_SCAN);
;;;160        
;;;161        /* Overall image size in MCUs */
;;;162        cinfo->MCUs_per_row = (JDIMENSION)
000226  f10505e8          ADD      r5,r5,#0xe8
00022a  6cea              LDR      r2,[r5,#0x4c]
00022c  ea4f01c2          LSL      r1,r2,#3
000230  f8550ccc          LDR      r0,[r5,#-0xcc]
000234  f7fffffe          BL       jdiv_round_up
000238  6768              STR      r0,[r5,#0x74]
;;;163          jdiv_round_up((long) cinfo->image_width,
;;;164    		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
;;;165        cinfo->MCU_rows_in_scan = (JDIMENSION)
00023a  6d2a              LDR      r2,[r5,#0x50]
00023c  00d1              LSLS     r1,r2,#3
00023e  f8550cc8          LDR      r0,[r5,#-0xc8]
000242  f7fffffe          BL       jdiv_round_up
000246  67a8              STR      r0,[r5,#0x78]
;;;166          jdiv_round_up((long) cinfo->image_height,
;;;167    		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
;;;168        
;;;169        cinfo->blocks_in_MCU = 0;
000248  f04f0000          MOV      r0,#0
00024c  67e8              STR      r0,[r5,#0x7c]
00024e  f1a505e8          SUB      r5,r5,#0xe8
;;;170        
;;;171        for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000252  4607              MOV      r7,r0
000254  e044              B        |L1.736|
                  |L1.598|
;;;172          compptr = cinfo->cur_comp_info[ci];
000256  f50570a6          ADD      r0,r5,#0x14c
00025a  f8504027          LDR      r4,[r0,r7,LSL #2]
;;;173          /* Sampling factors give # of blocks of component in each MCU */
;;;174          compptr->MCU_width = compptr->h_samp_factor;
00025e  68a0              LDR      r0,[r4,#8]
000260  6360              STR      r0,[r4,#0x34]
;;;175          compptr->MCU_height = compptr->v_samp_factor;
000262  68e0              LDR      r0,[r4,#0xc]
000264  63a0              STR      r0,[r4,#0x38]
;;;176          compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
000266  e9d4010d          LDRD     r0,r1,[r4,#0x34]
00026a  fb00f001          MUL      r0,r0,r1
00026e  63e0              STR      r0,[r4,#0x3c]
;;;177          compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
000270  6a61              LDR      r1,[r4,#0x24]
000272  6b60              LDR      r0,[r4,#0x34]
000274  fb00f001          MUL      r0,r0,r1
000278  6420              STR      r0,[r4,#0x40]
;;;178          /* Figure number of non-dummy blocks in last MCU column & row */
;;;179          tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
00027a  6b61              LDR      r1,[r4,#0x34]
00027c  69e0              LDR      r0,[r4,#0x1c]
00027e  fbb0f2f1          UDIV     r2,r0,r1
000282  fb010612          MLS      r6,r1,r2,r0
;;;180          if (tmp == 0) tmp = compptr->MCU_width;
000286  b906              CBNZ     r6,|L1.650|
000288  6b66              LDR      r6,[r4,#0x34]
                  |L1.650|
;;;181          compptr->last_col_width = tmp;
00028a  6466              STR      r6,[r4,#0x44]
;;;182          tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
00028c  6ba1              LDR      r1,[r4,#0x38]
00028e  6a20              LDR      r0,[r4,#0x20]
000290  fbb0f2f1          UDIV     r2,r0,r1
000294  fb010612          MLS      r6,r1,r2,r0
;;;183          if (tmp == 0) tmp = compptr->MCU_height;
000298  b906              CBNZ     r6,|L1.668|
00029a  6ba6              LDR      r6,[r4,#0x38]
                  |L1.668|
;;;184          compptr->last_row_height = tmp;
00029c  64a6              STR      r6,[r4,#0x48]
;;;185          /* Prepare array describing MCU composition */
;;;186          mcublks = compptr->MCU_blocks;
00029e  f8d4803c          LDR      r8,[r4,#0x3c]
;;;187          if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
0002a2  f8d50164          LDR      r0,[r5,#0x164]
0002a6  4440              ADD      r0,r0,r8
0002a8  280a              CMP      r0,#0xa
0002aa  dd07              BLE      |L1.700|
;;;188    	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
0002ac  f04f000d          MOV      r0,#0xd
0002b0  6829              LDR      r1,[r5,#0]
0002b2  6148              STR      r0,[r1,#0x14]
0002b4  6828              LDR      r0,[r5,#0]
0002b6  6801              LDR      r1,[r0,#0]
0002b8  4628              MOV      r0,r5
0002ba  4788              BLX      r1
                  |L1.700|
;;;189          while (mcublks-- > 0) {
0002bc  e009              B        |L1.722|
                  |L1.702|
;;;190    	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
0002be  f8d51164          LDR      r1,[r5,#0x164]
0002c2  f1010001          ADD      r0,r1,#1
0002c6  f8c50164          STR      r0,[r5,#0x164]
0002ca  f50570b4          ADD      r0,r5,#0x168
0002ce  f8407021          STR      r7,[r0,r1,LSL #2]
                  |L1.722|
0002d2  f1b80000          SUBS     r0,r8,#0              ;189
0002d6  f1a80801          SUB      r8,r8,#1              ;189
0002da  dcf0              BGT      |L1.702|
0002dc  f1070701          ADD      r7,r7,#1              ;171
                  |L1.736|
0002e0  f8d50148          LDR      r0,[r5,#0x148]        ;171
0002e4  42b8              CMP      r0,r7                 ;171
0002e6  dcb6              BGT      |L1.598|
                  |L1.744|
;;;191          }
;;;192        }
;;;193        
;;;194      }
;;;195    }
0002e8  e8bd81f0          POP      {r4-r8,pc}
;;;196    
                          ENDP

                  latch_quant_tables PROC
;;;219    LOCAL(void)
;;;220    latch_quant_tables (j_decompress_ptr cinfo)
0002ec  e92d41f0          PUSH     {r4-r8,lr}
;;;221    {
0002f0  4604              MOV      r4,r0
;;;222      int ci, qtblno;
;;;223      jpeg_component_info *compptr;
;;;224      JQUANT_TBL * qtbl;
;;;225    
;;;226      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
0002f2  f04f0700          MOV      r7,#0
0002f6  e02f              B        |L1.856|
                  |L1.760|
;;;227        compptr = cinfo->cur_comp_info[ci];
0002f8  f50470a6          ADD      r0,r4,#0x14c
0002fc  f8506027          LDR      r6,[r0,r7,LSL #2]
;;;228        /* No work if we already saved Q-table for this component */
;;;229        if (compptr->quant_table != NULL)
000300  6cf0              LDR      r0,[r6,#0x4c]
000302  b100              CBZ      r0,|L1.774|
;;;230          continue;
000304  e026              B        |L1.852|
                  |L1.774|
;;;231        /* Make sure specified quantization table is present */
;;;232        qtblno = compptr->quant_tbl_no;
000306  6935              LDR      r5,[r6,#0x10]
;;;233        if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
000308  2d00              CMP      r5,#0
00030a  db06              BLT      |L1.794|
00030c  2d04              CMP      r5,#4
00030e  da04              BGE      |L1.794|
;;;234    	cinfo->quant_tbl_ptrs[qtblno] == NULL)
000310  f10400a4          ADD      r0,r4,#0xa4
000314  f8500025          LDR      r0,[r0,r5,LSL #2]
000318  b948              CBNZ     r0,|L1.814|
                  |L1.794|
;;;235          ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
00031a  f04f0034          MOV      r0,#0x34
00031e  6821              LDR      r1,[r4,#0]
000320  6148              STR      r0,[r1,#0x14]
000322  6820              LDR      r0,[r4,#0]
000324  6185              STR      r5,[r0,#0x18]
000326  6820              LDR      r0,[r4,#0]
000328  6801              LDR      r1,[r0,#0]
00032a  4620              MOV      r0,r4
00032c  4788              BLX      r1
                  |L1.814|
;;;236        /* OK, save away the quantization table */
;;;237        qtbl = (JQUANT_TBL *)
00032e  6860              LDR      r0,[r4,#4]
000330  2284              MOVS     r2,#0x84
000332  2101              MOVS     r1,#1
000334  6803              LDR      r3,[r0,#0]
000336  4620              MOV      r0,r4
000338  4798              BLX      r3
00033a  4680              MOV      r8,r0
;;;238          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;239    				  SIZEOF(JQUANT_TBL));
;;;240        MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
00033c  f10400a4          ADD      r0,r4,#0xa4
000340  f8501025          LDR      r1,[r0,r5,LSL #2]
000344  f04f0284          MOV      r2,#0x84
000348  4640              MOV      r0,r8
00034a  f7fffffe          BL       __aeabi_memcpy4
;;;241        compptr->quant_table = qtbl;
00034e  f8c6804c          STR      r8,[r6,#0x4c]
000352  bf00              NOP                            ;230
                  |L1.852|
000354  f1070701          ADD      r7,r7,#1              ;226
                  |L1.856|
000358  f8d40148          LDR      r0,[r4,#0x148]        ;226
00035c  42b8              CMP      r0,r7                 ;226
00035e  dccb              BGT      |L1.760|
;;;242      }
;;;243    }
000360  e8bd81f0          POP      {r4-r8,pc}
;;;244    
                          ENDP

                  start_input_pass PROC
;;;253    METHODDEF(void)
;;;254    start_input_pass (j_decompress_ptr cinfo)
000364  b510              PUSH     {r4,lr}
;;;255    {
000366  4604              MOV      r4,r0
;;;256      per_scan_setup(cinfo);
000368  4620              MOV      r0,r4
00036a  f7fffffe          BL       per_scan_setup
;;;257      latch_quant_tables(cinfo);
00036e  4620              MOV      r0,r4
000370  f7fffffe          BL       latch_quant_tables
;;;258      (*cinfo->entropy->start_pass) (cinfo);
000374  f8d401bc          LDR      r0,[r4,#0x1bc]
000378  6801              LDR      r1,[r0,#0]
00037a  4620              MOV      r0,r4
00037c  4788              BLX      r1
;;;259      (*cinfo->coef->start_input_pass) (cinfo);
00037e  f8d401ac          LDR      r0,[r4,#0x1ac]
000382  6801              LDR      r1,[r0,#0]
000384  4620              MOV      r0,r4
000386  4788              BLX      r1
;;;260      cinfo->inputctl->consume_input = cinfo->coef->consume_data;
000388  f8d401ac          LDR      r0,[r4,#0x1ac]
00038c  6840              LDR      r0,[r0,#4]
00038e  f8d411b4          LDR      r1,[r4,#0x1b4]
000392  6008              STR      r0,[r1,#0]
;;;261    }
000394  bd10              POP      {r4,pc}
;;;262    
                          ENDP

                  consume_markers PROC
;;;287    METHODDEF(int)
;;;288    consume_markers (j_decompress_ptr cinfo)
000396  b570              PUSH     {r4-r6,lr}
;;;289    {
000398  4604              MOV      r4,r0
;;;290      my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
00039a  f8d451b4          LDR      r5,[r4,#0x1b4]
;;;291      int val;
;;;292    
;;;293      if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
00039e  6968              LDR      r0,[r5,#0x14]
0003a0  b108              CBZ      r0,|L1.934|
;;;294        return JPEG_REACHED_EOI;
0003a2  2002              MOVS     r0,#2
                  |L1.932|
;;;295    
;;;296      val = (*cinfo->marker->read_markers) (cinfo);
;;;297    
;;;298      switch (val) {
;;;299      case JPEG_REACHED_SOS:	/* Found SOS */
;;;300        if (inputctl->inheaders) {	/* 1st SOS */
;;;301          initial_setup(cinfo);
;;;302          inputctl->inheaders = FALSE;
;;;303          /* Note: start_input_pass must be called by jdmaster.c
;;;304           * before any more input can be consumed.  jdapimin.c is
;;;305           * responsible for enforcing this sequencing.
;;;306           */
;;;307        } else {			/* 2nd or later SOS marker */
;;;308          if (! inputctl->pub.has_multiple_scans)
;;;309    	ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
;;;310          start_input_pass(cinfo);
;;;311        }
;;;312        break;
;;;313      case JPEG_REACHED_EOI:	/* Found EOI */
;;;314        inputctl->pub.eoi_reached = TRUE;
;;;315        if (inputctl->inheaders) {	/* Tables-only datastream, apparently */
;;;316          if (cinfo->marker->saw_SOF)
;;;317    	ERREXIT(cinfo, JERR_SOF_NO_SOS);
;;;318        } else {
;;;319          /* Prevent infinite loop in coef ctlr's decompress_data routine
;;;320           * if user set output_scan_number larger than number of scans.
;;;321           */
;;;322          if (cinfo->output_scan_number > cinfo->input_scan_number)
;;;323    	cinfo->output_scan_number = cinfo->input_scan_number;
;;;324        }
;;;325        break;
;;;326      case JPEG_SUSPENDED:
;;;327        break;
;;;328      }
;;;329    
;;;330      return val;
;;;331    }
0003a4  bd70              POP      {r4-r6,pc}
                  |L1.934|
0003a6  f8d401b8          LDR      r0,[r4,#0x1b8]        ;296
0003aa  6841              LDR      r1,[r0,#4]            ;296
0003ac  4620              MOV      r0,r4                 ;296
0003ae  4788              BLX      r1                    ;296
0003b0  4606              MOV      r6,r0                 ;296
0003b2  b3c6              CBZ      r6,|L1.1062|
0003b4  2e01              CMP      r6,#1                 ;298
0003b6  d002              BEQ      |L1.958|
0003b8  2e02              CMP      r6,#2                 ;298
0003ba  d136              BNE      |L1.1066|
0003bc  e016              B        |L1.1004|
                  |L1.958|
0003be  69a8              LDR      r0,[r5,#0x18]         ;300
0003c0  b130              CBZ      r0,|L1.976|
0003c2  4620              MOV      r0,r4                 ;301
0003c4  f7fffffe          BL       initial_setup
0003c8  f04f0000          MOV      r0,#0                 ;302
0003cc  61a8              STR      r0,[r5,#0x18]         ;302
0003ce  e00c              B        |L1.1002|
                  |L1.976|
0003d0  6928              LDR      r0,[r5,#0x10]         ;308
0003d2  b938              CBNZ     r0,|L1.996|
0003d4  f04f0023          MOV      r0,#0x23              ;309
0003d8  6821              LDR      r1,[r4,#0]            ;309
0003da  6148              STR      r0,[r1,#0x14]         ;309
0003dc  6820              LDR      r0,[r4,#0]            ;309
0003de  6801              LDR      r1,[r0,#0]            ;309
0003e0  4620              MOV      r0,r4                 ;309
0003e2  4788              BLX      r1                    ;309
                  |L1.996|
0003e4  4620              MOV      r0,r4                 ;310
0003e6  f7fffffe          BL       start_input_pass
                  |L1.1002|
0003ea  e01e              B        |L1.1066|
                  |L1.1004|
0003ec  f04f0001          MOV      r0,#1                 ;314
0003f0  6168              STR      r0,[r5,#0x14]         ;314
0003f2  69a8              LDR      r0,[r5,#0x18]         ;315
0003f4  b160              CBZ      r0,|L1.1040|
0003f6  f8d401b8          LDR      r0,[r4,#0x1b8]        ;316
0003fa  6900              LDR      r0,[r0,#0x10]         ;316
0003fc  b190              CBZ      r0,|L1.1060|
0003fe  f04f003b          MOV      r0,#0x3b              ;317
000402  6821              LDR      r1,[r4,#0]            ;317
000404  6148              STR      r0,[r1,#0x14]         ;317
000406  6820              LDR      r0,[r4,#0]            ;317
000408  6801              LDR      r1,[r0,#0]            ;317
00040a  4620              MOV      r0,r4                 ;317
00040c  4788              BLX      r1                    ;317
00040e  e009              B        |L1.1060|
                  |L1.1040|
000410  f8d41090          LDR      r1,[r4,#0x90]         ;322
000414  f8d40098          LDR      r0,[r4,#0x98]         ;322
000418  4288              CMP      r0,r1                 ;322
00041a  dd03              BLE      |L1.1060|
00041c  f8d40090          LDR      r0,[r4,#0x90]         ;323
000420  f8c40098          STR      r0,[r4,#0x98]         ;323
                  |L1.1060|
000424  e001              B        |L1.1066|
                  |L1.1062|
000426  e7ff              B        |L1.1064|
                  |L1.1064|
000428  bf00              NOP                            ;327
                  |L1.1066|
00042a  bf00              NOP                            ;312
00042c  4630              MOV      r0,r6                 ;330
00042e  e7b9              B        |L1.932|
;;;332    
                          ENDP

                  finish_input_pass PROC
;;;270    METHODDEF(void)
;;;271    finish_input_pass (j_decompress_ptr cinfo)
000430  491e              LDR      r1,|L1.1196|
;;;272    {
;;;273      cinfo->inputctl->consume_input = consume_markers;
000432  f8d021b4          LDR      r2,[r0,#0x1b4]
000436  6011              STR      r1,[r2,#0]
;;;274    }
000438  4770              BX       lr
;;;275    
                          ENDP

                  reset_input_controller PROC
;;;338    METHODDEF(void)
;;;339    reset_input_controller (j_decompress_ptr cinfo)
00043a  b570              PUSH     {r4-r6,lr}
;;;340    {
00043c  4604              MOV      r4,r0
;;;341      my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
00043e  f8d451b4          LDR      r5,[r4,#0x1b4]
;;;342    
;;;343      inputctl->pub.consume_input = consume_markers;
000442  481a              LDR      r0,|L1.1196|
000444  6028              STR      r0,[r5,#0]
;;;344      inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
000446  f04f0000          MOV      r0,#0
00044a  6128              STR      r0,[r5,#0x10]
;;;345      inputctl->pub.eoi_reached = FALSE;
00044c  6168              STR      r0,[r5,#0x14]
;;;346      inputctl->inheaders = TRUE;
00044e  f04f0001          MOV      r0,#1
000452  61a8              STR      r0,[r5,#0x18]
;;;347      /* Reset other modules */
;;;348      (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
000454  6820              LDR      r0,[r4,#0]
000456  6901              LDR      r1,[r0,#0x10]
000458  4620              MOV      r0,r4
00045a  4788              BLX      r1
;;;349      (*cinfo->marker->reset_marker_reader) (cinfo);
00045c  f8d401b8          LDR      r0,[r4,#0x1b8]
000460  6801              LDR      r1,[r0,#0]
000462  4620              MOV      r0,r4
000464  4788              BLX      r1
;;;350      /* Reset progression state -- would be cleaner if entropy decoder did this */
;;;351      cinfo->coef_bits = NULL;
000466  f04f0000          MOV      r0,#0
00046a  f8c400a0          STR      r0,[r4,#0xa0]
;;;352    }
00046e  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP

                  jinit_input_controller PROC
;;;360    GLOBAL(void)
;;;361    jinit_input_controller (j_decompress_ptr cinfo)
000470  b570              PUSH     {r4-r6,lr}
;;;362    {
000472  4605              MOV      r5,r0
;;;363      my_inputctl_ptr inputctl;
;;;364    
;;;365      /* Create subobject in permanent pool */
;;;366      inputctl = (my_inputctl_ptr)
000474  6868              LDR      r0,[r5,#4]
000476  f04f021c          MOV      r2,#0x1c
00047a  f04f0100          MOV      r1,#0
00047e  6803              LDR      r3,[r0,#0]
000480  4628              MOV      r0,r5
000482  4798              BLX      r3
000484  4604              MOV      r4,r0
;;;367        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
;;;368    				SIZEOF(my_input_controller));
;;;369      cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
000486  f8c541b4          STR      r4,[r5,#0x1b4]
;;;370      /* Initialize method pointers */
;;;371      inputctl->pub.consume_input = consume_markers;
00048a  4808              LDR      r0,|L1.1196|
00048c  6020              STR      r0,[r4,#0]
;;;372      inputctl->pub.reset_input_controller = reset_input_controller;
00048e  4808              LDR      r0,|L1.1200|
000490  6060              STR      r0,[r4,#4]
;;;373      inputctl->pub.start_input_pass = start_input_pass;
000492  4808              LDR      r0,|L1.1204|
000494  60a0              STR      r0,[r4,#8]
;;;374      inputctl->pub.finish_input_pass = finish_input_pass;
000496  4808              LDR      r0,|L1.1208|
000498  60e0              STR      r0,[r4,#0xc]
;;;375      /* Initialize state: can't use reset_input_controller since we don't
;;;376       * want to try to reset other modules yet.
;;;377       */
;;;378      inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
00049a  f04f0000          MOV      r0,#0
00049e  6120              STR      r0,[r4,#0x10]
;;;379      inputctl->pub.eoi_reached = FALSE;
0004a0  6160              STR      r0,[r4,#0x14]
;;;380      inputctl->inheaders = TRUE;
0004a2  f04f0001          MOV      r0,#1
0004a6  61a0              STR      r0,[r4,#0x18]
;;;381    }
0004a8  bd70              POP      {r4-r6,pc}
                          ENDP

0004aa  0000              DCW      0x0000
                  |L1.1196|
                          DCD      consume_markers
                  |L1.1200|
                          DCD      reset_input_controller
                  |L1.1204|
                          DCD      start_input_pass
                  |L1.1208|
                          DCD      finish_input_pass
