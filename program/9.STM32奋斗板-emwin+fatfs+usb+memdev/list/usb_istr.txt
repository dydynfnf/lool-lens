; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\usb_istr.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\usb_istr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\MALLOC -I.\TFT -I.\EMWIN\EMWIN_INC -I.\EMWIN\DEMO -I.\PNG -I.\FATFS -I.\SDIO -I.\USB\inc -I.\USBCFG\inc -IE:\material\GUI\STM32·Ü¶·°å-emwin+fatfs+usb+memdev\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\usb_istr.crf USBCFG\scr\usb_istr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USB_Istr PROC
;;;71     *******************************************************************************/
;;;72     void USB_Istr(void)
000000  b510              PUSH     {r4,lr}
;;;73     {
;;;74     
;;;75       wIstr = _GetISTR();
000002  480f              LDR      r0,|L1.64|
000004  6800              LDR      r0,[r0,#0]
000006  490f              LDR      r1,|L1.68|
000008  8008              STRH     r0,[r1,#0]
;;;76     
;;;77     #if (IMR_MSK & ISTR_CTR)
;;;78       if (wIstr & ISTR_CTR & wInterrupt_Mask)
00000a  4608              MOV      r0,r1
00000c  8800              LDRH     r0,[r0,#0]  ; wIstr
00000e  f4004000          AND      r0,r0,#0x8000
000012  490d              LDR      r1,|L1.72|
000014  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000016  4008              ANDS     r0,r0,r1
000018  b108              CBZ      r0,|L1.30|
;;;79       {
;;;80         /* servicing of the endpoint correct transfer interrupt */
;;;81         /* clear of the CTR flag into the sub */
;;;82         CTR_LP();
00001a  f7fffffe          BL       CTR_LP
                  |L1.30|
;;;83     #ifdef CTR_CALLBACK
;;;84         CTR_Callback();
;;;85     #endif
;;;86       }
;;;87     #endif  
;;;88       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;89     #if (IMR_MSK & ISTR_RESET)
;;;90       if (wIstr & ISTR_RESET & wInterrupt_Mask)
00001e  4809              LDR      r0,|L1.68|
000020  8800              LDRH     r0,[r0,#0]  ; wIstr
000022  f4006080          AND      r0,r0,#0x400
000026  4908              LDR      r1,|L1.72|
000028  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
00002a  4008              ANDS     r0,r0,r1
00002c  b130              CBZ      r0,|L1.60|
;;;91       {
;;;92         _SetISTR((uint16_t)CLR_RESET);
00002e  f64f30ff          MOV      r0,#0xfbff
000032  4903              LDR      r1,|L1.64|
000034  6008              STR      r0,[r1,#0]
;;;93         Device_Property.Reset();
000036  4905              LDR      r1,|L1.76|
000038  6848              LDR      r0,[r1,#4]  ; Device_Property
00003a  4780              BLX      r0
                  |L1.60|
;;;94     #ifdef RESET_CALLBACK
;;;95         RESET_Callback();
;;;96     #endif
;;;97       }
;;;98     #endif
;;;99       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;100    #if (IMR_MSK & ISTR_DOVR)
;;;101      if (wIstr & ISTR_DOVR & wInterrupt_Mask)
;;;102      {
;;;103        _SetISTR((uint16_t)CLR_DOVR);
;;;104    #ifdef DOVR_CALLBACK
;;;105        DOVR_Callback();
;;;106    #endif
;;;107      }
;;;108    #endif
;;;109      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;110    #if (IMR_MSK & ISTR_ERR)
;;;111      if (wIstr & ISTR_ERR & wInterrupt_Mask)
;;;112      {
;;;113        _SetISTR((uint16_t)CLR_ERR);
;;;114    #ifdef ERR_CALLBACK
;;;115        ERR_Callback();
;;;116    #endif
;;;117      }
;;;118    #endif
;;;119      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;120    #if (IMR_MSK & ISTR_WKUP)
;;;121      if (wIstr & ISTR_WKUP & wInterrupt_Mask)
;;;122      {
;;;123        _SetISTR((uint16_t)CLR_WKUP);
;;;124        Resume(RESUME_EXTERNAL);
;;;125    #ifdef WKUP_CALLBACK
;;;126        WKUP_Callback();
;;;127    #endif
;;;128      }
;;;129    #endif
;;;130      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;131    #if (IMR_MSK & ISTR_SUSP)
;;;132      if (wIstr & ISTR_SUSP & wInterrupt_Mask)
;;;133      {
;;;134    
;;;135        /* check if SUSPEND is possible */
;;;136        if (fSuspendEnabled)
;;;137        {
;;;138          Suspend();
;;;139        }
;;;140        else
;;;141        {
;;;142          /* if not possible then resume after xx ms */
;;;143          Resume(RESUME_LATER);
;;;144        }
;;;145        /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
;;;146        _SetISTR((uint16_t)CLR_SUSP);
;;;147    #ifdef SUSP_CALLBACK
;;;148        SUSP_Callback();
;;;149    #endif
;;;150      }
;;;151    #endif
;;;152      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;153    #if (IMR_MSK & ISTR_SOF)
;;;154      if (wIstr & ISTR_SOF & wInterrupt_Mask)
;;;155      {
;;;156        _SetISTR((uint16_t)CLR_SOF);
;;;157        bIntPackSOF++;
;;;158    
;;;159    #ifdef SOF_CALLBACK
;;;160        SOF_Callback();
;;;161    #endif
;;;162      }
;;;163    #endif
;;;164      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;165    #if (IMR_MSK & ISTR_ESOF)
;;;166      if (wIstr & ISTR_ESOF & wInterrupt_Mask)
;;;167      {
;;;168        _SetISTR((uint16_t)CLR_ESOF);
;;;169        /* resume handling timing is made with ESOFs */
;;;170        Resume(RESUME_ESOF); /* request without change of the machine state */
;;;171    
;;;172    #ifdef ESOF_CALLBACK
;;;173        ESOF_Callback();
;;;174    #endif
;;;175      }
;;;176    #endif
;;;177    } /* USB_Istr */
00003c  bd10              POP      {r4,pc}
;;;178    
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      0x40005c44
                  |L1.68|
                          DCD      wIstr
                  |L1.72|
                          DCD      wInterrupt_Mask
                  |L1.76|
                          DCD      Device_Property

                          AREA ||.data||, DATA, ALIGN=2

                  wIstr
000000  0000              DCB      0x00,0x00
                  bIntPackSOF
000002  0000              DCB      0x00,0x00
                  pEpInt_IN
                          DCD      EP1_IN_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                  pEpInt_OUT
                          DCD      NOP_Process
                          DCD      EP2_OUT_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
