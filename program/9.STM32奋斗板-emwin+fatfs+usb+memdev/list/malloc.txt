; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\malloc.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\malloc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\MALLOC -I.\TFT -I.\STEMWIN\STEMWIN_Config -I.\STEMWIN\STEMWIN_INC -IC:\Users\Administrator\Desktop\gui\STM32奋斗板-stemwin\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\malloc.crf MALLOC\malloc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  mymemcpy PROC
;;;42     //n:需要复制的内存长度(字节为单位)
;;;43     void mymemcpy(void *des,void *src,u32 n)
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
;;;45     	u8 *xdes = des;
000002  4603              MOV      r3,r0
;;;46     	u8 *xsrc = src;
000004  460c              MOV      r4,r1
;;;47     	while(n--) *xdes++ = *xsrc++;
000006  e003              B        |L1.16|
                  |L1.8|
000008  f8145b01          LDRB     r5,[r4],#1
00000c  f8035b01          STRB     r5,[r3],#1
                  |L1.16|
000010  0015              MOVS     r5,r2
000012  f1a20201          SUB      r2,r2,#1
000016  d1f7              BNE      |L1.8|
;;;48     }
000018  bd70              POP      {r4-r6,pc}
;;;49     
                          ENDP

                  mymemset PROC
;;;53     //count:需要设置的内存大小(字节为单位)
;;;54     void mymemset(void*s,u8 c,u32 count)
00001a  b530              PUSH     {r4,r5,lr}
;;;55     {
;;;56     	u8 *xs = s;
00001c  4603              MOV      r3,r0
;;;57     	while(count--) *xs++=c;
00001e  e001              B        |L1.36|
                  |L1.32|
000020  f8031b01          STRB     r1,[r3],#1
                  |L1.36|
000024  0014              MOVS     r4,r2
000026  f1a20201          SUB      r2,r2,#1
00002a  d1f9              BNE      |L1.32|
;;;58     }
00002c  bd30              POP      {r4,r5,pc}
;;;59     
                          ENDP

                  mem_init PROC
;;;61     //memx:所属内存块
;;;62     void mem_init(u8 memx)
00002e  b510              PUSH     {r4,lr}
;;;63     {
000030  4604              MOV      r4,r0
;;;64     	mymemset(mallco_dev.memmap[memx],0,memtblsize[memx]*2); //内存状态表清零
000032  497c              LDR      r1,|L1.548|
000034  f8511024          LDR      r1,[r1,r4,LSL #2]
000038  004a              LSLS     r2,r1,#1
00003a  497b              LDR      r1,|L1.552|
00003c  f8510024          LDR      r0,[r1,r4,LSL #2]
000040  2100              MOVS     r1,#0
000042  f7fffffe          BL       mymemset
;;;65     	mymemset(mallco_dev.membase[memx], 0,memsize[memx]);	//内存池所有数据清零  
000046  4979              LDR      r1,|L1.556|
000048  f8512024          LDR      r2,[r1,r4,LSL #2]
00004c  4976              LDR      r1,|L1.552|
00004e  390c              SUBS     r1,r1,#0xc
000050  f8510024          LDR      r0,[r1,r4,LSL #2]
000054  2100              MOVS     r1,#0
000056  f7fffffe          BL       mymemset
;;;66     	mallco_dev.memrdy[memx]=1;								//内存管理初始化OK  
00005a  2101              MOVS     r1,#1
00005c  4872              LDR      r0,|L1.552|
00005e  300c              ADDS     r0,r0,#0xc
000060  5501              STRB     r1,[r0,r4]
;;;67     }
000062  bd10              POP      {r4,pc}
;;;68     
                          ENDP

                  mem_perused PROC
;;;71     //返回值:使用率(0~100)
;;;72     u8 mem_perused(u8 memx)  
000064  b510              PUSH     {r4,lr}
;;;73     {  
000066  4601              MOV      r1,r0
;;;74         u32 used=0;  
000068  2300              MOVS     r3,#0
;;;75         u32 i;  
;;;76         for(i=0;i<memtblsize[memx];i++)  
00006a  2200              MOVS     r2,#0
00006c  e007              B        |L1.126|
                  |L1.110|
;;;77         {  
;;;78             if(mallco_dev.memmap[memx][i])used++; 
00006e  486e              LDR      r0,|L1.552|
000070  f8500021          LDR      r0,[r0,r1,LSL #2]
000074  f8300012          LDRH     r0,[r0,r2,LSL #1]
000078  b100              CBZ      r0,|L1.124|
00007a  1c5b              ADDS     r3,r3,#1
                  |L1.124|
00007c  1c52              ADDS     r2,r2,#1              ;76
                  |L1.126|
00007e  4869              LDR      r0,|L1.548|
000080  f8500021          LDR      r0,[r0,r1,LSL #2]     ;76
000084  4290              CMP      r0,r2                 ;76
000086  d8f2              BHI      |L1.110|
;;;79         } 
;;;80         return (used*100)/(memtblsize[memx]);  
000088  2064              MOVS     r0,#0x64
00008a  4358              MULS     r0,r3,r0
00008c  4c65              LDR      r4,|L1.548|
00008e  f8544021          LDR      r4,[r4,r1,LSL #2]
000092  fbb0f0f4          UDIV     r0,r0,r4
000096  b2c0              UXTB     r0,r0
;;;81     } 
000098  bd10              POP      {r4,pc}
;;;82     
                          ENDP

                  mem_malloc PROC
;;;86     //返回值:0XFFFFFFFF,代表错误;其他,内存偏移地址 
;;;87     u32 mem_malloc(u8 memx,u32 size)  
00009a  e92d47f0          PUSH     {r4-r10,lr}
;;;88     {  
00009e  4604              MOV      r4,r0
0000a0  460f              MOV      r7,r1
;;;89         signed long offset=0;  
0000a2  2500              MOVS     r5,#0
;;;90         u16 nmemb;	//需要的内存块数  
;;;91     		u16 cmemb=0;//连续空内存块数
0000a4  46a9              MOV      r9,r5
;;;92         u32 i;  
;;;93         if(!mallco_dev.memrdy[memx])mallco_dev.init(memx);//未初始化,先执行初始化 
0000a6  4860              LDR      r0,|L1.552|
0000a8  300c              ADDS     r0,r0,#0xc
0000aa  5d00              LDRB     r0,[r0,r4]
0000ac  b920              CBNZ     r0,|L1.184|
0000ae  485e              LDR      r0,|L1.552|
0000b0  3814              SUBS     r0,r0,#0x14
0000b2  6801              LDR      r1,[r0,#0]  ; mallco_dev
0000b4  4620              MOV      r0,r4
0000b6  4788              BLX      r1
                  |L1.184|
;;;94         if(size==0)return 0XFFFFFFFF;//不需要分配
0000b8  b91f              CBNZ     r7,|L1.194|
0000ba  f04f30ff          MOV      r0,#0xffffffff
                  |L1.190|
;;;95         nmemb=size/memblksize[memx];  	//获取需要分配的连续内存块数
;;;96         if(size%memblksize[memx])nmemb++;  
;;;97         for(offset=memtblsize[memx]-1;offset>=0;offset--)//搜索整个内存控制区  
;;;98         {     
;;;99     		if(!mallco_dev.memmap[memx][offset])cmemb++;//连续空内存块数增加
;;;100    		else cmemb=0;								//连续内存块清零
;;;101    		if(cmemb==nmemb)							//找到了连续nmemb个空内存块
;;;102    		{
;;;103                for(i=0;i<nmemb;i++)  					//标注内存块非空 
;;;104                {  
;;;105                    mallco_dev.memmap[memx][offset+i]=nmemb;  
;;;106                }  
;;;107                return (offset*memblksize[memx]);//返回偏移地址  
;;;108    		}
;;;109        }  
;;;110        return 0XFFFFFFFF;//未找到符合分配条件的内存块  
;;;111    }  
0000be  e8bd87f0          POP      {r4-r10,pc}
                  |L1.194|
0000c2  485b              LDR      r0,|L1.560|
0000c4  f8500024          LDR      r0,[r0,r4,LSL #2]     ;95
0000c8  fbb7f0f0          UDIV     r0,r7,r0              ;95
0000cc  b286              UXTH     r6,r0                 ;95
0000ce  4858              LDR      r0,|L1.560|
0000d0  f8500024          LDR      r0,[r0,r4,LSL #2]     ;96
0000d4  fbb7f1f0          UDIV     r1,r7,r0              ;96
0000d8  fb007011          MLS      r0,r0,r1,r7           ;96
0000dc  b108              CBZ      r0,|L1.226|
0000de  1c70              ADDS     r0,r6,#1              ;96
0000e0  b286              UXTH     r6,r0                 ;96
                  |L1.226|
0000e2  4850              LDR      r0,|L1.548|
0000e4  f8500024          LDR      r0,[r0,r4,LSL #2]     ;97
0000e8  1e45              SUBS     r5,r0,#1              ;97
0000ea  e022              B        |L1.306|
                  |L1.236|
0000ec  484e              LDR      r0,|L1.552|
0000ee  f8500024          LDR      r0,[r0,r4,LSL #2]     ;99
0000f2  f8300015          LDRH     r0,[r0,r5,LSL #1]     ;99
0000f6  b920              CBNZ     r0,|L1.258|
0000f8  f1090001          ADD      r0,r9,#1              ;99
0000fc  fa1ff980          UXTH     r9,r0                 ;99
000100  e001              B        |L1.262|
                  |L1.258|
000102  f04f0900          MOV      r9,#0                 ;100
                  |L1.262|
000106  45b1              CMP      r9,r6                 ;101
000108  d112              BNE      |L1.304|
00010a  f04f0800          MOV      r8,#0                 ;103
00010e  e008              B        |L1.290|
                  |L1.272|
000110  4845              LDR      r0,|L1.552|
000112  f8500024          LDR      r0,[r0,r4,LSL #2]     ;105
000116  eb050108          ADD      r1,r5,r8              ;105
00011a  f8206011          STRH     r6,[r0,r1,LSL #1]     ;105
00011e  f1080801          ADD      r8,r8,#1              ;103
                  |L1.290|
000122  45b0              CMP      r8,r6                 ;103
000124  d3f4              BCC      |L1.272|
000126  4842              LDR      r0,|L1.560|
000128  f8500024          LDR      r0,[r0,r4,LSL #2]     ;107
00012c  4368              MULS     r0,r5,r0              ;107
00012e  e7c6              B        |L1.190|
                  |L1.304|
000130  1e6d              SUBS     r5,r5,#1              ;97
                  |L1.306|
000132  2d00              CMP      r5,#0                 ;97
000134  dada              BGE      |L1.236|
000136  f04f30ff          MOV      r0,#0xffffffff        ;110
00013a  e7c0              B        |L1.190|
;;;112    
                          ENDP

                  mem_free PROC
;;;116    //返回值:0,释放成功;1,释放失败;  
;;;117    u8 mem_free(u8 memx,u32 offset)  
00013c  e92d41f0          PUSH     {r4-r8,lr}
;;;118    {  
000140  4604              MOV      r4,r0
000142  460e              MOV      r6,r1
;;;119    	int i;  
;;;120      if(!mallco_dev.memrdy[memx])//未初始化,先执行初始化
000144  4838              LDR      r0,|L1.552|
000146  300c              ADDS     r0,r0,#0xc
000148  5d00              LDRB     r0,[r0,r4]
00014a  b938              CBNZ     r0,|L1.348|
;;;121    	{
;;;122    		mallco_dev.init(memx);    
00014c  4836              LDR      r0,|L1.552|
00014e  3814              SUBS     r0,r0,#0x14
000150  6801              LDR      r1,[r0,#0]  ; mallco_dev
000152  4620              MOV      r0,r4
000154  4788              BLX      r1
;;;123        return 1;//未初始化  
000156  2001              MOVS     r0,#1
                  |L1.344|
;;;124      }  
;;;125      if(offset<memsize[memx])//偏移在内存池内. 
;;;126      {  
;;;127    		int index=offset/memblksize[memx];			//偏移所在内存块号码  
;;;128        int nmemb=mallco_dev.memmap[memx][index];	//内存块数量
;;;129        for(i=0;i<nmemb;i++)  						//内存块清零
;;;130        {  
;;;131    			mallco_dev.memmap[memx][index+i]=0;  
;;;132        }  
;;;133        return 0;  
;;;134      }else return 2;//偏移超区了.  
;;;135    }  
000158  e8bd81f0          POP      {r4-r8,pc}
                  |L1.348|
00015c  4833              LDR      r0,|L1.556|
00015e  f8500024          LDR      r0,[r0,r4,LSL #2]     ;125
000162  42b0              CMP      r0,r6                 ;125
000164  d917              BLS      |L1.406|
000166  4832              LDR      r0,|L1.560|
000168  f8500024          LDR      r0,[r0,r4,LSL #2]     ;127
00016c  fbb6f1f0          UDIV     r1,r6,r0              ;127
000170  482d              LDR      r0,|L1.552|
000172  f8500024          LDR      r0,[r0,r4,LSL #2]     ;128
000176  f8302011          LDRH     r2,[r0,r1,LSL #1]     ;128
00017a  2500              MOVS     r5,#0                 ;129
00017c  e007              B        |L1.398|
                  |L1.382|
00017e  2300              MOVS     r3,#0                 ;131
000180  4829              LDR      r0,|L1.552|
000182  f8500024          LDR      r0,[r0,r4,LSL #2]     ;131
000186  194f              ADDS     r7,r1,r5              ;131
000188  f8203017          STRH     r3,[r0,r7,LSL #1]     ;131
00018c  1c6d              ADDS     r5,r5,#1              ;129
                  |L1.398|
00018e  4295              CMP      r5,r2                 ;129
000190  dbf5              BLT      |L1.382|
000192  2000              MOVS     r0,#0                 ;133
000194  e7e0              B        |L1.344|
                  |L1.406|
000196  2002              MOVS     r0,#2                 ;134
000198  e7de              B        |L1.344|
;;;136    
                          ENDP

                  myfree PROC
;;;139    //ptr:内存首地址 
;;;140    void myfree(u8 memx,void *ptr)  
00019a  b570              PUSH     {r4-r6,lr}
;;;141    {  
00019c  4605              MOV      r5,r0
00019e  460c              MOV      r4,r1
;;;142    	u32 offset;  
;;;143        if(ptr==NULL)return;//地址为0.  
0001a0  b904              CBNZ     r4,|L1.420|
                  |L1.418|
;;;144     	offset=(u32)ptr-(u32)mallco_dev.membase[memx];  
;;;145        mem_free(memx,offset);//释放内存     
;;;146    }  
0001a2  bd70              POP      {r4-r6,pc}
                  |L1.420|
0001a4  4820              LDR      r0,|L1.552|
0001a6  380c              SUBS     r0,r0,#0xc            ;144
0001a8  f8500025          LDR      r0,[r0,r5,LSL #2]     ;144
0001ac  1a26              SUBS     r6,r4,r0              ;144
0001ae  4631              MOV      r1,r6                 ;145
0001b0  4628              MOV      r0,r5                 ;145
0001b2  f7fffffe          BL       mem_free
0001b6  bf00              NOP      
0001b8  e7f3              B        |L1.418|
;;;147    
                          ENDP

                  mymalloc PROC
;;;151    //返回值:分配到的内存首地址.
;;;152    void *mymalloc(u8 memx,u32 size)  
0001ba  b570              PUSH     {r4-r6,lr}
;;;153    {  
0001bc  4604              MOV      r4,r0
0001be  460e              MOV      r6,r1
;;;154      u32 offset;  									      
;;;155    	offset=mem_malloc(memx,size);  	   				   
0001c0  4631              MOV      r1,r6
0001c2  4620              MOV      r0,r4
0001c4  f7fffffe          BL       mem_malloc
0001c8  4605              MOV      r5,r0
;;;156      if(offset==0XFFFFFFFF)return NULL;  
0001ca  1c68              ADDS     r0,r5,#1
0001cc  b908              CBNZ     r0,|L1.466|
0001ce  2000              MOVS     r0,#0
                  |L1.464|
;;;157      else return (void*)((u32)mallco_dev.membase[memx]+offset);  
;;;158    }  
0001d0  bd70              POP      {r4-r6,pc}
                  |L1.466|
0001d2  4815              LDR      r0,|L1.552|
0001d4  380c              SUBS     r0,r0,#0xc            ;157
0001d6  f8500024          LDR      r0,[r0,r4,LSL #2]     ;157
0001da  4428              ADD      r0,r0,r5              ;157
0001dc  e7f8              B        |L1.464|
;;;159    
                          ENDP

                  myrealloc PROC
;;;164    //返回值:新分配到的内存首地址.
;;;165    void *myrealloc(u8 memx,void *ptr,u32 size)  
0001de  e92d41f0          PUSH     {r4-r8,lr}
;;;166    {  
0001e2  4604              MOV      r4,r0
0001e4  460f              MOV      r7,r1
0001e6  4616              MOV      r6,r2
;;;167        u32 offset;  
;;;168        offset=mem_malloc(memx,size);  
0001e8  4631              MOV      r1,r6
0001ea  4620              MOV      r0,r4
0001ec  f7fffffe          BL       mem_malloc
0001f0  4605              MOV      r5,r0
;;;169        if(offset==0XFFFFFFFF)return NULL;     
0001f2  1c68              ADDS     r0,r5,#1
0001f4  b910              CBNZ     r0,|L1.508|
0001f6  2000              MOVS     r0,#0
                  |L1.504|
;;;170        else  
;;;171        {  									   
;;;172    	    mymemcpy((void*)((u32)mallco_dev.membase[memx]+offset),ptr,size);	//拷贝旧内存内容到新内存   
;;;173            myfree(memx,ptr);  											  		//释放旧内存
;;;174            return (void*)((u32)mallco_dev.membase[memx]+offset);  				//返回新内存首地址
;;;175        }  
;;;176    }
0001f8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.508|
0001fc  490a              LDR      r1,|L1.552|
0001fe  390c              SUBS     r1,r1,#0xc            ;172
000200  f8511024          LDR      r1,[r1,r4,LSL #2]     ;172
000204  1948              ADDS     r0,r1,r5              ;172
000206  4632              MOV      r2,r6                 ;172
000208  4639              MOV      r1,r7                 ;172
00020a  f7fffffe          BL       mymemcpy
00020e  4639              MOV      r1,r7                 ;173
000210  4620              MOV      r0,r4                 ;173
000212  f7fffffe          BL       myfree
000216  4804              LDR      r0,|L1.552|
000218  380c              SUBS     r0,r0,#0xc            ;174
00021a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;174
00021e  4428              ADD      r0,r0,r5              ;174
000220  e7ea              B        |L1.504|
                          ENDP

000222  0000              DCW      0x0000
                  |L1.548|
                          DCD      memtblsize
                  |L1.552|
                          DCD      mallco_dev+0x14
                  |L1.556|
                          DCD      memsize
                  |L1.560|
                          DCD      memblksize

                          AREA ||.ARM.__AT_0x10000000||, DATA, NOINIT, ALIGN=2

                  mem3base
                          %        61440

                          AREA ||.ARM.__AT_0x1000F000||, DATA, NOINIT, ALIGN=1

                  mem3mapbase
                          %        3840

                          AREA ||.ARM.__AT_0x68000000||, DATA, NOINIT, ALIGN=2

                  mem2base
                          %        204800

                          AREA ||.ARM.__AT_0x68032000||, DATA, NOINIT, ALIGN=1

                  mem2mapbase
                          %        12800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mem1base
                          %        112640
                  mem1mapbase
                          %        7040

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  memtblsize
                          DCD      0x00000dc0
                          DCD      0x00001900
                          DCD      0x00000780
                  memblksize
                          DCD      0x00000020
                          DCD      0x00000020
                          DCD      0x00000020
                  memsize
                          DCD      0x0001b800
                          DCD      0x00032000
                          DCD      0x0000f000

                          AREA ||.data||, DATA, ALIGN=2

                  mallco_dev
                          DCD      mem_init
                          DCD      mem_perused
                          DCD      mem1base
                          DCD      mem2base
                          DCD      mem3base
                          DCD      mem1mapbase
                          DCD      mem2mapbase
                          DCD      mem3mapbase
000020  00000000          DCB      0x00,0x00,0x00,0x00
