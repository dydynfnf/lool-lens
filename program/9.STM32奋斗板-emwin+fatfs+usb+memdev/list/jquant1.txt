; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jquant1.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jquant1.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jquant1.crf GUI\JPEG\jquant1.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  select_ncolors PROC
;;;185    LOCAL(int)
;;;186    select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;187    /* Determine allocation of desired colors to components, */
;;;188    /* and fill in Ncolors[] array to indicate choice. */
;;;189    /* Return value is total number of colors (product of Ncolors[] values). */
;;;190    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;191      int nc = cinfo->out_color_components; /* number of color components */
000008  f8d5b078          LDR      r11,[r5,#0x78]
;;;192      int max_colors = cinfo->desired_number_of_colors;
00000c  6e28              LDR      r0,[r5,#0x60]
00000e  9001              STR      r0,[sp,#4]
;;;193      int total_colors, iroot, i, j;
;;;194      boolean changed;
;;;195      long temp;
;;;196      static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };
;;;197    
;;;198      /* We can allocate at least the nc'th root of max_colors per component. */
;;;199      /* Compute floor(nc'th root of max_colors). */
;;;200      iroot = 1;
000010  f04f0601          MOV      r6,#1
;;;201      do {
000014  bf00              NOP      
                  |L1.22|
;;;202        iroot++;
000016  f1060601          ADD      r6,r6,#1
;;;203        temp = iroot;		/* set temp = iroot ** nc */
00001a  46b0              MOV      r8,r6
;;;204        for (i = 1; i < nc; i++)
00001c  f04f0401          MOV      r4,#1
000020  e003              B        |L1.42|
                  |L1.34|
;;;205          temp *= iroot;
000022  fb08f806          MUL      r8,r8,r6
000026  f1040401          ADD      r4,r4,#1              ;204
                  |L1.42|
00002a  455c              CMP      r4,r11                ;204
00002c  dbf9              BLT      |L1.34|
;;;206      } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
00002e  9801              LDR      r0,[sp,#4]
000030  4580              CMP      r8,r0
000032  ddf0              BLE      |L1.22|
;;;207      iroot--;			/* now iroot = floor(root) */
000034  f1a60601          SUB      r6,r6,#1
;;;208    
;;;209      /* Must have at least 2 color values per component */
;;;210      if (iroot < 2)
000038  2e02              CMP      r6,#2
00003a  da0a              BGE      |L1.82|
;;;211        ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);
00003c  f04f0038          MOV      r0,#0x38
000040  6829              LDR      r1,[r5,#0]
000042  6148              STR      r0,[r1,#0x14]
000044  6828              LDR      r0,[r5,#0]
000046  f8c08018          STR      r8,[r0,#0x18]
00004a  6828              LDR      r0,[r5,#0]
00004c  6801              LDR      r1,[r0,#0]
00004e  4628              MOV      r0,r5
000050  4788              BLX      r1
                  |L1.82|
;;;212    
;;;213      /* Initialize to iroot color values for each component */
;;;214      total_colors = 1;
000052  f04f0901          MOV      r9,#1
;;;215      for (i = 0; i < nc; i++) {
000056  f04f0400          MOV      r4,#0
00005a  e005              B        |L1.104|
                  |L1.92|
;;;216        Ncolors[i] = iroot;
00005c  f8476024          STR      r6,[r7,r4,LSL #2]
;;;217        total_colors *= iroot;
000060  fb09f906          MUL      r9,r9,r6
000064  f1040401          ADD      r4,r4,#1              ;215
                  |L1.104|
000068  455c              CMP      r4,r11                ;215
00006a  dbf7              BLT      |L1.92|
;;;218      }
;;;219      /* We may be able to increment the count for one or more components without
;;;220       * exceeding max_colors, though we know not all can be incremented.
;;;221       * Sometimes, the first component can be incremented more than once!
;;;222       * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
;;;223       * In RGB colorspace, try to increment G first, then R, then B.
;;;224       */
;;;225      do {
00006c  bf00              NOP      
                  |L1.110|
;;;226        changed = FALSE;
00006e  f04f0000          MOV      r0,#0
000072  9000              STR      r0,[sp,#0]
;;;227        for (i = 0; i < nc; i++) {
000074  4604              MOV      r4,r0
000076  e023              B        |L1.192|
                  |L1.120|
;;;228          j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
000078  f8950029          LDRB     r0,[r5,#0x29]
00007c  2802              CMP      r0,#2
00007e  d103              BNE      |L1.136|
000080  48fe              LDR      r0,|L1.1148|
000082  f8500024          LDR      r0,[r0,r4,LSL #2]
000086  e000              B        |L1.138|
                  |L1.136|
000088  4620              MOV      r0,r4
                  |L1.138|
00008a  4682              MOV      r10,r0
;;;229          /* calculate new total_colors if Ncolors[j] is incremented */
;;;230          temp = total_colors / Ncolors[j];
00008c  f857002a          LDR      r0,[r7,r10,LSL #2]
000090  fb99f8f0          SDIV     r8,r9,r0
;;;231          temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
000094  f857002a          LDR      r0,[r7,r10,LSL #2]
000098  f1000001          ADD      r0,r0,#1
00009c  fb08f800          MUL      r8,r8,r0
;;;232          if (temp > (long) max_colors)
0000a0  9801              LDR      r0,[sp,#4]
0000a2  4580              CMP      r8,r0
0000a4  dd00              BLE      |L1.168|
;;;233    	break;			/* won't fit, done with this pass */
0000a6  e00d              B        |L1.196|
                  |L1.168|
;;;234          Ncolors[j]++;		/* OK, apply the increment */
0000a8  f857002a          LDR      r0,[r7,r10,LSL #2]
0000ac  f1000001          ADD      r0,r0,#1
0000b0  f847002a          STR      r0,[r7,r10,LSL #2]
;;;235          total_colors = (int) temp;
0000b4  46c1              MOV      r9,r8
;;;236          changed = TRUE;
0000b6  f04f0001          MOV      r0,#1
0000ba  9000              STR      r0,[sp,#0]
0000bc  f1040401          ADD      r4,r4,#1              ;227
                  |L1.192|
0000c0  455c              CMP      r4,r11                ;227
0000c2  dbd9              BLT      |L1.120|
                  |L1.196|
0000c4  bf00              NOP                            ;233
;;;237        }
;;;238      } while (changed);
0000c6  9800              LDR      r0,[sp,#0]
0000c8  2800              CMP      r0,#0
0000ca  d1d0              BNE      |L1.110|
;;;239    
;;;240      return total_colors;
0000cc  4648              MOV      r0,r9
;;;241    }
0000ce  e8bd9ffc          POP      {r2-r12,pc}
;;;242    
                          ENDP

                  output_value PROC
;;;244    LOCAL(int)
;;;245    output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
0000d2  b570              PUSH     {r4-r6,lr}
;;;246    /* Return j'th output value, where j will range from 0 to maxj */
;;;247    /* The output values must fall in 0..MAXJSAMPLE in increasing order */
;;;248    {
0000d4  4604              MOV      r4,r0
;;;249      /* We always provide values 0 and MAXJSAMPLE for each component;
;;;250       * any additional values are equally spaced between these limits.
;;;251       * (Forcing the upper and lower values to the limits ensures that
;;;252       * dithering can't produce a color outside the selected gamut.)
;;;253       */
;;;254      GUI_USE_PARA(cinfo);
0000d6  bf00              NOP      
;;;255      GUI_USE_PARA(ci);
0000d8  bf00              NOP      
;;;256      return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
0000da  461d              MOV      r5,r3
0000dc  eb0370d5          ADD      r0,r3,r5,LSR #31
0000e0  ebc22602          RSB      r6,r2,r2,LSL #8
0000e4  eb060060          ADD      r0,r6,r0,ASR #1
0000e8  fb90f0f3          SDIV     r0,r0,r3
;;;257    }
0000ec  bd70              POP      {r4-r6,pc}
;;;258    
                          ENDP

                  largest_input_value PROC
;;;260    LOCAL(int)
;;;261    largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
0000ee  b530              PUSH     {r4,r5,lr}
;;;262    /* Return largest input value that should map to j'th output value */
;;;263    /* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
;;;264    {
0000f0  4604              MOV      r4,r0
;;;265      GUI_USE_PARA(cinfo);
0000f2  bf00              NOP      
;;;266      GUI_USE_PARA(ci);
0000f4  bf00              NOP      
;;;267      /* Breakpoints are halfway between values returned by output_value */
;;;268      return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
0000f6  ea4f0042          LSL      r0,r2,#1
0000fa  f1000001          ADD      r0,r0,#1
0000fe  ebc02000          RSB      r0,r0,r0,LSL #8
000102  4418              ADD      r0,r0,r3
000104  ea4f0543          LSL      r5,r3,#1
000108  fb90f0f5          SDIV     r0,r0,r5
;;;269    }
00010c  bd30              POP      {r4,r5,pc}
;;;270    
                          ENDP

                  create_colormap PROC
;;;276    LOCAL(void)
;;;277    create_colormap (j_decompress_ptr cinfo)
00010e  e92d4ff0          PUSH     {r4-r11,lr}
;;;278    {
000112  b085              SUB      sp,sp,#0x14
000114  4604              MOV      r4,r0
;;;279      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000116  f8d451cc          LDR      r5,[r4,#0x1cc]
;;;280      JSAMPARRAY colormap;		/* Created colormap */
;;;281      int total_colors;		/* Number of distinct output colors */
;;;282      int i,j,k, nci, blksize, blkdist, ptr, val;
;;;283    
;;;284      /* Select number of colors for each component */
;;;285      total_colors = select_ncolors(cinfo, cquantize->Ncolors);
00011a  f1050120          ADD      r1,r5,#0x20
00011e  4620              MOV      r0,r4
000120  f7fffffe          BL       select_ncolors
000124  4606              MOV      r6,r0
;;;286    
;;;287      /* Report selected color counts */
;;;288      if (cinfo->out_color_components == 3)
000126  6fa0              LDR      r0,[r4,#0x78]
000128  2803              CMP      r0,#3
00012a  d119              BNE      |L1.352|
;;;289        TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
00012c  bf00              NOP      
00012e  6820              LDR      r0,[r4,#0]
000130  f1000b18          ADD      r11,r0,#0x18
000134  f8cb6000          STR      r6,[r11,#0]
000138  6a28              LDR      r0,[r5,#0x20]
00013a  f8cb0004          STR      r0,[r11,#4]
00013e  6a68              LDR      r0,[r5,#0x24]
000140  f8cb0008          STR      r0,[r11,#8]
000144  6aa8              LDR      r0,[r5,#0x28]
000146  f8cb000c          STR      r0,[r11,#0xc]
00014a  f04f005e          MOV      r0,#0x5e
00014e  6821              LDR      r1,[r4,#0]
000150  6148              STR      r0,[r1,#0x14]
000152  6820              LDR      r0,[r4,#0]
000154  f04f0101          MOV      r1,#1
000158  6842              LDR      r2,[r0,#4]
00015a  4620              MOV      r0,r4
00015c  4790              BLX      r2
00015e  e00b              B        |L1.376|
                  |L1.352|
;;;290    	     total_colors, cquantize->Ncolors[0],
;;;291    	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
;;;292      else
;;;293        TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);
000160  f04f005f          MOV      r0,#0x5f
000164  6821              LDR      r1,[r4,#0]
000166  6148              STR      r0,[r1,#0x14]
000168  6820              LDR      r0,[r4,#0]
00016a  6186              STR      r6,[r0,#0x18]
00016c  6820              LDR      r0,[r4,#0]
00016e  f04f0101          MOV      r1,#1
000172  6842              LDR      r2,[r0,#4]
000174  4620              MOV      r0,r4
000176  4790              BLX      r2
                  |L1.376|
;;;294    
;;;295      /* Allocate and fill in the colormap. */
;;;296      /* The colors are ordered in the map in standard row-major order, */
;;;297      /* i.e. rightmost (highest-indexed) color changes most rapidly. */
;;;298    
;;;299      colormap = (*cinfo->mem->alloc_sarray)
000178  6fa3              LDR      r3,[r4,#0x78]
00017a  6860              LDR      r0,[r4,#4]
00017c  4632              MOV      r2,r6
00017e  2101              MOVS     r1,#1
000180  f8d0c008          LDR      r12,[r0,#8]
000184  4620              MOV      r0,r4
000186  47e0              BLX      r12
000188  4680              MOV      r8,r0
;;;300        ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;301         (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
;;;302    
;;;303      /* blksize is number of adjacent repeated entries for a component */
;;;304      /* blkdist is distance between groups of identical entries for a component */
;;;305      blkdist = total_colors;
00018a  9602              STR      r6,[sp,#8]
;;;306    
;;;307      for (i = 0; i < cinfo->out_color_components; i++) {
00018c  f04f0700          MOV      r7,#0
000190  e03a              B        |L1.520|
                  |L1.402|
;;;308        /* fill in colormap entries for i'th color component */
;;;309        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
000192  f1050020          ADD      r0,r5,#0x20
000196  f850a027          LDR      r10,[r0,r7,LSL #2]
;;;310        blksize = blkdist / nci;
00019a  9802              LDR      r0,[sp,#8]
00019c  fb90f0fa          SDIV     r0,r0,r10
0001a0  9003              STR      r0,[sp,#0xc]
;;;311        for (j = 0; j < nci; j++) {
0001a2  f04f0900          MOV      r9,#0
0001a6  e029              B        |L1.508|
                  |L1.424|
;;;312          /* Compute j'th output value (out of nci) for component */
;;;313          val = output_value(cinfo, i, j, nci-1);
0001a8  f1aa0301          SUB      r3,r10,#1
0001ac  464a              MOV      r2,r9
0001ae  4639              MOV      r1,r7
0001b0  4620              MOV      r0,r4
0001b2  f7fffffe          BL       output_value
0001b6  9000              STR      r0,[sp,#0]
;;;314          /* Fill in all colormap entries that have this value of this component */
;;;315          for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
0001b8  9803              LDR      r0,[sp,#0xc]
0001ba  fb09f000          MUL      r0,r9,r0
0001be  9001              STR      r0,[sp,#4]
0001c0  e017              B        |L1.498|
                  |L1.450|
;;;316    	/* fill in blksize entries beginning at ptr */
;;;317    	for (k = 0; k < blksize; k++)
0001c2  f04f0000          MOV      r0,#0
0001c6  9004              STR      r0,[sp,#0x10]
0001c8  e00b              B        |L1.482|
                  |L1.458|
;;;318    	  colormap[i][ptr+k] = (JSAMPLE) val;
0001ca  9800              LDR      r0,[sp,#0]
0001cc  b2c2              UXTB     r2,r0
0001ce  f8583027          LDR      r3,[r8,r7,LSL #2]
0001d2  9904              LDR      r1,[sp,#0x10]
0001d4  9801              LDR      r0,[sp,#4]
0001d6  4408              ADD      r0,r0,r1
0001d8  541a              STRB     r2,[r3,r0]
0001da  9804              LDR      r0,[sp,#0x10]         ;317
0001dc  f1000001          ADD      r0,r0,#1              ;317
0001e0  9004              STR      r0,[sp,#0x10]         ;317
                  |L1.482|
0001e2  e9dd1003          LDRD     r1,r0,[sp,#0xc]       ;317
0001e6  4288              CMP      r0,r1                 ;317
0001e8  dbef              BLT      |L1.458|
0001ea  e9dd0101          LDRD     r0,r1,[sp,#4]         ;315
0001ee  4408              ADD      r0,r0,r1              ;315
0001f0  9001              STR      r0,[sp,#4]            ;315
                  |L1.498|
0001f2  9801              LDR      r0,[sp,#4]            ;315
0001f4  42b0              CMP      r0,r6                 ;315
0001f6  dbe4              BLT      |L1.450|
0001f8  f1090901          ADD      r9,r9,#1              ;311
                  |L1.508|
0001fc  45d1              CMP      r9,r10                ;311
0001fe  dbd3              BLT      |L1.424|
;;;319          }
;;;320        }
;;;321        blkdist = blksize;		/* blksize of this color is blkdist of next */
000200  9803              LDR      r0,[sp,#0xc]
000202  9002              STR      r0,[sp,#8]
000204  f1070701          ADD      r7,r7,#1              ;307
                  |L1.520|
000208  6fa0              LDR      r0,[r4,#0x78]         ;307
00020a  42b8              CMP      r0,r7                 ;307
00020c  dcc1              BGT      |L1.402|
;;;322      }
;;;323    
;;;324      /* Save the colormap in private storage,
;;;325       * where it will survive color quantization mode changes.
;;;326       */
;;;327      cquantize->sv_colormap = colormap;
00020e  f8c58010          STR      r8,[r5,#0x10]
;;;328      cquantize->sv_actual = total_colors;
000212  616e              STR      r6,[r5,#0x14]
;;;329    }
000214  b005              ADD      sp,sp,#0x14
000216  e8bd8ff0          POP      {r4-r11,pc}
;;;330    
                          ENDP

                  create_colorindex PROC
;;;336    LOCAL(void)
;;;337    create_colorindex (j_decompress_ptr cinfo)
00021a  e92d5ffc          PUSH     {r2-r12,lr}
;;;338    {
00021e  4607              MOV      r7,r0
;;;339      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000220  f8d741cc          LDR      r4,[r7,#0x1cc]
;;;340      JSAMPROW indexptr;
;;;341      int i,j,k, nci, blksize, val, pad;
;;;342    
;;;343      /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
;;;344       * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
;;;345       * This is not necessary in the other dithering modes.  However, we
;;;346       * flag whether it was done in case user changes dithering mode.
;;;347       */
;;;348      if (cinfo->dither_mode == JDITHER_ORDERED) {
000224  f8970058          LDRB     r0,[r7,#0x58]
000228  2801              CMP      r0,#1
00022a  d103              BNE      |L1.564|
;;;349        pad = MAXJSAMPLE*2;
00022c  f44f79ff          MOV      r9,#0x1fe
;;;350        cquantize->is_padded = TRUE;
000230  61e0              STR      r0,[r4,#0x1c]
000232  e003              B        |L1.572|
                  |L1.564|
;;;351      } else {
;;;352        pad = 0;
000234  f04f0900          MOV      r9,#0
;;;353        cquantize->is_padded = FALSE;
000238  4648              MOV      r0,r9
00023a  61e0              STR      r0,[r4,#0x1c]
                  |L1.572|
;;;354      }
;;;355    
;;;356      cquantize->colorindex = (*cinfo->mem->alloc_sarray)
00023c  f5097280          ADD      r2,r9,#0x100
000240  6fbb              LDR      r3,[r7,#0x78]
000242  6878              LDR      r0,[r7,#4]
000244  2101              MOVS     r1,#1
000246  f8d0c008          LDR      r12,[r0,#8]
00024a  4638              MOV      r0,r7
00024c  47e0              BLX      r12
00024e  61a0              STR      r0,[r4,#0x18]
;;;357        ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;358         (JDIMENSION) (MAXJSAMPLE+1 + pad),
;;;359         (JDIMENSION) cinfo->out_color_components);
;;;360    
;;;361      /* blksize is number of adjacent repeated entries for a component */
;;;362      blksize = cquantize->sv_actual;
000250  f8d4b014          LDR      r11,[r4,#0x14]
;;;363    
;;;364      for (i = 0; i < cinfo->out_color_components; i++) {
000254  f04f0500          MOV      r5,#0
000258  e051              B        |L1.766|
                  |L1.602|
;;;365        /* fill in colorindex entries for i'th color component */
;;;366        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
00025a  f1040020          ADD      r0,r4,#0x20
00025e  f850a025          LDR      r10,[r0,r5,LSL #2]
;;;367        blksize = blksize / nci;
000262  fb9bfbfa          SDIV     r11,r11,r10
;;;368    
;;;369        /* adjust colorindex pointers to provide padding at negative indexes. */
;;;370        if (pad)
000266  f1b90f00          CMP      r9,#0
00026a  d007              BEQ      |L1.636|
;;;371          cquantize->colorindex[i] += MAXJSAMPLE;
00026c  69a0              LDR      r0,[r4,#0x18]
00026e  f8500025          LDR      r0,[r0,r5,LSL #2]
000272  f10000ff          ADD      r0,r0,#0xff
000276  69a1              LDR      r1,[r4,#0x18]
000278  f8410025          STR      r0,[r1,r5,LSL #2]
                  |L1.636|
;;;372    
;;;373        /* in loop, val = index of current output value, */
;;;374        /* and k = largest j that maps to current val */
;;;375        indexptr = cquantize->colorindex[i];
00027c  69a0              LDR      r0,[r4,#0x18]
00027e  f8508025          LDR      r8,[r0,r5,LSL #2]
;;;376        val = 0;
000282  f04f0000          MOV      r0,#0
000286  9000              STR      r0,[sp,#0]
;;;377        k = largest_input_value(cinfo, i, 0, nci-1);
000288  f1aa0301          SUB      r3,r10,#1
00028c  4602              MOV      r2,r0
00028e  4629              MOV      r1,r5
000290  4638              MOV      r0,r7
000292  f7fffffe          BL       largest_input_value
000296  9001              STR      r0,[sp,#4]
;;;378        for (j = 0; j <= MAXJSAMPLE; j++) {
000298  f04f0600          MOV      r6,#0
00029c  e015              B        |L1.714|
                  |L1.670|
;;;379          while (j > k)		/* advance val if past boundary */
00029e  e00a              B        |L1.694|
                  |L1.672|
;;;380    	k = largest_input_value(cinfo, i, ++val, nci-1);
0002a0  f1aa0301          SUB      r3,r10,#1
0002a4  9800              LDR      r0,[sp,#0]
0002a6  1c40              ADDS     r0,r0,#1
0002a8  4602              MOV      r2,r0
0002aa  4629              MOV      r1,r5
0002ac  9000              STR      r0,[sp,#0]
0002ae  4638              MOV      r0,r7
0002b0  f7fffffe          BL       largest_input_value
0002b4  9001              STR      r0,[sp,#4]
                  |L1.694|
0002b6  9801              LDR      r0,[sp,#4]            ;379
0002b8  4286              CMP      r6,r0                 ;379
0002ba  dcf1              BGT      |L1.672|
;;;381          /* premultiply so that no multiplication needed in main processing */
;;;382          indexptr[j] = (JSAMPLE) (val * blksize);
0002bc  9800              LDR      r0,[sp,#0]
0002be  fb00f00b          MUL      r0,r0,r11
0002c2  f8080006          STRB     r0,[r8,r6]
0002c6  f1060601          ADD      r6,r6,#1              ;378
                  |L1.714|
0002ca  2eff              CMP      r6,#0xff              ;378
0002cc  dde7              BLE      |L1.670|
;;;383        }
;;;384        /* Pad at both ends if necessary */
;;;385        if (pad)
0002ce  f1b90f00          CMP      r9,#0
0002d2  d012              BEQ      |L1.762|
;;;386          for (j = 1; j <= MAXJSAMPLE; j++) {
0002d4  f04f0601          MOV      r6,#1
0002d8  e00d              B        |L1.758|
                  |L1.730|
;;;387    	indexptr[-j] = indexptr[0];
0002da  f8980000          LDRB     r0,[r8,#0]
0002de  f1c60100          RSB      r1,r6,#0
0002e2  f8080001          STRB     r0,[r8,r1]
;;;388    	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
0002e6  f89810ff          LDRB     r1,[r8,#0xff]
0002ea  f10600ff          ADD      r0,r6,#0xff
0002ee  f8081000          STRB     r1,[r8,r0]
0002f2  f1060601          ADD      r6,r6,#1              ;386
                  |L1.758|
0002f6  2eff              CMP      r6,#0xff              ;386
0002f8  ddef              BLE      |L1.730|
                  |L1.762|
0002fa  f1050501          ADD      r5,r5,#1              ;364
                  |L1.766|
0002fe  6fb8              LDR      r0,[r7,#0x78]         ;364
000300  42a8              CMP      r0,r5                 ;364
000302  dcaa              BGT      |L1.602|
;;;389          }
;;;390      }
;;;391    }
000304  e8bd9ffc          POP      {r2-r12,pc}
;;;392    
                          ENDP

                  make_odither_array PROC
;;;399    LOCAL(ODITHER_MATRIX_PTR)
;;;400    make_odither_array (j_decompress_ptr cinfo, int ncolors)
000308  e92d47f0          PUSH     {r4-r10,lr}
;;;401    {
00030c  4607              MOV      r7,r0
00030e  4688              MOV      r8,r1
;;;402      ODITHER_MATRIX_PTR odither;
;;;403      int j,k;
;;;404      INT32 num,den;
;;;405    
;;;406      odither = (ODITHER_MATRIX_PTR)
000310  6878              LDR      r0,[r7,#4]
000312  f44f6280          MOV      r2,#0x400
000316  f04f0101          MOV      r1,#1
00031a  6803              LDR      r3,[r0,#0]
00031c  4638              MOV      r0,r7
00031e  4798              BLX      r3
000320  4681              MOV      r9,r0
;;;407        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;408    				SIZEOF(ODITHER_MATRIX));
;;;409      /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
;;;410       * Hence the dither value for the matrix cell with fill order f
;;;411       * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
;;;412       * On 16-bit-int machine, be careful to avoid overflow.
;;;413       */
;;;414      den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
000322  f1a80001          SUB      r0,r8,#1
000326  ea4f2a40          LSL      r10,r0,#9
;;;415      for (j = 0; j < ODITHER_SIZE; j++) {
00032a  f04f0400          MOV      r4,#0
00032e  e021              B        |L1.884|
                  |L1.816|
;;;416        for (k = 0; k < ODITHER_SIZE; k++) {
000330  f04f0500          MOV      r5,#0
000334  e01a              B        |L1.876|
                  |L1.822|
;;;417          num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
000336  4852              LDR      r0,|L1.1152|
000338  eb001004          ADD      r0,r0,r4,LSL #4
00033c  5d40              LDRB     r0,[r0,r5]
00033e  ea4f0040          LSL      r0,r0,#1
000342  f1c000ff          RSB      r0,r0,#0xff
000346  ebc02600          RSB      r6,r0,r0,LSL #8
;;;418    	    * MAXJSAMPLE;
;;;419          /* Ensure round towards zero despite C's lack of consistency
;;;420           * about rounding negative values in integer division...
;;;421           */
;;;422          odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
00034a  2e00              CMP      r6,#0
00034c  da06              BGE      |L1.860|
00034e  f1c60000          RSB      r0,r6,#0
000352  fb90f0fa          SDIV     r0,r0,r10
000356  f1c00000          RSB      r0,r0,#0
00035a  e001              B        |L1.864|
                  |L1.860|
00035c  fb96f0fa          SDIV     r0,r6,r10
                  |L1.864|
000360  eb091184          ADD      r1,r9,r4,LSL #6
000364  f8410025          STR      r0,[r1,r5,LSL #2]
000368  f1050501          ADD      r5,r5,#1              ;416
                  |L1.876|
00036c  2d10              CMP      r5,#0x10              ;416
00036e  dbe2              BLT      |L1.822|
000370  f1040401          ADD      r4,r4,#1              ;415
                  |L1.884|
000374  2c10              CMP      r4,#0x10              ;415
000376  dbdb              BLT      |L1.816|
;;;423        }
;;;424      }
;;;425      return odither;
000378  4648              MOV      r0,r9
;;;426    }
00037a  e8bd87f0          POP      {r4-r10,pc}
;;;427    
                          ENDP

                  create_odither_tables PROC
;;;435    LOCAL(void)
;;;436    create_odither_tables (j_decompress_ptr cinfo)
00037e  e92d47f0          PUSH     {r4-r10,lr}
;;;437    {
000382  4607              MOV      r7,r0
;;;438      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000384  f8d751cc          LDR      r5,[r7,#0x1cc]
;;;439      ODITHER_MATRIX_PTR odither;
;;;440      int i, j, nci;
;;;441    
;;;442      for (i = 0; i < cinfo->out_color_components; i++) {
000388  f04f0400          MOV      r4,#0
00038c  e025              B        |L1.986|
                  |L1.910|
;;;443        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
00038e  f1050020          ADD      r0,r5,#0x20
000392  f8508024          LDR      r8,[r0,r4,LSL #2]
;;;444        odither = NULL;		/* search for matching prior component */
000396  f04f0900          MOV      r9,#0
;;;445        for (j = 0; j < i; j++) {
00039a  464e              MOV      r6,r9
00039c  e00c              B        |L1.952|
                  |L1.926|
;;;446          if (nci == cquantize->Ncolors[j]) {
00039e  f1050020          ADD      r0,r5,#0x20
0003a2  f8500026          LDR      r0,[r0,r6,LSL #2]
0003a6  4540              CMP      r0,r8
0003a8  d104              BNE      |L1.948|
;;;447    	odither = cquantize->odither[j];
0003aa  f1050034          ADD      r0,r5,#0x34
0003ae  f8509026          LDR      r9,[r0,r6,LSL #2]
;;;448    	break;
0003b2  e003              B        |L1.956|
                  |L1.948|
0003b4  f1060601          ADD      r6,r6,#1              ;445
                  |L1.952|
0003b8  42a6              CMP      r6,r4                 ;445
0003ba  dbf0              BLT      |L1.926|
                  |L1.956|
0003bc  bf00              NOP      
;;;449          }
;;;450        }
;;;451        if (odither == NULL)	/* need a new table? */
0003be  f1b90f00          CMP      r9,#0
0003c2  d104              BNE      |L1.974|
;;;452          odither = make_odither_array(cinfo, nci);
0003c4  4641              MOV      r1,r8
0003c6  4638              MOV      r0,r7
0003c8  f7fffffe          BL       make_odither_array
0003cc  4681              MOV      r9,r0
                  |L1.974|
;;;453        cquantize->odither[i] = odither;
0003ce  f1050034          ADD      r0,r5,#0x34
0003d2  f8409024          STR      r9,[r0,r4,LSL #2]
0003d6  f1040401          ADD      r4,r4,#1              ;442
                  |L1.986|
0003da  6fb8              LDR      r0,[r7,#0x78]         ;442
0003dc  42a0              CMP      r0,r4                 ;442
0003de  dcd6              BGT      |L1.910|
;;;454      }
;;;455    }
0003e0  e8bd87f0          POP      {r4-r10,pc}
;;;456    
                          ENDP

                  color_quantize PROC
;;;462    METHODDEF(void)
;;;463    color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
0003e4  e92d4ffc          PUSH     {r2-r11,lr}
;;;464    		JSAMPARRAY output_buf, int num_rows)
;;;465    /* General case, no dithering */
;;;466    {
0003e8  460c              MOV      r4,r1
0003ea  4615              MOV      r5,r2
;;;467      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0003ec  f8d091cc          LDR      r9,[r0,#0x1cc]
;;;468      JSAMPARRAY colorindex = cquantize->colorindex;
0003f0  f8d9a018          LDR      r10,[r9,#0x18]
;;;469      register int pixcode, ci;
;;;470      register JSAMPROW ptrin, ptrout;
;;;471      int row;
;;;472      JDIMENSION col;
;;;473      JDIMENSION width = cinfo->output_width;
0003f4  f8d0b070          LDR      r11,[r0,#0x70]
0003f8  f8cdb004          STR      r11,[sp,#4]
;;;474      register int nc = cinfo->out_color_components;
0003fc  f8d0b078          LDR      r11,[r0,#0x78]
000400  f8cdb000          STR      r11,[sp,#0]
;;;475    
;;;476      for (row = 0; row < num_rows; row++) {
000404  f04f0100          MOV      r1,#0
000408  e01e              B        |L1.1096|
                  |L1.1034|
;;;477        ptrin = input_buf[row];
00040a  f854c021          LDR      r12,[r4,r1,LSL #2]
;;;478        ptrout = output_buf[row];
00040e  f8558021          LDR      r8,[r5,r1,LSL #2]
;;;479        for (col = width; col > 0; col--) {
000412  9f01              LDR      r7,[sp,#4]
000414  e014              B        |L1.1088|
                  |L1.1046|
;;;480          pixcode = 0;
000416  f04f0600          MOV      r6,#0
;;;481          for (ci = 0; ci < nc; ci++) {
00041a  4632              MOV      r2,r6
00041c  e008              B        |L1.1072|
                  |L1.1054|
;;;482    	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
00041e  f81cbb01          LDRB     r11,[r12],#1
000422  f85ae022          LDR      lr,[r10,r2,LSL #2]
000426  f81eb00b          LDRB     r11,[lr,r11]
00042a  445e              ADD      r6,r6,r11
00042c  f1020201          ADD      r2,r2,#1              ;481
                  |L1.1072|
000430  f8ddb000          LDR      r11,[sp,#0]           ;481
000434  455a              CMP      r2,r11                ;481
000436  dbf2              BLT      |L1.1054|
;;;483          }
;;;484          *ptrout++ = (JSAMPLE) pixcode;
000438  f8086b01          STRB     r6,[r8],#1
00043c  f1a70701          SUB      r7,r7,#1              ;479
                  |L1.1088|
000440  2f00              CMP      r7,#0                 ;479
000442  d1e8              BNE      |L1.1046|
000444  f1010101          ADD      r1,r1,#1              ;476
                  |L1.1096|
000448  4299              CMP      r1,r3                 ;476
00044a  dbde              BLT      |L1.1034|
;;;485        }
;;;486      }
;;;487    }
00044c  e8bd8ffc          POP      {r2-r11,pc}
;;;488    
                          ENDP

                  color_quantize3 PROC
;;;490    METHODDEF(void)
;;;491    color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000450  e92d4ffc          PUSH     {r2-r11,lr}
;;;492    		 JSAMPARRAY output_buf, int num_rows)
;;;493    /* Fast path for out_color_components==3, no dithering */
;;;494    {
000454  4604              MOV      r4,r0
000456  460d              MOV      r5,r1
000458  4616              MOV      r6,r2
00045a  461f              MOV      r7,r3
;;;495      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00045c  f8d421cc          LDR      r2,[r4,#0x1cc]
;;;496      register int pixcode;
;;;497      register JSAMPROW ptrin, ptrout;
;;;498      JSAMPROW colorindex0 = cquantize->colorindex[0];
000460  f8d2b018          LDR      r11,[r2,#0x18]
000464  f8db9000          LDR      r9,[r11,#0]
;;;499      JSAMPROW colorindex1 = cquantize->colorindex[1];
000468  f8d2b018          LDR      r11,[r2,#0x18]
00046c  f8dba004          LDR      r10,[r11,#4]
;;;500      JSAMPROW colorindex2 = cquantize->colorindex[2];
000470  f8d2b018          LDR      r11,[r2,#0x18]
000474  f8dbb008          LDR      r11,[r11,#8]
000478  e004              B        |L1.1156|
00047a  0000              DCW      0x0000
                  |L1.1148|
                          DCD      RGB_order
                  |L1.1152|
                          DCD      base_dither_matrix
                  |L1.1156|
000484  f8cdb004          STR      r11,[sp,#4]
;;;501      int row;
;;;502      JDIMENSION col;
;;;503      JDIMENSION width = cinfo->output_width;
000488  f8d4b070          LDR      r11,[r4,#0x70]
00048c  f8cdb000          STR      r11,[sp,#0]
;;;504    
;;;505      for (row = 0; row < num_rows; row++) {
000490  f04f0100          MOV      r1,#0
000494  e01f              B        |L1.1238|
                  |L1.1174|
;;;506        ptrin = input_buf[row];
000496  f8550021          LDR      r0,[r5,r1,LSL #2]
;;;507        ptrout = output_buf[row];
00049a  f856c021          LDR      r12,[r6,r1,LSL #2]
;;;508        for (col = width; col > 0; col--) {
00049e  f8dd8000          LDR      r8,[sp,#0]
0004a2  e013              B        |L1.1228|
                  |L1.1188|
;;;509          pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
0004a4  f810bb01          LDRB     r11,[r0],#1
0004a8  f819300b          LDRB     r3,[r9,r11]
;;;510          pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
0004ac  f810bb01          LDRB     r11,[r0],#1
0004b0  f81ab00b          LDRB     r11,[r10,r11]
0004b4  445b              ADD      r3,r3,r11
;;;511          pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
0004b6  f810bb01          LDRB     r11,[r0],#1
0004ba  f8dde004          LDR      lr,[sp,#4]
0004be  f81eb00b          LDRB     r11,[lr,r11]
0004c2  445b              ADD      r3,r3,r11
;;;512          *ptrout++ = (JSAMPLE) pixcode;
0004c4  f80c3b01          STRB     r3,[r12],#1
0004c8  f1a80801          SUB      r8,r8,#1              ;508
                  |L1.1228|
0004cc  f1b80f00          CMP      r8,#0                 ;508
0004d0  d1e8              BNE      |L1.1188|
0004d2  f1010101          ADD      r1,r1,#1              ;505
                  |L1.1238|
0004d6  42b9              CMP      r1,r7                 ;505
0004d8  dbdd              BLT      |L1.1174|
;;;513        }
;;;514      }
;;;515    }
0004da  e8bd8ffc          POP      {r2-r11,pc}
;;;516    
                          ENDP

                  quantize_ord_dither PROC
;;;518    METHODDEF(void)
;;;519    quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
0004de  e92d4fff          PUSH     {r0-r11,lr}
;;;520    		     JSAMPARRAY output_buf, int num_rows)
;;;521    /* General case, with ordered dithering */
;;;522    {
0004e2  b087              SUB      sp,sp,#0x1c
0004e4  4606              MOV      r6,r0
0004e6  4690              MOV      r8,r2
;;;523      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0004e8  f8d671cc          LDR      r7,[r6,#0x1cc]
;;;524      register JSAMPROW input_ptr;
;;;525      register JSAMPROW output_ptr;
;;;526      JSAMPROW colorindex_ci;
;;;527      int * dither;			/* points to active row of dither matrix */
;;;528      int row_index, col_index;	/* current indexes into dither matrix */
;;;529      int nc = cinfo->out_color_components;
0004ec  6fb0              LDR      r0,[r6,#0x78]
0004ee  9002              STR      r0,[sp,#8]
;;;530      int ci;
;;;531      int row;
;;;532      JDIMENSION col;
;;;533      JDIMENSION width = cinfo->output_width;
0004f0  f8d6b070          LDR      r11,[r6,#0x70]
;;;534    
;;;535      for (row = 0; row < num_rows; row++) {
0004f4  f04f0500          MOV      r5,#0
0004f8  e050              B        |L1.1436|
                  |L1.1274|
;;;536        /* Initialize output values to 0 so can process components separately */
;;;537        jzero_far((void FAR *) output_buf[row],
0004fa  4659              MOV      r1,r11
0004fc  f8580025          LDR      r0,[r8,r5,LSL #2]
000500  f7fffffe          BL       jzero_far
;;;538    	      (size_t) (width * SIZEOF(JSAMPLE)));
;;;539        row_index = cquantize->row_index;
000504  f8d7a030          LDR      r10,[r7,#0x30]
;;;540        for (ci = 0; ci < nc; ci++) {
000508  f04f0400          MOV      r4,#0
00050c  e03b              B        |L1.1414|
                  |L1.1294|
;;;541          input_ptr = input_buf[row] + ci;
00050e  9808              LDR      r0,[sp,#0x20]
000510  f8500025          LDR      r0,[r0,r5,LSL #2]
000514  4420              ADD      r0,r0,r4
000516  9006              STR      r0,[sp,#0x18]
;;;542          output_ptr = output_buf[row];
000518  f8589025          LDR      r9,[r8,r5,LSL #2]
;;;543          colorindex_ci = cquantize->colorindex[ci];
00051c  69b8              LDR      r0,[r7,#0x18]
00051e  f8500024          LDR      r0,[r0,r4,LSL #2]
000522  9005              STR      r0,[sp,#0x14]
;;;544          dither = cquantize->odither[ci][row_index];
000524  f1070034          ADD      r0,r7,#0x34
000528  f8500024          LDR      r0,[r0,r4,LSL #2]
00052c  eb00108a          ADD      r0,r0,r10,LSL #6
000530  9004              STR      r0,[sp,#0x10]
;;;545          col_index = 0;
000532  f04f0000          MOV      r0,#0
000536  9003              STR      r0,[sp,#0xc]
;;;546    
;;;547          for (col = width; col > 0; col--) {
000538  f8cdb004          STR      r11,[sp,#4]
00053c  e01e              B        |L1.1404|
                  |L1.1342|
;;;548    	/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
;;;549    	 * select output value, accumulate into output code for this pixel.
;;;550    	 * Range-limiting need not be done explicitly, as we have extended
;;;551    	 * the colorindex table to produce the right answers for out-of-range
;;;552    	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
;;;553    	 * required amount of padding.
;;;554    	 */
;;;555    	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
00053e  9806              LDR      r0,[sp,#0x18]
000540  7802              LDRB     r2,[r0,#0]
000542  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000546  f8500021          LDR      r0,[r0,r1,LSL #2]
00054a  eb020100          ADD      r1,r2,r0
00054e  9805              LDR      r0,[sp,#0x14]
000550  5c40              LDRB     r0,[r0,r1]
000552  f8991000          LDRB     r1,[r9,#0]
000556  4408              ADD      r0,r0,r1
000558  f8890000          STRB     r0,[r9,#0]
;;;556    	input_ptr += nc;
00055c  9902              LDR      r1,[sp,#8]
00055e  9806              LDR      r0,[sp,#0x18]
000560  4408              ADD      r0,r0,r1
000562  9006              STR      r0,[sp,#0x18]
;;;557    	output_ptr++;
000564  f1090901          ADD      r9,r9,#1
;;;558    	col_index = (col_index + 1) & ODITHER_MASK;
000568  9803              LDR      r0,[sp,#0xc]
00056a  f1000001          ADD      r0,r0,#1
00056e  f000000f          AND      r0,r0,#0xf
000572  9003              STR      r0,[sp,#0xc]
000574  9801              LDR      r0,[sp,#4]            ;547
000576  f1a00001          SUB      r0,r0,#1              ;547
00057a  9001              STR      r0,[sp,#4]            ;547
                  |L1.1404|
00057c  9801              LDR      r0,[sp,#4]            ;547
00057e  2800              CMP      r0,#0                 ;547
000580  d1dd              BNE      |L1.1342|
000582  f1040401          ADD      r4,r4,#1              ;540
                  |L1.1414|
000586  9802              LDR      r0,[sp,#8]            ;540
000588  4284              CMP      r4,r0                 ;540
00058a  dbc0              BLT      |L1.1294|
;;;559          }
;;;560        }
;;;561        /* Advance row index for next row */
;;;562        row_index = (row_index + 1) & ODITHER_MASK;
00058c  f10a0001          ADD      r0,r10,#1
000590  f0000a0f          AND      r10,r0,#0xf
;;;563        cquantize->row_index = row_index;
000594  f8c7a030          STR      r10,[r7,#0x30]
000598  f1050501          ADD      r5,r5,#1              ;535
                  |L1.1436|
00059c  980a              LDR      r0,[sp,#0x28]         ;535
00059e  4285              CMP      r5,r0                 ;535
0005a0  dbab              BLT      |L1.1274|
;;;564      }
;;;565    }
0005a2  b00b              ADD      sp,sp,#0x2c
0005a4  e8bd8ff0          POP      {r4-r11,pc}
;;;566    
                          ENDP

                  quantize3_ord_dither PROC
;;;568    METHODDEF(void)
;;;569    quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
0005a8  e92d4fff          PUSH     {r0-r11,lr}
;;;570    		      JSAMPARRAY output_buf, int num_rows)
;;;571    /* Fast path for out_color_components==3, with ordered dithering */
;;;572    {
0005ac  b084              SUB      sp,sp,#0x10
0005ae  4605              MOV      r5,r0
;;;573      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0005b0  f8d501cc          LDR      r0,[r5,#0x1cc]
;;;574      register int pixcode;
;;;575      register JSAMPROW input_ptr;
;;;576      register JSAMPROW output_ptr;
;;;577      JSAMPROW colorindex0 = cquantize->colorindex[0];
0005b4  f8d0b018          LDR      r11,[r0,#0x18]
0005b8  f8dbb000          LDR      r11,[r11,#0]
0005bc  f8cdb00c          STR      r11,[sp,#0xc]
;;;578      JSAMPROW colorindex1 = cquantize->colorindex[1];
0005c0  f8d0b018          LDR      r11,[r0,#0x18]
0005c4  f8dbb004          LDR      r11,[r11,#4]
0005c8  f8cdb008          STR      r11,[sp,#8]
;;;579      JSAMPROW colorindex2 = cquantize->colorindex[2];
0005cc  f8d0b018          LDR      r11,[r0,#0x18]
0005d0  f8dbb008          LDR      r11,[r11,#8]
0005d4  f8cdb004          STR      r11,[sp,#4]
;;;580      int * dither0;		/* points to active row of dither matrix */
;;;581      int * dither1;
;;;582      int * dither2;
;;;583      int row_index, col_index;	/* current indexes into dither matrix */
;;;584      int row;
;;;585      JDIMENSION col;
;;;586      JDIMENSION width = cinfo->output_width;
0005d8  f8d5b070          LDR      r11,[r5,#0x70]
0005dc  f8cdb000          STR      r11,[sp,#0]
;;;587    
;;;588      for (row = 0; row < num_rows; row++) {
0005e0  f04f0400          MOV      r4,#0
0005e4  e048              B        |L1.1656|
                  |L1.1510|
;;;589        row_index = cquantize->row_index;
0005e6  6b02              LDR      r2,[r0,#0x30]
;;;590        input_ptr = input_buf[row];
0005e8  f8ddb014          LDR      r11,[sp,#0x14]
0005ec  f85b1024          LDR      r1,[r11,r4,LSL #2]
;;;591        output_ptr = output_buf[row];
0005f0  f8ddb018          LDR      r11,[sp,#0x18]
0005f4  f85b7024          LDR      r7,[r11,r4,LSL #2]
;;;592        dither0 = cquantize->odither[0][row_index];
0005f8  f8d0b034          LDR      r11,[r0,#0x34]
0005fc  eb0b1c82          ADD      r12,r11,r2,LSL #6
;;;593        dither1 = cquantize->odither[1][row_index];
000600  f8d0b038          LDR      r11,[r0,#0x38]
000604  eb0b1882          ADD      r8,r11,r2,LSL #6
;;;594        dither2 = cquantize->odither[2][row_index];
000608  f8d0b03c          LDR      r11,[r0,#0x3c]
00060c  eb0b1982          ADD      r9,r11,r2,LSL #6
;;;595        col_index = 0;
000610  f04f0300          MOV      r3,#0
;;;596    
;;;597        for (col = width; col > 0; col--) {
000614  f8dda000          LDR      r10,[sp,#0]
000618  e024              B        |L1.1636|
                  |L1.1562|
;;;598          pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
00061a  f811bb01          LDRB     r11,[r1],#1
00061e  f85ce023          LDR      lr,[r12,r3,LSL #2]
000622  44de              ADD      lr,lr,r11
000624  f8ddb00c          LDR      r11,[sp,#0xc]
000628  f81b600e          LDRB     r6,[r11,lr]
;;;599    					dither0[col_index]]);
;;;600          pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
00062c  f811bb01          LDRB     r11,[r1],#1
000630  f858e023          LDR      lr,[r8,r3,LSL #2]
000634  44de              ADD      lr,lr,r11
000636  f8ddb008          LDR      r11,[sp,#8]
00063a  f81bb00e          LDRB     r11,[r11,lr]
00063e  445e              ADD      r6,r6,r11
;;;601    					dither1[col_index]]);
;;;602          pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
000640  f811bb01          LDRB     r11,[r1],#1
000644  f859e023          LDR      lr,[r9,r3,LSL #2]
000648  44de              ADD      lr,lr,r11
00064a  f8ddb004          LDR      r11,[sp,#4]
00064e  f81bb00e          LDRB     r11,[r11,lr]
000652  445e              ADD      r6,r6,r11
;;;603    					dither2[col_index]]);
;;;604          *output_ptr++ = (JSAMPLE) pixcode;
000654  f8076b01          STRB     r6,[r7],#1
;;;605          col_index = (col_index + 1) & ODITHER_MASK;
000658  f1030b01          ADD      r11,r3,#1
00065c  f00b030f          AND      r3,r11,#0xf
000660  f1aa0a01          SUB      r10,r10,#1            ;597
                  |L1.1636|
000664  f1ba0f00          CMP      r10,#0                ;597
000668  d1d7              BNE      |L1.1562|
;;;606        }
;;;607        row_index = (row_index + 1) & ODITHER_MASK;
00066a  f1020b01          ADD      r11,r2,#1
00066e  f00b020f          AND      r2,r11,#0xf
;;;608        cquantize->row_index = row_index;
000672  6302              STR      r2,[r0,#0x30]
000674  f1040401          ADD      r4,r4,#1              ;588
                  |L1.1656|
000678  f8ddb01c          LDR      r11,[sp,#0x1c]        ;588
00067c  455c              CMP      r4,r11                ;588
00067e  dbb2              BLT      |L1.1510|
;;;609      }
;;;610    }
000680  b008              ADD      sp,sp,#0x20
000682  e8bd8ff0          POP      {r4-r11,pc}
;;;611    
                          ENDP

                  quantize_fs_dither PROC
;;;613    METHODDEF(void)
;;;614    quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000686  e92d4fff          PUSH     {r0-r11,lr}
;;;615    		    JSAMPARRAY output_buf, int num_rows)
;;;616    /* General case, with Floyd-Steinberg dithering */
;;;617    {
00068a  b08d              SUB      sp,sp,#0x34
00068c  4680              MOV      r8,r0
;;;618      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00068e  f8d851cc          LDR      r5,[r8,#0x1cc]
;;;619      register LOCFSERROR cur;	/* current error or pixel value */
;;;620      LOCFSERROR belowerr;		/* error for pixel below cur */
;;;621      LOCFSERROR bpreverr;		/* error for below/prev col */
;;;622      LOCFSERROR bnexterr;		/* error for below/next col */
;;;623      LOCFSERROR delta;
;;;624      register FSERRPTR errorptr;	/* => fserrors[] at column before current */
;;;625      register JSAMPROW input_ptr;
;;;626      register JSAMPROW output_ptr;
;;;627      JSAMPROW colorindex_ci;
;;;628      JSAMPROW colormap_ci;
;;;629      int pixcode;
;;;630      int nc = cinfo->out_color_components;
000692  f8d80078          LDR      r0,[r8,#0x78]
000696  9004              STR      r0,[sp,#0x10]
;;;631      int dir;			/* 1 for left-to-right, -1 for right-to-left */
;;;632      int dirnc;			/* dir * nc */
;;;633      int ci;
;;;634      int row;
;;;635      JDIMENSION col;
;;;636      JDIMENSION width = cinfo->output_width;
000698  f8d87070          LDR      r7,[r8,#0x70]
;;;637      JSAMPLE *range_limit = cinfo->sample_range_limit;
00069c  f8d80144          LDR      r0,[r8,#0x144]
0006a0  9000              STR      r0,[sp,#0]
;;;638      SHIFT_TEMPS
;;;639    
;;;640      for (row = 0; row < num_rows; row++) {
0006a2  f04f0a00          MOV      r10,#0
0006a6  e09e              B        |L1.2022|
                  |L1.1704|
;;;641        /* Initialize output values to 0 so can process components separately */
;;;642        jzero_far((void FAR *) output_buf[row],
0006a8  4639              MOV      r1,r7
0006aa  9a0f              LDR      r2,[sp,#0x3c]
0006ac  f852002a          LDR      r0,[r2,r10,LSL #2]
0006b0  f7fffffe          BL       jzero_far
;;;643    	      (size_t) (width * SIZEOF(JSAMPLE)));
;;;644        for (ci = 0; ci < nc; ci++) {
0006b4  f04f0600          MOV      r6,#0
0006b8  e087              B        |L1.1994|
                  |L1.1722|
;;;645          input_ptr = input_buf[row] + ci;
0006ba  980e              LDR      r0,[sp,#0x38]
0006bc  f850002a          LDR      r0,[r0,r10,LSL #2]
0006c0  4430              ADD      r0,r0,r6
0006c2  9009              STR      r0,[sp,#0x24]
;;;646          output_ptr = output_buf[row];
0006c4  980f              LDR      r0,[sp,#0x3c]
0006c6  f850002a          LDR      r0,[r0,r10,LSL #2]
0006ca  9008              STR      r0,[sp,#0x20]
;;;647          if (cquantize->on_odd_row) {
0006cc  6d68              LDR      r0,[r5,#0x54]
0006ce  b1e0              CBZ      r0,|L1.1802|
;;;648    	/* work right to left in this row */
;;;649    	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
0006d0  f1a70001          SUB      r0,r7,#1
0006d4  9a09              LDR      r2,[sp,#0x24]
0006d6  9904              LDR      r1,[sp,#0x10]
0006d8  fb002001          MLA      r0,r0,r1,r2
0006dc  9009              STR      r0,[sp,#0x24]
;;;650    	output_ptr += width-1;
0006de  f1a70001          SUB      r0,r7,#1
0006e2  9908              LDR      r1,[sp,#0x20]
0006e4  4408              ADD      r0,r0,r1
0006e6  9008              STR      r0,[sp,#0x20]
;;;651    	dir = -1;
0006e8  f04f30ff          MOV      r0,#0xffffffff
0006ec  9003              STR      r0,[sp,#0xc]
;;;652    	dirnc = -nc;
0006ee  9804              LDR      r0,[sp,#0x10]
0006f0  f1c00000          RSB      r0,r0,#0
0006f4  9002              STR      r0,[sp,#8]
;;;653    	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
0006f6  f1050044          ADD      r0,r5,#0x44
0006fa  f8501026          LDR      r1,[r0,r6,LSL #2]
0006fe  f1070001          ADD      r0,r7,#1
000702  eb010040          ADD      r0,r1,r0,LSL #1
000706  900a              STR      r0,[sp,#0x28]
000708  e009              B        |L1.1822|
                  |L1.1802|
;;;654          } else {
;;;655    	/* work left to right in this row */
;;;656    	dir = 1;
00070a  f04f0001          MOV      r0,#1
00070e  9003              STR      r0,[sp,#0xc]
;;;657    	dirnc = nc;
000710  9804              LDR      r0,[sp,#0x10]
000712  9002              STR      r0,[sp,#8]
;;;658    	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
000714  f1050044          ADD      r0,r5,#0x44
000718  f8500026          LDR      r0,[r0,r6,LSL #2]
00071c  900a              STR      r0,[sp,#0x28]
                  |L1.1822|
;;;659          }
;;;660          colorindex_ci = cquantize->colorindex[ci];
00071e  69a8              LDR      r0,[r5,#0x18]
000720  f8500026          LDR      r0,[r0,r6,LSL #2]
000724  9007              STR      r0,[sp,#0x1c]
;;;661          colormap_ci = cquantize->sv_colormap[ci];
000726  6928              LDR      r0,[r5,#0x10]
000728  f8500026          LDR      r0,[r0,r6,LSL #2]
00072c  9006              STR      r0,[sp,#0x18]
;;;662          /* Preset error values: no error propagated to first pixel from left */
;;;663          cur = 0;
00072e  f04f0400          MOV      r4,#0
;;;664          /* and no error propagated to row below yet */
;;;665          belowerr = bpreverr = 0;
000732  4620              MOV      r0,r4
000734  900b              STR      r0,[sp,#0x2c]
000736  900c              STR      r0,[sp,#0x30]
;;;666    
;;;667          for (col = width; col > 0; col--) {
000738  9701              STR      r7,[sp,#4]
00073a  e03d              B        |L1.1976|
                  |L1.1852|
;;;668    	/* cur holds the error propagated from the previous pixel on the
;;;669    	 * current line.  Add the error propagated from the previous line
;;;670    	 * to form the complete error correction term for this pixel, and
;;;671    	 * round the error term (which is expressed * 16) to an integer.
;;;672    	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
;;;673    	 * for either sign of the error value.
;;;674    	 * Note: errorptr points to *previous* column's array entry.
;;;675    	 */
;;;676    	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
00073c  9903              LDR      r1,[sp,#0xc]
00073e  980a              LDR      r0,[sp,#0x28]
000740  f9300011          LDRSH    r0,[r0,r1,LSL #1]
000744  4420              ADD      r0,r0,r4
000746  f1000008          ADD      r0,r0,#8
00074a  ea4f1420          ASR      r4,r0,#4
;;;677    	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
;;;678    	 * The maximum error is +- MAXJSAMPLE; this sets the required size
;;;679    	 * of the range_limit array.
;;;680    	 */
;;;681    	cur += GETJSAMPLE(*input_ptr);
00074e  9809              LDR      r0,[sp,#0x24]
000750  7800              LDRB     r0,[r0,#0]
000752  4404              ADD      r4,r4,r0
;;;682    	cur = GETJSAMPLE(range_limit[cur]);
000754  9800              LDR      r0,[sp,#0]
000756  5d04              LDRB     r4,[r0,r4]
;;;683    	/* Select output value, accumulate into output code for this pixel */
;;;684    	pixcode = GETJSAMPLE(colorindex_ci[cur]);
000758  9807              LDR      r0,[sp,#0x1c]
00075a  5d00              LDRB     r0,[r0,r4]
00075c  9005              STR      r0,[sp,#0x14]
;;;685    	*output_ptr += (JSAMPLE) pixcode;
00075e  9808              LDR      r0,[sp,#0x20]
000760  7801              LDRB     r1,[r0,#0]
000762  9805              LDR      r0,[sp,#0x14]
000764  4408              ADD      r0,r0,r1
000766  b2c1              UXTB     r1,r0
000768  9808              LDR      r0,[sp,#0x20]
00076a  7001              STRB     r1,[r0,#0]
;;;686    	/* Compute actual representation error at this pixel */
;;;687    	/* Note: we can do this even though we don't have the final */
;;;688    	/* pixel code, because the colormap is orthogonal. */
;;;689    	cur -= GETJSAMPLE(colormap_ci[pixcode]);
00076c  e9dd0105          LDRD     r0,r1,[sp,#0x14]
000770  5c08              LDRB     r0,[r1,r0]
000772  eba40400          SUB      r4,r4,r0
;;;690    	/* Compute error fractions to be propagated to adjacent pixels.
;;;691    	 * Add these into the running sums, and simultaneously shift the
;;;692    	 * next-line error sums left by 1 column.
;;;693    	 */
;;;694    	bnexterr = cur;
000776  46a1              MOV      r9,r4
;;;695    	delta = cur * 2;
000778  ea4f0b44          LSL      r11,r4,#1
;;;696    	cur += delta;		/* form error * 3 */
00077c  445c              ADD      r4,r4,r11
;;;697    	errorptr[0] = (FSERROR) (bpreverr + cur);
00077e  980b              LDR      r0,[sp,#0x2c]
000780  4420              ADD      r0,r0,r4
000782  b201              SXTH     r1,r0
000784  980a              LDR      r0,[sp,#0x28]
000786  8001              STRH     r1,[r0,#0]
;;;698    	cur += delta;		/* form error * 5 */
000788  445c              ADD      r4,r4,r11
;;;699    	bpreverr = belowerr + cur;
00078a  980c              LDR      r0,[sp,#0x30]
00078c  4420              ADD      r0,r0,r4
00078e  900b              STR      r0,[sp,#0x2c]
;;;700    	belowerr = bnexterr;
000790  f8cd9030          STR      r9,[sp,#0x30]
;;;701    	cur += delta;		/* form error * 7 */
000794  445c              ADD      r4,r4,r11
;;;702    	/* At this point cur contains the 7/16 error value to be propagated
;;;703    	 * to the next pixel on the current line, and all the errors for the
;;;704    	 * next line have been shifted over. We are therefore ready to move on.
;;;705    	 */
;;;706    	input_ptr += dirnc;	/* advance input ptr to next column */
000796  9902              LDR      r1,[sp,#8]
000798  9809              LDR      r0,[sp,#0x24]
00079a  4408              ADD      r0,r0,r1
00079c  9009              STR      r0,[sp,#0x24]
;;;707    	output_ptr += dir;	/* advance output ptr to next column */
00079e  9903              LDR      r1,[sp,#0xc]
0007a0  9808              LDR      r0,[sp,#0x20]
0007a2  4408              ADD      r0,r0,r1
0007a4  9008              STR      r0,[sp,#0x20]
;;;708    	errorptr += dir;	/* advance errorptr to current column */
0007a6  9903              LDR      r1,[sp,#0xc]
0007a8  980a              LDR      r0,[sp,#0x28]
0007aa  eb000041          ADD      r0,r0,r1,LSL #1
0007ae  900a              STR      r0,[sp,#0x28]
0007b0  9801              LDR      r0,[sp,#4]            ;667
0007b2  f1a00001          SUB      r0,r0,#1              ;667
0007b6  9001              STR      r0,[sp,#4]            ;667
                  |L1.1976|
0007b8  9801              LDR      r0,[sp,#4]            ;667
0007ba  2800              CMP      r0,#0                 ;667
0007bc  d1be              BNE      |L1.1852|
;;;709          }
;;;710          /* Post-loop cleanup: we must unload the final error value into the
;;;711           * final fserrors[] entry.  Note we need not unload belowerr because
;;;712           * it is for the dummy column before or after the actual array.
;;;713           */
;;;714          errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
0007be  980b              LDR      r0,[sp,#0x2c]
0007c0  b201              SXTH     r1,r0
0007c2  980a              LDR      r0,[sp,#0x28]
0007c4  8001              STRH     r1,[r0,#0]
0007c6  f1060601          ADD      r6,r6,#1              ;644
                  |L1.1994|
0007ca  9804              LDR      r0,[sp,#0x10]         ;644
0007cc  4286              CMP      r6,r0                 ;644
0007ce  f6ffaf74          BLT      |L1.1722|
;;;715        }
;;;716        cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
0007d2  6d68              LDR      r0,[r5,#0x54]
0007d4  b910              CBNZ     r0,|L1.2012|
0007d6  f04f0001          MOV      r0,#1
0007da  e001              B        |L1.2016|
                  |L1.2012|
0007dc  f04f0000          MOV      r0,#0
                  |L1.2016|
0007e0  6568              STR      r0,[r5,#0x54]
0007e2  f10a0a01          ADD      r10,r10,#1            ;640
                  |L1.2022|
0007e6  9810              LDR      r0,[sp,#0x40]         ;640
0007e8  4582              CMP      r10,r0                ;640
0007ea  f6ffaf5d          BLT      |L1.1704|
;;;717      }
;;;718    }
0007ee  b011              ADD      sp,sp,#0x44
0007f0  e8bd8ff0          POP      {r4-r11,pc}
;;;719    
                          ENDP

                  alloc_fs_workspace PROC
;;;725    LOCAL(void)
;;;726    alloc_fs_workspace (j_decompress_ptr cinfo)
0007f4  e92d41f0          PUSH     {r4-r8,lr}
;;;727    {
0007f8  4604              MOV      r4,r0
;;;728      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0007fa  f8d471cc          LDR      r7,[r4,#0x1cc]
;;;729      size_t arraysize;
;;;730      int i;
;;;731    
;;;732      arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
0007fe  6f20              LDR      r0,[r4,#0x70]
000800  f1000002          ADD      r0,r0,#2
000804  ea4f0640          LSL      r6,r0,#1
;;;733      for (i = 0; i < cinfo->out_color_components; i++) {
000808  f04f0500          MOV      r5,#0
00080c  e00b              B        |L1.2086|
                  |L1.2062|
;;;734        cquantize->fserrors[i] = (FSERRPTR)
00080e  6860              LDR      r0,[r4,#4]
000810  4632              MOV      r2,r6
000812  2101              MOVS     r1,#1
000814  6843              LDR      r3,[r0,#4]
000816  4620              MOV      r0,r4
000818  4798              BLX      r3
00081a  f1070144          ADD      r1,r7,#0x44
00081e  f8410025          STR      r0,[r1,r5,LSL #2]
000822  f1050501          ADD      r5,r5,#1              ;733
                  |L1.2086|
000826  6fa0              LDR      r0,[r4,#0x78]         ;733
000828  42a8              CMP      r0,r5                 ;733
00082a  dcf0              BGT      |L1.2062|
;;;735          (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
;;;736      }
;;;737    }
00082c  e8bd81f0          POP      {r4-r8,pc}
;;;738    
                          ENDP

                  start_pass_1_quant PROC
;;;744    METHODDEF(void)
;;;745    start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
000830  e92d41f0          PUSH     {r4-r8,lr}
;;;746    {
000834  4605              MOV      r5,r0
000836  460f              MOV      r7,r1
;;;747      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000838  f1050558          ADD      r5,r5,#0x58
00083c  f8d54174          LDR      r4,[r5,#0x174]
;;;748      size_t arraysize;
;;;749      int i;
;;;750    
;;;751      GUI_USE_PARA(is_pre_scan);
000840  bf00              NOP      
;;;752      /* Install my colormap. */
;;;753      cinfo->colormap = cquantize->sv_colormap;
000842  6920              LDR      r0,[r4,#0x10]
000844  6328              STR      r0,[r5,#0x30]
;;;754      cinfo->actual_number_of_colors = cquantize->sv_actual;
000846  6960              LDR      r0,[r4,#0x14]
000848  62e8              STR      r0,[r5,#0x2c]
;;;755    
;;;756      /* Initialize for desired dithering mode. */
;;;757      switch (cinfo->dither_mode) {
00084a  f8150958          LDRB     r0,[r5],#-0x58
00084e  b120              CBZ      r0,|L1.2138|
000850  2801              CMP      r0,#1
000852  d00b              BEQ      |L1.2156|
000854  2802              CMP      r0,#2
000856  d13e              BNE      |L1.2262|
000858  e01e              B        |L1.2200|
                  |L1.2138|
;;;758      case JDITHER_NONE:
;;;759        if (cinfo->out_color_components == 3)
00085a  6fa8              LDR      r0,[r5,#0x78]
00085c  2803              CMP      r0,#3
00085e  d102              BNE      |L1.2150|
;;;760          cquantize->pub.color_quantize = color_quantize3;
000860  484b              LDR      r0,|L1.2448|
000862  6060              STR      r0,[r4,#4]
000864  e001              B        |L1.2154|
                  |L1.2150|
;;;761        else
;;;762          cquantize->pub.color_quantize = color_quantize;
000866  484b              LDR      r0,|L1.2452|
000868  6060              STR      r0,[r4,#4]
                  |L1.2154|
;;;763        break;
00086a  e03d              B        |L1.2280|
                  |L1.2156|
;;;764      case JDITHER_ORDERED:
;;;765        if (cinfo->out_color_components == 3)
00086c  6fa8              LDR      r0,[r5,#0x78]
00086e  2803              CMP      r0,#3
000870  d102              BNE      |L1.2168|
;;;766          cquantize->pub.color_quantize = quantize3_ord_dither;
000872  4849              LDR      r0,|L1.2456|
000874  6060              STR      r0,[r4,#4]
000876  e001              B        |L1.2172|
                  |L1.2168|
;;;767        else
;;;768          cquantize->pub.color_quantize = quantize_ord_dither;
000878  4848              LDR      r0,|L1.2460|
00087a  6060              STR      r0,[r4,#4]
                  |L1.2172|
;;;769        cquantize->row_index = 0;	/* initialize state for ordered dither */
00087c  f04f0000          MOV      r0,#0
000880  6320              STR      r0,[r4,#0x30]
;;;770        /* If user changed to ordered dither from another mode,
;;;771         * we must recreate the color index table with padding.
;;;772         * This will cost extra space, but probably isn't very likely.
;;;773         */
;;;774        if (! cquantize->is_padded)
000882  69e0              LDR      r0,[r4,#0x1c]
000884  b910              CBNZ     r0,|L1.2188|
;;;775          create_colorindex(cinfo);
000886  4628              MOV      r0,r5
000888  f7fffffe          BL       create_colorindex
                  |L1.2188|
;;;776        /* Create ordered-dither tables if we didn't already. */
;;;777        if (cquantize->odither[0] == NULL)
00088c  6b60              LDR      r0,[r4,#0x34]
00088e  b910              CBNZ     r0,|L1.2198|
;;;778          create_odither_tables(cinfo);
000890  4628              MOV      r0,r5
000892  f7fffffe          BL       create_odither_tables
                  |L1.2198|
;;;779        break;
000896  e027              B        |L1.2280|
                  |L1.2200|
;;;780      case JDITHER_FS:
;;;781        cquantize->pub.color_quantize = quantize_fs_dither;
000898  4841              LDR      r0,|L1.2464|
00089a  6060              STR      r0,[r4,#4]
;;;782        cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
00089c  f04f0000          MOV      r0,#0
0008a0  6560              STR      r0,[r4,#0x54]
;;;783        /* Allocate Floyd-Steinberg workspace if didn't already. */
;;;784        if (cquantize->fserrors[0] == NULL)
0008a2  6c60              LDR      r0,[r4,#0x44]
0008a4  b910              CBNZ     r0,|L1.2220|
;;;785          alloc_fs_workspace(cinfo);
0008a6  4628              MOV      r0,r5
0008a8  f7fffffe          BL       alloc_fs_workspace
                  |L1.2220|
;;;786        /* Initialize the propagated errors to zero. */
;;;787        arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
0008ac  6f28              LDR      r0,[r5,#0x70]
0008ae  f1000002          ADD      r0,r0,#2
0008b2  ea4f0840          LSL      r8,r0,#1
;;;788        for (i = 0; i < cinfo->out_color_components; i++)
0008b6  f04f0600          MOV      r6,#0
0008ba  e008              B        |L1.2254|
                  |L1.2236|
;;;789          jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
0008bc  f1040144          ADD      r1,r4,#0x44
0008c0  f8510026          LDR      r0,[r1,r6,LSL #2]
0008c4  4641              MOV      r1,r8
0008c6  f7fffffe          BL       jzero_far
0008ca  f1060601          ADD      r6,r6,#1              ;788
                  |L1.2254|
0008ce  6fa8              LDR      r0,[r5,#0x78]         ;788
0008d0  42b0              CMP      r0,r6                 ;788
0008d2  dcf3              BGT      |L1.2236|
;;;790        break;
0008d4  e008              B        |L1.2280|
                  |L1.2262|
;;;791      default:
;;;792        ERREXIT(cinfo, JERR_NOT_COMPILED);
0008d6  f04f0030          MOV      r0,#0x30
0008da  6829              LDR      r1,[r5,#0]
0008dc  6148              STR      r0,[r1,#0x14]
0008de  6828              LDR      r0,[r5,#0]
0008e0  6801              LDR      r1,[r0,#0]
0008e2  4628              MOV      r0,r5
0008e4  4788              BLX      r1
;;;793        break;
0008e6  bf00              NOP      
                  |L1.2280|
0008e8  bf00              NOP                            ;763
;;;794      }
;;;795    }
0008ea  e8bd81f0          POP      {r4-r8,pc}
;;;796    
                          ENDP

                  finish_pass_1_quant PROC
;;;802    METHODDEF(void)
;;;803    finish_pass_1_quant (j_decompress_ptr cinfo)
0008ee  bf00              NOP      
;;;804    {
;;;805      GUI_USE_PARA(cinfo);
;;;806      /* no work in 1-pass case */
;;;807    }
0008f0  4770              BX       lr
;;;808    
                          ENDP

                  new_color_map_1_quant PROC
;;;815    METHODDEF(void)
;;;816    new_color_map_1_quant (j_decompress_ptr cinfo)
0008f2  b510              PUSH     {r4,lr}
;;;817    {
0008f4  4604              MOV      r4,r0
;;;818      ERREXIT(cinfo, JERR_MODE_CHANGE);
0008f6  f04f002e          MOV      r0,#0x2e
0008fa  6821              LDR      r1,[r4,#0]
0008fc  6148              STR      r0,[r1,#0x14]
0008fe  6820              LDR      r0,[r4,#0]
000900  6801              LDR      r1,[r0,#0]
000902  4620              MOV      r0,r4
000904  4788              BLX      r1
;;;819    }
000906  bd10              POP      {r4,pc}
;;;820    
                          ENDP

                  jinit_1pass_quantizer PROC
;;;826    GLOBAL(void)
;;;827    jinit_1pass_quantizer (j_decompress_ptr cinfo)
000908  b570              PUSH     {r4-r6,lr}
;;;828    {
00090a  4604              MOV      r4,r0
;;;829      my_cquantize_ptr cquantize;
;;;830    
;;;831      cquantize = (my_cquantize_ptr)
00090c  6860              LDR      r0,[r4,#4]
00090e  f04f0258          MOV      r2,#0x58
000912  f04f0101          MOV      r1,#1
000916  6803              LDR      r3,[r0,#0]
000918  4620              MOV      r0,r4
00091a  4798              BLX      r3
00091c  4605              MOV      r5,r0
;;;832        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;833    				SIZEOF(my_cquantizer));
;;;834      cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
00091e  f8c451cc          STR      r5,[r4,#0x1cc]
;;;835      cquantize->pub.start_pass = start_pass_1_quant;
000922  4820              LDR      r0,|L1.2468|
000924  6028              STR      r0,[r5,#0]
;;;836      cquantize->pub.finish_pass = finish_pass_1_quant;
000926  4820              LDR      r0,|L1.2472|
000928  60a8              STR      r0,[r5,#8]
;;;837      cquantize->pub.new_color_map = new_color_map_1_quant;
00092a  4820              LDR      r0,|L1.2476|
00092c  60e8              STR      r0,[r5,#0xc]
;;;838      cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
00092e  f04f0000          MOV      r0,#0
000932  6468              STR      r0,[r5,#0x44]
;;;839      cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
000934  6368              STR      r0,[r5,#0x34]
;;;840    
;;;841      /* Make sure my internal arrays won't overflow */
;;;842      if (cinfo->out_color_components > MAX_Q_COMPS)
000936  6fa0              LDR      r0,[r4,#0x78]
000938  2804              CMP      r0,#4
00093a  dd0b              BLE      |L1.2388|
;;;843        ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
00093c  f04f0037          MOV      r0,#0x37
000940  6821              LDR      r1,[r4,#0]
000942  6148              STR      r0,[r1,#0x14]
000944  f04f0004          MOV      r0,#4
000948  6821              LDR      r1,[r4,#0]
00094a  6188              STR      r0,[r1,#0x18]
00094c  6820              LDR      r0,[r4,#0]
00094e  6801              LDR      r1,[r0,#0]
000950  4620              MOV      r0,r4
000952  4788              BLX      r1
                  |L1.2388|
;;;844      /* Make sure colormap indexes can be represented by JSAMPLEs */
;;;845      if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
000954  6e20              LDR      r0,[r4,#0x60]
000956  f5b07f80          CMP      r0,#0x100
00095a  dd0b              BLE      |L1.2420|
;;;846        ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);
00095c  f04f0039          MOV      r0,#0x39
000960  6821              LDR      r1,[r4,#0]
000962  6148              STR      r0,[r1,#0x14]
000964  f44f7080          MOV      r0,#0x100
000968  6821              LDR      r1,[r4,#0]
00096a  6188              STR      r0,[r1,#0x18]
00096c  6820              LDR      r0,[r4,#0]
00096e  6801              LDR      r1,[r0,#0]
000970  4620              MOV      r0,r4
000972  4788              BLX      r1
                  |L1.2420|
;;;847    
;;;848      /* Create the colormap and color index table. */
;;;849      create_colormap(cinfo);
000974  4620              MOV      r0,r4
000976  f7fffffe          BL       create_colormap
;;;850      create_colorindex(cinfo);
00097a  4620              MOV      r0,r4
00097c  f7fffffe          BL       create_colorindex
;;;851    
;;;852      /* Allocate Floyd-Steinberg workspace now if requested.
;;;853       * We do this now since it is FAR storage and may affect the memory
;;;854       * manager's space calculations.  If the user changes to FS dither
;;;855       * mode in a later pass, we will allocate the space then, and will
;;;856       * possibly overrun the max_memory_to_use setting.
;;;857       */
;;;858      if (cinfo->dither_mode == JDITHER_FS)
000980  f8940058          LDRB     r0,[r4,#0x58]
000984  2802              CMP      r0,#2
000986  d102              BNE      |L1.2446|
;;;859        alloc_fs_workspace(cinfo);
000988  4620              MOV      r0,r4
00098a  f7fffffe          BL       alloc_fs_workspace
                  |L1.2446|
;;;860    }
00098e  bd70              POP      {r4-r6,pc}
;;;861    
                          ENDP

                  |L1.2448|
                          DCD      color_quantize3
                  |L1.2452|
                          DCD      color_quantize
                  |L1.2456|
                          DCD      quantize3_ord_dither
                  |L1.2460|
                          DCD      quantize_ord_dither
                  |L1.2464|
                          DCD      quantize_fs_dither
                  |L1.2468|
                          DCD      start_pass_1_quant
                  |L1.2472|
                          DCD      finish_pass_1_quant
                  |L1.2476|
                          DCD      new_color_map_1_quant

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  base_dither_matrix
000000  00c030f0          DCB      0x00,0xc0,0x30,0xf0
000004  0ccc3cfc          DCB      0x0c,0xcc,0x3c,0xfc
000008  03c333f3          DCB      0x03,0xc3,0x33,0xf3
00000c  0fcf3fff          DCB      0x0f,0xcf,0x3f,0xff
000010  8040b070          DCB      0x80,0x40,0xb0,0x70
000014  8c4cbc7c          DCB      0x8c,0x4c,0xbc,0x7c
000018  8343b373          DCB      0x83,0x43,0xb3,0x73
00001c  8f4fbf7f          DCB      0x8f,0x4f,0xbf,0x7f
000020  20e010d0          DCB      0x20,0xe0,0x10,0xd0
000024  2cec1cdc          DCB      0x2c,0xec,0x1c,0xdc
000028  23e313d3          DCB      0x23,0xe3,0x13,0xd3
00002c  2fef1fdf          DCB      0x2f,0xef,0x1f,0xdf
000030  a0609050          DCB      0xa0,0x60,0x90,0x50
000034  ac6c9c5c          DCB      0xac,0x6c,0x9c,0x5c
000038  a3639353          DCB      0xa3,0x63,0x93,0x53
00003c  af6f9f5f          DCB      0xaf,0x6f,0x9f,0x5f
000040  08c838f8          DCB      0x08,0xc8,0x38,0xf8
000044  04c434f4          DCB      0x04,0xc4,0x34,0xf4
000048  0bcb3bfb          DCB      0x0b,0xcb,0x3b,0xfb
00004c  07c737f7          DCB      0x07,0xc7,0x37,0xf7
000050  8848b878          DCB      0x88,0x48,0xb8,0x78
000054  8444b474          DCB      0x84,0x44,0xb4,0x74
000058  8b4bbb7b          DCB      0x8b,0x4b,0xbb,0x7b
00005c  8747b777          DCB      0x87,0x47,0xb7,0x77
000060  28e818d8          DCB      0x28,0xe8,0x18,0xd8
000064  24e414d4          DCB      0x24,0xe4,0x14,0xd4
000068  2beb1bdb          DCB      0x2b,0xeb,0x1b,0xdb
00006c  27e717d7          DCB      0x27,0xe7,0x17,0xd7
000070  a8689858          DCB      0xa8,0x68,0x98,0x58
000074  a4649454          DCB      0xa4,0x64,0x94,0x54
000078  ab6b9b5b          DCB      0xab,0x6b,0x9b,0x5b
00007c  a7679757          DCB      0xa7,0x67,0x97,0x57
000080  02c232f2          DCB      0x02,0xc2,0x32,0xf2
000084  0ece3efe          DCB      0x0e,0xce,0x3e,0xfe
000088  01c131f1          DCB      0x01,0xc1,0x31,0xf1
00008c  0dcd3dfd          DCB      0x0d,0xcd,0x3d,0xfd
000090  8242b272          DCB      0x82,0x42,0xb2,0x72
000094  8e4ebe7e          DCB      0x8e,0x4e,0xbe,0x7e
000098  8141b171          DCB      0x81,0x41,0xb1,0x71
00009c  8d4dbd7d          DCB      0x8d,0x4d,0xbd,0x7d
0000a0  22e212d2          DCB      0x22,0xe2,0x12,0xd2
0000a4  2eee1ede          DCB      0x2e,0xee,0x1e,0xde
0000a8  21e111d1          DCB      0x21,0xe1,0x11,0xd1
0000ac  2ded1ddd          DCB      0x2d,0xed,0x1d,0xdd
0000b0  a2629252          DCB      0xa2,0x62,0x92,0x52
0000b4  ae6e9e5e          DCB      0xae,0x6e,0x9e,0x5e
0000b8  a1619151          DCB      0xa1,0x61,0x91,0x51
0000bc  ad6d9d5d          DCB      0xad,0x6d,0x9d,0x5d
0000c0  0aca3afa          DCB      0x0a,0xca,0x3a,0xfa
0000c4  06c636f6          DCB      0x06,0xc6,0x36,0xf6
0000c8  09c939f9          DCB      0x09,0xc9,0x39,0xf9
0000cc  05c535f5          DCB      0x05,0xc5,0x35,0xf5
0000d0  8a4aba7a          DCB      0x8a,0x4a,0xba,0x7a
0000d4  8646b676          DCB      0x86,0x46,0xb6,0x76
0000d8  8949b979          DCB      0x89,0x49,0xb9,0x79
0000dc  8545b575          DCB      0x85,0x45,0xb5,0x75
0000e0  2aea1ada          DCB      0x2a,0xea,0x1a,0xda
0000e4  26e616d6          DCB      0x26,0xe6,0x16,0xd6
0000e8  29e919d9          DCB      0x29,0xe9,0x19,0xd9
0000ec  25e515d5          DCB      0x25,0xe5,0x15,0xd5
0000f0  aa6a9a5a          DCB      0xaa,0x6a,0x9a,0x5a
0000f4  a6669656          DCB      0xa6,0x66,0x96,0x56
0000f8  a9699959          DCB      0xa9,0x69,0x99,0x59
0000fc  a5659555          DCB      0xa5,0x65,0x95,0x55
                  RGB_order
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000002
