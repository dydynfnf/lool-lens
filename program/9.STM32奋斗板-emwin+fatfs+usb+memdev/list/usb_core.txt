; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\usb_core.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\usb_core.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\MALLOC -I.\TFT -I.\EMWIN\EMWIN_INC -I.\EMWIN\DEMO -I.\PNG -I.\FATFS -I.\SDIO -I.\USB\inc -I.\USBCFG\inc -IE:\material\GUI\STM32·Ü¶·°å-emwin+fatfs+usb+memdev\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\usb_core.crf USB\src\usb_core.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Standard_GetConfiguration PROC
;;;60     *******************************************************************************/
;;;61     uint8_t *Standard_GetConfiguration(uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;62     {
000002  4604              MOV      r4,r0
;;;63       if (Length == 0)
000004  b92c              CBNZ     r4,|L1.18|
;;;64       {
;;;65         pInformation->Ctrl_Info.Usb_wLength =
000006  2001              MOVS     r0,#1
000008  49f6              LDR      r1,|L1.996|
00000a  6809              LDR      r1,[r1,#0]  ; pInformation
00000c  8208              STRH     r0,[r1,#0x10]
;;;66           sizeof(pInformation->Current_Configuration);
;;;67         return 0;
00000e  2000              MOVS     r0,#0
                  |L1.16|
;;;68       }
;;;69       pUser_Standard_Requests->User_GetConfiguration();
;;;70       return (uint8_t *)&pInformation->Current_Configuration;
;;;71     }
000010  bd10              POP      {r4,pc}
                  |L1.18|
000012  49f5              LDR      r1,|L1.1000|
000014  6809              LDR      r1,[r1,#0]            ;69  ; pUser_Standard_Requests
000016  6808              LDR      r0,[r1,#0]            ;69
000018  4780              BLX      r0                    ;69
00001a  48f2              LDR      r0,|L1.996|
00001c  6800              LDR      r0,[r0,#0]            ;70  ; pInformation
00001e  300a              ADDS     r0,r0,#0xa            ;70
000020  e7f6              B        |L1.16|
;;;72     
                          ENDP

                  Standard_SetConfiguration PROC
;;;81     *******************************************************************************/
;;;82     RESULT Standard_SetConfiguration(void)
000022  b510              PUSH     {r4,lr}
;;;83     {
;;;84     
;;;85       if ((pInformation->USBwValue0 <=
000024  48ef              LDR      r0,|L1.996|
000026  6800              LDR      r0,[r0,#0]  ; pInformation
000028  78c0              LDRB     r0,[r0,#3]
00002a  49f0              LDR      r1,|L1.1004|
00002c  7849              LDRB     r1,[r1,#1]  ; Device_Table
00002e  4288              CMP      r0,r1
000030  dc13              BGT      |L1.90|
;;;86           Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
000032  48ec              LDR      r0,|L1.996|
000034  6800              LDR      r0,[r0,#0]  ; pInformation
000036  7880              LDRB     r0,[r0,#2]
000038  b978              CBNZ     r0,|L1.90|
;;;87           && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
00003a  48ea              LDR      r0,|L1.996|
00003c  6800              LDR      r0,[r0,#0]  ; pInformation
00003e  8880              LDRH     r0,[r0,#4]
000040  b958              CBNZ     r0,|L1.90|
;;;88       {
;;;89         pInformation->Current_Configuration = pInformation->USBwValue0;
000042  48e8              LDR      r0,|L1.996|
000044  6800              LDR      r0,[r0,#0]  ; pInformation
000046  78c0              LDRB     r0,[r0,#3]
000048  49e6              LDR      r1,|L1.996|
00004a  6809              LDR      r1,[r1,#0]  ; pInformation
00004c  7288              STRB     r0,[r1,#0xa]
;;;90         pUser_Standard_Requests->User_SetConfiguration();
00004e  49e6              LDR      r1,|L1.1000|
000050  6809              LDR      r1,[r1,#0]  ; pUser_Standard_Requests
000052  6848              LDR      r0,[r1,#4]
000054  4780              BLX      r0
;;;91         return USB_SUCCESS;
000056  2000              MOVS     r0,#0
                  |L1.88|
;;;92       }
;;;93       else
;;;94       {
;;;95         return USB_UNSUPPORT;
;;;96       }
;;;97     }
000058  bd10              POP      {r4,pc}
                  |L1.90|
00005a  2002              MOVS     r0,#2                 ;95
00005c  e7fc              B        |L1.88|
;;;98     
                          ENDP

                  Standard_GetInterface PROC
;;;106    *******************************************************************************/
;;;107    uint8_t *Standard_GetInterface(uint16_t Length)
00005e  b510              PUSH     {r4,lr}
;;;108    {
000060  4604              MOV      r4,r0
;;;109      if (Length == 0)
000062  b92c              CBNZ     r4,|L1.112|
;;;110      {
;;;111        pInformation->Ctrl_Info.Usb_wLength =
000064  2001              MOVS     r0,#1
000066  49df              LDR      r1,|L1.996|
000068  6809              LDR      r1,[r1,#0]  ; pInformation
00006a  8208              STRH     r0,[r1,#0x10]
;;;112          sizeof(pInformation->Current_AlternateSetting);
;;;113        return 0;
00006c  2000              MOVS     r0,#0
                  |L1.110|
;;;114      }
;;;115      pUser_Standard_Requests->User_GetInterface();
;;;116      return (uint8_t *)&pInformation->Current_AlternateSetting;
;;;117    }
00006e  bd10              POP      {r4,pc}
                  |L1.112|
000070  49dd              LDR      r1,|L1.1000|
000072  6809              LDR      r1,[r1,#0]            ;115  ; pUser_Standard_Requests
000074  6888              LDR      r0,[r1,#8]            ;115
000076  4780              BLX      r0                    ;115
000078  48da              LDR      r0,|L1.996|
00007a  6800              LDR      r0,[r0,#0]            ;116  ; pInformation
00007c  300c              ADDS     r0,r0,#0xc            ;116
00007e  e7f6              B        |L1.110|
;;;118    
                          ENDP

                  Standard_SetInterface PROC
;;;127    *******************************************************************************/
;;;128    RESULT Standard_SetInterface(void)
000080  b510              PUSH     {r4,lr}
;;;129    {
;;;130      RESULT Re;
;;;131      /*Test if the specified Interface and Alternate Setting are supported by
;;;132        the application Firmware*/
;;;133      Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
000082  4bd8              LDR      r3,|L1.996|
000084  681b              LDR      r3,[r3,#0]  ; pInformation
000086  78d9              LDRB     r1,[r3,#3]
000088  4bd6              LDR      r3,|L1.996|
00008a  681b              LDR      r3,[r3,#0]  ; pInformation
00008c  7958              LDRB     r0,[r3,#5]
00008e  4bd8              LDR      r3,|L1.1008|
000090  681b              LDR      r3,[r3,#0]  ; pProperty
000092  699a              LDR      r2,[r3,#0x18]
000094  4790              BLX      r2
000096  4604              MOV      r4,r0
;;;134    
;;;135      if (pInformation->Current_Configuration != 0)
000098  48d2              LDR      r0,|L1.996|
00009a  6800              LDR      r0,[r0,#0]  ; pInformation
00009c  7a80              LDRB     r0,[r0,#0xa]
00009e  b1e8              CBZ      r0,|L1.220|
;;;136      {
;;;137        if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
0000a0  b93c              CBNZ     r4,|L1.178|
0000a2  48d0              LDR      r0,|L1.996|
0000a4  6800              LDR      r0,[r0,#0]  ; pInformation
0000a6  7900              LDRB     r0,[r0,#4]
0000a8  b918              CBNZ     r0,|L1.178|
;;;138            || (pInformation->USBwValue1 != 0))
0000aa  48ce              LDR      r0,|L1.996|
0000ac  6800              LDR      r0,[r0,#0]  ; pInformation
0000ae  7880              LDRB     r0,[r0,#2]
0000b0  b108              CBZ      r0,|L1.182|
                  |L1.178|
;;;139        {
;;;140          return  USB_UNSUPPORT;
0000b2  2002              MOVS     r0,#2
                  |L1.180|
;;;141        }
;;;142        else if (Re == USB_SUCCESS)
;;;143        {
;;;144          pUser_Standard_Requests->User_SetInterface();
;;;145          pInformation->Current_Interface = pInformation->USBwIndex0;
;;;146          pInformation->Current_AlternateSetting = pInformation->USBwValue0;
;;;147          return USB_SUCCESS;
;;;148        }
;;;149    
;;;150      }
;;;151    
;;;152      return USB_UNSUPPORT;
;;;153    }
0000b4  bd10              POP      {r4,pc}
                  |L1.182|
0000b6  b98c              CBNZ     r4,|L1.220|
0000b8  49cb              LDR      r1,|L1.1000|
0000ba  6809              LDR      r1,[r1,#0]            ;144  ; pUser_Standard_Requests
0000bc  68c8              LDR      r0,[r1,#0xc]          ;144
0000be  4780              BLX      r0                    ;144
0000c0  48c8              LDR      r0,|L1.996|
0000c2  6800              LDR      r0,[r0,#0]            ;145  ; pInformation
0000c4  7940              LDRB     r0,[r0,#5]            ;145
0000c6  49c7              LDR      r1,|L1.996|
0000c8  6809              LDR      r1,[r1,#0]            ;145  ; pInformation
0000ca  72c8              STRB     r0,[r1,#0xb]          ;145
0000cc  48c5              LDR      r0,|L1.996|
0000ce  6800              LDR      r0,[r0,#0]            ;146  ; pInformation
0000d0  78c0              LDRB     r0,[r0,#3]            ;146
0000d2  49c4              LDR      r1,|L1.996|
0000d4  6809              LDR      r1,[r1,#0]            ;146  ; pInformation
0000d6  7308              STRB     r0,[r1,#0xc]          ;146
0000d8  2000              MOVS     r0,#0                 ;147
0000da  e7eb              B        |L1.180|
                  |L1.220|
0000dc  2002              MOVS     r0,#2                 ;152
0000de  e7e9              B        |L1.180|
;;;154    
                          ENDP

                  Standard_GetStatus PROC
;;;162    *******************************************************************************/
;;;163    uint8_t *Standard_GetStatus(uint16_t Length)
0000e0  b510              PUSH     {r4,lr}
;;;164    {
0000e2  4604              MOV      r4,r0
;;;165      if (Length == 0)
0000e4  b92c              CBNZ     r4,|L1.242|
;;;166      {
;;;167        pInformation->Ctrl_Info.Usb_wLength = 2;
0000e6  2002              MOVS     r0,#2
0000e8  49be              LDR      r1,|L1.996|
0000ea  6809              LDR      r1,[r1,#0]  ; pInformation
0000ec  8208              STRH     r0,[r1,#0x10]
;;;168        return 0;
0000ee  2000              MOVS     r0,#0
                  |L1.240|
;;;169      }
;;;170    
;;;171      /* Reset Status Information */
;;;172      StatusInfo.w = 0;
;;;173    
;;;174      if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
;;;175      {
;;;176        /*Get Device Status */
;;;177        uint8_t Feature = pInformation->Current_Feature;
;;;178    
;;;179        /* Remote Wakeup enabled */
;;;180        if (ValBit(Feature, 5))
;;;181        {
;;;182          SetBit(StatusInfo0, 1);
;;;183        }
;;;184        else
;;;185        {
;;;186          ClrBit(StatusInfo0, 1);
;;;187        }      
;;;188    
;;;189        /* Bus-powered */
;;;190        if (ValBit(Feature, 6))
;;;191        {
;;;192          SetBit(StatusInfo0, 0);
;;;193        }
;;;194        else /* Self-powered */
;;;195        {
;;;196          ClrBit(StatusInfo0, 0);
;;;197        }
;;;198      }
;;;199      /*Interface Status*/
;;;200      else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
;;;201      {
;;;202        return (uint8_t *)&StatusInfo;
;;;203      }
;;;204      /*Get EndPoint Status*/
;;;205      else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
;;;206      {
;;;207        uint8_t Related_Endpoint;
;;;208        uint8_t wIndex0 = pInformation->USBwIndex0;
;;;209    
;;;210        Related_Endpoint = (wIndex0 & 0x0f);
;;;211        if (ValBit(wIndex0, 7))
;;;212        {
;;;213          /* IN endpoint */
;;;214          if (_GetTxStallStatus(Related_Endpoint))
;;;215          {
;;;216            SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
;;;217          }
;;;218        }
;;;219        else
;;;220        {
;;;221          /* OUT endpoint */
;;;222          if (_GetRxStallStatus(Related_Endpoint))
;;;223          {
;;;224            SetBit(StatusInfo0, 0); /* OUT Endpoint stalled */
;;;225          }
;;;226        }
;;;227    
;;;228      }
;;;229      else
;;;230      {
;;;231        return NULL;
;;;232      }
;;;233      pUser_Standard_Requests->User_GetStatus();
;;;234      return (uint8_t *)&StatusInfo;
;;;235    }
0000f0  bd10              POP      {r4,pc}
                  |L1.242|
0000f2  2000              MOVS     r0,#0                 ;172
0000f4  49bf              LDR      r1,|L1.1012|
0000f6  8008              STRH     r0,[r1,#0]            ;172
0000f8  48ba              LDR      r0,|L1.996|
0000fa  6800              LDR      r0,[r0,#0]            ;174  ; pInformation
0000fc  7800              LDRB     r0,[r0,#0]            ;174
0000fe  f000007f          AND      r0,r0,#0x7f           ;174
000102  bb18              CBNZ     r0,|L1.332|
000104  49b7              LDR      r1,|L1.996|
000106  6809              LDR      r1,[r1,#0]            ;177  ; pInformation
000108  7a48              LDRB     r0,[r1,#9]            ;177
00010a  f0000120          AND      r1,r0,#0x20           ;180
00010e  b131              CBZ      r1,|L1.286|
000110  49b8              LDR      r1,|L1.1012|
000112  7809              LDRB     r1,[r1,#0]            ;182  ; StatusInfo
000114  f0410102          ORR      r1,r1,#2              ;182
000118  4ab6              LDR      r2,|L1.1012|
00011a  7011              STRB     r1,[r2,#0]            ;182
00011c  e005              B        |L1.298|
                  |L1.286|
00011e  49b5              LDR      r1,|L1.1012|
000120  7809              LDRB     r1,[r1,#0]            ;186  ; StatusInfo
000122  f00101fd          AND      r1,r1,#0xfd           ;186
000126  4ab3              LDR      r2,|L1.1012|
000128  7011              STRB     r1,[r2,#0]            ;186
                  |L1.298|
00012a  f0000140          AND      r1,r0,#0x40           ;190
00012e  b131              CBZ      r1,|L1.318|
000130  49b0              LDR      r1,|L1.1012|
000132  7809              LDRB     r1,[r1,#0]            ;192  ; StatusInfo
000134  f0410101          ORR      r1,r1,#1              ;192
000138  4aae              LDR      r2,|L1.1012|
00013a  7011              STRB     r1,[r2,#0]            ;192
00013c  e005              B        |L1.330|
                  |L1.318|
00013e  49ad              LDR      r1,|L1.1012|
000140  7809              LDRB     r1,[r1,#0]            ;196  ; StatusInfo
000142  f00101fe          AND      r1,r1,#0xfe           ;196
000146  4aab              LDR      r2,|L1.1012|
000148  7011              STRB     r1,[r2,#0]            ;196
                  |L1.330|
00014a  e03a              B        |L1.450|
                  |L1.332|
00014c  48a5              LDR      r0,|L1.996|
00014e  6800              LDR      r0,[r0,#0]            ;200  ; pInformation
000150  7800              LDRB     r0,[r0,#0]            ;200
000152  f000007f          AND      r0,r0,#0x7f           ;200
000156  2801              CMP      r0,#1                 ;200
000158  d101              BNE      |L1.350|
00015a  48a6              LDR      r0,|L1.1012|
00015c  e7c8              B        |L1.240|
                  |L1.350|
00015e  48a1              LDR      r0,|L1.996|
000160  6800              LDR      r0,[r0,#0]            ;205  ; pInformation
000162  7800              LDRB     r0,[r0,#0]            ;205
000164  f000007f          AND      r0,r0,#0x7f           ;205
000168  2802              CMP      r0,#2                 ;205
00016a  d128              BNE      |L1.446|
00016c  4a9d              LDR      r2,|L1.996|
00016e  6812              LDR      r2,[r2,#0]            ;208  ; pInformation
000170  7951              LDRB     r1,[r2,#5]            ;208
000172  f001000f          AND      r0,r1,#0xf            ;210
000176  f0010280          AND      r2,r1,#0x80           ;211
00017a  b17a              CBZ      r2,|L1.412|
00017c  4b9e              LDR      r3,|L1.1016|
00017e  eb030280          ADD      r2,r3,r0,LSL #2       ;214
000182  f8d22c00          LDR      r2,[r2,#0xc00]        ;214
000186  f0020230          AND      r2,r2,#0x30           ;214
00018a  2a10              CMP      r2,#0x10              ;214
00018c  d116              BNE      |L1.444|
00018e  4a99              LDR      r2,|L1.1012|
000190  7812              LDRB     r2,[r2,#0]            ;216  ; StatusInfo
000192  f0420201          ORR      r2,r2,#1              ;216
000196  4b97              LDR      r3,|L1.1012|
000198  701a              STRB     r2,[r3,#0]            ;216
00019a  e00f              B        |L1.444|
                  |L1.412|
00019c  4b96              LDR      r3,|L1.1016|
00019e  eb030280          ADD      r2,r3,r0,LSL #2       ;222
0001a2  f8d22c00          LDR      r2,[r2,#0xc00]        ;222
0001a6  f4025240          AND      r2,r2,#0x3000         ;222
0001aa  f5b25f80          CMP      r2,#0x1000            ;222
0001ae  d105              BNE      |L1.444|
0001b0  4a90              LDR      r2,|L1.1012|
0001b2  7812              LDRB     r2,[r2,#0]            ;224  ; StatusInfo
0001b4  f0420201          ORR      r2,r2,#1              ;224
0001b8  4b8e              LDR      r3,|L1.1012|
0001ba  701a              STRB     r2,[r3,#0]            ;224
                  |L1.444|
0001bc  e001              B        |L1.450|
                  |L1.446|
0001be  2000              MOVS     r0,#0                 ;231
0001c0  e796              B        |L1.240|
                  |L1.450|
0001c2  4989              LDR      r1,|L1.1000|
0001c4  6809              LDR      r1,[r1,#0]            ;233  ; pUser_Standard_Requests
0001c6  6908              LDR      r0,[r1,#0x10]         ;233
0001c8  4780              BLX      r0                    ;233
0001ca  488a              LDR      r0,|L1.1012|
0001cc  e790              B        |L1.240|
;;;236    
                          ENDP

                  Standard_ClearFeature PROC
;;;244    *******************************************************************************/
;;;245    RESULT Standard_ClearFeature(void)
0001ce  e92d47f0          PUSH     {r4-r10,lr}
;;;246    {
;;;247      uint32_t     Type_Rec = Type_Recipient;
0001d2  4884              LDR      r0,|L1.996|
0001d4  6800              LDR      r0,[r0,#0]  ; pInformation
0001d6  7800              LDRB     r0,[r0,#0]
0001d8  f000087f          AND      r8,r0,#0x7f
;;;248      uint32_t     Status;
;;;249    
;;;250    
;;;251      if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
0001dc  f1b80f00          CMP      r8,#0
0001e0  d10a              BNE      |L1.504|
;;;252      {/*Device Clear Feature*/
;;;253        ClrBit(pInformation->Current_Feature, 5);
0001e2  4880              LDR      r0,|L1.996|
0001e4  6800              LDR      r0,[r0,#0]  ; pInformation
0001e6  7a40              LDRB     r0,[r0,#9]
0001e8  f00000df          AND      r0,r0,#0xdf
0001ec  497d              LDR      r1,|L1.996|
0001ee  6809              LDR      r1,[r1,#0]  ; pInformation
0001f0  7248              STRB     r0,[r1,#9]
;;;254        return USB_SUCCESS;
0001f2  2000              MOVS     r0,#0
                  |L1.500|
;;;255      }
;;;256      else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
;;;257      {/*EndPoint Clear Feature*/
;;;258        DEVICE* pDev;
;;;259        uint32_t Related_Endpoint;
;;;260        uint32_t wIndex0;
;;;261        uint32_t rEP;
;;;262    
;;;263        if ((pInformation->USBwValue != ENDPOINT_STALL)
;;;264            || (pInformation->USBwIndex1 != 0))
;;;265        {
;;;266          return USB_UNSUPPORT;
;;;267        }
;;;268    
;;;269        pDev = &Device_Table;
;;;270        wIndex0 = pInformation->USBwIndex0;
;;;271        rEP = wIndex0 & ~0x80;
;;;272        Related_Endpoint = ENDP0 + rEP;
;;;273    
;;;274        if (ValBit(pInformation->USBwIndex0, 7))
;;;275        {
;;;276          /*Get Status of endpoint & stall the request if the related_ENdpoint
;;;277          is Disabled*/
;;;278          Status = _GetEPTxStatus(Related_Endpoint);
;;;279        }
;;;280        else
;;;281        {
;;;282          Status = _GetEPRxStatus(Related_Endpoint);
;;;283        }
;;;284    
;;;285        if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
;;;286            || (pInformation->Current_Configuration == 0))
;;;287        {
;;;288          return USB_UNSUPPORT;
;;;289        }
;;;290    
;;;291    
;;;292        if (wIndex0 & 0x80)
;;;293        {
;;;294          /* IN endpoint */
;;;295          if (_GetTxStallStatus(Related_Endpoint ))
;;;296          {
;;;297          #ifndef STM32F10X_CL
;;;298            ClearDTOG_TX(Related_Endpoint);
;;;299          #endif /* STM32F10X_CL */
;;;300            SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
;;;301          }
;;;302        }
;;;303        else
;;;304        {
;;;305          /* OUT endpoint */
;;;306          if (_GetRxStallStatus(Related_Endpoint))
;;;307          {
;;;308            if (Related_Endpoint == ENDP0)
;;;309            {
;;;310              /* After clear the STALL, enable the default endpoint receiver */
;;;311              SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
;;;312              _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
;;;313            }
;;;314            else
;;;315            {
;;;316            #ifndef STM32F10X_CL
;;;317              ClearDTOG_RX(Related_Endpoint);
;;;318            #endif /* STM32F10X_CL */
;;;319              _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
;;;320            }
;;;321          }
;;;322        }
;;;323        pUser_Standard_Requests->User_ClearFeature();
;;;324        return USB_SUCCESS;
;;;325      }
;;;326    
;;;327      return USB_UNSUPPORT;
;;;328    }
0001f4  e8bd87f0          POP      {r4-r10,pc}
                  |L1.504|
0001f8  f1b80f02          CMP      r8,#2                 ;256
0001fc  d17e              BNE      |L1.764|
0001fe  4879              LDR      r0,|L1.996|
000200  6800              LDR      r0,[r0,#0]            ;263  ; pInformation
000202  8840              LDRH     r0,[r0,#2]            ;263
000204  b918              CBNZ     r0,|L1.526|
000206  4877              LDR      r0,|L1.996|
000208  6800              LDR      r0,[r0,#0]            ;264  ; pInformation
00020a  7900              LDRB     r0,[r0,#4]            ;264
00020c  b108              CBZ      r0,|L1.530|
                  |L1.526|
00020e  2002              MOVS     r0,#2                 ;266
000210  e7f0              B        |L1.500|
                  |L1.530|
000212  f8df91d8          LDR      r9,|L1.1004|
000216  4873              LDR      r0,|L1.996|
000218  6800              LDR      r0,[r0,#0]            ;270  ; pInformation
00021a  7947              LDRB     r7,[r0,#5]            ;270
00021c  f0270580          BIC      r5,r7,#0x80           ;271
000220  462c              MOV      r4,r5                 ;272
000222  4870              LDR      r0,|L1.996|
000224  6800              LDR      r0,[r0,#0]            ;274  ; pInformation
000226  7940              LDRB     r0,[r0,#5]            ;274
000228  f0000080          AND      r0,r0,#0x80           ;274
00022c  b138              CBZ      r0,|L1.574|
00022e  4972              LDR      r1,|L1.1016|
000230  eb010084          ADD      r0,r1,r4,LSL #2       ;278
000234  f8d00c00          LDR      r0,[r0,#0xc00]        ;278
000238  f0000630          AND      r6,r0,#0x30           ;278
00023c  e006              B        |L1.588|
                  |L1.574|
00023e  496e              LDR      r1,|L1.1016|
000240  eb010084          ADD      r0,r1,r4,LSL #2       ;282
000244  f8d00c00          LDR      r0,[r0,#0xc00]        ;282
000248  f4005640          AND      r6,r0,#0x3000         ;282
                  |L1.588|
00024c  f8990000          LDRB     r0,[r9,#0]            ;285
000250  42a8              CMP      r0,r5                 ;285
000252  d904              BLS      |L1.606|
000254  b11e              CBZ      r6,|L1.606|
000256  4863              LDR      r0,|L1.996|
000258  6800              LDR      r0,[r0,#0]            ;286  ; pInformation
00025a  7a80              LDRB     r0,[r0,#0xa]          ;286
00025c  b908              CBNZ     r0,|L1.610|
                  |L1.606|
00025e  2002              MOVS     r0,#2                 ;288
000260  e7c8              B        |L1.500|
                  |L1.610|
000262  f0070080          AND      r0,r7,#0x80           ;292
000266  b180              CBZ      r0,|L1.650|
000268  4963              LDR      r1,|L1.1016|
00026a  eb010084          ADD      r0,r1,r4,LSL #2       ;295
00026e  f8d00c00          LDR      r0,[r0,#0xc00]        ;295
000272  f0000030          AND      r0,r0,#0x30           ;295
000276  2810              CMP      r0,#0x10              ;295
000278  d14b              BNE      |L1.786|
00027a  b2e0              UXTB     r0,r4                 ;298
00027c  f7fffffe          BL       ClearDTOG_TX
000280  b2e0              UXTB     r0,r4                 ;300
000282  2130              MOVS     r1,#0x30              ;300
000284  f7fffffe          BL       SetEPTxStatus
000288  e043              B        |L1.786|
                  |L1.650|
00028a  495b              LDR      r1,|L1.1016|
00028c  eb010084          ADD      r0,r1,r4,LSL #2       ;306
000290  f8d00c00          LDR      r0,[r0,#0xc00]        ;306
000294  f4005040          AND      r0,r0,#0x3000         ;306
000298  f5b05f80          CMP      r0,#0x1000            ;306
00029c  d139              BNE      |L1.786|
00029e  b9e4              CBNZ     r4,|L1.730|
0002a0  4a56              LDR      r2,|L1.1020|
0002a2  f892102c          LDRB     r1,[r2,#0x2c]         ;311  ; Device_Property
0002a6  b2e0              UXTB     r0,r4                 ;311
0002a8  f7fffffe          BL       SetEPRxCount
0002ac  4a52              LDR      r2,|L1.1016|
0002ae  eb020184          ADD      r1,r2,r4,LSL #2       ;312
0002b2  f8d11c00          LDR      r1,[r1,#0xc00]        ;312
0002b6  f64b728f          MOV      r2,#0xbf8f            ;312
0002ba  ea010002          AND      r0,r1,r2              ;312
0002be  f4805080          EOR      r0,r0,#0x1000         ;312
0002c2  f4805000          EOR      r0,r0,#0x2000         ;312
0002c6  f4404100          ORR      r1,r0,#0x8000         ;312
0002ca  f0410180          ORR      r1,r1,#0x80           ;312
0002ce  4b4a              LDR      r3,|L1.1016|
0002d0  eb030284          ADD      r2,r3,r4,LSL #2       ;312
0002d4  f8c21c00          STR      r1,[r2,#0xc00]        ;312
0002d8  e01b              B        |L1.786|
                  |L1.730|
0002da  b2e0              UXTB     r0,r4                 ;317
0002dc  f7fffffe          BL       ClearDTOG_RX
0002e0  4a45              LDR      r2,|L1.1016|
0002e2  eb020184          ADD      r1,r2,r4,LSL #2       ;319
0002e6  f8d11c00          LDR      r1,[r1,#0xc00]        ;319
0002ea  f64b728f          MOV      r2,#0xbf8f            ;319
0002ee  ea010002          AND      r0,r1,r2              ;319
0002f2  f4805080          EOR      r0,r0,#0x1000         ;319
0002f6  f4805000          EOR      r0,r0,#0x2000         ;319
0002fa  e000              B        |L1.766|
                  |L1.764|
0002fc  e00f              B        |L1.798|
                  |L1.766|
0002fe  f4404100          ORR      r1,r0,#0x8000         ;319
000302  f0410180          ORR      r1,r1,#0x80           ;319
000306  4b3c              LDR      r3,|L1.1016|
000308  eb030284          ADD      r2,r3,r4,LSL #2       ;319
00030c  f8c21c00          STR      r1,[r2,#0xc00]        ;319
000310  bf00              NOP                            ;319
                  |L1.786|
000312  4935              LDR      r1,|L1.1000|
000314  6809              LDR      r1,[r1,#0]            ;323  ; pUser_Standard_Requests
000316  6948              LDR      r0,[r1,#0x14]         ;323
000318  4780              BLX      r0                    ;323
00031a  2000              MOVS     r0,#0                 ;324
00031c  e76a              B        |L1.500|
                  |L1.798|
00031e  bf00              NOP                            ;325
000320  2002              MOVS     r0,#2                 ;327
000322  e767              B        |L1.500|
;;;329    
                          ENDP

                  Standard_SetEndPointFeature PROC
;;;337    *******************************************************************************/
;;;338    RESULT Standard_SetEndPointFeature(void)
000324  e92d41f0          PUSH     {r4-r8,lr}
;;;339    {
;;;340      uint32_t    wIndex0;
;;;341      uint32_t    Related_Endpoint;
;;;342      uint32_t    rEP;
;;;343      uint32_t    Status;
;;;344    
;;;345      wIndex0 = pInformation->USBwIndex0;
000328  482e              LDR      r0,|L1.996|
00032a  6800              LDR      r0,[r0,#0]  ; pInformation
00032c  7946              LDRB     r6,[r0,#5]
;;;346      rEP = wIndex0 & ~0x80;
00032e  f0260780          BIC      r7,r6,#0x80
;;;347      Related_Endpoint = ENDP0 + rEP;
000332  463c              MOV      r4,r7
;;;348    
;;;349      if (ValBit(pInformation->USBwIndex0, 7))
000334  482b              LDR      r0,|L1.996|
000336  6800              LDR      r0,[r0,#0]  ; pInformation
000338  7940              LDRB     r0,[r0,#5]
00033a  f0000080          AND      r0,r0,#0x80
00033e  b138              CBZ      r0,|L1.848|
;;;350      {
;;;351        /* get Status of endpoint & stall the request if the related_ENdpoint
;;;352        is Disabled*/
;;;353        Status = _GetEPTxStatus(Related_Endpoint);
000340  492d              LDR      r1,|L1.1016|
000342  eb010084          ADD      r0,r1,r4,LSL #2
000346  f8d00c00          LDR      r0,[r0,#0xc00]
00034a  f0000530          AND      r5,r0,#0x30
00034e  e006              B        |L1.862|
                  |L1.848|
;;;354      }
;;;355      else
;;;356      {
;;;357        Status = _GetEPRxStatus(Related_Endpoint);
000350  4929              LDR      r1,|L1.1016|
000352  eb010084          ADD      r0,r1,r4,LSL #2
000356  f8d00c00          LDR      r0,[r0,#0xc00]
00035a  f4005540          AND      r5,r0,#0x3000
                  |L1.862|
;;;358      }
;;;359    
;;;360      if (Related_Endpoint >= Device_Table.Total_Endpoint
00035e  4823              LDR      r0,|L1.1004|
000360  7800              LDRB     r0,[r0,#0]  ; Device_Table
000362  42a0              CMP      r0,r4
000364  d908              BLS      |L1.888|
;;;361          || pInformation->USBwValue != 0 || Status == 0
000366  481f              LDR      r0,|L1.996|
000368  6800              LDR      r0,[r0,#0]  ; pInformation
00036a  8840              LDRH     r0,[r0,#2]
00036c  b920              CBNZ     r0,|L1.888|
00036e  b11d              CBZ      r5,|L1.888|
;;;362          || pInformation->Current_Configuration == 0)
000370  481c              LDR      r0,|L1.996|
000372  6800              LDR      r0,[r0,#0]  ; pInformation
000374  7a80              LDRB     r0,[r0,#0xa]
000376  b910              CBNZ     r0,|L1.894|
                  |L1.888|
;;;363      {
;;;364        return USB_UNSUPPORT;
000378  2002              MOVS     r0,#2
                  |L1.890|
;;;365      }
;;;366      else
;;;367      {
;;;368        if (wIndex0 & 0x80)
;;;369        {
;;;370          /* IN endpoint */
;;;371          _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
;;;372        }
;;;373    
;;;374        else
;;;375        {
;;;376          /* OUT endpoint */
;;;377          _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
;;;378        }
;;;379      }
;;;380      pUser_Standard_Requests->User_SetEndPointFeature();
;;;381      return USB_SUCCESS;
;;;382    }
00037a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.894|
00037e  f0060080          AND      r0,r6,#0x80           ;368
000382  b1a0              CBZ      r0,|L1.942|
000384  4a1c              LDR      r2,|L1.1016|
000386  eb020184          ADD      r1,r2,r4,LSL #2       ;371
00038a  f8d11c00          LDR      r1,[r1,#0xc00]        ;371
00038e  f64872bf          MOV      r2,#0x8fbf            ;371
000392  ea010002          AND      r0,r1,r2              ;371
000396  f0800010          EOR      r0,r0,#0x10           ;371
00039a  f4404100          ORR      r1,r0,#0x8000         ;371
00039e  f0410180          ORR      r1,r1,#0x80           ;371
0003a2  4b15              LDR      r3,|L1.1016|
0003a4  eb030284          ADD      r2,r3,r4,LSL #2       ;371
0003a8  f8c21c00          STR      r1,[r2,#0xc00]        ;371
0003ac  e014              B        |L1.984|
                  |L1.942|
0003ae  4a12              LDR      r2,|L1.1016|
0003b0  eb020184          ADD      r1,r2,r4,LSL #2       ;377
0003b4  f8d11c00          LDR      r1,[r1,#0xc00]        ;377
0003b8  f64b728f          MOV      r2,#0xbf8f            ;377
0003bc  ea010002          AND      r0,r1,r2              ;377
0003c0  f4805080          EOR      r0,r0,#0x1000         ;377
0003c4  f4404100          ORR      r1,r0,#0x8000         ;377
0003c8  f0410180          ORR      r1,r1,#0x80           ;377
0003cc  4b0a              LDR      r3,|L1.1016|
0003ce  eb030284          ADD      r2,r3,r4,LSL #2       ;377
0003d2  f8c21c00          STR      r1,[r2,#0xc00]        ;377
0003d6  bf00              NOP                            ;377
                  |L1.984|
0003d8  4903              LDR      r1,|L1.1000|
0003da  6809              LDR      r1,[r1,#0]            ;380  ; pUser_Standard_Requests
0003dc  6988              LDR      r0,[r1,#0x18]         ;380
0003de  4780              BLX      r0                    ;380
0003e0  2000              MOVS     r0,#0                 ;381
0003e2  e7ca              B        |L1.890|
                  |L1.996|
                          DCD      pInformation
                  |L1.1000|
                          DCD      pUser_Standard_Requests
                  |L1.1004|
                          DCD      Device_Table
                  |L1.1008|
                          DCD      pProperty
                  |L1.1012|
                          DCD      StatusInfo
                  |L1.1016|
                          DCD      0x40005000
                  |L1.1020|
                          DCD      Device_Property
                          ENDP

                  Standard_SetDeviceFeature PROC
;;;391    *******************************************************************************/
;;;392    RESULT Standard_SetDeviceFeature(void)
000400  b510              PUSH     {r4,lr}
;;;393    {
;;;394      SetBit(pInformation->Current_Feature, 5);
000402  48f7              LDR      r0,|L1.2016|
000404  6800              LDR      r0,[r0,#0]  ; pInformation
000406  7a40              LDRB     r0,[r0,#9]
000408  f0400020          ORR      r0,r0,#0x20
00040c  49f4              LDR      r1,|L1.2016|
00040e  6809              LDR      r1,[r1,#0]  ; pInformation
000410  7248              STRB     r0,[r1,#9]
;;;395      pUser_Standard_Requests->User_SetDeviceFeature();
000412  49f4              LDR      r1,|L1.2020|
000414  6809              LDR      r1,[r1,#0]  ; pUser_Standard_Requests
000416  69c8              LDR      r0,[r1,#0x1c]
000418  4780              BLX      r0
;;;396      return USB_SUCCESS;
00041a  2000              MOVS     r0,#0
;;;397    }
00041c  bd10              POP      {r4,pc}
;;;398    
                          ENDP

                  Standard_GetDescriptorData PROC
;;;417    *******************************************************************************/
;;;418    uint8_t *Standard_GetDescriptorData(uint16_t Length, ONE_DESCRIPTOR *pDesc)
00041e  b510              PUSH     {r4,lr}
;;;419    {
000420  4602              MOV      r2,r0
;;;420      uint32_t  wOffset;
;;;421    
;;;422      wOffset = pInformation->Ctrl_Info.Usb_wOffset;
000422  48ef              LDR      r0,|L1.2016|
000424  6800              LDR      r0,[r0,#0]  ; pInformation
000426  8a43              LDRH     r3,[r0,#0x12]
;;;423      if (Length == 0)
000428  b932              CBNZ     r2,|L1.1080|
;;;424      {
;;;425        pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
00042a  8888              LDRH     r0,[r1,#4]
00042c  1ac0              SUBS     r0,r0,r3
00042e  4cec              LDR      r4,|L1.2016|
000430  6824              LDR      r4,[r4,#0]  ; pInformation
000432  8220              STRH     r0,[r4,#0x10]
;;;426        return 0;
000434  2000              MOVS     r0,#0
                  |L1.1078|
;;;427      }
;;;428    
;;;429      return pDesc->Descriptor + wOffset;
;;;430    }
000436  bd10              POP      {r4,pc}
                  |L1.1080|
000438  6808              LDR      r0,[r1,#0]            ;429
00043a  4418              ADD      r0,r0,r3              ;429
00043c  e7fb              B        |L1.1078|
;;;431    
                          ENDP

                  DataStageOut PROC
;;;438    *******************************************************************************/
;;;439    void DataStageOut(void)
00043e  e92d41f0          PUSH     {r4-r8,lr}
;;;440    {
;;;441      ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
000442  48e7              LDR      r0,|L1.2016|
000444  6800              LDR      r0,[r0,#0]  ; pInformation
000446  f1000410          ADD      r4,r0,#0x10
;;;442      uint32_t save_rLength;
;;;443    
;;;444      save_rLength = pEPinfo->Usb_rLength;
00044a  8826              LDRH     r6,[r4,#0]
;;;445    
;;;446      if (pEPinfo->CopyData && save_rLength)
00044c  68a0              LDR      r0,[r4,#8]
00044e  b1c0              CBZ      r0,|L1.1154|
000450  b1be              CBZ      r6,|L1.1154|
;;;447      {
;;;448        uint8_t *Buffer;
;;;449        uint32_t Length;
;;;450    
;;;451        Length = pEPinfo->PacketSize;
000452  88a5              LDRH     r5,[r4,#4]
;;;452        if (Length > save_rLength)
000454  42b5              CMP      r5,r6
000456  d900              BLS      |L1.1114|
;;;453        {
;;;454          Length = save_rLength;
000458  4635              MOV      r5,r6
                  |L1.1114|
;;;455        }
;;;456    
;;;457        Buffer = (*pEPinfo->CopyData)(Length);
00045a  b2a8              UXTH     r0,r5
00045c  68a1              LDR      r1,[r4,#8]
00045e  4788              BLX      r1
000460  4607              MOV      r7,r0
;;;458        pEPinfo->Usb_rLength -= Length;
000462  8820              LDRH     r0,[r4,#0]
000464  1b40              SUBS     r0,r0,r5
000466  8020              STRH     r0,[r4,#0]
;;;459        pEPinfo->Usb_rOffset += Length;
000468  8860              LDRH     r0,[r4,#2]
00046a  4428              ADD      r0,r0,r5
00046c  8060              STRH     r0,[r4,#2]
;;;460    
;;;461      #ifdef STM32F10X_CL  
;;;462        PCD_EP_Read(ENDP0, Buffer, Length); 
;;;463      #else  
;;;464        PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
00046e  2000              MOVS     r0,#0
000470  f7fffffe          BL       GetEPRxAddr
000474  4680              MOV      r8,r0
000476  b2aa              UXTH     r2,r5
000478  4641              MOV      r1,r8
00047a  4638              MOV      r0,r7
00047c  f7fffffe          BL       PMAToUserBufferCopy
;;;465      #endif  /* STM32F10X_CL */
;;;466      }
000480  bf00              NOP      
                  |L1.1154|
;;;467    
;;;468      if (pEPinfo->Usb_rLength != 0)
000482  8820              LDRH     r0,[r4,#0]
000484  b150              CBZ      r0,|L1.1180|
;;;469      {
;;;470        vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
000486  f44f5040          MOV      r0,#0x3000
00048a  49d7              LDR      r1,|L1.2024|
00048c  8008              STRH     r0,[r1,#0]
;;;471        SetEPTxCount(ENDP0, 0);
00048e  2100              MOVS     r1,#0
000490  4608              MOV      r0,r1
000492  f7fffffe          BL       SetEPTxCount
;;;472        vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
000496  2030              MOVS     r0,#0x30
000498  49d4              LDR      r1,|L1.2028|
00049a  8008              STRH     r0,[r1,#0]
                  |L1.1180|
;;;473      }
;;;474      /* Set the next State*/
;;;475      if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
00049c  8820              LDRH     r0,[r4,#0]
00049e  88a1              LDRH     r1,[r4,#4]
0004a0  4288              CMP      r0,r1
0004a2  db04              BLT      |L1.1198|
;;;476      {
;;;477        pInformation->ControlState = OUT_DATA;
0004a4  2003              MOVS     r0,#3
0004a6  49ce              LDR      r1,|L1.2016|
0004a8  6809              LDR      r1,[r1,#0]  ; pInformation
0004aa  7208              STRB     r0,[r1,#8]
0004ac  e018              B        |L1.1248|
                  |L1.1198|
;;;478      }
;;;479      else
;;;480      {
;;;481        if (pEPinfo->Usb_rLength > 0)
0004ae  8820              LDRH     r0,[r4,#0]
0004b0  2800              CMP      r0,#0
0004b2  dd04              BLE      |L1.1214|
;;;482        {
;;;483          pInformation->ControlState = LAST_OUT_DATA;
0004b4  2005              MOVS     r0,#5
0004b6  49ca              LDR      r1,|L1.2016|
0004b8  6809              LDR      r1,[r1,#0]  ; pInformation
0004ba  7208              STRB     r0,[r1,#8]
0004bc  e010              B        |L1.1248|
                  |L1.1214|
;;;484        }
;;;485        else if (pEPinfo->Usb_rLength == 0)
0004be  8820              LDRH     r0,[r4,#0]
0004c0  b970              CBNZ     r0,|L1.1248|
;;;486        {
;;;487          pInformation->ControlState = WAIT_STATUS_IN;
0004c2  2006              MOVS     r0,#6
0004c4  49c6              LDR      r1,|L1.2016|
0004c6  6809              LDR      r1,[r1,#0]  ; pInformation
0004c8  7208              STRB     r0,[r1,#8]
;;;488          USB_StatusIn();
0004ca  2100              MOVS     r1,#0
0004cc  48c8              LDR      r0,|L1.2032|
0004ce  6800              LDR      r0,[r0,#0]
0004d0  b280              UXTH     r0,r0
0004d2  1c80              ADDS     r0,r0,#2
0004d4  4ac7              LDR      r2,|L1.2036|
0004d6  f8421010          STR      r1,[r2,r0,LSL #1]
0004da  2030              MOVS     r0,#0x30
0004dc  49c3              LDR      r1,|L1.2028|
0004de  8008              STRH     r0,[r1,#0]
                  |L1.1248|
;;;489        }
;;;490      }
;;;491    }
0004e0  e8bd81f0          POP      {r4-r8,pc}
;;;492    
                          ENDP

                  DataStageIn PROC
;;;499    *******************************************************************************/
;;;500    void DataStageIn(void)
0004e4  e92d47f0          PUSH     {r4-r10,lr}
;;;501    {
;;;502      ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
0004e8  48bd              LDR      r0,|L1.2016|
0004ea  6800              LDR      r0,[r0,#0]  ; pInformation
0004ec  f1000510          ADD      r5,r0,#0x10
;;;503      uint32_t save_wLength = pEPinfo->Usb_wLength;
0004f0  882e              LDRH     r6,[r5,#0]
;;;504      uint32_t ControlState = pInformation->ControlState;
0004f2  48bb              LDR      r0,|L1.2016|
0004f4  6800              LDR      r0,[r0,#0]  ; pInformation
0004f6  7a07              LDRB     r7,[r0,#8]
;;;505    
;;;506      uint8_t *DataBuffer;
;;;507      uint32_t Length;
;;;508    
;;;509      if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
0004f8  b9d6              CBNZ     r6,|L1.1328|
0004fa  2f04              CMP      r7,#4
0004fc  d118              BNE      |L1.1328|
;;;510      {
;;;511        if(Data_Mul_MaxPacketSize == TRUE)
0004fe  48be              LDR      r0,|L1.2040|
000500  7800              LDRB     r0,[r0,#0]  ; Data_Mul_MaxPacketSize
000502  2801              CMP      r0,#1
000504  d10f              BNE      |L1.1318|
;;;512        {
;;;513          /* No more data to send and empty packet */
;;;514          Send0LengthData();
000506  2100              MOVS     r1,#0
000508  48b9              LDR      r0,|L1.2032|
00050a  6800              LDR      r0,[r0,#0]
00050c  b280              UXTH     r0,r0
00050e  1c80              ADDS     r0,r0,#2
000510  4ab8              LDR      r2,|L1.2036|
000512  f8421010          STR      r1,[r2,r0,LSL #1]
000516  2030              MOVS     r0,#0x30
000518  49b4              LDR      r1,|L1.2028|
00051a  8008              STRH     r0,[r1,#0]
;;;515          ControlState = LAST_IN_DATA;
00051c  bf00              NOP      
;;;516          Data_Mul_MaxPacketSize = FALSE;
00051e  2000              MOVS     r0,#0
000520  49b5              LDR      r1,|L1.2040|
000522  7008              STRB     r0,[r1,#0]
000524  e003              B        |L1.1326|
                  |L1.1318|
;;;517        }
;;;518        else 
;;;519        {
;;;520          /* No more data to send so STALL the TX Status*/
;;;521          ControlState = WAIT_STATUS_OUT;
000526  2707              MOVS     r7,#7
;;;522    
;;;523        #ifdef STM32F10X_CL      
;;;524          PCD_EP_Read (ENDP0, 0, 0);
;;;525        #endif  /* STM32F10X_CL */ 
;;;526        
;;;527        #ifndef STM32F10X_CL 
;;;528          vSetEPTxStatus(EP_TX_STALL);
000528  2010              MOVS     r0,#0x10
00052a  49b0              LDR      r1,|L1.2028|
00052c  8008              STRH     r0,[r1,#0]
                  |L1.1326|
;;;529        #endif  /* STM32F10X_CL */ 
;;;530        }
;;;531        
;;;532        goto Expect_Status_Out;
00052e  e027              B        |L1.1408|
                  |L1.1328|
;;;533      }
;;;534    
;;;535      Length = pEPinfo->PacketSize;
000530  88ac              LDRH     r4,[r5,#4]
;;;536      ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
000532  42a6              CMP      r6,r4
000534  d801              BHI      |L1.1338|
000536  2004              MOVS     r0,#4
000538  e000              B        |L1.1340|
                  |L1.1338|
00053a  2002              MOVS     r0,#2
                  |L1.1340|
00053c  4607              MOV      r7,r0
;;;537    
;;;538      if (Length > save_wLength)
00053e  42b4              CMP      r4,r6
000540  d900              BLS      |L1.1348|
;;;539      {
;;;540        Length = save_wLength;
000542  4634              MOV      r4,r6
                  |L1.1348|
;;;541      }
;;;542    
;;;543      DataBuffer = (*pEPinfo->CopyData)(Length);
000544  b2a0              UXTH     r0,r4
000546  68a9              LDR      r1,[r5,#8]
000548  4788              BLX      r1
00054a  4680              MOV      r8,r0
;;;544    
;;;545    #ifdef STM32F10X_CL
;;;546      PCD_EP_Write (ENDP0, DataBuffer, Length);
;;;547    #else   
;;;548      UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
00054c  2000              MOVS     r0,#0
00054e  f7fffffe          BL       GetEPTxAddr
000552  4681              MOV      r9,r0
000554  b2a2              UXTH     r2,r4
000556  4649              MOV      r1,r9
000558  4640              MOV      r0,r8
00055a  f7fffffe          BL       UserToPMABufferCopy
;;;549    #endif /* STM32F10X_CL */ 
;;;550    
;;;551      SetEPTxCount(ENDP0, Length);
00055e  b2a1              UXTH     r1,r4
000560  2000              MOVS     r0,#0
000562  f7fffffe          BL       SetEPTxCount
;;;552    
;;;553      pEPinfo->Usb_wLength -= Length;
000566  8828              LDRH     r0,[r5,#0]
000568  1b00              SUBS     r0,r0,r4
00056a  8028              STRH     r0,[r5,#0]
;;;554      pEPinfo->Usb_wOffset += Length;
00056c  8868              LDRH     r0,[r5,#2]
00056e  4420              ADD      r0,r0,r4
000570  8068              STRH     r0,[r5,#2]
;;;555      vSetEPTxStatus(EP_TX_VALID);
000572  2030              MOVS     r0,#0x30
000574  499d              LDR      r1,|L1.2028|
000576  8008              STRH     r0,[r1,#0]
;;;556    
;;;557      USB_StatusOut();/* Expect the host to abort the data IN stage */
000578  0200              LSLS     r0,r0,#8
00057a  499b              LDR      r1,|L1.2024|
00057c  8008              STRH     r0,[r1,#0]
;;;558    
;;;559    Expect_Status_Out:
00057e  bf00              NOP      
                  |L1.1408|
;;;560      pInformation->ControlState = ControlState;
000580  4997              LDR      r1,|L1.2016|
000582  6809              LDR      r1,[r1,#0]  ; pInformation
000584  720f              STRB     r7,[r1,#8]
;;;561    }
000586  e8bd87f0          POP      {r4-r10,pc}
;;;562    
                          ENDP

                  NoData_Setup0 PROC
;;;569    *******************************************************************************/
;;;570    void NoData_Setup0(void)
00058a  b570              PUSH     {r4-r6,lr}
;;;571    {
;;;572      RESULT Result = USB_UNSUPPORT;
00058c  2602              MOVS     r6,#2
;;;573      uint32_t RequestNo = pInformation->USBbRequest;
00058e  4894              LDR      r0,|L1.2016|
000590  6800              LDR      r0,[r0,#0]  ; pInformation
000592  7844              LDRB     r4,[r0,#1]
;;;574      uint32_t ControlState;
;;;575    
;;;576      if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
000594  4892              LDR      r0,|L1.2016|
000596  6800              LDR      r0,[r0,#0]  ; pInformation
000598  7800              LDRB     r0,[r0,#0]
00059a  f000007f          AND      r0,r0,#0x7f
00059e  2800              CMP      r0,#0
0005a0  d144              BNE      |L1.1580|
;;;577      {
;;;578        /* Device Request*/
;;;579        /* SET_CONFIGURATION*/
;;;580        if (RequestNo == SET_CONFIGURATION)
0005a2  2c09              CMP      r4,#9
0005a4  d103              BNE      |L1.1454|
;;;581        {
;;;582          Result = Standard_SetConfiguration();
0005a6  f7fffffe          BL       Standard_SetConfiguration
0005aa  4606              MOV      r6,r0
0005ac  e05f              B        |L1.1646|
                  |L1.1454|
;;;583        }
;;;584    
;;;585        /*SET ADDRESS*/
;;;586        else if (RequestNo == SET_ADDRESS)
0005ae  2c05              CMP      r4,#5
0005b0  d114              BNE      |L1.1500|
;;;587        {
;;;588          if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
0005b2  488b              LDR      r0,|L1.2016|
0005b4  6800              LDR      r0,[r0,#0]  ; pInformation
0005b6  78c0              LDRB     r0,[r0,#3]
0005b8  287f              CMP      r0,#0x7f
0005ba  dc0b              BGT      |L1.1492|
0005bc  4888              LDR      r0,|L1.2016|
0005be  6800              LDR      r0,[r0,#0]  ; pInformation
0005c0  7880              LDRB     r0,[r0,#2]
0005c2  b938              CBNZ     r0,|L1.1492|
;;;589              || (pInformation->USBwIndex != 0)
0005c4  4886              LDR      r0,|L1.2016|
0005c6  6800              LDR      r0,[r0,#0]  ; pInformation
0005c8  8880              LDRH     r0,[r0,#4]
0005ca  b918              CBNZ     r0,|L1.1492|
;;;590              || (pInformation->Current_Configuration != 0))
0005cc  4884              LDR      r0,|L1.2016|
0005ce  6800              LDR      r0,[r0,#0]  ; pInformation
0005d0  7a80              LDRB     r0,[r0,#0xa]
0005d2  b108              CBZ      r0,|L1.1496|
                  |L1.1492|
;;;591            /* Device Address should be 127 or less*/
;;;592          {
;;;593            ControlState = STALLED;
0005d4  2508              MOVS     r5,#8
;;;594            goto exit_NoData_Setup0;
0005d6  e065              B        |L1.1700|
                  |L1.1496|
;;;595          }
;;;596          else
;;;597          {
;;;598            Result = USB_SUCCESS;
0005d8  2600              MOVS     r6,#0
0005da  e048              B        |L1.1646|
                  |L1.1500|
;;;599    
;;;600          #ifdef STM32F10X_CL
;;;601             SetDeviceAddress(pInformation->USBwValue0);
;;;602          #endif  /* STM32F10X_CL */
;;;603          }
;;;604        }
;;;605        /*SET FEATURE for Device*/
;;;606        else if (RequestNo == SET_FEATURE)
0005dc  2c03              CMP      r4,#3
0005de  d10e              BNE      |L1.1534|
;;;607        {
;;;608          if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP) \
0005e0  487f              LDR      r0,|L1.2016|
0005e2  6800              LDR      r0,[r0,#0]  ; pInformation
0005e4  78c0              LDRB     r0,[r0,#3]
0005e6  2801              CMP      r0,#1
0005e8  d107              BNE      |L1.1530|
;;;609              && (pInformation->USBwIndex == 0))
0005ea  487d              LDR      r0,|L1.2016|
0005ec  6800              LDR      r0,[r0,#0]  ; pInformation
0005ee  8880              LDRH     r0,[r0,#4]
0005f0  b918              CBNZ     r0,|L1.1530|
;;;610          {
;;;611            Result = Standard_SetDeviceFeature();
0005f2  f7fffffe          BL       Standard_SetDeviceFeature
0005f6  4606              MOV      r6,r0
0005f8  e039              B        |L1.1646|
                  |L1.1530|
;;;612          }
;;;613          else
;;;614          {
;;;615            Result = USB_UNSUPPORT;
0005fa  2602              MOVS     r6,#2
0005fc  e037              B        |L1.1646|
                  |L1.1534|
;;;616          }
;;;617        }
;;;618        /*Clear FEATURE for Device */
;;;619        else if (RequestNo == CLEAR_FEATURE)
0005fe  2c01              CMP      r4,#1
000600  d135              BNE      |L1.1646|
;;;620        {
;;;621          if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
000602  4877              LDR      r0,|L1.2016|
000604  6800              LDR      r0,[r0,#0]  ; pInformation
000606  78c0              LDRB     r0,[r0,#3]
000608  2801              CMP      r0,#1
00060a  d10d              BNE      |L1.1576|
;;;622              && pInformation->USBwIndex == 0
00060c  4874              LDR      r0,|L1.2016|
00060e  6800              LDR      r0,[r0,#0]  ; pInformation
000610  8880              LDRH     r0,[r0,#4]
000612  b948              CBNZ     r0,|L1.1576|
;;;623              && ValBit(pInformation->Current_Feature, 5))
000614  4872              LDR      r0,|L1.2016|
000616  6800              LDR      r0,[r0,#0]  ; pInformation
000618  7a40              LDRB     r0,[r0,#9]
00061a  f0000020          AND      r0,r0,#0x20
00061e  b118              CBZ      r0,|L1.1576|
;;;624          {
;;;625            Result = Standard_ClearFeature();
000620  f7fffffe          BL       Standard_ClearFeature
000624  4606              MOV      r6,r0
000626  e022              B        |L1.1646|
                  |L1.1576|
;;;626          }
;;;627          else
;;;628          {
;;;629            Result = USB_UNSUPPORT;
000628  2602              MOVS     r6,#2
00062a  e020              B        |L1.1646|
                  |L1.1580|
;;;630          }
;;;631        }
;;;632    
;;;633      }
;;;634    
;;;635      /* Interface Request*/
;;;636      else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
00062c  486c              LDR      r0,|L1.2016|
00062e  6800              LDR      r0,[r0,#0]  ; pInformation
000630  7800              LDRB     r0,[r0,#0]
000632  f000007f          AND      r0,r0,#0x7f
000636  2801              CMP      r0,#1
000638  d105              BNE      |L1.1606|
;;;637      {
;;;638        /*SET INTERFACE*/
;;;639        if (RequestNo == SET_INTERFACE)
00063a  2c0b              CMP      r4,#0xb
00063c  d117              BNE      |L1.1646|
;;;640        {
;;;641          Result = Standard_SetInterface();
00063e  f7fffffe          BL       Standard_SetInterface
000642  4606              MOV      r6,r0
000644  e013              B        |L1.1646|
                  |L1.1606|
;;;642        }
;;;643      }
;;;644    
;;;645      /* EndPoint Request*/
;;;646      else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
000646  4866              LDR      r0,|L1.2016|
000648  6800              LDR      r0,[r0,#0]  ; pInformation
00064a  7800              LDRB     r0,[r0,#0]
00064c  f000007f          AND      r0,r0,#0x7f
000650  2802              CMP      r0,#2
000652  d10b              BNE      |L1.1644|
;;;647      {
;;;648        /*CLEAR FEATURE for EndPoint*/
;;;649        if (RequestNo == CLEAR_FEATURE)
000654  2c01              CMP      r4,#1
000656  d103              BNE      |L1.1632|
;;;650        {
;;;651          Result = Standard_ClearFeature();
000658  f7fffffe          BL       Standard_ClearFeature
00065c  4606              MOV      r6,r0
00065e  e006              B        |L1.1646|
                  |L1.1632|
;;;652        }
;;;653        /* SET FEATURE for EndPoint*/
;;;654        else if (RequestNo == SET_FEATURE)
000660  2c03              CMP      r4,#3
000662  d104              BNE      |L1.1646|
;;;655        {
;;;656          Result = Standard_SetEndPointFeature();
000664  f7fffffe          BL       Standard_SetEndPointFeature
000668  4606              MOV      r6,r0
00066a  e000              B        |L1.1646|
                  |L1.1644|
;;;657        }
;;;658      }
;;;659      else
;;;660      {
;;;661        Result = USB_UNSUPPORT;
00066c  2602              MOVS     r6,#2
                  |L1.1646|
;;;662      }
;;;663    
;;;664    
;;;665      if (Result != USB_SUCCESS)
00066e  b14e              CBZ      r6,|L1.1668|
;;;666      {
;;;667        Result = (*pProperty->Class_NoData_Setup)(RequestNo);
000670  b2e0              UXTB     r0,r4
000672  4a62              LDR      r2,|L1.2044|
000674  6812              LDR      r2,[r2,#0]  ; pProperty
000676  6951              LDR      r1,[r2,#0x14]
000678  4788              BLX      r1
00067a  4606              MOV      r6,r0
;;;668        if (Result == USB_NOT_READY)
00067c  2e03              CMP      r6,#3
00067e  d101              BNE      |L1.1668|
;;;669        {
;;;670          ControlState = PAUSE;
000680  2509              MOVS     r5,#9
;;;671          goto exit_NoData_Setup0;
000682  e00f              B        |L1.1700|
                  |L1.1668|
;;;672        }
;;;673      }
;;;674    
;;;675      if (Result != USB_SUCCESS)
000684  b10e              CBZ      r6,|L1.1674|
;;;676      {
;;;677        ControlState = STALLED;
000686  2508              MOVS     r5,#8
;;;678        goto exit_NoData_Setup0;
000688  e00c              B        |L1.1700|
                  |L1.1674|
;;;679      }
;;;680    
;;;681      ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
00068a  2506              MOVS     r5,#6
;;;682    
;;;683      USB_StatusIn();
00068c  2100              MOVS     r1,#0
00068e  4858              LDR      r0,|L1.2032|
000690  6800              LDR      r0,[r0,#0]
000692  b280              UXTH     r0,r0
000694  1c80              ADDS     r0,r0,#2
000696  4a57              LDR      r2,|L1.2036|
000698  f8421010          STR      r1,[r2,r0,LSL #1]
00069c  2030              MOVS     r0,#0x30
00069e  4953              LDR      r1,|L1.2028|
0006a0  8008              STRH     r0,[r1,#0]
;;;684    
;;;685    exit_NoData_Setup0:
0006a2  bf00              NOP      
                  |L1.1700|
;;;686      pInformation->ControlState = ControlState;
0006a4  494e              LDR      r1,|L1.2016|
0006a6  6809              LDR      r1,[r1,#0]  ; pInformation
0006a8  720d              STRB     r5,[r1,#8]
;;;687      return;
;;;688    }
0006aa  bd70              POP      {r4-r6,pc}
;;;689    
                          ENDP

                  Data_Setup0 PROC
;;;696    *******************************************************************************/
;;;697    void Data_Setup0(void)
0006ac  e92d4ff8          PUSH     {r3-r11,lr}
;;;698    {
;;;699      uint8_t *(*CopyRoutine)(uint16_t);
;;;700      RESULT Result;
;;;701      uint32_t Request_No = pInformation->USBbRequest;
0006b0  484b              LDR      r0,|L1.2016|
0006b2  6800              LDR      r0,[r0,#0]  ; pInformation
0006b4  7845              LDRB     r5,[r0,#1]
;;;702    
;;;703      uint32_t Related_Endpoint, Reserved;
;;;704      uint32_t wOffset, Status;
;;;705    
;;;706    
;;;707    
;;;708      CopyRoutine = NULL;
0006b6  2700              MOVS     r7,#0
;;;709      wOffset = 0;
0006b8  46ba              MOV      r10,r7
;;;710    
;;;711      /*GET DESCRIPTOR*/
;;;712      if (Request_No == GET_DESCRIPTOR)
0006ba  2d06              CMP      r5,#6
0006bc  d11b              BNE      |L1.1782|
;;;713      {
;;;714        if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
0006be  4848              LDR      r0,|L1.2016|
0006c0  6800              LDR      r0,[r0,#0]  ; pInformation
0006c2  7800              LDRB     r0,[r0,#0]
0006c4  f000007f          AND      r0,r0,#0x7f
0006c8  2800              CMP      r0,#0
0006ca  d113              BNE      |L1.1780|
;;;715        {
;;;716          uint8_t wValue1 = pInformation->USBwValue1;
0006cc  4944              LDR      r1,|L1.2016|
0006ce  6809              LDR      r1,[r1,#0]  ; pInformation
0006d0  7888              LDRB     r0,[r1,#2]
;;;717          if (wValue1 == DEVICE_DESCRIPTOR)
0006d2  2801              CMP      r0,#1
0006d4  d103              BNE      |L1.1758|
;;;718          {
;;;719            CopyRoutine = pProperty->GetDeviceDescriptor;
0006d6  4949              LDR      r1,|L1.2044|
0006d8  6809              LDR      r1,[r1,#0]  ; pProperty
0006da  69cf              LDR      r7,[r1,#0x1c]
0006dc  e00a              B        |L1.1780|
                  |L1.1758|
;;;720          }
;;;721          else if (wValue1 == CONFIG_DESCRIPTOR)
0006de  2802              CMP      r0,#2
0006e0  d103              BNE      |L1.1770|
;;;722          {
;;;723            CopyRoutine = pProperty->GetConfigDescriptor;
0006e2  4946              LDR      r1,|L1.2044|
0006e4  6809              LDR      r1,[r1,#0]  ; pProperty
0006e6  6a0f              LDR      r7,[r1,#0x20]
0006e8  e004              B        |L1.1780|
                  |L1.1770|
;;;724          }
;;;725          else if (wValue1 == STRING_DESCRIPTOR)
0006ea  2803              CMP      r0,#3
0006ec  d102              BNE      |L1.1780|
;;;726          {
;;;727            CopyRoutine = pProperty->GetStringDescriptor;
0006ee  4943              LDR      r1,|L1.2044|
0006f0  6809              LDR      r1,[r1,#0]  ; pProperty
0006f2  6a4f              LDR      r7,[r1,#0x24]
                  |L1.1780|
;;;728          }  /* End of GET_DESCRIPTOR */
;;;729        }
0006f4  e0ad              B        |L1.2130|
                  |L1.1782|
;;;730      }
;;;731    
;;;732      /*GET STATUS*/
;;;733      else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
0006f6  2d00              CMP      r5,#0
0006f8  d167              BNE      |L1.1994|
0006fa  4839              LDR      r0,|L1.2016|
0006fc  6800              LDR      r0,[r0,#0]  ; pInformation
0006fe  8840              LDRH     r0,[r0,#2]
000700  2800              CMP      r0,#0
000702  d162              BNE      |L1.1994|
;;;734               && (pInformation->USBwLength == 0x0002)
000704  4836              LDR      r0,|L1.2016|
000706  6800              LDR      r0,[r0,#0]  ; pInformation
000708  88c0              LDRH     r0,[r0,#6]
00070a  2802              CMP      r0,#2
00070c  d15d              BNE      |L1.1994|
;;;735               && (pInformation->USBwIndex1 == 0))
00070e  4834              LDR      r0,|L1.2016|
000710  6800              LDR      r0,[r0,#0]  ; pInformation
000712  7900              LDRB     r0,[r0,#4]
000714  2800              CMP      r0,#0
000716  d158              BNE      |L1.1994|
;;;736      {
;;;737        /* GET STATUS for Device*/
;;;738        if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
000718  4831              LDR      r0,|L1.2016|
00071a  6800              LDR      r0,[r0,#0]  ; pInformation
00071c  7800              LDRB     r0,[r0,#0]
00071e  f000007f          AND      r0,r0,#0x7f
000722  b930              CBNZ     r0,|L1.1842|
;;;739            && (pInformation->USBwIndex == 0))
000724  482e              LDR      r0,|L1.2016|
000726  6800              LDR      r0,[r0,#0]  ; pInformation
000728  8880              LDRH     r0,[r0,#4]
00072a  b910              CBNZ     r0,|L1.1842|
;;;740        {
;;;741          CopyRoutine = Standard_GetStatus;
00072c  f2af674f          ADR      r7,Standard_GetStatus + 1
000730  e08f              B        |L1.2130|
                  |L1.1842|
;;;742        }
;;;743    
;;;744        /* GET STATUS for Interface*/
;;;745        else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
000732  482b              LDR      r0,|L1.2016|
000734  6800              LDR      r0,[r0,#0]  ; pInformation
000736  7800              LDRB     r0,[r0,#0]
000738  f000007f          AND      r0,r0,#0x7f
00073c  2801              CMP      r0,#1
00073e  d111              BNE      |L1.1892|
;;;746        {
;;;747          if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
000740  4927              LDR      r1,|L1.2016|
000742  6809              LDR      r1,[r1,#0]  ; pInformation
000744  7948              LDRB     r0,[r1,#5]
000746  492d              LDR      r1,|L1.2044|
000748  6809              LDR      r1,[r1,#0]  ; pProperty
00074a  698a              LDR      r2,[r1,#0x18]
00074c  2100              MOVS     r1,#0
00074e  4790              BLX      r2
000750  2800              CMP      r0,#0
000752  d17e              BNE      |L1.2130|
;;;748              && (pInformation->Current_Configuration != 0))
000754  4822              LDR      r0,|L1.2016|
000756  6800              LDR      r0,[r0,#0]  ; pInformation
000758  7a80              LDRB     r0,[r0,#0xa]
00075a  2800              CMP      r0,#0
00075c  d079              BEQ      |L1.2130|
;;;749          {
;;;750            CopyRoutine = Standard_GetStatus;
00075e  f2af677f          ADR      r7,Standard_GetStatus + 1
000762  e076              B        |L1.2130|
                  |L1.1892|
;;;751          }
;;;752        }
;;;753    
;;;754        /* GET STATUS for EndPoint*/
;;;755        else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
000764  481e              LDR      r0,|L1.2016|
000766  6800              LDR      r0,[r0,#0]  ; pInformation
000768  7800              LDRB     r0,[r0,#0]
00076a  f000007f          AND      r0,r0,#0x7f
00076e  2802              CMP      r0,#2
000770  d16f              BNE      |L1.2130|
;;;756        {
;;;757          Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
000772  481b              LDR      r0,|L1.2016|
000774  6800              LDR      r0,[r0,#0]  ; pInformation
000776  7940              LDRB     r0,[r0,#5]
000778  f000060f          AND      r6,r0,#0xf
;;;758          Reserved = pInformation->USBwIndex0 & 0x70;
00077c  4818              LDR      r0,|L1.2016|
00077e  6800              LDR      r0,[r0,#0]  ; pInformation
000780  7940              LDRB     r0,[r0,#5]
000782  f0000970          AND      r9,r0,#0x70
;;;759    
;;;760          if (ValBit(pInformation->USBwIndex0, 7))
000786  4816              LDR      r0,|L1.2016|
000788  6800              LDR      r0,[r0,#0]  ; pInformation
00078a  7940              LDRB     r0,[r0,#5]
00078c  f0000080          AND      r0,r0,#0x80
000790  b138              CBZ      r0,|L1.1954|
;;;761          {
;;;762            /*Get Status of endpoint & stall the request if the related_ENdpoint
;;;763            is Disabled*/
;;;764            Status = _GetEPTxStatus(Related_Endpoint);
000792  491b              LDR      r1,|L1.2048|
000794  eb010086          ADD      r0,r1,r6,LSL #2
000798  f8d00c00          LDR      r0,[r0,#0xc00]
00079c  f0000830          AND      r8,r0,#0x30
0007a0  e006              B        |L1.1968|
                  |L1.1954|
;;;765          }
;;;766          else
;;;767          {
;;;768            Status = _GetEPRxStatus(Related_Endpoint);
0007a2  4917              LDR      r1,|L1.2048|
0007a4  eb010086          ADD      r0,r1,r6,LSL #2
0007a8  f8d00c00          LDR      r0,[r0,#0xc00]
0007ac  f4005840          AND      r8,r0,#0x3000
                  |L1.1968|
;;;769          }
;;;770    
;;;771          if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
0007b0  4814              LDR      r0,|L1.2052|
0007b2  7800              LDRB     r0,[r0,#0]  ; Device_Table
0007b4  42b0              CMP      r0,r6
0007b6  d94c              BLS      |L1.2130|
0007b8  f1b90f00          CMP      r9,#0
0007bc  d149              BNE      |L1.2130|
;;;772              && (Status != 0))
0007be  f1b80f00          CMP      r8,#0
0007c2  d046              BEQ      |L1.2130|
;;;773          {
;;;774            CopyRoutine = Standard_GetStatus;
0007c4  f2af67e7          ADR      r7,Standard_GetStatus + 1
0007c8  e043              B        |L1.2130|
                  |L1.1994|
;;;775          }
;;;776        }
;;;777    
;;;778      }
;;;779    
;;;780      /*GET CONFIGURATION*/
;;;781      else if (Request_No == GET_CONFIGURATION)
0007ca  2d08              CMP      r5,#8
0007cc  d11c              BNE      |L1.2056|
;;;782      {
;;;783        if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
0007ce  4804              LDR      r0,|L1.2016|
0007d0  6800              LDR      r0,[r0,#0]  ; pInformation
0007d2  7800              LDRB     r0,[r0,#0]
0007d4  f000007f          AND      r0,r0,#0x7f
0007d8  bbd8              CBNZ     r0,|L1.2130|
;;;784        {
;;;785          CopyRoutine = Standard_GetConfiguration;
0007da  f2af77db          ADR      r7,Standard_GetConfiguration + 1
0007de  e038              B        |L1.2130|
                  |L1.2016|
                          DCD      pInformation
                  |L1.2020|
                          DCD      pUser_Standard_Requests
                  |L1.2024|
                          DCD      SaveRState
                  |L1.2028|
                          DCD      SaveTState
                  |L1.2032|
                          DCD      0x40005c50
                  |L1.2036|
                          DCD      0x40006000
                  |L1.2040|
                          DCD      Data_Mul_MaxPacketSize
                  |L1.2044|
                          DCD      pProperty
                  |L1.2048|
                          DCD      0x40005000
                  |L1.2052|
                          DCD      Device_Table
                  |L1.2056|
;;;786        }
;;;787      }
;;;788      /*GET INTERFACE*/
;;;789      else if (Request_No == GET_INTERFACE)
000808  2d0a              CMP      r5,#0xa
00080a  d122              BNE      |L1.2130|
;;;790      {
;;;791        if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
00080c  48c5              LDR      r0,|L1.2852|
00080e  6800              LDR      r0,[r0,#0]  ; pInformation
000810  7800              LDRB     r0,[r0,#0]
000812  f000007f          AND      r0,r0,#0x7f
000816  2801              CMP      r0,#1
000818  d11b              BNE      |L1.2130|
;;;792            && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
00081a  48c2              LDR      r0,|L1.2852|
00081c  6800              LDR      r0,[r0,#0]  ; pInformation
00081e  7a80              LDRB     r0,[r0,#0xa]
000820  b1b8              CBZ      r0,|L1.2130|
000822  48c0              LDR      r0,|L1.2852|
000824  6800              LDR      r0,[r0,#0]  ; pInformation
000826  8840              LDRH     r0,[r0,#2]
000828  b998              CBNZ     r0,|L1.2130|
;;;793            && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
00082a  48be              LDR      r0,|L1.2852|
00082c  6800              LDR      r0,[r0,#0]  ; pInformation
00082e  7900              LDRB     r0,[r0,#4]
000830  b978              CBNZ     r0,|L1.2130|
000832  48bc              LDR      r0,|L1.2852|
000834  6800              LDR      r0,[r0,#0]  ; pInformation
000836  88c0              LDRH     r0,[r0,#6]
000838  2801              CMP      r0,#1
00083a  d10a              BNE      |L1.2130|
;;;794            && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
00083c  49b9              LDR      r1,|L1.2852|
00083e  6809              LDR      r1,[r1,#0]  ; pInformation
000840  7948              LDRB     r0,[r1,#5]
000842  49b9              LDR      r1,|L1.2856|
000844  6809              LDR      r1,[r1,#0]  ; pProperty
000846  698a              LDR      r2,[r1,#0x18]
000848  2100              MOVS     r1,#0
00084a  4790              BLX      r2
00084c  b908              CBNZ     r0,|L1.2130|
;;;795        {
;;;796          CopyRoutine = Standard_GetInterface;
00084e  f2af77f1          ADR      r7,Standard_GetInterface + 1
                  |L1.2130|
;;;797        }
;;;798    
;;;799      }
;;;800      
;;;801      if (CopyRoutine)
000852  b157              CBZ      r7,|L1.2154|
;;;802      {
;;;803        pInformation->Ctrl_Info.Usb_wOffset = wOffset;
000854  48b3              LDR      r0,|L1.2852|
000856  6800              LDR      r0,[r0,#0]  ; pInformation
000858  f8a0a012          STRH     r10,[r0,#0x12]
;;;804        pInformation->Ctrl_Info.CopyData = CopyRoutine;
00085c  48b1              LDR      r0,|L1.2852|
00085e  6800              LDR      r0,[r0,#0]  ; pInformation
000860  6187              STR      r7,[r0,#0x18]
;;;805        /* sb in the original the cast to word was directly */
;;;806        /* now the cast is made step by step */
;;;807        (*CopyRoutine)(0);
000862  2000              MOVS     r0,#0
000864  47b8              BLX      r7
;;;808        Result = USB_SUCCESS;
000866  2400              MOVS     r4,#0
000868  e00f              B        |L1.2186|
                  |L1.2154|
;;;809      }
;;;810      else
;;;811      {
;;;812        Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
00086a  4aae              LDR      r2,|L1.2852|
00086c  6812              LDR      r2,[r2,#0]  ; pInformation
00086e  7850              LDRB     r0,[r2,#1]
000870  4aad              LDR      r2,|L1.2856|
000872  6812              LDR      r2,[r2,#0]  ; pProperty
000874  6911              LDR      r1,[r2,#0x10]
000876  4788              BLX      r1
000878  4604              MOV      r4,r0
;;;813        if (Result == USB_NOT_READY)
00087a  2c03              CMP      r4,#3
00087c  d105              BNE      |L1.2186|
;;;814        {
;;;815          pInformation->ControlState = PAUSE;
00087e  2009              MOVS     r0,#9
000880  49a8              LDR      r1,|L1.2852|
000882  6809              LDR      r1,[r1,#0]  ; pInformation
000884  7208              STRB     r0,[r1,#8]
                  |L1.2182|
;;;816          return;
;;;817        }
;;;818      }
;;;819    
;;;820      if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
;;;821      {
;;;822        /* Data is not ready, wait it */
;;;823        pInformation->ControlState = PAUSE;
;;;824        return;
;;;825      }
;;;826      if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
;;;827      {
;;;828        /* Unsupported request */
;;;829        pInformation->ControlState = STALLED;
;;;830        return;
;;;831      }
;;;832    
;;;833    
;;;834      if (ValBit(pInformation->USBbmRequestType, 7))
;;;835      {
;;;836        /* Device ==> Host */
;;;837        __IO uint32_t wLength = pInformation->USBwLength;
;;;838         
;;;839        /* Restrict the data length to be the one host asks for */
;;;840        if (pInformation->Ctrl_Info.Usb_wLength > wLength)
;;;841        {
;;;842          pInformation->Ctrl_Info.Usb_wLength = wLength;
;;;843        }
;;;844        
;;;845        else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
;;;846        {
;;;847          if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
;;;848          {
;;;849            Data_Mul_MaxPacketSize = FALSE;
;;;850          }
;;;851          else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
;;;852          {
;;;853            Data_Mul_MaxPacketSize = TRUE;
;;;854          }
;;;855        }   
;;;856    
;;;857        pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
;;;858        DataStageIn();
;;;859      }
;;;860      else
;;;861      {
;;;862        pInformation->ControlState = OUT_DATA;
;;;863        vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
;;;864      }
;;;865    
;;;866      return;
;;;867    }
000886  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.2186|
00088a  48a6              LDR      r0,|L1.2852|
00088c  6800              LDR      r0,[r0,#0]            ;820  ; pInformation
00088e  8a00              LDRH     r0,[r0,#0x10]         ;820
000890  f64f71ff          MOV      r1,#0xffff            ;820
000894  4288              CMP      r0,r1                 ;820
000896  d104              BNE      |L1.2210|
000898  2009              MOVS     r0,#9                 ;823
00089a  49a2              LDR      r1,|L1.2852|
00089c  6809              LDR      r1,[r1,#0]            ;823  ; pInformation
00089e  7208              STRB     r0,[r1,#8]            ;823
0008a0  e7f1              B        |L1.2182|
                  |L1.2210|
0008a2  2c02              CMP      r4,#2                 ;826
0008a4  d003              BEQ      |L1.2222|
0008a6  489f              LDR      r0,|L1.2852|
0008a8  6800              LDR      r0,[r0,#0]            ;826  ; pInformation
0008aa  8a00              LDRH     r0,[r0,#0x10]         ;826
0008ac  b920              CBNZ     r0,|L1.2232|
                  |L1.2222|
0008ae  2008              MOVS     r0,#8                 ;829
0008b0  499c              LDR      r1,|L1.2852|
0008b2  6809              LDR      r1,[r1,#0]            ;829  ; pInformation
0008b4  7208              STRB     r0,[r1,#8]            ;829
0008b6  e7e6              B        |L1.2182|
                  |L1.2232|
0008b8  489a              LDR      r0,|L1.2852|
0008ba  6800              LDR      r0,[r0,#0]            ;834  ; pInformation
0008bc  7800              LDRB     r0,[r0,#0]            ;834
0008be  f0000080          AND      r0,r0,#0x80           ;834
0008c2  b3e0              CBZ      r0,|L1.2366|
0008c4  4897              LDR      r0,|L1.2852|
0008c6  6800              LDR      r0,[r0,#0]            ;837  ; pInformation
0008c8  88c0              LDRH     r0,[r0,#6]            ;837
0008ca  9000              STR      r0,[sp,#0]            ;837
0008cc  4895              LDR      r0,|L1.2852|
0008ce  6800              LDR      r0,[r0,#0]            ;840  ; pInformation
0008d0  8a00              LDRH     r0,[r0,#0x10]         ;840
0008d2  9900              LDR      r1,[sp,#0]            ;840
0008d4  4288              CMP      r0,r1                 ;840
0008d6  d904              BLS      |L1.2274|
0008d8  4992              LDR      r1,|L1.2852|
0008da  9800              LDR      r0,[sp,#0]            ;842
0008dc  6809              LDR      r1,[r1,#0]            ;842  ; pInformation
0008de  8208              STRH     r0,[r1,#0x10]         ;842
0008e0  e023              B        |L1.2346|
                  |L1.2274|
0008e2  4890              LDR      r0,|L1.2852|
0008e4  6800              LDR      r0,[r0,#0]            ;845  ; pInformation
0008e6  8a00              LDRH     r0,[r0,#0x10]         ;845
0008e8  498e              LDR      r1,|L1.2852|
0008ea  6809              LDR      r1,[r1,#0]            ;845  ; pInformation
0008ec  88c9              LDRH     r1,[r1,#6]            ;845
0008ee  4288              CMP      r0,r1                 ;845
0008f0  da1b              BGE      |L1.2346|
0008f2  488c              LDR      r0,|L1.2852|
0008f4  6800              LDR      r0,[r0,#0]            ;847  ; pInformation
0008f6  8a00              LDRH     r0,[r0,#0x10]         ;847
0008f8  498b              LDR      r1,|L1.2856|
0008fa  6809              LDR      r1,[r1,#0]            ;847  ; pProperty
0008fc  f891102c          LDRB     r1,[r1,#0x2c]         ;847
000900  4288              CMP      r0,r1                 ;847
000902  da03              BGE      |L1.2316|
000904  2000              MOVS     r0,#0                 ;849
000906  4989              LDR      r1,|L1.2860|
000908  7008              STRB     r0,[r1,#0]            ;849
00090a  e00e              B        |L1.2346|
                  |L1.2316|
00090c  4885              LDR      r0,|L1.2852|
00090e  6800              LDR      r0,[r0,#0]            ;851  ; pInformation
000910  8a00              LDRH     r0,[r0,#0x10]         ;851
000912  4985              LDR      r1,|L1.2856|
000914  6809              LDR      r1,[r1,#0]            ;851  ; pProperty
000916  f891102c          LDRB     r1,[r1,#0x2c]         ;851
00091a  fb90f2f1          SDIV     r2,r0,r1              ;851
00091e  fb010012          MLS      r0,r1,r2,r0           ;851
000922  b910              CBNZ     r0,|L1.2346|
000924  2001              MOVS     r0,#1                 ;853
000926  4981              LDR      r1,|L1.2860|
000928  7008              STRB     r0,[r1,#0]            ;853
                  |L1.2346|
00092a  487f              LDR      r0,|L1.2856|
00092c  6800              LDR      r0,[r0,#0]            ;857  ; pProperty
00092e  f890102c          LDRB     r1,[r0,#0x2c]         ;857
000932  487c              LDR      r0,|L1.2852|
000934  6800              LDR      r0,[r0,#0]            ;857  ; pInformation
000936  8281              STRH     r1,[r0,#0x14]         ;857
000938  f7fffffe          BL       DataStageIn
00093c  e007              B        |L1.2382|
                  |L1.2366|
00093e  e7ff              B        |L1.2368|
                  |L1.2368|
000940  2003              MOVS     r0,#3                 ;862
000942  4978              LDR      r1,|L1.2852|
000944  6809              LDR      r1,[r1,#0]            ;862  ; pInformation
000946  7208              STRB     r0,[r1,#8]            ;862
000948  0300              LSLS     r0,r0,#12             ;863
00094a  4979              LDR      r1,|L1.2864|
00094c  8008              STRH     r0,[r1,#0]            ;863
                  |L1.2382|
00094e  bf00              NOP                            ;866
000950  e799              B        |L1.2182|
;;;868    
                          ENDP

                  Post0_Process PROC
;;;1012   *******************************************************************************/
;;;1013   uint8_t Post0_Process(void)
000952  b510              PUSH     {r4,lr}
;;;1014   {
;;;1015   #ifdef STM32F10X_CL  
;;;1016     USB_OTG_EP *ep;
;;;1017   #endif /* STM32F10X_CL */
;;;1018         
;;;1019     SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
000954  4877              LDR      r0,|L1.2868|
000956  f890102c          LDRB     r1,[r0,#0x2c]  ; Device_Property
00095a  2000              MOVS     r0,#0
00095c  f7fffffe          BL       SetEPRxCount
;;;1020   
;;;1021     if (pInformation->ControlState == STALLED)
000960  4870              LDR      r0,|L1.2852|
000962  6800              LDR      r0,[r0,#0]  ; pInformation
000964  7a00              LDRB     r0,[r0,#8]
000966  2808              CMP      r0,#8
000968  d105              BNE      |L1.2422|
;;;1022     {
;;;1023       vSetEPRxStatus(EP_RX_STALL);
00096a  0240              LSLS     r0,r0,#9
00096c  4970              LDR      r1,|L1.2864|
00096e  8008              STRH     r0,[r1,#0]
;;;1024       vSetEPTxStatus(EP_TX_STALL);
000970  2010              MOVS     r0,#0x10
000972  4971              LDR      r1,|L1.2872|
000974  8008              STRH     r0,[r1,#0]
                  |L1.2422|
;;;1025     }
;;;1026   
;;;1027   #ifdef STM32F10X_CL
;;;1028     else if ((pInformation->ControlState == OUT_DATA) ||
;;;1029         (pInformation->ControlState == WAIT_STATUS_OUT))
;;;1030     {
;;;1031       ep = PCD_GetInEP(0);
;;;1032       ep->is_in = 0;
;;;1033       OTGD_FS_EP0StartXfer(ep);
;;;1034       
;;;1035       vSetEPTxStatus(EP_TX_VALID);
;;;1036     }
;;;1037     
;;;1038     else if ((pInformation->ControlState == IN_DATA) || 
;;;1039         (pInformation->ControlState == WAIT_STATUS_IN))
;;;1040     {
;;;1041       ep = PCD_GetInEP(0);
;;;1042       ep->is_in = 1;
;;;1043       OTGD_FS_EP0StartXfer(ep);    
;;;1044     }  
;;;1045   #endif /* STM32F10X_CL */
;;;1046   
;;;1047     return (pInformation->ControlState == PAUSE);
000976  486b              LDR      r0,|L1.2852|
000978  6800              LDR      r0,[r0,#0]  ; pInformation
00097a  7a00              LDRB     r0,[r0,#8]
00097c  2809              CMP      r0,#9
00097e  d101              BNE      |L1.2436|
000980  2001              MOVS     r0,#1
                  |L1.2434|
;;;1048   }
000982  bd10              POP      {r4,pc}
                  |L1.2436|
000984  2000              MOVS     r0,#0                 ;1047
000986  e7fc              B        |L1.2434|
;;;1049   
                          ENDP

                  Setup0_Process PROC
;;;875    *******************************************************************************/
;;;876    uint8_t Setup0_Process(void)
000988  b538              PUSH     {r3-r5,lr}
;;;877    {
;;;878    
;;;879      union
;;;880      {
;;;881        uint8_t* b;
;;;882        uint16_t* w;
;;;883      } pBuf;
;;;884    
;;;885    #ifdef STM32F10X_CL
;;;886      USB_OTG_EP *ep;
;;;887      uint16_t offset = 0;
;;;888     
;;;889      ep = PCD_GetOutEP(ENDP0);
;;;890      pBuf.b = ep->xfer_buff;
;;;891    #else  
;;;892      uint16_t offset = 1;
00098a  2401              MOVS     r4,#1
;;;893      
;;;894      pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
00098c  486b              LDR      r0,|L1.2876|
00098e  6800              LDR      r0,[r0,#0]
000990  b280              UXTH     r0,r0
000992  1d00              ADDS     r0,r0,#4
000994  496a              LDR      r1,|L1.2880|
000996  f8310010          LDRH     r0,[r1,r0,LSL #1]
00099a  b280              UXTH     r0,r0
00099c  eb010040          ADD      r0,r1,r0,LSL #1
0009a0  9000              STR      r0,[sp,#0]
;;;895    #endif /* STM32F10X_CL */
;;;896    
;;;897      if (pInformation->ControlState != PAUSE)
0009a2  4860              LDR      r0,|L1.2852|
0009a4  6800              LDR      r0,[r0,#0]  ; pInformation
0009a6  7a00              LDRB     r0,[r0,#8]
0009a8  2809              CMP      r0,#9
0009aa  d032              BEQ      |L1.2578|
;;;898      {
;;;899        pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
0009ac  9800              LDR      r0,[sp,#0]
0009ae  7800              LDRB     r0,[r0,#0]
0009b0  495c              LDR      r1,|L1.2852|
0009b2  6809              LDR      r1,[r1,#0]  ; pInformation
0009b4  7008              STRB     r0,[r1,#0]
0009b6  9800              LDR      r0,[sp,#0]
0009b8  1c40              ADDS     r0,r0,#1
0009ba  9000              STR      r0,[sp,#0]
;;;900        pInformation->USBbRequest = *pBuf.b++; /* bRequest */
0009bc  9800              LDR      r0,[sp,#0]
0009be  7800              LDRB     r0,[r0,#0]
0009c0  4958              LDR      r1,|L1.2852|
0009c2  6809              LDR      r1,[r1,#0]  ; pInformation
0009c4  7048              STRB     r0,[r1,#1]
0009c6  9800              LDR      r0,[sp,#0]
0009c8  1c40              ADDS     r0,r0,#1
0009ca  9000              STR      r0,[sp,#0]
;;;901        pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
0009cc  9800              LDR      r0,[sp,#0]
0009ce  eb000044          ADD      r0,r0,r4,LSL #1
0009d2  9000              STR      r0,[sp,#0]
;;;902        pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
0009d4  9900              LDR      r1,[sp,#0]
0009d6  f8310b02          LDRH     r0,[r1],#2
0009da  9100              STR      r1,[sp,#0]
0009dc  f7fffffe          BL       ByteSwap
0009e0  4950              LDR      r1,|L1.2852|
0009e2  6809              LDR      r1,[r1,#0]  ; pInformation
0009e4  8048              STRH     r0,[r1,#2]
;;;903        pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
0009e6  9800              LDR      r0,[sp,#0]
0009e8  eb000044          ADD      r0,r0,r4,LSL #1
0009ec  9000              STR      r0,[sp,#0]
;;;904        pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
0009ee  9900              LDR      r1,[sp,#0]
0009f0  f8310b02          LDRH     r0,[r1],#2
0009f4  9100              STR      r1,[sp,#0]
0009f6  f7fffffe          BL       ByteSwap
0009fa  494a              LDR      r1,|L1.2852|
0009fc  6809              LDR      r1,[r1,#0]  ; pInformation
0009fe  8088              STRH     r0,[r1,#4]
;;;905        pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
000a00  9800              LDR      r0,[sp,#0]
000a02  eb000044          ADD      r0,r0,r4,LSL #1
000a06  9000              STR      r0,[sp,#0]
;;;906        pInformation->USBwLength = *pBuf.w; /* wLength */
000a08  9800              LDR      r0,[sp,#0]
000a0a  8800              LDRH     r0,[r0,#0]
000a0c  4945              LDR      r1,|L1.2852|
000a0e  6809              LDR      r1,[r1,#0]  ; pInformation
000a10  80c8              STRH     r0,[r1,#6]
                  |L1.2578|
;;;907      }
;;;908    
;;;909      pInformation->ControlState = SETTING_UP;
000a12  2001              MOVS     r0,#1
000a14  4943              LDR      r1,|L1.2852|
000a16  6809              LDR      r1,[r1,#0]  ; pInformation
000a18  7208              STRB     r0,[r1,#8]
;;;910      if (pInformation->USBwLength == 0)
000a1a  4842              LDR      r0,|L1.2852|
000a1c  6800              LDR      r0,[r0,#0]  ; pInformation
000a1e  88c0              LDRH     r0,[r0,#6]
000a20  b910              CBNZ     r0,|L1.2600|
;;;911      {
;;;912        /* Setup with no data stage */
;;;913        NoData_Setup0();
000a22  f7fffffe          BL       NoData_Setup0
000a26  e001              B        |L1.2604|
                  |L1.2600|
;;;914      }
;;;915      else
;;;916      {
;;;917        /* Setup with data stage */
;;;918        Data_Setup0();
000a28  f7fffffe          BL       Data_Setup0
                  |L1.2604|
;;;919      }
;;;920      return Post0_Process();
000a2c  f7fffffe          BL       Post0_Process
;;;921    }
000a30  bd38              POP      {r3-r5,pc}
;;;922    
                          ENDP

                  SetDeviceAddress PROC
;;;1056   *******************************************************************************/
;;;1057   void SetDeviceAddress(uint8_t Val)
000a32  b530              PUSH     {r4,r5,lr}
;;;1058   {
000a34  4601              MOV      r1,r0
;;;1059   #ifdef STM32F10X_CL 
;;;1060     PCD_EP_SetAddress ((uint8_t)Val);
;;;1061   #else 
;;;1062     uint32_t i;
;;;1063     uint32_t nEP = Device_Table.Total_Endpoint;
000a36  4b43              LDR      r3,|L1.2884|
000a38  781a              LDRB     r2,[r3,#0]  ; Device_Table
;;;1064   
;;;1065     /* set address in every used endpoint */
;;;1066     for (i = 0; i < nEP; i++)
000a3a  2000              MOVS     r0,#0
000a3c  e014              B        |L1.2664|
                  |L1.2622|
;;;1067     {
;;;1068       _SetEPAddress((uint8_t)i, (uint8_t)i);
000a3e  0603              LSLS     r3,r0,#24
000a40  4c41              LDR      r4,|L1.2888|
000a42  eb045393          ADD      r3,r4,r3,LSR #22
000a46  f8d33c00          LDR      r3,[r3,#0xc00]
000a4a  f648748f          MOV      r4,#0x8f8f
000a4e  4023              ANDS     r3,r3,r4
000a50  f2480480          MOV      r4,#0x8080
000a54  4323              ORRS     r3,r3,r4
000a56  b2c4              UXTB     r4,r0
000a58  4323              ORRS     r3,r3,r4
000a5a  0604              LSLS     r4,r0,#24
000a5c  4d3a              LDR      r5,|L1.2888|
000a5e  eb055494          ADD      r4,r5,r4,LSR #22
000a62  f8c43c00          STR      r3,[r4,#0xc00]
000a66  1c40              ADDS     r0,r0,#1              ;1066
                  |L1.2664|
000a68  4290              CMP      r0,r2                 ;1066
000a6a  d3e8              BCC      |L1.2622|
;;;1069     } /* for */
;;;1070     _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
000a6c  f0410380          ORR      r3,r1,#0x80
000a70  4c32              LDR      r4,|L1.2876|
000a72  1f24              SUBS     r4,r4,#4
000a74  6023              STR      r3,[r4,#0]
;;;1071   #endif  /* STM32F10X_CL */  
;;;1072   }
000a76  bd30              POP      {r4,r5,pc}
;;;1073   
                          ENDP

                  In0_Process PROC
;;;929    *******************************************************************************/
;;;930    uint8_t In0_Process(void)
000a78  b510              PUSH     {r4,lr}
;;;931    {
;;;932      uint32_t ControlState = pInformation->ControlState;
000a7a  482a              LDR      r0,|L1.2852|
000a7c  6800              LDR      r0,[r0,#0]  ; pInformation
000a7e  7a04              LDRB     r4,[r0,#8]
;;;933    
;;;934      if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
000a80  2c02              CMP      r4,#2
000a82  d001              BEQ      |L1.2696|
000a84  2c04              CMP      r4,#4
000a86  d105              BNE      |L1.2708|
                  |L1.2696|
;;;935      {
;;;936        DataStageIn();
000a88  f7fffffe          BL       DataStageIn
;;;937        /* ControlState may be changed outside the function */
;;;938        ControlState = pInformation->ControlState;
000a8c  4825              LDR      r0,|L1.2852|
000a8e  6800              LDR      r0,[r0,#0]  ; pInformation
000a90  7a04              LDRB     r4,[r0,#8]
000a92  e01c              B        |L1.2766|
                  |L1.2708|
;;;939      }
;;;940    
;;;941      else if (ControlState == WAIT_STATUS_IN)
000a94  2c06              CMP      r4,#6
000a96  d119              BNE      |L1.2764|
;;;942      {
;;;943        if ((pInformation->USBbRequest == SET_ADDRESS) &&
000a98  4822              LDR      r0,|L1.2852|
000a9a  6800              LDR      r0,[r0,#0]  ; pInformation
000a9c  7840              LDRB     r0,[r0,#1]
000a9e  2805              CMP      r0,#5
000aa0  d10e              BNE      |L1.2752|
;;;944            (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
000aa2  4820              LDR      r0,|L1.2852|
000aa4  6800              LDR      r0,[r0,#0]  ; pInformation
000aa6  7800              LDRB     r0,[r0,#0]
000aa8  f000007f          AND      r0,r0,#0x7f
000aac  b940              CBNZ     r0,|L1.2752|
;;;945        {
;;;946          SetDeviceAddress(pInformation->USBwValue0);
000aae  491d              LDR      r1,|L1.2852|
000ab0  6809              LDR      r1,[r1,#0]  ; pInformation
000ab2  78c8              LDRB     r0,[r1,#3]
000ab4  f7fffffe          BL       SetDeviceAddress
;;;947          pUser_Standard_Requests->User_SetDeviceAddress();
000ab8  4924              LDR      r1,|L1.2892|
000aba  6809              LDR      r1,[r1,#0]  ; pUser_Standard_Requests
000abc  6a08              LDR      r0,[r1,#0x20]
000abe  4780              BLX      r0
                  |L1.2752|
;;;948        }
;;;949        (*pProperty->Process_Status_IN)();
000ac0  4919              LDR      r1,|L1.2856|
000ac2  6809              LDR      r1,[r1,#0]  ; pProperty
000ac4  6888              LDR      r0,[r1,#8]
000ac6  4780              BLX      r0
;;;950        ControlState = STALLED;
000ac8  2408              MOVS     r4,#8
000aca  e000              B        |L1.2766|
                  |L1.2764|
;;;951      }
;;;952    
;;;953      else
;;;954      {
;;;955        ControlState = STALLED;
000acc  2408              MOVS     r4,#8
                  |L1.2766|
;;;956      }
;;;957    
;;;958      pInformation->ControlState = ControlState;
000ace  4915              LDR      r1,|L1.2852|
000ad0  6809              LDR      r1,[r1,#0]  ; pInformation
000ad2  720c              STRB     r4,[r1,#8]
;;;959    
;;;960      return Post0_Process();
000ad4  f7fffffe          BL       Post0_Process
;;;961    }
000ad8  bd10              POP      {r4,pc}
;;;962    
                          ENDP

                  Out0_Process PROC
;;;969    *******************************************************************************/
;;;970    uint8_t Out0_Process(void)
000ada  b510              PUSH     {r4,lr}
;;;971    {
;;;972      uint32_t ControlState = pInformation->ControlState;
000adc  4811              LDR      r0,|L1.2852|
000ade  6800              LDR      r0,[r0,#0]  ; pInformation
000ae0  7a04              LDRB     r4,[r0,#8]
;;;973    
;;;974      if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
000ae2  2c02              CMP      r4,#2
000ae4  d001              BEQ      |L1.2794|
000ae6  2c04              CMP      r4,#4
000ae8  d101              BNE      |L1.2798|
                  |L1.2794|
;;;975      {
;;;976        /* host aborts the transfer before finish */
;;;977        ControlState = STALLED;
000aea  2408              MOVS     r4,#8
000aec  e012              B        |L1.2836|
                  |L1.2798|
;;;978      }
;;;979      else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
000aee  2c03              CMP      r4,#3
000af0  d001              BEQ      |L1.2806|
000af2  2c05              CMP      r4,#5
000af4  d105              BNE      |L1.2818|
                  |L1.2806|
;;;980      {
;;;981        DataStageOut();
000af6  f7fffffe          BL       DataStageOut
;;;982        ControlState = pInformation->ControlState; /* may be changed outside the function */
000afa  480a              LDR      r0,|L1.2852|
000afc  6800              LDR      r0,[r0,#0]  ; pInformation
000afe  7a04              LDRB     r4,[r0,#8]
000b00  e008              B        |L1.2836|
                  |L1.2818|
;;;983      }
;;;984    
;;;985      else if (ControlState == WAIT_STATUS_OUT)
000b02  2c07              CMP      r4,#7
000b04  d105              BNE      |L1.2834|
;;;986      {
;;;987        (*pProperty->Process_Status_OUT)();
000b06  4908              LDR      r1,|L1.2856|
000b08  6809              LDR      r1,[r1,#0]  ; pProperty
000b0a  68c8              LDR      r0,[r1,#0xc]
000b0c  4780              BLX      r0
;;;988      #ifndef STM32F10X_CL
;;;989        ControlState = STALLED;
000b0e  2408              MOVS     r4,#8
000b10  e000              B        |L1.2836|
                  |L1.2834|
;;;990      #endif /* STM32F10X_CL */
;;;991      }
;;;992    
;;;993    
;;;994      /* Unexpect state, STALL the endpoint */
;;;995      else
;;;996      {
;;;997        ControlState = STALLED;
000b12  2408              MOVS     r4,#8
                  |L1.2836|
;;;998      }
;;;999    
;;;1000     pInformation->ControlState = ControlState;
000b14  4903              LDR      r1,|L1.2852|
000b16  6809              LDR      r1,[r1,#0]  ; pInformation
000b18  720c              STRB     r4,[r1,#8]
;;;1001   
;;;1002     return Post0_Process();
000b1a  f7fffffe          BL       Post0_Process
;;;1003   }
000b1e  bd10              POP      {r4,pc}
;;;1004   
                          ENDP

                  NOP_Process PROC
;;;1080   *******************************************************************************/
;;;1081   void NOP_Process(void)
000b20  4770              BX       lr
;;;1082   {
;;;1083   }
;;;1084   
                          ENDP

000b22  0000              DCW      0x0000
                  |L1.2852|
                          DCD      pInformation
                  |L1.2856|
                          DCD      pProperty
                  |L1.2860|
                          DCD      Data_Mul_MaxPacketSize
                  |L1.2864|
                          DCD      SaveRState
                  |L1.2868|
                          DCD      Device_Property
                  |L1.2872|
                          DCD      SaveTState
                  |L1.2876|
                          DCD      0x40005c50
                  |L1.2880|
                          DCD      0x40006000
                  |L1.2884|
                          DCD      Device_Table
                  |L1.2888|
                          DCD      0x40005000
                  |L1.2892|
                          DCD      pUser_Standard_Requests

                          AREA ||.data||, DATA, ALIGN=1

                  StatusInfo
000000  0000              DCB      0x00,0x00
                  Data_Mul_MaxPacketSize
000002  00                DCB      0x00
