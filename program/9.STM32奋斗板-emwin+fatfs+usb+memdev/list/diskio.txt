; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\diskio.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\diskio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\MALLOC -I.\TFT -I.\EMWIN\EMWIN_INC -I.\EMWIN\DEMO -I.\PNG -I.\FATFS -I.\SDIO -I.\USB\inc -I.\USBCFG\inc -IE:\material\GUI\STM32·Ü¶·°å-emwin+fatfs+usb+memdev\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\diskio.crf FATFS\diskio.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;21     
;;;22     DSTATUS disk_initialize (
000000  4601              MOV      r1,r0
;;;23     	BYTE drv				/* Physical drive nmuber (0..) */
;;;24     )
;;;25     {
;;;26     	return 0;
000002  2000              MOVS     r0,#0
;;;27     }
000004  4770              BX       lr
;;;28     
                          ENDP

                  disk_status PROC
;;;33     
;;;34     DSTATUS disk_status (
000006  4601              MOV      r1,r0
;;;35     	BYTE drv		/* Physical drive nmuber (0..) */
;;;36     )
;;;37     {	
;;;38     	return 0;
000008  2000              MOVS     r0,#0
;;;39     }
00000a  4770              BX       lr
;;;40     
                          ENDP

                  disk_read PROC
;;;45     
;;;46     DRESULT disk_read (
00000c  e92d41f0          PUSH     {r4-r8,lr}
;;;47     	BYTE drv,		/* Physical drive nmuber (0..) */
;;;48     	BYTE *buff,		/* Data buffer to store read data */
;;;49     	DWORD sector,	/* Sector address (LBA) */
;;;50     	BYTE count		/* Number of sectors to read (1..255) */
;;;51     )
;;;52     {	 
000010  4607              MOV      r7,r0
000012  460c              MOV      r4,r1
000014  4615              MOV      r5,r2
000016  461e              MOV      r6,r3
;;;53     	//if(count==1)
;;;54         //{
;;;55               SD_ReadBlock((u32 *)(&buff[0]),sector << 9 ,SECTOR_SIZE*count);
000018  0670              LSLS     r0,r6,#25
00001a  0c02              LSRS     r2,r0,#16
00001c  0269              LSLS     r1,r5,#9
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       SD_ReadBlock
;;;56              
;;;57     	//}
;;;58     	return RES_OK;
000024  2000              MOVS     r0,#0
;;;59     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;60     
                          ENDP

                  disk_write PROC
;;;66     #if _READONLY == 0
;;;67     DRESULT disk_write (
00002a  e92d41f0          PUSH     {r4-r8,lr}
;;;68     	BYTE drv,			/* Physical drive nmuber (0..) */
;;;69     	const BYTE *buff,	/* Data to be written */
;;;70     	DWORD sector,		/* Sector address (LBA) */
;;;71     	BYTE count			/* Number of sectors to write (1..255) */
;;;72     )
;;;73     {
00002e  4607              MOV      r7,r0
000030  460c              MOV      r4,r1
000032  4615              MOV      r5,r2
000034  461e              MOV      r6,r3
;;;74     	//if(count==1)
;;;75         //{     
;;;76               SD_WriteBlock((u32 *)(&buff[0]),sector << 9 ,SECTOR_SIZE*count);
000036  0670              LSLS     r0,r6,#25
000038  0c02              LSRS     r2,r0,#16
00003a  0269              LSLS     r1,r5,#9
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       SD_WriteBlock
;;;77     	//}         
;;;78       	return RES_OK;
000042  2000              MOVS     r0,#0
;;;79     }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;80     #endif /* _READONLY */
                          ENDP

                  disk_ioctl PROC
;;;86     
;;;87     DRESULT disk_ioctl (
000048  4603              MOV      r3,r0
;;;88     	BYTE drv,		/* Physical drive nmuber (0..) */
;;;89     	BYTE ctrl,		/* Control code */
;;;90     	void *buff		/* Buffer to send/receive control data */
;;;91     )
;;;92     {
;;;93     	return RES_OK;
00004a  2000              MOVS     r0,#0
;;;94     }
00004c  4770              BX       lr
;;;95     
                          ENDP

                  get_fattime PROC
;;;96     DWORD get_fattime(void){
00004e  2000              MOVS     r0,#0
;;;97     	return 0;
;;;98     }
000050  4770              BX       lr
;;;99     
                          ENDP

