; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\wm.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\wm.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\wm.crf GUI\WM\WM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _CheckCriticalHandles PROC
;;;99     */
;;;100    static void _CheckCriticalHandles(WM_HWIN hWin) {
000000  4601              MOV      r1,r0
;;;101      WM_CRITICAL_HANDLE * pCH;
;;;102      for (pCH = WM__pFirstCriticalHandle; pCH; pCH = pCH->pNext) {
000002  4afe              LDR      r2,|L1.1020|
000004  6810              LDR      r0,[r2,#0]  ; WM__pFirstCriticalHandle
000006  e007              B        |L1.24|
                  |L1.8|
;;;103        if (pCH->hWin == hWin) {
000008  f9b02004          LDRSH    r2,[r0,#4]
00000c  428a              CMP      r2,r1
00000e  d102              BNE      |L1.22|
;;;104          pCH->hWin = 0;
000010  f04f0200          MOV      r2,#0
000014  8082              STRH     r2,[r0,#4]
                  |L1.22|
000016  6800              LDR      r0,[r0,#0]            ;102
                  |L1.24|
000018  2800              CMP      r0,#0                 ;102
00001a  d1f5              BNE      |L1.8|
;;;105        }
;;;106      }
;;;107    }
00001c  4770              BX       lr
;;;108    
                          ENDP

                  _DesktopHandle2Index PROC
;;;119    */
;;;120    static int _DesktopHandle2Index(WM_HWIN hDesktop) {
00001e  4601              MOV      r1,r0
;;;121    #if GUI_NUM_LAYERS > 1
;;;122      int i;
;;;123      for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;124        if (hDesktop == WM__ahDesktopWin[i]) {
;;;125          return i;
;;;126        }
;;;127      }
;;;128    #else
;;;129      if (hDesktop == WM__ahDesktopWin[0]) {
000020  48f7              LDR      r0,|L1.1024|
000022  f9b00000          LDRSH    r0,[r0,#0]  ; WM__ahDesktopWin
000026  4288              CMP      r0,r1
000028  d101              BNE      |L1.46|
;;;130        return 0;
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;131      }
;;;132    #endif
;;;133      return -1;
;;;134    }
00002c  4770              BX       lr
                  |L1.46|
00002e  f04f30ff          MOV      r0,#0xffffffff        ;133
000032  e7fb              B        |L1.44|
;;;135    
                          ENDP

                  ResetNextDrawWin PROC
;;;155    */
;;;156    static void ResetNextDrawWin(void) {
000034  f04f0000          MOV      r0,#0
;;;157      NextDrawWin = WM_HWIN_NULL;
000038  49f2              LDR      r1,|L1.1028|
00003a  8008              STRH     r0,[r1,#0]
;;;158    }
00003c  4770              BX       lr
;;;159    
                          ENDP

                  _GethDrawWin PROC
;;;167    */
;;;168    static WM_HWIN _GethDrawWin(void) {
00003e  49f2              LDR      r1,|L1.1032|
;;;169      WM_HWIN h;
;;;170      #if WM_SUPPORT_TRANSPARENCY
;;;171        if (WM__hATransWindow) {
000040  8809              LDRH     r1,[r1,#0]  ; WM__hATransWindow
000042  b119              CBZ      r1,|L1.76|
;;;172          h = WM__hATransWindow;
000044  49f0              LDR      r1,|L1.1032|
000046  f9b10000          LDRSH    r0,[r1,#0]  ; WM__hATransWindow
00004a  e002              B        |L1.82|
                  |L1.76|
;;;173        } else
;;;174      #endif
;;;175      {
;;;176        h = GUI_Context.hAWin;
00004c  49ef              LDR      r1,|L1.1036|
00004e  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
                  |L1.82|
;;;177      }
;;;178      return h;
;;;179    }
000052  4770              BX       lr
;;;180    
                          ENDP

                  WM__Client2Screen PROC
;;;462    */
;;;463    void WM__Client2Screen(const WM_Obj* pWin, GUI_RECT *pRect) {
000054  b570              PUSH     {r4-r6,lr}
000056  4604              MOV      r4,r0
000058  460d              MOV      r5,r1
;;;464      GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
00005a  f9b42002          LDRSH    r2,[r4,#2]
00005e  f9b41000          LDRSH    r1,[r4,#0]
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       GUI_MoveRect
;;;465    }
000068  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP

                  _SetClipRectUserIntersect PROC
;;;184    */
;;;185    static void _SetClipRectUserIntersect(const GUI_RECT* prSrc) {
00006a  b57c              PUSH     {r2-r6,lr}
00006c  4604              MOV      r4,r0
;;;186      if (GUI_Context.WM__pUserClipRect == NULL) {
00006e  48e7              LDR      r0,|L1.1036|
000070  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
000072  b918              CBNZ     r0,|L1.124|
;;;187        LCD_SetClipRectEx(prSrc);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       LCD_SetClipRectEx
00007a  e016              B        |L1.170|
                  |L1.124|
;;;188      } else {
;;;189        GUI_RECT r;
;;;190        r = *GUI_Context.WM__pUserClipRect;             
00007c  48e3              LDR      r0,|L1.1036|
00007e  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
000080  6801              LDR      r1,[r0,#0]
000082  9100              STR      r1,[sp,#0]
000084  6840              LDR      r0,[r0,#4]
000086  9001              STR      r0,[sp,#4]
;;;191        WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
000088  f7fffffe          BL       _GethDrawWin
00008c  4606              MOV      r6,r0
00008e  f7fffffe          BL       GUI_ALLOC_h2p
000092  4605              MOV      r5,r0
000094  4669              MOV      r1,sp
000096  f7fffffe          BL       WM__Client2Screen
;;;192        /* Set intersection as clip rect */    
;;;193        GUI__IntersectRect(&r, prSrc);
00009a  4621              MOV      r1,r4
00009c  4668              MOV      r0,sp
00009e  f7fffffe          BL       GUI__IntersectRect
;;;194        LCD_SetClipRectEx(&r);
0000a2  4668              MOV      r0,sp
0000a4  f7fffffe          BL       LCD_SetClipRectEx
;;;195      }
0000a8  bf00              NOP      
                  |L1.170|
;;;196    }
0000aa  bd7c              POP      {r2-r6,pc}
;;;197    
                          ENDP

                  WM__RectIsNZ PROC
;;;613    */
;;;614    int WM__RectIsNZ(const GUI_RECT* pr) {
0000ac  4601              MOV      r1,r0
;;;615      if (pr->x0 > pr->x1)
0000ae  f9b10000          LDRSH    r0,[r1,#0]
0000b2  f9b12004          LDRSH    r2,[r1,#4]
0000b6  4290              CMP      r0,r2
0000b8  dd01              BLE      |L1.190|
;;;616        return 0;
0000ba  2000              MOVS     r0,#0
                  |L1.188|
;;;617      if (pr->y0 > pr->y1)
;;;618        return 0;
;;;619      return 1;
;;;620    }
0000bc  4770              BX       lr
                  |L1.190|
0000be  f9b10002          LDRSH    r0,[r1,#2]            ;617
0000c2  f9b12006          LDRSH    r2,[r1,#6]            ;617
0000c6  4290              CMP      r0,r2                 ;617
0000c8  dd01              BLE      |L1.206|
0000ca  2000              MOVS     r0,#0                 ;618
0000cc  e7f6              B        |L1.188|
                  |L1.206|
0000ce  2001              MOVS     r0,#1                 ;619
0000d0  e7f4              B        |L1.188|
;;;621    
                          ENDP

                  WM__Invalidate1Abs PROC
;;;209    */
;;;210    void WM__Invalidate1Abs(WM_HWIN hWin, const GUI_RECT * pRect) {
0000d2  e92d41fc          PUSH     {r2-r8,lr}
0000d6  4607              MOV      r7,r0
0000d8  460d              MOV      r5,r1
;;;211      GUI_RECT r;
;;;212      WM_Obj* pWin;
;;;213      int Status;
;;;214      pWin = WM_H2P(hWin);
0000da  4638              MOV      r0,r7
0000dc  f7fffffe          BL       GUI_ALLOC_h2p
0000e0  4604              MOV      r4,r0
;;;215      Status = pWin->Status;
0000e2  8ba6              LDRH     r6,[r4,#0x1c]
;;;216      if ((Status & WM_SF_ISVIS) == 0) {
0000e4  f0160f02          TST      r6,#2
0000e8  d101              BNE      |L1.238|
                  |L1.234|
;;;217        return;   /* Window is not visible... we are done */
;;;218      }
;;;219      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
;;;220        return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
;;;221      }
;;;222      if (WM__RectIsNZ(pRect) == 0) {
;;;223        return;   /* Nothing to do ... */
;;;224      }
;;;225      /* Calc affected area */
;;;226      GUI__IntersectRects(&r, pRect, &pWin->Rect);
;;;227      if (WM__RectIsNZ(&r)) {
;;;228        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;229          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;230        #endif
;;;231    
;;;232        if (pWin->Status & WM_SF_INVALID) {
;;;233          GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
;;;234        } else {
;;;235          pWin->InvalidRect = r;
;;;236          pWin->Status |= WM_SF_INVALID;
;;;237          WM__NumInvalidWindows++;
;;;238          /* Optional code: Call external routine to notify that drawing is required */
;;;239          #ifdef GUI_X_REDRAW
;;;240          if (_IsInited) {
;;;241            GUI_RECT r;
;;;242            r = pWin->Rect;
;;;243            if (WM__ClipAtParentBorders(&r,  hWin)) {
;;;244              GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
;;;245            }
;;;246          }
;;;247          #endif
;;;248          GUI_X_SIGNAL_EVENT();
;;;249        }
;;;250        /* Debug code: shows invalid areas */
;;;251        #if (WM_SUPPORT_DIAG)
;;;252          if (WM__pfShowInvalid) {
;;;253            (WM__pfShowInvalid)(hWin);
;;;254          }
;;;255        #endif
;;;256      }
;;;257    }
0000ea  e8bd81fc          POP      {r2-r8,pc}
                  |L1.238|
0000ee  f6400001          MOV      r0,#0x801             ;219
0000f2  4030              ANDS     r0,r0,r6              ;219
0000f4  2801              CMP      r0,#1                 ;219
0000f6  d100              BNE      |L1.250|
0000f8  e7f7              B        |L1.234|
                  |L1.250|
0000fa  4628              MOV      r0,r5                 ;222
0000fc  f7fffffe          BL       WM__RectIsNZ
000100  b900              CBNZ     r0,|L1.260|
000102  e7f2              B        |L1.234|
                  |L1.260|
000104  4622              MOV      r2,r4                 ;226
000106  4629              MOV      r1,r5                 ;226
000108  4668              MOV      r0,sp                 ;226
00010a  f7fffffe          BL       GUI__IntersectRects
00010e  4668              MOV      r0,sp                 ;227
000110  f7fffffe          BL       WM__RectIsNZ
000114  b1c0              CBZ      r0,|L1.328|
000116  8ba0              LDRH     r0,[r4,#0x1c]         ;232
000118  f0100f20          TST      r0,#0x20              ;232
00011c  d006              BEQ      |L1.300|
00011e  466a              MOV      r2,sp                 ;233
000120  f1040108          ADD      r1,r4,#8              ;233
000124  4608              MOV      r0,r1                 ;233
000126  f7fffffe          BL       GUI_MergeRect
00012a  e00d              B        |L1.328|
                  |L1.300|
00012c  9800              LDR      r0,[sp,#0]            ;235
00012e  60a0              STR      r0,[r4,#8]            ;235
000130  9801              LDR      r0,[sp,#4]            ;235
000132  60e0              STR      r0,[r4,#0xc]          ;235
000134  8ba0              LDRH     r0,[r4,#0x1c]         ;236
000136  f0400020          ORR      r0,r0,#0x20           ;236
00013a  83a0              STRH     r0,[r4,#0x1c]         ;236
00013c  48b4              LDR      r0,|L1.1040|
00013e  8800              LDRH     r0,[r0,#0]            ;237  ; WM__NumInvalidWindows
000140  f1000001          ADD      r0,r0,#1              ;237
000144  49b2              LDR      r1,|L1.1040|
000146  8008              STRH     r0,[r1,#0]            ;237
                  |L1.328|
000148  bf00              NOP      
00014a  e7ce              B        |L1.234|
;;;258    
                          ENDP

                  WM__ClipAtParentBorders PROC
;;;281    */
;;;282    int WM__ClipAtParentBorders(GUI_RECT* pRect, WM_HWIN hWin) {
00014c  b570              PUSH     {r4-r6,lr}
00014e  4606              MOV      r6,r0
000150  460d              MOV      r5,r1
;;;283      WM_Obj* pWin;
;;;284    
;;;285      /* Iterate up the window hierarchy.
;;;286         If the window is invisible, we are done.
;;;287         Clip at parent boarders.
;;;288         We are done with iterating if hWin has no parent.
;;;289      */
;;;290      do {
000152  bf00              NOP      
                  |L1.340|
;;;291        pWin = WM_H2P(hWin);
000154  4628              MOV      r0,r5
000156  f7fffffe          BL       GUI_ALLOC_h2p
00015a  4604              MOV      r4,r0
;;;292        if ((pWin->Status & WM_SF_ISVIS) == 0) {
00015c  8ba0              LDRH     r0,[r4,#0x1c]
00015e  f0100f02          TST      r0,#2
000162  d101              BNE      |L1.360|
;;;293          return 0;                     /* Invisible */
000164  2000              MOVS     r0,#0
                  |L1.358|
;;;294        }
;;;295        GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
;;;296        if (pWin->hParent == 0) {
;;;297          break;   /* hWin is now the top level window which has no parent */
;;;298        }
;;;299        hWin = pWin->hParent;                    /* Go one level up (parent)*/
;;;300      } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
;;;301      
;;;302      /* Now check if the top level window is a desktop window. If it is not,
;;;303        then the window is not visible.
;;;304      */
;;;305      if (_DesktopHandle2Index(hWin) < 0) {
;;;306        return 0;           /* No desktop - (unattached) - Nothing to draw */
;;;307      }
;;;308      return 1;               /* Something may be visible */
;;;309    }
000166  bd70              POP      {r4-r6,pc}
                  |L1.360|
000168  4621              MOV      r1,r4                 ;295
00016a  4630              MOV      r0,r6                 ;295
00016c  f7fffffe          BL       GUI__IntersectRect
000170  8ae0              LDRH     r0,[r4,#0x16]         ;296
000172  b900              CBNZ     r0,|L1.374|
000174  e002              B        |L1.380|
                  |L1.374|
000176  f9b45016          LDRSH    r5,[r4,#0x16]         ;299
00017a  e7eb              B        |L1.340|
                  |L1.380|
00017c  bf00              NOP                            ;297
00017e  4628              MOV      r0,r5                 ;305
000180  f7fffffe          BL       _DesktopHandle2Index
000184  2800              CMP      r0,#0                 ;305
000186  da01              BGE      |L1.396|
000188  2000              MOVS     r0,#0                 ;306
00018a  e7ec              B        |L1.358|
                  |L1.396|
00018c  2001              MOVS     r0,#1                 ;308
00018e  e7ea              B        |L1.358|
;;;310    
                          ENDP

                  WM__ActivateClipRect PROC
;;;314    */
;;;315    void  WM__ActivateClipRect(void) {
000190  b51c              PUSH     {r2-r4,lr}
;;;316      if (WM_IsActive) {
000192  48a0              LDR      r0,|L1.1044|
000194  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000196  b118              CBZ      r0,|L1.416|
;;;317        _SetClipRectUserIntersect(&_ClipContext.CurRect);
000198  489f              LDR      r0,|L1.1048|
00019a  f7fffffe          BL       _SetClipRectUserIntersect
00019e  e016              B        |L1.462|
                  |L1.416|
;;;318      } else {    /* Window manager disabled, typically because meory device is active */
;;;319        GUI_RECT r;
;;;320        WM_Obj *pAWin;
;;;321        pAWin = WM_H2P(GUI_Context.hAWin);
0001a0  499a              LDR      r1,|L1.1036|
0001a2  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
0001a6  f7fffffe          BL       GUI_ALLOC_h2p
0001aa  4604              MOV      r4,r0
;;;322        r = pAWin->Rect;
0001ac  e9d40100          LDRD     r0,r1,[r4,#0]
0001b0  e9cd0100          STRD     r0,r1,[sp,#0]
;;;323        #if WM_SUPPORT_TRANSPARENCY
;;;324          if (WM__hATransWindow) {
0001b4  4894              LDR      r0,|L1.1032|
0001b6  8800              LDRH     r0,[r0,#0]  ; WM__hATransWindow
0001b8  b128              CBZ      r0,|L1.454|
;;;325            WM__ClipAtParentBorders(&r, WM__hATransWindow);
0001ba  4893              LDR      r0,|L1.1032|
0001bc  f9b01000          LDRSH    r1,[r0,#0]  ; WM__hATransWindow
0001c0  4668              MOV      r0,sp
0001c2  f7fffffe          BL       WM__ClipAtParentBorders
                  |L1.454|
;;;326          }
;;;327        #endif
;;;328        /* Take UserClipRect into account */
;;;329        _SetClipRectUserIntersect(&r);
0001c6  4668              MOV      r0,sp
0001c8  f7fffffe          BL       _SetClipRectUserIntersect
;;;330      }
0001cc  bf00              NOP      
                  |L1.462|
;;;331    }
0001ce  bd1c              POP      {r2-r4,pc}
;;;332    
                          ENDP

                  WM__InsertWindowIntoList PROC
;;;341    */
;;;342    void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
0001d0  e92d4ff8          PUSH     {r3-r11,lr}
0001d4  4606              MOV      r6,r0
0001d6  4688              MOV      r8,r1
;;;343      int OnTop;
;;;344      WM_HWIN hi;
;;;345      WM_Obj * pWin;
;;;346      WM_Obj * pParent;
;;;347      WM_Obj * pi;
;;;348    
;;;349      if (hParent) {
0001d8  f1b80f00          CMP      r8,#0
0001dc  d040              BEQ      |L1.608|
;;;350        pWin = WM_H2P(hWin);
0001de  4630              MOV      r0,r6
0001e0  f7fffffe          BL       GUI_ALLOC_h2p
0001e4  4604              MOV      r4,r0
;;;351        pWin->hNext = 0;
0001e6  f04f0000          MOV      r0,#0
0001ea  8360              STRH     r0,[r4,#0x1a]
;;;352        pWin->hParent = hParent;
0001ec  f8a48016          STRH     r8,[r4,#0x16]
;;;353        pParent = WM_H2P(hParent);
0001f0  4640              MOV      r0,r8
0001f2  f7fffffe          BL       GUI_ALLOC_h2p
0001f6  4607              MOV      r7,r0
;;;354        OnTop   = pWin->Status & WM_CF_STAYONTOP;
0001f8  8ba0              LDRH     r0,[r4,#0x1c]
0001fa  f0000b08          AND      r11,r0,#8
;;;355        hi = pParent->hFirstChild;
0001fe  f9b79018          LDRSH    r9,[r7,#0x18]
;;;356        /* Put it at beginning of the list if there is no child */
;;;357        if (hi == 0) {   /* No child yet ... Makes things easy ! */
000202  f1b90f00          CMP      r9,#0
000206  d102              BNE      |L1.526|
;;;358          pParent->hFirstChild = hWin;
000208  833e              STRH     r6,[r7,#0x18]
                  |L1.522|
;;;359          return;                         /* Early out ... We are done */
;;;360        }
;;;361        /* Put it at beginning of the list if first child is a TOP window and new one is not */
;;;362        pi = WM_H2P(hi);
;;;363        if (!OnTop) {
;;;364          if (pi->Status & WM_SF_STAYONTOP) {
;;;365            pWin->hNext = hi;
;;;366            pParent->hFirstChild = hWin;
;;;367            return;                         /* Early out ... We are done */
;;;368          }
;;;369        }
;;;370        /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
;;;371        do {
;;;372          WM_Obj* pNext;
;;;373          WM_HWIN hNext;
;;;374          if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
;;;375            pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
;;;376            break;
;;;377          }
;;;378          pNext = WM_H2P(hNext);
;;;379          if (!OnTop) {
;;;380            if (pNext->Status & WM_SF_STAYONTOP) {
;;;381              pi->hNext = hWin;
;;;382              pWin->hNext = hNext;
;;;383              break;
;;;384            }
;;;385          }
;;;386          pi = pNext;
;;;387        }  while (1);
;;;388        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;389          WM__NotifyVisChanged(hWin, &pWin->Rect);
;;;390        #endif
;;;391      }
;;;392    }
00020a  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.526|
00020e  4648              MOV      r0,r9                 ;362
000210  f7fffffe          BL       GUI_ALLOC_h2p
000214  4605              MOV      r5,r0                 ;362
000216  f1bb0f00          CMP      r11,#0                ;363
00021a  d107              BNE      |L1.556|
00021c  8ba8              LDRH     r0,[r5,#0x1c]         ;364
00021e  f0100f08          TST      r0,#8                 ;364
000222  d003              BEQ      |L1.556|
000224  f8a4901a          STRH     r9,[r4,#0x1a]         ;365
000228  833e              STRH     r6,[r7,#0x18]         ;366
00022a  e7ee              B        |L1.522|
                  |L1.556|
00022c  bf00              NOP                            ;371
                  |L1.558|
00022e  f9b5001a          LDRSH    r0,[r5,#0x1a]         ;374
000232  9000              STR      r0,[sp,#0]            ;374
000234  b908              CBNZ     r0,|L1.570|
000236  836e              STRH     r6,[r5,#0x1a]         ;375
000238  e011              B        |L1.606|
                  |L1.570|
00023a  9800              LDR      r0,[sp,#0]            ;378
00023c  f7fffffe          BL       GUI_ALLOC_h2p
000240  4682              MOV      r10,r0                ;378
000242  f1bb0f00          CMP      r11,#0                ;379
000246  d108              BNE      |L1.602|
000248  f8ba001c          LDRH     r0,[r10,#0x1c]        ;380
00024c  f0100f08          TST      r0,#8                 ;380
000250  d003              BEQ      |L1.602|
000252  836e              STRH     r6,[r5,#0x1a]         ;381
000254  9800              LDR      r0,[sp,#0]            ;382
000256  8360              STRH     r0,[r4,#0x1a]         ;382
000258  e001              B        |L1.606|
                  |L1.602|
00025a  4655              MOV      r5,r10                ;386
00025c  e7e7              B        |L1.558|
                  |L1.606|
00025e  bf00              NOP                            ;376
                  |L1.608|
000260  bf00              NOP      
000262  e7d2              B        |L1.522|
;;;393    
                          ENDP

                  WM__RemoveWindowFromList PROC
;;;397    */
;;;398    void WM__RemoveWindowFromList(WM_HWIN hWin) {
000264  e92d47f0          PUSH     {r4-r10,lr}
000268  4607              MOV      r7,r0
;;;399      WM_HWIN hi, hParent;
;;;400      WM_Obj * pWin, * pParent, * pi;
;;;401      
;;;402      pWin = WM_H2P(hWin);
00026a  4638              MOV      r0,r7
00026c  f7fffffe          BL       GUI_ALLOC_h2p
000270  4681              MOV      r9,r0
;;;403      hParent = pWin->hParent;
000272  f9b98016          LDRSH    r8,[r9,#0x16]
;;;404      if (hParent) {
000276  f1b80f00          CMP      r8,#0
00027a  d020              BEQ      |L1.702|
;;;405        pParent = WM_H2P(hParent);
00027c  4640              MOV      r0,r8
00027e  f7fffffe          BL       GUI_ALLOC_h2p
000282  4606              MOV      r6,r0
;;;406        hi = pParent->hFirstChild;
000284  f9b65018          LDRSH    r5,[r6,#0x18]
;;;407        if (hi == hWin) {
000288  42bd              CMP      r5,r7
00028a  d106              BNE      |L1.666|
;;;408          pi = WM_H2P(hi);
00028c  4628              MOV      r0,r5
00028e  f7fffffe          BL       GUI_ALLOC_h2p
000292  4604              MOV      r4,r0
;;;409          pParent->hFirstChild = pi->hNext;
000294  8b60              LDRH     r0,[r4,#0x1a]
000296  8330              STRH     r0,[r6,#0x18]
000298  e011              B        |L1.702|
                  |L1.666|
;;;410        } else {
;;;411          while (hi) {
00029a  e00d              B        |L1.696|
                  |L1.668|
;;;412            pi = WM_H2P(hi);
00029c  4628              MOV      r0,r5
00029e  f7fffffe          BL       GUI_ALLOC_h2p
0002a2  4604              MOV      r4,r0
;;;413            if (pi->hNext == hWin) {
0002a4  f9b4001a          LDRSH    r0,[r4,#0x1a]
0002a8  42b8              CMP      r0,r7
0002aa  d103              BNE      |L1.692|
;;;414              pi->hNext = pWin->hNext;
0002ac  f8b9001a          LDRH     r0,[r9,#0x1a]
0002b0  8360              STRH     r0,[r4,#0x1a]
;;;415              break;
0002b2  e003              B        |L1.700|
                  |L1.692|
;;;416            }
;;;417            hi = pi->hNext;
0002b4  f9b4501a          LDRSH    r5,[r4,#0x1a]
                  |L1.696|
0002b8  2d00              CMP      r5,#0                 ;411
0002ba  d1ef              BNE      |L1.668|
                  |L1.700|
0002bc  bf00              NOP                            ;415
                  |L1.702|
;;;418          }
;;;419        }
;;;420      }
;;;421    }
0002be  e8bd87f0          POP      {r4-r10,pc}
;;;422    
                          ENDP

                  WM_InvalidateWindowAndDescsEx PROC
;;;490    */
;;;491    void WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect) {
0002c2  e92d47fc          PUSH     {r2-r10,lr}
0002c6  4607              MOV      r7,r0
0002c8  4689              MOV      r9,r1
;;;492      GUI_RECT Rect;
;;;493      WM_Obj*  pWin;
;;;494      WM_Obj* pChild;
;;;495      WM_HWIN hChild;
;;;496      int Status;
;;;497    
;;;498      if (hWin) {
0002ca  b337              CBZ      r7,|L1.794|
;;;499        pWin = WM_H2P(hWin);
0002cc  4638              MOV      r0,r7
0002ce  f7fffffe          BL       GUI_ALLOC_h2p
0002d2  4604              MOV      r4,r0
;;;500        Status  = pWin->Status;
0002d4  f8b4801c          LDRH     r8,[r4,#0x1c]
;;;501        if ((Status & WM_SF_ISVIS) == 0) {
0002d8  f0180f02          TST      r8,#2
0002dc  d101              BNE      |L1.738|
                  |L1.734|
;;;502          return;                                                            /* Window is not visible... we are done */
;;;503        }
;;;504        if (GUI__IntersectRects(&Rect, pInvalidRect, &pWin->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
;;;505          return;                                                            /* No intersection, nothing to do */
;;;506        }
;;;507        WM__Invalidate1Abs(hWin, &Rect);    /* Invalidate window itself */
;;;508        for (hChild = WM_GetFirstChild(hWin); hChild; hChild = pChild->hNext) {
;;;509          WM_InvalidateWindowAndDescsEx(hChild, &Rect);
;;;510          pChild = WM_H2P(hChild);
;;;511        }
;;;512      }
;;;513    }
0002de  e8bd87fc          POP      {r2-r10,pc}
                  |L1.738|
0002e2  4622              MOV      r2,r4                 ;504
0002e4  4649              MOV      r1,r9                 ;504
0002e6  4668              MOV      r0,sp                 ;504
0002e8  f7fffffe          BL       GUI__IntersectRects
0002ec  b900              CBNZ     r0,|L1.752|
0002ee  e7f6              B        |L1.734|
                  |L1.752|
0002f0  4669              MOV      r1,sp                 ;507
0002f2  4638              MOV      r0,r7                 ;507
0002f4  f7fffffe          BL       WM__Invalidate1Abs
0002f8  4638              MOV      r0,r7                 ;508
0002fa  f7fffffe          BL       WM_GetFirstChild
0002fe  4606              MOV      r6,r0                 ;508
000300  e009              B        |L1.790|
                  |L1.770|
000302  4669              MOV      r1,sp                 ;509
000304  4630              MOV      r0,r6                 ;509
000306  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
00030a  4630              MOV      r0,r6                 ;510
00030c  f7fffffe          BL       GUI_ALLOC_h2p
000310  4605              MOV      r5,r0                 ;510
000312  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;508
                  |L1.790|
000316  2e00              CMP      r6,#0                 ;508
000318  d1f3              BNE      |L1.770|
                  |L1.794|
00031a  bf00              NOP      
00031c  e7df              B        |L1.734|
;;;514    
                          ENDP

                  WM__InvalidateRectEx PROC
;;;534    */
;;;535    void WM__InvalidateRectEx(const GUI_RECT* pInvalidRect, WM_HWIN hParent, WM_HWIN hStop) {
00031e  e92d47fc          PUSH     {r2-r10,lr}
000322  4681              MOV      r9,r0
000324  460e              MOV      r6,r1
000326  4692              MOV      r10,r2
;;;536      GUI_RECT Rect;
;;;537      WM_Obj*  pParent;
;;;538      WM_Obj*  pi;
;;;539      WM_HWIN  hi;
;;;540      int Status;
;;;541    
;;;542      /* Perform some parameter checks and check for "early out" conditions. */
;;;543      if (hParent == 0) {
000328  b90e              CBNZ     r6,|L1.814|
                  |L1.810|
;;;544        return;                                                            /* Desktop window or unattached wind. Nothing to do. */
;;;545      }
;;;546      pParent = WM_H2P(hParent);
;;;547      Status  = pParent->Status;
;;;548      if ((Status & WM_SF_ISVIS) == 0) {
;;;549        return;                                                            /* Window is not visible... we are done */
;;;550      }
;;;551      if (GUI__IntersectRects(&Rect, pInvalidRect, &pParent->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
;;;552        return;                                                            /* No intersection, nothing to do */
;;;553      }
;;;554      /* Invalidate the rectangle in the parent */
;;;555      /* If the parent is (partially) transparent, we need to move up in the hierarchy */
;;;556      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
;;;557        WM__InvalidateRectEx(&Rect, pParent->hParent, pParent->hNext);
;;;558      } else {
;;;559        WM__Invalidate1Abs(hParent, &Rect);
;;;560      }
;;;561      /* Invalidate siblings up to hStop */
;;;562      for (hi = pParent->hFirstChild; hi; hi = pi->hNext) {
;;;563        if (hi == hStop) {
;;;564          break;
;;;565        }
;;;566        WM_InvalidateWindowAndDescsEx(hi, &Rect);
;;;567        pi = WM_H2P(hi);
;;;568      }
;;;569    }
00032a  e8bd87fc          POP      {r2-r10,pc}
                  |L1.814|
00032e  4630              MOV      r0,r6                 ;546
000330  f7fffffe          BL       GUI_ALLOC_h2p
000334  4604              MOV      r4,r0                 ;546
000336  f8b4801c          LDRH     r8,[r4,#0x1c]         ;547
00033a  f0180f02          TST      r8,#2                 ;548
00033e  d100              BNE      |L1.834|
000340  e7f3              B        |L1.810|
                  |L1.834|
000342  4622              MOV      r2,r4                 ;551
000344  4649              MOV      r1,r9                 ;551
000346  4668              MOV      r0,sp                 ;551
000348  f7fffffe          BL       GUI__IntersectRects
00034c  b900              CBNZ     r0,|L1.848|
00034e  e7ec              B        |L1.810|
                  |L1.848|
000350  f6400001          MOV      r0,#0x801             ;556
000354  ea080000          AND      r0,r8,r0              ;556
000358  2801              CMP      r0,#1                 ;556
00035a  d107              BNE      |L1.876|
00035c  f9b4201a          LDRSH    r2,[r4,#0x1a]         ;557
000360  f9b41016          LDRSH    r1,[r4,#0x16]         ;557
000364  4668              MOV      r0,sp                 ;557
000366  f7fffffe          BL       WM__InvalidateRectEx
00036a  e003              B        |L1.884|
                  |L1.876|
00036c  4669              MOV      r1,sp                 ;559
00036e  4630              MOV      r0,r6                 ;559
000370  f7fffffe          BL       WM__Invalidate1Abs
                  |L1.884|
000374  f9b45018          LDRSH    r5,[r4,#0x18]         ;562
000378  e00c              B        |L1.916|
                  |L1.890|
00037a  4555              CMP      r5,r10                ;563
00037c  d100              BNE      |L1.896|
00037e  e00b              B        |L1.920|
                  |L1.896|
000380  4669              MOV      r1,sp                 ;566
000382  4628              MOV      r0,r5                 ;566
000384  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
000388  4628              MOV      r0,r5                 ;567
00038a  f7fffffe          BL       GUI_ALLOC_h2p
00038e  4607              MOV      r7,r0                 ;567
000390  f9b7501a          LDRSH    r5,[r7,#0x1a]         ;562
                  |L1.916|
000394  2d00              CMP      r5,#0                 ;562
000396  d1f0              BNE      |L1.890|
                  |L1.920|
000398  bf00              NOP                            ;564
00039a  bf00              NOP      
00039c  e7c5              B        |L1.810|
;;;570    
                          ENDP

                  WM__DetachWindow PROC
;;;430    */
;;;431    void WM__DetachWindow(WM_HWIN hWin) {
00039e  b570              PUSH     {r4-r6,lr}
0003a0  4605              MOV      r5,r0
;;;432      WM_Obj* pWin;
;;;433      WM_HWIN hParent;
;;;434      pWin = WM_H2P(hWin);
0003a2  4628              MOV      r0,r5
0003a4  f7fffffe          BL       GUI_ALLOC_h2p
0003a8  4604              MOV      r4,r0
;;;435      hParent = pWin->hParent;
0003aa  f9b46016          LDRSH    r6,[r4,#0x16]
;;;436      if (hParent) {
0003ae  b166              CBZ      r6,|L1.970|
;;;437        WM__InvalidateRectEx(&pWin->Rect, pWin->hParent, pWin->hNext);
0003b0  f9b4201a          LDRSH    r2,[r4,#0x1a]
0003b4  f9b41016          LDRSH    r1,[r4,#0x16]
0003b8  4620              MOV      r0,r4
0003ba  f7fffffe          BL       WM__InvalidateRectEx
;;;438        WM__RemoveWindowFromList(hWin);
0003be  4628              MOV      r0,r5
0003c0  f7fffffe          BL       WM__RemoveWindowFromList
;;;439        pWin->hParent = 0;
0003c4  f04f0000          MOV      r0,#0
0003c8  82e0              STRH     r0,[r4,#0x16]
                  |L1.970|
;;;440      }
;;;441    }
0003ca  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP

                  WM_SelectWindow PROC
;;;1001   */
;;;1002   WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
0003cc  b570              PUSH     {r4-r6,lr}
0003ce  4604              MOV      r4,r0
;;;1003     WM_HWIN hWinPrev;
;;;1004     WM_Obj* pObj;
;;;1005   
;;;1006     WM_ASSERT_NOT_IN_PAINT();
;;;1007     WM_LOCK();
;;;1008     hWinPrev = GUI_Context.hAWin;
0003d0  480e              LDR      r0,|L1.1036|
0003d2  f9b0603c          LDRSH    r6,[r0,#0x3c]  ; GUI_Context
;;;1009     if (hWin == 0) {
0003d6  b914              CBNZ     r4,|L1.990|
;;;1010       hWin = WM__FirstWin;
0003d8  4810              LDR      r0,|L1.1052|
0003da  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
                  |L1.990|
;;;1011     }
;;;1012     /* Select new window */
;;;1013     GUI_Context.hAWin = hWin;
0003de  480b              LDR      r0,|L1.1036|
0003e0  8784              STRH     r4,[r0,#0x3c]
;;;1014     #if GUI_NUM_LAYERS > 1
;;;1015     {
;;;1016       WM_HWIN hTop;
;;;1017       int LayerIndex;
;;;1018       hTop = _GetTopLevelWindow(hWin);
;;;1019       LayerIndex = _DesktopHandle2Index(hTop);
;;;1020       if (LayerIndex >= 0) {
;;;1021         GUI_SelectLayer(LayerIndex);
;;;1022       }
;;;1023     }
;;;1024     #endif
;;;1025     pObj = WM_H2P(hWin);
0003e2  4620              MOV      r0,r4
0003e4  f7fffffe          BL       GUI_ALLOC_h2p
0003e8  4605              MOV      r5,r0
;;;1026     LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
0003ea  f7fffffe          BL       LCD_SetClipRectMax
;;;1027     GUI_Context.xOff = pObj->Rect.x0;
0003ee  f9b50000          LDRSH    r0,[r5,#0]
0003f2  4906              LDR      r1,|L1.1036|
0003f4  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;1028     GUI_Context.yOff = pObj->Rect.y0;
0003f6  f9b50002          LDRSH    r0,[r5,#2]
0003fa  e011              B        |L1.1056|
                  |L1.1020|
                          DCD      WM__pFirstCriticalHandle
                  |L1.1024|
                          DCD      WM__ahDesktopWin
                  |L1.1028|
                          DCD      NextDrawWin
                  |L1.1032|
                          DCD      WM__hATransWindow
                  |L1.1036|
                          DCD      GUI_Context
                  |L1.1040|
                          DCD      WM__NumInvalidWindows
                  |L1.1044|
                          DCD      WM_IsActive
                  |L1.1048|
                          DCD      _ClipContext+0x8
                  |L1.1052|
                          DCD      WM__FirstWin
                  |L1.1056|
000420  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;1029     WM_UNLOCK();
;;;1030     return hWinPrev;
000422  4630              MOV      r0,r6
;;;1031   }
000424  bd70              POP      {r4-r6,pc}
;;;1032   
                          ENDP

                  WM__RemoveFromLinList PROC
;;;574    */
;;;575    void WM__RemoveFromLinList(WM_HWIN hWin) {
000426  e92d41f0          PUSH     {r4-r8,lr}
00042a  4606              MOV      r6,r0
;;;576      WM_Obj* piWin;
;;;577      WM_HWIN hiWin;
;;;578      WM_HWIN hNext;
;;;579      for (hiWin = WM__FirstWin; hiWin; ) {
00042c  48f9              LDR      r0,|L1.2068|
00042e  f9b07000          LDRSH    r7,[r0,#0]  ; WM__FirstWin
000432  e00e              B        |L1.1106|
                  |L1.1076|
;;;580        piWin = WM_H2P(hiWin);
000434  4638              MOV      r0,r7
000436  f7fffffe          BL       GUI_ALLOC_h2p
00043a  4604              MOV      r4,r0
;;;581        hNext = piWin->hNextLin;
00043c  f9b45014          LDRSH    r5,[r4,#0x14]
;;;582        if (hNext == hWin) {
000440  42b5              CMP      r5,r6
000442  d105              BNE      |L1.1104|
;;;583          piWin->hNextLin = WM_H2P(hWin)->hNextLin;
000444  4630              MOV      r0,r6
000446  f7fffffe          BL       GUI_ALLOC_h2p
00044a  8a80              LDRH     r0,[r0,#0x14]
00044c  82a0              STRH     r0,[r4,#0x14]
;;;584          break;
00044e  e002              B        |L1.1110|
                  |L1.1104|
;;;585        }
;;;586        hiWin = hNext;
000450  462f              MOV      r7,r5
                  |L1.1106|
000452  2f00              CMP      r7,#0                 ;579
000454  d1ee              BNE      |L1.1076|
                  |L1.1110|
000456  bf00              NOP                            ;584
;;;587      }
;;;588    }
000458  e8bd81f0          POP      {r4-r8,pc}
;;;589    
                          ENDP

                  WM__SendMsgNoData PROC
;;;753    */
;;;754    void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
00045c  b53e              PUSH     {r1-r5,lr}
00045e  4605              MOV      r5,r0
000460  460c              MOV      r4,r1
;;;755      WM_MESSAGE Msg;
;;;756      Msg.hWin  = hWin;
000462  f8ad5004          STRH     r5,[sp,#4]
;;;757      Msg.MsgId = MsgId;
000466  9400              STR      r4,[sp,#0]
;;;758      WM__SendMessage(hWin, &Msg);
000468  4669              MOV      r1,sp
00046a  4628              MOV      r0,r5
00046c  f7fffffe          BL       WM__SendMessage
;;;759    }
000470  bd3e              POP      {r1-r5,pc}
;;;760    
                          ENDP

                  WM__IsWindow PROC
;;;470    */
;;;471    int WM__IsWindow(WM_HWIN hWin) {
000472  b570              PUSH     {r4-r6,lr}
000474  4605              MOV      r5,r0
;;;472      WM_HWIN iWin;
;;;473      for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
000476  48e7              LDR      r0,|L1.2068|
000478  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
00047c  e008              B        |L1.1168|
                  |L1.1150|
;;;474        if (iWin == hWin) {
00047e  42ac              CMP      r4,r5
000480  d101              BNE      |L1.1158|
;;;475          return 1;
000482  2001              MOVS     r0,#1
                  |L1.1156|
;;;476        }
;;;477      }
;;;478      return 0;
;;;479    }
000484  bd70              POP      {r4-r6,pc}
                  |L1.1158|
000486  4620              MOV      r0,r4                 ;473
000488  f7fffffe          BL       GUI_ALLOC_h2p
00048c  f9b04014          LDRSH    r4,[r0,#0x14]         ;473
                  |L1.1168|
000490  2c00              CMP      r4,#0                 ;473
000492  d1f4              BNE      |L1.1150|
000494  2000              MOVS     r0,#0                 ;478
000496  e7f5              B        |L1.1156|
;;;480    
                          ENDP

                  WM_DeleteWindow PROC
;;;942    */
;;;943    void WM_DeleteWindow (WM_HWIN hWin) {
000498  b570              PUSH     {r4-r6,lr}
00049a  4604              MOV      r4,r0
;;;944      WM_Obj* pWin;
;;;945      if (!hWin) {
00049c  b904              CBNZ     r4,|L1.1184|
                  |L1.1182|
;;;946        return;
;;;947      }
;;;948      WM_ASSERT_NOT_IN_PAINT();
;;;949      WM_LOCK();
;;;950      if (WM__IsWindow(hWin)) {
;;;951        pWin = WM_H2P(hWin);
;;;952        ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
;;;953      /* Make sure that focus is set to an existing window */
;;;954        if (WM__hWinFocus == hWin) {
;;;955          WM__hWinFocus = 0;
;;;956        }
;;;957        if (WM__hCapture == hWin) {
;;;958          WM__hCapture = 0;
;;;959        }
;;;960        /* check if critical handles are affected. If so, reset the window handle to 0 */
;;;961        _CheckCriticalHandles(hWin);
;;;962        /* Inform parent */
;;;963        WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
;;;964        /* Delete all children */
;;;965        _DeleteAllChildren(pWin);
;;;966        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;967          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;968        #endif
;;;969        /* Send WM_DELETE message to window in order to inform window itself */
;;;970        WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
;;;971        WM__DetachWindow(hWin);
;;;972        /* Remove window from window stack */
;;;973        WM__RemoveFromLinList(hWin);
;;;974        /* Handle transparency counter if necessary */
;;;975        #if WM_SUPPORT_TRANSPARENCY
;;;976          if (pWin->Status & WM_SF_HASTRANS) {
;;;977            WM__TransWindowCnt--;
;;;978          }
;;;979        #endif
;;;980        /* Make sure window is no longer counted as invalid */
;;;981        if (pWin->Status & WM_SF_INVALID) {
;;;982          WM__NumInvalidWindows--;
;;;983        }
;;;984      /* Free window memory */
;;;985        WM__NumWindows--;
;;;986        GUI_ALLOC_Free(hWin);
;;;987      /* Select a valid window */
;;;988        WM_SelectWindow(WM__FirstWin);
;;;989      } else {
;;;990        GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
;;;991      }
;;;992      WM_UNLOCK();
;;;993    }
00049e  bd70              POP      {r4-r6,pc}
                  |L1.1184|
0004a0  4620              MOV      r0,r4                 ;950
0004a2  f7fffffe          BL       WM__IsWindow
0004a6  2800              CMP      r0,#0                 ;950
0004a8  d04d              BEQ      |L1.1350|
0004aa  4620              MOV      r0,r4                 ;951
0004ac  f7fffffe          BL       GUI_ALLOC_h2p
0004b0  4605              MOV      r5,r0                 ;951
0004b2  f7fffffe          BL       ResetNextDrawWin
0004b6  48d8              LDR      r0,|L1.2072|
0004b8  f9b00000          LDRSH    r0,[r0,#0]            ;954  ; WM__hWinFocus
0004bc  42a0              CMP      r0,r4                 ;954
0004be  d103              BNE      |L1.1224|
0004c0  f04f0000          MOV      r0,#0                 ;955
0004c4  49d4              LDR      r1,|L1.2072|
0004c6  8008              STRH     r0,[r1,#0]            ;955
                  |L1.1224|
0004c8  48d4              LDR      r0,|L1.2076|
0004ca  f9b00000          LDRSH    r0,[r0,#0]            ;957  ; WM__hCapture
0004ce  42a0              CMP      r0,r4                 ;957
0004d0  d103              BNE      |L1.1242|
0004d2  f04f0000          MOV      r0,#0                 ;958
0004d6  49d1              LDR      r1,|L1.2076|
0004d8  8008              STRH     r0,[r1,#0]            ;958
                  |L1.1242|
0004da  4620              MOV      r0,r4                 ;961
0004dc  f7fffffe          BL       _CheckCriticalHandles
0004e0  2107              MOVS     r1,#7                 ;963
0004e2  4620              MOV      r0,r4                 ;963
0004e4  f7fffffe          BL       WM_NotifyParent
0004e8  4628              MOV      r0,r5                 ;965
0004ea  f7fffffe          BL       _DeleteAllChildren
0004ee  210b              MOVS     r1,#0xb               ;970
0004f0  4620              MOV      r0,r4                 ;970
0004f2  f7fffffe          BL       WM__SendMsgNoData
0004f6  4620              MOV      r0,r4                 ;971
0004f8  f7fffffe          BL       WM__DetachWindow
0004fc  4620              MOV      r0,r4                 ;973
0004fe  f7fffffe          BL       WM__RemoveFromLinList
000502  8ba8              LDRH     r0,[r5,#0x1c]         ;976
000504  f0100f01          TST      r0,#1                 ;976
000508  d005              BEQ      |L1.1302|
00050a  48c5              LDR      r0,|L1.2080|
00050c  6800              LDR      r0,[r0,#0]            ;977  ; WM__TransWindowCnt
00050e  f1a00001          SUB      r0,r0,#1              ;977
000512  49c3              LDR      r1,|L1.2080|
000514  6008              STR      r0,[r1,#0]            ;977  ; WM__TransWindowCnt
                  |L1.1302|
000516  8ba8              LDRH     r0,[r5,#0x1c]         ;981
000518  f0100f20          TST      r0,#0x20              ;981
00051c  d005              BEQ      |L1.1322|
00051e  48c1              LDR      r0,|L1.2084|
000520  8800              LDRH     r0,[r0,#0]            ;982  ; WM__NumInvalidWindows
000522  f1a00001          SUB      r0,r0,#1              ;982
000526  49bf              LDR      r1,|L1.2084|
000528  8008              STRH     r0,[r1,#0]            ;982
                  |L1.1322|
00052a  48bf              LDR      r0,|L1.2088|
00052c  8800              LDRH     r0,[r0,#0]            ;985  ; WM__NumWindows
00052e  f1a00001          SUB      r0,r0,#1              ;985
000532  49bd              LDR      r1,|L1.2088|
000534  8008              STRH     r0,[r1,#0]            ;985
000536  4620              MOV      r0,r4                 ;986
000538  f7fffffe          BL       GUI_ALLOC_Free
00053c  48b5              LDR      r0,|L1.2068|
00053e  f9b00000          LDRSH    r0,[r0,#0]            ;988  ; WM__FirstWin
000542  f7fffffe          BL       WM_SelectWindow
                  |L1.1350|
000546  bf00              NOP      
000548  e7a9              B        |L1.1182|
;;;994    
                          ENDP

                  _DeleteAllChildren PROC
;;;446    */
;;;447    static void _DeleteAllChildren(WM_Obj * pParent) {
00054a  b510              PUSH     {r4,lr}
00054c  4604              MOV      r4,r0
;;;448      do {
00054e  bf00              NOP      
                  |L1.1360|
;;;449        WM_DeleteWindow(pParent->hFirstChild);
000550  f9b40018          LDRSH    r0,[r4,#0x18]
000554  f7fffffe          BL       WM_DeleteWindow
;;;450      } while (pParent->hFirstChild);
000558  8b20              LDRH     r0,[r4,#0x18]
00055a  2800              CMP      r0,#0
00055c  d1f8              BNE      |L1.1360|
;;;451    }
00055e  bd10              POP      {r4,pc}
;;;452    
                          ENDP

                  _AddToLinList PROC
;;;593    */
;;;594    static void _AddToLinList(WM_HWIN hNew) {
000560  b570              PUSH     {r4-r6,lr}
000562  4604              MOV      r4,r0
;;;595      WM_Obj* pFirst;
;;;596      WM_Obj* pNew;
;;;597      if (WM__FirstWin) {
000564  48ab              LDR      r0,|L1.2068|
000566  8800              LDRH     r0,[r0,#0]  ; WM__FirstWin
000568  b168              CBZ      r0,|L1.1414|
;;;598        pFirst = WM_H2P(WM__FirstWin);
00056a  48aa              LDR      r0,|L1.2068|
00056c  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
000570  f7fffffe          BL       GUI_ALLOC_h2p
000574  4606              MOV      r6,r0
;;;599        pNew   = WM_H2P(hNew);
000576  4620              MOV      r0,r4
000578  f7fffffe          BL       GUI_ALLOC_h2p
00057c  4605              MOV      r5,r0
;;;600        pNew->hNextLin = pFirst->hNextLin;
00057e  8ab0              LDRH     r0,[r6,#0x14]
000580  82a8              STRH     r0,[r5,#0x14]
;;;601        pFirst->hNextLin = hNew;
000582  82b4              STRH     r4,[r6,#0x14]
000584  e001              B        |L1.1418|
                  |L1.1414|
;;;602      } else {
;;;603        WM__FirstWin = hNew;
000586  48a3              LDR      r0,|L1.2068|
000588  8004              STRH     r4,[r0,#0]
                  |L1.1418|
;;;604      }
;;;605    }
00058a  bd70              POP      {r4-r6,pc}
;;;606    
                          ENDP

                  _Findy1 PROC
;;;626    */
;;;627    static void _Findy1(WM_HWIN iWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
00058c  e92d47fc          PUSH     {r2-r10,lr}
000590  4606              MOV      r6,r0
000592  460c              MOV      r4,r1
000594  4617              MOV      r7,r2
;;;628      WM_Obj* pWin;
;;;629      for (; iWin; iWin = pWin->hNext) { 
000596  e04e              B        |L1.1590|
                  |L1.1432|
;;;630        int Status = (pWin = WM_H2P(iWin))->Status;
000598  4630              MOV      r0,r6
00059a  f7fffffe          BL       GUI_ALLOC_h2p
00059e  4605              MOV      r5,r0
0005a0  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;631        /* Check if this window affects us at all */    
;;;632        if (Status & WM_SF_ISVIS) {
0005a4  f0180f02          TST      r8,#2
0005a8  d043              BEQ      |L1.1586|
;;;633          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;634          if (pParentRect) {
0005aa  b12f              CBZ      r7,|L1.1464|
;;;635            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
0005ac  463a              MOV      r2,r7
0005ae  4629              MOV      r1,r5
0005b0  4668              MOV      r0,sp
0005b2  f7fffffe          BL       GUI__IntersectRects
0005b6  e003              B        |L1.1472|
                  |L1.1464|
;;;636          } else {
;;;637            rWinClipped = pWin->Rect;
0005b8  e9d50100          LDRD     r0,r1,[r5,#0]
0005bc  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1472|
;;;638          }
;;;639          /* Check if this window affects us at all */    
;;;640          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
0005c0  4669              MOV      r1,sp
0005c2  4620              MOV      r0,r4
0005c4  f7fffffe          BL       GUI_RectsIntersect
0005c8  b1f8              CBZ      r0,|L1.1546|
;;;641            if ((Status & WM_SF_HASTRANS) == 0) {
0005ca  f0180f01          TST      r8,#1
0005ce  d11d              BNE      |L1.1548|
;;;642              if (pWin->Rect.y0 > pRect->y0) {
0005d0  f9b50002          LDRSH    r0,[r5,#2]
0005d4  f9b41002          LDRSH    r1,[r4,#2]
0005d8  4288              CMP      r0,r1
0005da  dd0d              BLE      |L1.1528|
;;;643                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
0005dc  f9bd0002          LDRSH    r0,[sp,#2]
0005e0  1e40              SUBS     r0,r0,#1
0005e2  f9b41006          LDRSH    r1,[r4,#6]
0005e6  4288              CMP      r0,r1
0005e8  da22              BGE      |L1.1584|
0005ea  f8bd0002          LDRH     r0,[sp,#2]
0005ee  f1a00001          SUB      r0,r0,#1
0005f2  b200              SXTH     r0,r0
0005f4  80e0              STRH     r0,[r4,#6]
0005f6  e01b              B        |L1.1584|
                  |L1.1528|
;;;644              } else {
;;;645                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
0005f8  f9bd0006          LDRSH    r0,[sp,#6]
0005fc  f9b41006          LDRSH    r1,[r4,#6]
000600  4288              CMP      r0,r1
000602  da15              BGE      |L1.1584|
000604  f8bd0006          LDRH     r0,[sp,#6]
000608  80e0              STRH     r0,[r4,#6]
                  |L1.1546|
00060a  e011              B        |L1.1584|
                  |L1.1548|
;;;646              }
;;;647            } else {
;;;648              /* Check all children*/ 
;;;649              WM_HWIN hChild;
;;;650              WM_Obj* pChild;
;;;651              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00060c  f9b59018          LDRSH    r9,[r5,#0x18]
000610  e00a              B        |L1.1576|
                  |L1.1554|
;;;652                pChild = WM_H2P(hChild);
000612  4648              MOV      r0,r9
000614  f7fffffe          BL       GUI_ALLOC_h2p
000618  4682              MOV      r10,r0
;;;653                _Findy1(hChild, pRect, &rWinClipped);
00061a  466a              MOV      r2,sp
00061c  4621              MOV      r1,r4
00061e  4648              MOV      r0,r9
000620  f7fffffe          BL       _Findy1
000624  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;651
                  |L1.1576|
000628  f1b90f00          CMP      r9,#0                 ;651
00062c  d1f1              BNE      |L1.1554|
;;;654              }
;;;655            }
00062e  bf00              NOP      
                  |L1.1584|
;;;656          }
;;;657        }
000630  bf00              NOP      
                  |L1.1586|
000632  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;629
                  |L1.1590|
000636  2e00              CMP      r6,#0                 ;629
000638  d1ae              BNE      |L1.1432|
;;;658      }
;;;659    }
00063a  e8bd87fc          POP      {r2-r10,pc}
;;;660    
                          ENDP

                  _Findx0 PROC
;;;664    */
;;;665    static int _Findx0(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
00063e  e92d5ffc          PUSH     {r2-r12,lr}
000642  4606              MOV      r6,r0
000644  460d              MOV      r5,r1
000646  4617              MOV      r7,r2
;;;666      WM_Obj* pWin;
;;;667      int r = 0;
000648  f04f0b00          MOV      r11,#0
;;;668      for (; hWin; hWin = pWin->hNext) { 
00064c  e03c              B        |L1.1736|
                  |L1.1614|
;;;669        int Status = (pWin = WM_H2P(hWin))->Status;
00064e  4630              MOV      r0,r6
000650  f7fffffe          BL       GUI_ALLOC_h2p
000654  4604              MOV      r4,r0
000656  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;670        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
00065a  f0180f02          TST      r8,#2
00065e  d031              BEQ      |L1.1732|
;;;671          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;672          if (pParentRect) {
000660  b12f              CBZ      r7,|L1.1646|
;;;673            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000662  463a              MOV      r2,r7
000664  4621              MOV      r1,r4
000666  4668              MOV      r0,sp
000668  f7fffffe          BL       GUI__IntersectRects
00066c  e003              B        |L1.1654|
                  |L1.1646|
;;;674          } else {
;;;675            rWinClipped = pWin->Rect;
00066e  e9d40100          LDRD     r0,r1,[r4,#0]
000672  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1654|
;;;676          }
;;;677          /* Check if this window affects us at all */    
;;;678          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000676  4669              MOV      r1,sp
000678  4628              MOV      r0,r5
00067a  f7fffffe          BL       GUI_RectsIntersect
00067e  b300              CBZ      r0,|L1.1730|
;;;679            if ((Status & WM_SF_HASTRANS) == 0) {
000680  f0180f01          TST      r8,#1
000684  d108              BNE      |L1.1688|
;;;680              pRect->x0 = rWinClipped.x1+1;
000686  f8bd0004          LDRH     r0,[sp,#4]
00068a  f1000001          ADD      r0,r0,#1
00068e  b200              SXTH     r0,r0
000690  8028              STRH     r0,[r5,#0]
;;;681              r = 1;
000692  f04f0b01          MOV      r11,#1
000696  e014              B        |L1.1730|
                  |L1.1688|
;;;682            } else {
;;;683              /* Check all children */
;;;684              WM_HWIN hChild;
;;;685              WM_Obj* pChild;
;;;686              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000698  f9b49018          LDRSH    r9,[r4,#0x18]
00069c  e00d              B        |L1.1722|
                  |L1.1694|
;;;687                pChild = WM_H2P(hChild);
00069e  4648              MOV      r0,r9
0006a0  f7fffffe          BL       GUI_ALLOC_h2p
0006a4  4682              MOV      r10,r0
;;;688                if (_Findx0(hChild, pRect, &rWinClipped)) {
0006a6  466a              MOV      r2,sp
0006a8  4629              MOV      r1,r5
0006aa  4648              MOV      r0,r9
0006ac  f7fffffe          BL       _Findx0
0006b0  b108              CBZ      r0,|L1.1718|
;;;689                  r = 1;
0006b2  f04f0b01          MOV      r11,#1
                  |L1.1718|
0006b6  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;686
                  |L1.1722|
0006ba  f1b90f00          CMP      r9,#0                 ;686
0006be  d1ee              BNE      |L1.1694|
;;;690                }
;;;691              }
;;;692            }
0006c0  bf00              NOP      
                  |L1.1730|
;;;693          }
;;;694        }
0006c2  bf00              NOP      
                  |L1.1732|
0006c4  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;668
                  |L1.1736|
0006c8  2e00              CMP      r6,#0                 ;668
0006ca  d1c0              BNE      |L1.1614|
;;;695      }
;;;696      return r;
0006cc  4658              MOV      r0,r11
;;;697    }
0006ce  e8bd9ffc          POP      {r2-r12,pc}
;;;698    
                          ENDP

                  _Findx1 PROC
;;;702    */
;;;703    static void _Findx1(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
0006d2  e92d47fc          PUSH     {r2-r10,lr}
0006d6  4606              MOV      r6,r0
0006d8  460d              MOV      r5,r1
0006da  4617              MOV      r7,r2
;;;704      WM_Obj* pWin;
;;;705      for (; hWin; hWin = pWin->hNext) { 
0006dc  e037              B        |L1.1870|
                  |L1.1758|
;;;706        int Status = (pWin = WM_H2P(hWin))->Status;
0006de  4630              MOV      r0,r6
0006e0  f7fffffe          BL       GUI_ALLOC_h2p
0006e4  4604              MOV      r4,r0
0006e6  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;707        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
0006ea  f0180f02          TST      r8,#2
0006ee  d02c              BEQ      |L1.1866|
;;;708          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;709          if (pParentRect) {
0006f0  b12f              CBZ      r7,|L1.1790|
;;;710            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
0006f2  463a              MOV      r2,r7
0006f4  4621              MOV      r1,r4
0006f6  4668              MOV      r0,sp
0006f8  f7fffffe          BL       GUI__IntersectRects
0006fc  e003              B        |L1.1798|
                  |L1.1790|
;;;711          } else {
;;;712            rWinClipped = pWin->Rect;
0006fe  e9d40100          LDRD     r0,r1,[r4,#0]
000702  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1798|
;;;713          }
;;;714          /* Check if this window affects us at all */    
;;;715          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000706  4669              MOV      r1,sp
000708  4628              MOV      r0,r5
00070a  f7fffffe          BL       GUI_RectsIntersect
00070e  b1d8              CBZ      r0,|L1.1864|
;;;716            if ((Status & WM_SF_HASTRANS) == 0) {
000710  f0180f01          TST      r8,#1
000714  d106              BNE      |L1.1828|
;;;717              pRect->x1 = rWinClipped.x0-1;
000716  f8bd0000          LDRH     r0,[sp,#0]
00071a  f1a00001          SUB      r0,r0,#1
00071e  b200              SXTH     r0,r0
000720  80a8              STRH     r0,[r5,#4]
000722  e011              B        |L1.1864|
                  |L1.1828|
;;;718            } else {
;;;719              /* Check all children */
;;;720              WM_HWIN hChild;
;;;721              WM_Obj* pChild;
;;;722              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000724  f9b49018          LDRSH    r9,[r4,#0x18]
000728  e00a              B        |L1.1856|
                  |L1.1834|
;;;723                pChild = WM_H2P(hChild);
00072a  4648              MOV      r0,r9
00072c  f7fffffe          BL       GUI_ALLOC_h2p
000730  4682              MOV      r10,r0
;;;724                _Findx1(hChild, pRect, &rWinClipped);
000732  466a              MOV      r2,sp
000734  4629              MOV      r1,r5
000736  4648              MOV      r0,r9
000738  f7fffffe          BL       _Findx1
00073c  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;722
                  |L1.1856|
000740  f1b90f00          CMP      r9,#0                 ;722
000744  d1f1              BNE      |L1.1834|
;;;725              }
;;;726            }
000746  bf00              NOP      
                  |L1.1864|
;;;727          }
;;;728        }
000748  bf00              NOP      
                  |L1.1866|
00074a  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;705
                  |L1.1870|
00074e  2e00              CMP      r6,#0                 ;705
000750  d1c5              BNE      |L1.1758|
;;;729      }
;;;730    }
000752  e8bd87fc          POP      {r2-r10,pc}
;;;731    
                          ENDP

                  WM_SendMessage PROC
;;;741    */
;;;742    void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000756  b570              PUSH     {r4-r6,lr}
000758  4604              MOV      r4,r0
00075a  460d              MOV      r5,r1
;;;743      if (hWin) {
00075c  b11c              CBZ      r4,|L1.1894|
;;;744        WM_LOCK();
;;;745        WM__SendMessage(hWin, pMsg);
00075e  4629              MOV      r1,r5
000760  4620              MOV      r0,r4
000762  f7fffffe          BL       WM__SendMessage
                  |L1.1894|
;;;746        WM_UNLOCK();
;;;747      }  
;;;748    }
000766  bd70              POP      {r4-r6,pc}
;;;749    
                          ENDP

                  WM__GetClientRectWin PROC
;;;767    */
;;;768    void WM__GetClientRectWin(const WM_Obj* pWin, GUI_RECT* pRect) {
000768  f04f0200          MOV      r2,#0
;;;769      pRect->x0 = pRect->y0 = 0;
00076c  804a              STRH     r2,[r1,#2]
00076e  800a              STRH     r2,[r1,#0]
;;;770      pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
000770  8882              LDRH     r2,[r0,#4]
000772  8803              LDRH     r3,[r0,#0]
000774  eba20203          SUB      r2,r2,r3
000778  b212              SXTH     r2,r2
00077a  808a              STRH     r2,[r1,#4]
;;;771      pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
00077c  88c2              LDRH     r2,[r0,#6]
00077e  8843              LDRH     r3,[r0,#2]
000780  eba20203          SUB      r2,r2,r3
000784  b212              SXTH     r2,r2
000786  80ca              STRH     r2,[r1,#6]
;;;772    }
000788  4770              BX       lr
;;;773    
                          ENDP

                  WM__GetInvalidRectAbs PROC
;;;777    */
;;;778    static void WM__GetInvalidRectAbs(WM_Obj* pWin, GUI_RECT* pRect) {
00078a  6882              LDR      r2,[r0,#8]
;;;779      *pRect = pWin->InvalidRect;
00078c  600a              STR      r2,[r1,#0]
00078e  68c2              LDR      r2,[r0,#0xc]
000790  604a              STR      r2,[r1,#4]
;;;780    }
000792  4770              BX       lr
;;;781    
                          ENDP

                  WM_InvalidateRect PROC
;;;795    */
;;;796    void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT*pRect) {
000794  e92d41ff          PUSH     {r0-r8,lr}
000798  4605              MOV      r5,r0
00079a  460e              MOV      r6,r1
;;;797      GUI_RECT r;
;;;798      WM_Obj* pWin;
;;;799      int Status;
;;;800      if (hWin) {
00079c  b355              CBZ      r5,|L1.2036|
;;;801        WM_LOCK();
;;;802        pWin = WM_H2P(hWin);
00079e  4628              MOV      r0,r5
0007a0  f7fffffe          BL       GUI_ALLOC_h2p
0007a4  4604              MOV      r4,r0
;;;803        Status = pWin->Status;
0007a6  8ba7              LDRH     r7,[r4,#0x1c]
;;;804        if (Status & WM_SF_ISVIS) {
0007a8  f0170f02          TST      r7,#2
0007ac  d027              BEQ      |L1.2046|
;;;805          r = pWin->Rect;
0007ae  e9d40100          LDRD     r0,r1,[r4,#0]
0007b2  e9cd0102          STRD     r0,r1,[sp,#8]
;;;806          if (pRect) {
0007b6  b166              CBZ      r6,|L1.2002|
;;;807            GUI_RECT rPara;
;;;808            rPara = *pRect;
0007b8  6830              LDR      r0,[r6,#0]
0007ba  9000              STR      r0,[sp,#0]
0007bc  6870              LDR      r0,[r6,#4]
0007be  9001              STR      r0,[sp,#4]
;;;809            WM__Client2Screen(pWin, &rPara);
0007c0  4669              MOV      r1,sp
0007c2  4620              MOV      r0,r4
0007c4  f7fffffe          BL       WM__Client2Screen
;;;810            GUI__IntersectRect(&r, &rPara);
0007c8  4669              MOV      r1,sp
0007ca  a802              ADD      r0,sp,#8
0007cc  f7fffffe          BL       GUI__IntersectRect
;;;811          }
0007d0  bf00              NOP      
                  |L1.2002|
;;;812          if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
0007d2  4629              MOV      r1,r5
0007d4  a802              ADD      r0,sp,#8
0007d6  f7fffffe          BL       WM__ClipAtParentBorders
0007da  b158              CBZ      r0,|L1.2036|
;;;813            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
0007dc  f6400001          MOV      r0,#0x801
0007e0  4038              ANDS     r0,r0,r7
0007e2  2801              CMP      r0,#1
0007e4  d107              BNE      |L1.2038|
;;;814              WM__InvalidateRectEx(&r, pWin->hParent, pWin->hNext);
0007e6  f9b4201a          LDRSH    r2,[r4,#0x1a]
0007ea  f9b41016          LDRSH    r1,[r4,#0x16]
0007ee  a802              ADD      r0,sp,#8
0007f0  f7fffffe          BL       WM__InvalidateRectEx
                  |L1.2036|
0007f4  e003              B        |L1.2046|
                  |L1.2038|
;;;815            } else {
;;;816              WM__Invalidate1Abs(hWin, &r);
0007f6  a902              ADD      r1,sp,#8
0007f8  4628              MOV      r0,r5
0007fa  f7fffffe          BL       WM__Invalidate1Abs
                  |L1.2046|
;;;817            }
;;;818          }
;;;819        }
;;;820        WM_UNLOCK();
;;;821      }
;;;822    }
0007fe  e8bd81ff          POP      {r0-r8,pc}
;;;823    
                          ENDP

                  WM_InvalidateWindow PROC
;;;829    */
;;;830    void WM_InvalidateWindow(WM_HWIN hWin) {
000802  b510              PUSH     {r4,lr}
000804  4604              MOV      r4,r0
;;;831      WM_InvalidateRect(hWin, NULL);
000806  f04f0100          MOV      r1,#0
00080a  4620              MOV      r0,r4
00080c  f7fffffe          BL       WM_InvalidateRect
;;;832    }
000810  bd10              POP      {r4,pc}
000812  0000              DCW      0x0000
                  |L1.2068|
                          DCD      WM__FirstWin
                  |L1.2072|
                          DCD      WM__hWinFocus
                  |L1.2076|
                          DCD      WM__hCapture
                  |L1.2080|
                          DCD      WM__TransWindowCnt
                  |L1.2084|
                          DCD      WM__NumInvalidWindows
                  |L1.2088|
                          DCD      WM__NumWindows
                          ENDP

                  WM_CreateWindowAsChild PROC
;;;843    */
;;;844    WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
00082c  e92d4ff8          PUSH     {r3-r11,lr}
;;;845                                   ,WM_HWIN hParent, U16 Style, WM_CALLBACK* cb
;;;846                                   ,int NumExtraBytes) {
000830  4680              MOV      r8,r0
000832  4689              MOV      r9,r1
000834  4692              MOV      r10,r2
000836  469b              MOV      r11,r3
000838  e9dd750a          LDRD     r7,r5,[sp,#0x28]
;;;847      WM_Obj* pWin;
;;;848      WM_HWIN hWin;
;;;849      WM_ASSERT_NOT_IN_PAINT();
;;;850      WM_LOCK();
;;;851      Style |= WM__CreateFlags;
00083c  48fc              LDR      r0,|L1.3120|
00083e  8800              LDRH     r0,[r0,#0]  ; WM__CreateFlags
000840  ea450500          ORR      r5,r5,r0
;;;852      /* Default parent is Desktop 0 */
;;;853      if (!hParent) {
000844  b92f              CBNZ     r7,|L1.2130|
;;;854        if (WM__NumWindows) {
000846  48fb              LDR      r0,|L1.3124|
000848  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
00084a  b110              CBZ      r0,|L1.2130|
;;;855        #if GUI_NUM_LAYERS == 1
;;;856          hParent = WM__ahDesktopWin[0];
00084c  48fa              LDR      r0,|L1.3128|
00084e  f9b07000          LDRSH    r7,[r0,#0]  ; WM__ahDesktopWin
                  |L1.2130|
;;;857        #else
;;;858          hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
;;;859        #endif
;;;860        }
;;;861      }
;;;862      if (hParent == WM_UNATTACHED) {
000852  1c78              ADDS     r0,r7,#1
000854  d100              BNE      |L1.2136|
;;;863        hParent = WM_HWIN_NULL;
000856  4607              MOV      r7,r0
                  |L1.2136|
;;;864      }  
;;;865      if (hParent) {
000858  b307              CBZ      r7,|L1.2204|
;;;866        WM_Obj* pParent = WM_H2P(hParent);
00085a  4638              MOV      r0,r7
00085c  f7fffffe          BL       GUI_ALLOC_h2p
000860  4606              MOV      r6,r0
;;;867        x0 += pParent->Rect.x0;
000862  f9b60000          LDRSH    r0,[r6,#0]
000866  4480              ADD      r8,r8,r0
;;;868        y0 += pParent->Rect.y0;
000868  f9b60002          LDRSH    r0,[r6,#2]
00086c  4481              ADD      r9,r9,r0
;;;869        if (width==0) {
00086e  f1ba0f00          CMP      r10,#0
000872  d107              BNE      |L1.2180|
;;;870          width = pParent->Rect.x1 - pParent->Rect.x0+1;
000874  f9b60004          LDRSH    r0,[r6,#4]
000878  f9b61000          LDRSH    r1,[r6,#0]
00087c  eba00001          SUB      r0,r0,r1
000880  f1000a01          ADD      r10,r0,#1
                  |L1.2180|
;;;871        }
;;;872        if (height==0) {
000884  f1bb0f00          CMP      r11,#0
000888  d107              BNE      |L1.2202|
;;;873          height = pParent->Rect.y1 - pParent->Rect.y0+1;
00088a  f9b60006          LDRSH    r0,[r6,#6]
00088e  f9b61002          LDRSH    r1,[r6,#2]
000892  eba00001          SUB      r0,r0,r1
000896  f1000b01          ADD      r11,r0,#1
                  |L1.2202|
;;;874        }
;;;875      }
00089a  bf00              NOP      
                  |L1.2204|
;;;876      if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
00089c  980d              LDR      r0,[sp,#0x34]
00089e  3020              ADDS     r0,r0,#0x20
0008a0  b200              SXTH     r0,r0
0008a2  f7fffffe          BL       GUI_ALLOC_AllocZero
0008a6  9000              STR      r0,[sp,#0]
0008a8  2800              CMP      r0,#0
0008aa  d04f              BEQ      |L1.2380|
;;;877        GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
;;;878      } else {
;;;879        WM__NumWindows++;
0008ac  48e1              LDR      r0,|L1.3124|
0008ae  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
0008b0  f1000001          ADD      r0,r0,#1
0008b4  49df              LDR      r1,|L1.3124|
0008b6  8008              STRH     r0,[r1,#0]
;;;880        pWin = WM_H2P(hWin);
0008b8  9800              LDR      r0,[sp,#0]
0008ba  f7fffffe          BL       GUI_ALLOC_h2p
0008be  4604              MOV      r4,r0
;;;881        pWin->Rect.x0 = x0;
0008c0  fa0ff088          SXTH     r0,r8
0008c4  8020              STRH     r0,[r4,#0]
;;;882        pWin->Rect.y0 = y0;
0008c6  fa0ff089          SXTH     r0,r9
0008ca  8060              STRH     r0,[r4,#2]
;;;883        pWin->Rect.x1 = x0 + width - 1;
0008cc  eb08000a          ADD      r0,r8,r10
0008d0  f1a00001          SUB      r0,r0,#1
0008d4  b200              SXTH     r0,r0
0008d6  80a0              STRH     r0,[r4,#4]
;;;884        pWin->Rect.y1 = y0 + height - 1;
0008d8  eb09000b          ADD      r0,r9,r11
0008dc  f1a00001          SUB      r0,r0,#1
0008e0  b200              SXTH     r0,r0
0008e2  80e0              STRH     r0,[r4,#6]
;;;885        pWin->cb = cb;
0008e4  980c              LDR      r0,[sp,#0x30]
0008e6  6120              STR      r0,[r4,#0x10]
;;;886        /* Copy the flags which can simply be accepted */
;;;887        pWin->Status |= (Style & (WM_CF_SHOW |
0008e8  8ba0              LDRH     r0,[r4,#0x1c]
0008ea  f643719f          MOV      r1,#0x3f9f
0008ee  ea050101          AND      r1,r5,r1
0008f2  ea400001          ORR      r0,r0,r1
0008f6  83a0              STRH     r0,[r4,#0x1c]
;;;888                                  WM_SF_MEMDEV |
;;;889                                  WM_CF_MEMDEV_ON_REDRAW |
;;;890                                  WM_SF_STAYONTOP |
;;;891                                  WM_CF_DISABLED |
;;;892                                  WM_SF_CONST_OUTLINE |
;;;893                                  WM_SF_HASTRANS |
;;;894                                  WM_CF_ANCHOR_RIGHT |
;;;895                                  WM_CF_ANCHOR_BOTTOM |
;;;896                                  WM_CF_ANCHOR_LEFT |
;;;897                                  WM_CF_ANCHOR_TOP |
;;;898                                  WM_CF_LATE_CLIP));
;;;899        /* Add to linked lists */
;;;900        _AddToLinList(hWin);
0008f8  9800              LDR      r0,[sp,#0]
0008fa  f7fffffe          BL       _AddToLinList
;;;901        WM__InsertWindowIntoList(hWin, hParent);
0008fe  4639              MOV      r1,r7
000900  9800              LDR      r0,[sp,#0]
000902  f7fffffe          BL       WM__InsertWindowIntoList
;;;902        /* Activate window if WM_CF_ACTIVATE is specified */
;;;903        if (Style & WM_CF_ACTIVATE) {
000906  f0150f20          TST      r5,#0x20
00090a  d002              BEQ      |L1.2322|
;;;904          WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
00090c  9800              LDR      r0,[sp,#0]
00090e  f7fffffe          BL       WM_SelectWindow
                  |L1.2322|
;;;905        }
;;;906        /* Handle the Style flags, one at a time */
;;;907        #if WM_SUPPORT_TRANSPARENCY
;;;908          if (Style & WM_SF_HASTRANS) {
000912  f0150f01          TST      r5,#1
000916  d005              BEQ      |L1.2340|
;;;909            WM__TransWindowCnt++;          /* Increment counter for transparency windows */
000918  48c8              LDR      r0,|L1.3132|
00091a  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
00091c  f1000001          ADD      r0,r0,#1
000920  49c6              LDR      r1,|L1.3132|
000922  6008              STR      r0,[r1,#0]  ; WM__TransWindowCnt
                  |L1.2340|
;;;910          }
;;;911        #endif
;;;912        if (Style & WM_CF_BGND) {
000924  f0150f40          TST      r5,#0x40
000928  d002              BEQ      |L1.2352|
;;;913          WM_BringToBottom(hWin);
00092a  9800              LDR      r0,[sp,#0]
00092c  f7fffffe          BL       WM_BringToBottom
                  |L1.2352|
;;;914        }
;;;915        if (Style & WM_CF_SHOW) {
000930  f0150f02          TST      r5,#2
000934  d006              BEQ      |L1.2372|
;;;916          pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
000936  8ba0              LDRH     r0,[r4,#0x1c]
000938  f0400002          ORR      r0,r0,#2
00093c  83a0              STRH     r0,[r4,#0x1c]
;;;917          WM_InvalidateWindow(hWin);    /* Mark content as invalid */
00093e  9800              LDR      r0,[sp,#0]
000940  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2372|
;;;918        }
;;;919        WM__SendMsgNoData(hWin, WM_CREATE);
000944  2101              MOVS     r1,#1
000946  9800              LDR      r0,[sp,#0]
000948  f7fffffe          BL       WM__SendMsgNoData
                  |L1.2380|
;;;920      }
;;;921      WM_UNLOCK();
;;;922      return hWin;
00094c  9800              LDR      r0,[sp,#0]
;;;923    }
00094e  e8bd8ff8          POP      {r3-r11,pc}
;;;924    
                          ENDP

                  WM_CreateWindow PROC
;;;928    */
;;;929    WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U16 Style, WM_CALLBACK* cb, int NumExtraBytes) {
000952  e92d47ff          PUSH     {r0-r10,lr}
000956  4604              MOV      r4,r0
000958  460d              MOV      r5,r1
00095a  4616              MOV      r6,r2
00095c  461f              MOV      r7,r3
00095e  e9dd9a0d          LDRD     r9,r10,[sp,#0x34]
000962  f8dd8030          LDR      r8,[sp,#0x30]
;;;930      return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
000966  f04f0000          MOV      r0,#0
00096a  463b              MOV      r3,r7
00096c  4632              MOV      r2,r6
00096e  4629              MOV      r1,r5
000970  e88d0701          STM      sp,{r0,r8-r10}
000974  4620              MOV      r0,r4
000976  f7fffffe          BL       WM_CreateWindowAsChild
;;;931    }
00097a  b004              ADD      sp,sp,#0x10
00097c  e8bd87f0          POP      {r4-r10,pc}
;;;932    
                          ENDP

                  WM_GetActiveWindow PROC
;;;1036   */
;;;1037   WM_HWIN WM_GetActiveWindow(void) {
000980  48af              LDR      r0,|L1.3136|
;;;1038     return GUI_Context.hAWin;
000982  f9b0003c          LDRSH    r0,[r0,#0x3c]  ; GUI_Context
;;;1039   }
000986  4770              BX       lr
;;;1040   
                          ENDP

                  _FindNext_IVR PROC
;;;1071   #if WM_SUPPORT_OBSTRUCT
;;;1072   static int _FindNext_IVR(void) {
000988  b57c              PUSH     {r2-r6,lr}
;;;1073     WM_HMEM hParent;
;;;1074     GUI_RECT r;
;;;1075     WM_Obj* pAWin;
;;;1076     WM_Obj* pParent;
;;;1077     r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
00098a  49ae              LDR      r1,|L1.3140|
00098c  e9d10102          LDRD     r0,r1,[r1,#8]
000990  e9cd0100          STRD     r0,r1,[sp,#0]
;;;1078     /*
;;;1079        STEP 1:
;;;1080          Set the next position which could be part of the next IVR
;;;1081          This will be the first unhandle pixel in reading order, i.e. next one to the right
;;;1082          or next one down if we are at the right border.
;;;1083     */
;;;1084     if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
000994  48ab              LDR      r0,|L1.3140|
000996  6900              LDR      r0,[r0,#0x10]  ; _ClipContext
000998  b940              CBNZ     r0,|L1.2476|
;;;1085       r.x0 = _ClipContext.ClientRect.x0;
00099a  48aa              LDR      r0,|L1.3140|
00099c  8800              LDRH     r0,[r0,#0]  ; _ClipContext
00099e  f8ad0000          STRH     r0,[sp,#0]
;;;1086       r.y0 = _ClipContext.ClientRect.y0;
0009a2  48a8              LDR      r0,|L1.3140|
0009a4  8840              LDRH     r0,[r0,#2]  ; _ClipContext
0009a6  f8ad0002          STRH     r0,[sp,#2]
0009aa  e01d              B        |L1.2536|
                  |L1.2476|
;;;1087     } else {
;;;1088       r.x0 = _ClipContext.CurRect.x1+1;
0009ac  48a5              LDR      r0,|L1.3140|
0009ae  8980              LDRH     r0,[r0,#0xc]
0009b0  f1000001          ADD      r0,r0,#1
0009b4  b200              SXTH     r0,r0
0009b6  f8ad0000          STRH     r0,[sp,#0]
;;;1089       r.y0 = _ClipContext.CurRect.y0;
0009ba  48a2              LDR      r0,|L1.3140|
0009bc  8940              LDRH     r0,[r0,#0xa]
0009be  f8ad0002          STRH     r0,[sp,#2]
;;;1090       if (r.x0 > _ClipContext.ClientRect.x1) {
0009c2  f9bd0000          LDRSH    r0,[sp,#0]
0009c6  499f              LDR      r1,|L1.3140|
0009c8  f9b11004          LDRSH    r1,[r1,#4]  ; _ClipContext
0009cc  4288              CMP      r0,r1
0009ce  dd0b              BLE      |L1.2536|
;;;1091   NextStripe:  /* go down to next stripe */
0009d0  bf00              NOP      
                  |L1.2514|
;;;1092         r.x0 = _ClipContext.ClientRect.x0;
0009d2  489c              LDR      r0,|L1.3140|
0009d4  8800              LDRH     r0,[r0,#0]  ; _ClipContext
0009d6  f8ad0000          STRH     r0,[sp,#0]
;;;1093         r.y0 = _ClipContext.CurRect.y1+1;
0009da  489a              LDR      r0,|L1.3140|
0009dc  89c0              LDRH     r0,[r0,#0xe]
0009de  f1000001          ADD      r0,r0,#1
0009e2  b200              SXTH     r0,r0
0009e4  f8ad0002          STRH     r0,[sp,#2]
                  |L1.2536|
;;;1094       }
;;;1095     }
;;;1096     /*
;;;1097        STEP 2:
;;;1098          Check if we are done completely.
;;;1099     */
;;;1100     if (r.y0 >_ClipContext.ClientRect.y1) {
0009e8  f9bd0002          LDRSH    r0,[sp,#2]
0009ec  4995              LDR      r1,|L1.3140|
0009ee  f9b11006          LDRSH    r1,[r1,#6]  ; _ClipContext
0009f2  4288              CMP      r0,r1
0009f4  dd01              BLE      |L1.2554|
;;;1101       return 0;
0009f6  2000              MOVS     r0,#0
                  |L1.2552|
;;;1102     }
;;;1103     /* STEP 3:
;;;1104          Find out the max. height (r.y1) if we are at the left border.
;;;1105          Since we are using the same height for all IVRs at the same y0,
;;;1106          we do this only for the leftmost one.
;;;1107     */
;;;1108     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1109     if (r.x0 == _ClipContext.ClientRect.x0) {
;;;1110       r.y1 = _ClipContext.ClientRect.y1;
;;;1111       r.x1 = _ClipContext.ClientRect.x1;
;;;1112       /* Iterate over all windows which are above */
;;;1113       /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1114       for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
;;;1115         pParent = WM_H2P(hParent);
;;;1116         _Findy1(pParent->hNext, &r, NULL);
;;;1117       }
;;;1118       /* Check all children */
;;;1119       _Findy1(pAWin->hFirstChild, &r, NULL);
;;;1120     }
;;;1121     /* 
;;;1122       STEP 4
;;;1123         Find out x0 for the given y0, y1 by iterating over windows above.
;;;1124         if we find one that intersects, adjust x0 to the right.
;;;1125     */
;;;1126   Find_x0:
;;;1127     r.x1 = r.x0;
;;;1128     /* Iterate over all windows which are above */
;;;1129     /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
;;;1130     #if 0   /* This is a planned, but not yet released optimization */
;;;1131       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1132       {
;;;1133         hParent = pAWin->hParent;
;;;1134       } else
;;;1135     #endif
;;;1136     {
;;;1137       hParent = GUI_Context.hAWin;
;;;1138     }
;;;1139     for (; hParent; hParent = pParent->hParent) {
;;;1140       pParent = WM_H2P(hParent);
;;;1141       if (_Findx0(pParent->hNext, &r, NULL)) {
;;;1142         goto Find_x0;
;;;1143       }
;;;1144     }
;;;1145     /* Check all children */
;;;1146     if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
;;;1147       goto Find_x0;
;;;1148     }
;;;1149     /* 
;;;1150      STEP 5:
;;;1151        If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
;;;1152        Find out x1 for the given x0, y0, y1
;;;1153     */
;;;1154     r.x1 = _ClipContext.ClientRect.x1;
;;;1155     if (r.x1 < r.x0) {/* horizontal border reached ? */
;;;1156       _ClipContext.CurRect = r;
;;;1157       goto NextStripe;
;;;1158     }    
;;;1159     /* 
;;;1160      STEP 6:
;;;1161        Find r.x1. We have to Iterate over all windows which are above
;;;1162     */
;;;1163     /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1164     #if 0   /* This is a planned, but not yet released optimization */
;;;1165       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1166       {
;;;1167         hParent = pAWin->hParent;
;;;1168       } else
;;;1169     #endif
;;;1170     {
;;;1171       hParent = GUI_Context.hAWin;
;;;1172     }
;;;1173     for (; hParent; hParent = pParent->hParent) {
;;;1174       pParent = WM_H2P(hParent);
;;;1175       _Findx1(pParent->hNext, &r, NULL);
;;;1176     }
;;;1177     /* Check all children */
;;;1178     _Findx1(pAWin->hFirstChild, &r, NULL);
;;;1179     /* We are done. Return the rectangle we found in the _ClipContext. */
;;;1180     if (_ClipContext.Cnt >200) {
;;;1181       return 0;  /* error !!! This should not happen !*/
;;;1182     }
;;;1183     _ClipContext.CurRect = r;
;;;1184     return 1;  /* IVR is valid ! */
;;;1185   }
0009f8  bd7c              POP      {r2-r6,pc}
                  |L1.2554|
0009fa  4991              LDR      r1,|L1.3136|
0009fc  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1108  ; GUI_Context
000a00  f7fffffe          BL       GUI_ALLOC_h2p
000a04  4605              MOV      r5,r0                 ;1108
000a06  f9bd0000          LDRSH    r0,[sp,#0]            ;1109
000a0a  498e              LDR      r1,|L1.3140|
000a0c  f9b11000          LDRSH    r1,[r1,#0]            ;1109  ; _ClipContext
000a10  4288              CMP      r0,r1                 ;1109
000a12  d120              BNE      |L1.2646|
000a14  488b              LDR      r0,|L1.3140|
000a16  88c0              LDRH     r0,[r0,#6]            ;1110  ; _ClipContext
000a18  f8ad0006          STRH     r0,[sp,#6]            ;1110
000a1c  4889              LDR      r0,|L1.3140|
000a1e  8880              LDRH     r0,[r0,#4]            ;1111  ; _ClipContext
000a20  f8ad0004          STRH     r0,[sp,#4]            ;1111
000a24  4886              LDR      r0,|L1.3136|
000a26  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1114  ; GUI_Context
000a2a  e00c              B        |L1.2630|
                  |L1.2604|
000a2c  4630              MOV      r0,r6                 ;1115
000a2e  f7fffffe          BL       GUI_ALLOC_h2p
000a32  4604              MOV      r4,r0                 ;1115
000a34  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1116
000a38  f04f0200          MOV      r2,#0                 ;1116
000a3c  4669              MOV      r1,sp                 ;1116
000a3e  f7fffffe          BL       _Findy1
000a42  f9b46016          LDRSH    r6,[r4,#0x16]         ;1114
                  |L1.2630|
000a46  2e00              CMP      r6,#0                 ;1114
000a48  d1f0              BNE      |L1.2604|
000a4a  f9b50018          LDRSH    r0,[r5,#0x18]         ;1119
000a4e  2200              MOVS     r2,#0                 ;1119
000a50  4669              MOV      r1,sp                 ;1119
000a52  f7fffffe          BL       _Findy1
                  |L1.2646|
000a56  bf00              NOP                            ;1126
                  |L1.2648|
000a58  f8bd0000          LDRH     r0,[sp,#0]            ;1127
000a5c  f8ad0004          STRH     r0,[sp,#4]            ;1127
000a60  4877              LDR      r0,|L1.3136|
000a62  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1137  ; GUI_Context
000a66  e00e              B        |L1.2694|
                  |L1.2664|
000a68  4630              MOV      r0,r6                 ;1140
000a6a  f7fffffe          BL       GUI_ALLOC_h2p
000a6e  4604              MOV      r4,r0                 ;1140
000a70  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1141
000a74  f04f0200          MOV      r2,#0                 ;1141
000a78  4669              MOV      r1,sp                 ;1141
000a7a  f7fffffe          BL       _Findx0
000a7e  b100              CBZ      r0,|L1.2690|
000a80  e7ea              B        |L1.2648|
                  |L1.2690|
000a82  f9b46016          LDRSH    r6,[r4,#0x16]         ;1139
                  |L1.2694|
000a86  2e00              CMP      r6,#0                 ;1139
000a88  d1ee              BNE      |L1.2664|
000a8a  f9b50018          LDRSH    r0,[r5,#0x18]         ;1146
000a8e  2200              MOVS     r2,#0                 ;1146
000a90  4669              MOV      r1,sp                 ;1146
000a92  f7fffffe          BL       _Findx0
000a96  b100              CBZ      r0,|L1.2714|
000a98  e7de              B        |L1.2648|
                  |L1.2714|
000a9a  486a              LDR      r0,|L1.3140|
000a9c  8880              LDRH     r0,[r0,#4]            ;1154  ; _ClipContext
000a9e  f8ad0004          STRH     r0,[sp,#4]            ;1154
000aa2  f9bd0004          LDRSH    r0,[sp,#4]            ;1155
000aa6  f9bd1000          LDRSH    r1,[sp,#0]            ;1155
000aaa  4288              CMP      r0,r1                 ;1155
000aac  da05              BGE      |L1.2746|
000aae  4865              LDR      r0,|L1.3140|
000ab0  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1156
000ab4  e9c01202          STRD     r1,r2,[r0,#8]         ;1156
000ab8  e78b              B        |L1.2514|
                  |L1.2746|
000aba  4861              LDR      r0,|L1.3136|
000abc  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1171  ; GUI_Context
000ac0  e00c              B        |L1.2780|
                  |L1.2754|
000ac2  4630              MOV      r0,r6                 ;1174
000ac4  f7fffffe          BL       GUI_ALLOC_h2p
000ac8  4604              MOV      r4,r0                 ;1174
000aca  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1175
000ace  f04f0200          MOV      r2,#0                 ;1175
000ad2  4669              MOV      r1,sp                 ;1175
000ad4  f7fffffe          BL       _Findx1
000ad8  f9b46016          LDRSH    r6,[r4,#0x16]         ;1173
                  |L1.2780|
000adc  2e00              CMP      r6,#0                 ;1173
000ade  d1f0              BNE      |L1.2754|
000ae0  f9b50018          LDRSH    r0,[r5,#0x18]         ;1178
000ae4  2200              MOVS     r2,#0                 ;1178
000ae6  4669              MOV      r1,sp                 ;1178
000ae8  f7fffffe          BL       _Findx1
000aec  4855              LDR      r0,|L1.3140|
000aee  6900              LDR      r0,[r0,#0x10]         ;1180  ; _ClipContext
000af0  28c8              CMP      r0,#0xc8              ;1180
000af2  dd01              BLE      |L1.2808|
000af4  2000              MOVS     r0,#0                 ;1181
000af6  e77f              B        |L1.2552|
                  |L1.2808|
000af8  4852              LDR      r0,|L1.3140|
000afa  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1183
000afe  e9c01202          STRD     r1,r2,[r0,#8]         ;1183
000b02  2001              MOVS     r0,#1                 ;1184
000b04  e778              B        |L1.2552|
;;;1186   
                          ENDP

                  WM__GetNextIVR PROC
;;;1210   */
;;;1211   int  WM__GetNextIVR(void) {
000b06  b510              PUSH     {r4,lr}
;;;1212     #if GUI_SUPPORT_CURSOR
;;;1213       static char _CursorHidden;
;;;1214     #endif
;;;1215     /* If WM is not active, we have no rectangles to return */
;;;1216     if (WM_IsActive==0) {
000b08  484f              LDR      r0,|L1.3144|
000b0a  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000b0c  b908              CBNZ     r0,|L1.2834|
;;;1217       return 0;
000b0e  2000              MOVS     r0,#0
                  |L1.2832|
;;;1218     }
;;;1219     if (_ClipContext.EntranceCnt > 1) {
;;;1220       _ClipContext.EntranceCnt--;
;;;1221       return 0;
;;;1222     }
;;;1223     #if GUI_SUPPORT_CURSOR
;;;1224       if (_CursorHidden) {
;;;1225         _CursorHidden = 0;
;;;1226         (*GUI_CURSOR_pfTempUnhide) ();
;;;1227       }
;;;1228     #endif
;;;1229     ++_ClipContext.Cnt;
;;;1230     /* Find next rectangle and use it as ClipRect */
;;;1231     if (!_FindNext_IVR()) {
;;;1232       _ClipContext.EntranceCnt--;  /* This search is over ! */
;;;1233       return 0;        /* Could not find an other one ! */
;;;1234     }
;;;1235     WM__ActivateClipRect();
;;;1236     /* Hide cursor if necessary */
;;;1237     #if GUI_SUPPORT_CURSOR
;;;1238       if (GUI_CURSOR_pfTempHide) {
;;;1239         _CursorHidden = (*GUI_CURSOR_pfTempHide) ( &_ClipContext.CurRect);
;;;1240       }
;;;1241     #endif
;;;1242     return 1;
;;;1243   }
000b10  bd10              POP      {r4,pc}
                  |L1.2834|
000b12  484c              LDR      r0,|L1.3140|
000b14  6940              LDR      r0,[r0,#0x14]         ;1219  ; _ClipContext
000b16  2801              CMP      r0,#1                 ;1219
000b18  dd08              BLE      |L1.2860|
000b1a  484a              LDR      r0,|L1.3140|
000b1c  6940              LDR      r0,[r0,#0x14]         ;1220  ; _ClipContext
000b1e  f1a00001          SUB      r0,r0,#1              ;1220
000b22  4948              LDR      r1,|L1.3140|
000b24  6148              STR      r0,[r1,#0x14]         ;1220  ; _ClipContext
000b26  f04f0000          MOV      r0,#0                 ;1221
000b2a  e7f1              B        |L1.2832|
                  |L1.2860|
000b2c  4845              LDR      r0,|L1.3140|
000b2e  6900              LDR      r0,[r0,#0x10]         ;1229  ; _ClipContext
000b30  f1000001          ADD      r0,r0,#1              ;1229
000b34  4943              LDR      r1,|L1.3140|
000b36  6108              STR      r0,[r1,#0x10]         ;1229  ; _ClipContext
000b38  f7fffffe          BL       _FindNext_IVR
000b3c  b940              CBNZ     r0,|L1.2896|
000b3e  4841              LDR      r0,|L1.3140|
000b40  6940              LDR      r0,[r0,#0x14]         ;1232  ; _ClipContext
000b42  f1a00001          SUB      r0,r0,#1              ;1232
000b46  493f              LDR      r1,|L1.3140|
000b48  6148              STR      r0,[r1,#0x14]         ;1232  ; _ClipContext
000b4a  f04f0000          MOV      r0,#0                 ;1233
000b4e  e7df              B        |L1.2832|
                  |L1.2896|
000b50  f7fffffe          BL       WM__ActivateClipRect
000b54  2001              MOVS     r0,#1                 ;1242
000b56  e7db              B        |L1.2832|
;;;1244   
                          ENDP

                  WM__InitIVRSearch PROC
;;;1256   */
;;;1257   int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
000b58  b57f              PUSH     {r0-r6,lr}
000b5a  4605              MOV      r5,r0
;;;1258     GUI_RECT r;
;;;1259     WM_Obj* pAWin;
;;;1260     GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
;;;1261      /* If WM is not active -> nothing to do, leave cliprect alone */
;;;1262     if (WM_IsActive==0) {
000b5c  483a              LDR      r0,|L1.3144|
000b5e  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000b60  b920              CBNZ     r0,|L1.2924|
;;;1263       WM__ActivateClipRect();
000b62  f7fffffe          BL       WM__ActivateClipRect
;;;1264       return 1;
000b66  2001              MOVS     r0,#1
                  |L1.2920|
;;;1265     }
;;;1266     /* If we entered multiple times, leave Cliprect alone */
;;;1267     if (++_ClipContext.EntranceCnt > 1)
;;;1268       return 1;
;;;1269     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1270     _ClipContext.Cnt        = -1;
;;;1271    /* When using callback mechanism, it is legal to reduce drawing
;;;1272       area to the invalid area ! */
;;;1273     if (WM__PaintCallbackCnt) {
;;;1274       WM__GetInvalidRectAbs(pAWin, &r);
;;;1275     } else {  /* Not using callback mechanism, therefor allow entire rectangle */
;;;1276       if (pAWin->Status & WM_SF_ISVIS) {
;;;1277         r = pAWin->Rect;
;;;1278       } else {
;;;1279         --_ClipContext.EntranceCnt;
;;;1280         return 0;  /* window is not even visible ! */
;;;1281       }
;;;1282     }
;;;1283     /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
;;;1284     if (pMaxRect) {
;;;1285       GUI__IntersectRect(&r, pMaxRect);
;;;1286     }
;;;1287     /* If user has reduced the cliprect size, reduce the rectangle */
;;;1288     if (GUI_Context.WM__pUserClipRect) {
;;;1289       WM_Obj* pWin = pAWin;
;;;1290       GUI_RECT rUser = *(GUI_Context.WM__pUserClipRect);
;;;1291       #if WM_SUPPORT_TRANSPARENCY
;;;1292         if (WM__hATransWindow) {
;;;1293           pWin = WM_H2P(WM__hATransWindow);
;;;1294         }   
;;;1295       #endif
;;;1296       WM__Client2Screen(pWin, &rUser);
;;;1297       GUI__IntersectRect(&r, &rUser);
;;;1298     }
;;;1299     /* For transparent windows, we need to further reduce the rectangle */
;;;1300     #if WM_SUPPORT_TRANSPARENCY
;;;1301       if (WM__hATransWindow) {
;;;1302         if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
;;;1303           --_ClipContext.EntranceCnt;
;;;1304           return 0;           /* Nothing to draw */
;;;1305         }
;;;1306       }
;;;1307     #endif
;;;1308     /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
;;;1309     if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
;;;1310       --_ClipContext.EntranceCnt;
;;;1311       return 0;           /* Nothing to draw */
;;;1312     }
;;;1313     /* Store the rectangle and find the first rectangle of the area */
;;;1314     _ClipContext.ClientRect = r;
;;;1315     return WM__GetNextIVR();
;;;1316   }
000b68  b004              ADD      sp,sp,#0x10
000b6a  bd70              POP      {r4-r6,pc}
                  |L1.2924|
000b6c  4835              LDR      r0,|L1.3140|
000b6e  6940              LDR      r0,[r0,#0x14]         ;1267  ; _ClipContext
000b70  1c40              ADDS     r0,r0,#1              ;1267
000b72  4934              LDR      r1,|L1.3140|
000b74  6148              STR      r0,[r1,#0x14]         ;1267  ; _ClipContext
000b76  2801              CMP      r0,#1                 ;1267
000b78  dd01              BLE      |L1.2942|
000b7a  2001              MOVS     r0,#1                 ;1268
000b7c  e7f4              B        |L1.2920|
                  |L1.2942|
000b7e  4930              LDR      r1,|L1.3136|
000b80  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1269  ; GUI_Context
000b84  f7fffffe          BL       GUI_ALLOC_h2p
000b88  4604              MOV      r4,r0                 ;1269
000b8a  f04f30ff          MOV      r0,#0xffffffff        ;1270
000b8e  492d              LDR      r1,|L1.3140|
000b90  6108              STR      r0,[r1,#0x10]         ;1270  ; _ClipContext
000b92  482e              LDR      r0,|L1.3148|
000b94  7800              LDRB     r0,[r0,#0]            ;1273  ; WM__PaintCallbackCnt
000b96  b120              CBZ      r0,|L1.2978|
000b98  a902              ADD      r1,sp,#8              ;1274
000b9a  4620              MOV      r0,r4                 ;1274
000b9c  f7fffffe          BL       WM__GetInvalidRectAbs
000ba0  e011              B        |L1.3014|
                  |L1.2978|
000ba2  8ba0              LDRH     r0,[r4,#0x1c]         ;1276
000ba4  f0100f02          TST      r0,#2                 ;1276
000ba8  d004              BEQ      |L1.2996|
000baa  e9d40100          LDRD     r0,r1,[r4,#0]         ;1277
000bae  e9cd0102          STRD     r0,r1,[sp,#8]         ;1277
000bb2  e008              B        |L1.3014|
                  |L1.2996|
000bb4  4823              LDR      r0,|L1.3140|
000bb6  6940              LDR      r0,[r0,#0x14]         ;1279  ; _ClipContext
000bb8  f1a00001          SUB      r0,r0,#1              ;1279
000bbc  4921              LDR      r1,|L1.3140|
000bbe  6148              STR      r0,[r1,#0x14]         ;1279  ; _ClipContext
000bc0  f04f0000          MOV      r0,#0                 ;1280
000bc4  e7d0              B        |L1.2920|
                  |L1.3014|
000bc6  b11d              CBZ      r5,|L1.3024|
000bc8  4629              MOV      r1,r5                 ;1285
000bca  a802              ADD      r0,sp,#8              ;1285
000bcc  f7fffffe          BL       GUI__IntersectRect
                  |L1.3024|
000bd0  481b              LDR      r0,|L1.3136|
000bd2  6b80              LDR      r0,[r0,#0x38]         ;1288  ; GUI_Context
000bd4  b1c0              CBZ      r0,|L1.3080|
000bd6  4626              MOV      r6,r4                 ;1289
000bd8  4819              LDR      r0,|L1.3136|
000bda  6b80              LDR      r0,[r0,#0x38]         ;1290  ; GUI_Context
000bdc  6801              LDR      r1,[r0,#0]            ;1290
000bde  9100              STR      r1,[sp,#0]            ;1290
000be0  6840              LDR      r0,[r0,#4]            ;1290
000be2  9001              STR      r0,[sp,#4]            ;1290
000be4  481a              LDR      r0,|L1.3152|
000be6  8800              LDRH     r0,[r0,#0]            ;1292  ; WM__hATransWindow
000be8  b128              CBZ      r0,|L1.3062|
000bea  4819              LDR      r0,|L1.3152|
000bec  f9b00000          LDRSH    r0,[r0,#0]            ;1293  ; WM__hATransWindow
000bf0  f7fffffe          BL       GUI_ALLOC_h2p
000bf4  4606              MOV      r6,r0                 ;1293
                  |L1.3062|
000bf6  4669              MOV      r1,sp                 ;1296
000bf8  4630              MOV      r0,r6                 ;1296
000bfa  f7fffffe          BL       WM__Client2Screen
000bfe  4669              MOV      r1,sp                 ;1297
000c00  a802              ADD      r0,sp,#8              ;1297
000c02  f7fffffe          BL       GUI__IntersectRect
000c06  bf00              NOP                            ;1298
                  |L1.3080|
000c08  4811              LDR      r0,|L1.3152|
000c0a  8800              LDRH     r0,[r0,#0]            ;1301  ; WM__hATransWindow
000c0c  b178              CBZ      r0,|L1.3118|
000c0e  4810              LDR      r0,|L1.3152|
000c10  f9b01000          LDRSH    r1,[r0,#0]            ;1302  ; WM__hATransWindow
000c14  a802              ADD      r0,sp,#8              ;1302
000c16  f7fffffe          BL       WM__ClipAtParentBorders
000c1a  b940              CBNZ     r0,|L1.3118|
000c1c  4809              LDR      r0,|L1.3140|
000c1e  6940              LDR      r0,[r0,#0x14]         ;1303  ; _ClipContext
000c20  f1a00001          SUB      r0,r0,#1              ;1303
000c24  4907              LDR      r1,|L1.3140|
000c26  6148              STR      r0,[r1,#0x14]         ;1303  ; _ClipContext
000c28  f04f0000          MOV      r0,#0                 ;1304
000c2c  e79c              B        |L1.2920|
                  |L1.3118|
000c2e  e011              B        |L1.3156|
                  |L1.3120|
                          DCD      WM__CreateFlags
                  |L1.3124|
                          DCD      WM__NumWindows
                  |L1.3128|
                          DCD      WM__ahDesktopWin
                  |L1.3132|
                          DCD      WM__TransWindowCnt
                  |L1.3136|
                          DCD      GUI_Context
                  |L1.3140|
                          DCD      _ClipContext
                  |L1.3144|
                          DCD      WM_IsActive
                  |L1.3148|
                          DCD      WM__PaintCallbackCnt
                  |L1.3152|
                          DCD      WM__hATransWindow
                  |L1.3156|
000c54  48fe              LDR      r0,|L1.4176|
000c56  f9b0103c          LDRSH    r1,[r0,#0x3c]         ;1309  ; GUI_Context
000c5a  a802              ADD      r0,sp,#8              ;1309
000c5c  f7fffffe          BL       WM__ClipAtParentBorders
000c60  b940              CBNZ     r0,|L1.3188|
000c62  48fc              LDR      r0,|L1.4180|
000c64  6940              LDR      r0,[r0,#0x14]         ;1310  ; _ClipContext
000c66  f1a00001          SUB      r0,r0,#1              ;1310
000c6a  49fa              LDR      r1,|L1.4180|
000c6c  6148              STR      r0,[r1,#0x14]         ;1310  ; _ClipContext
000c6e  f04f0000          MOV      r0,#0                 ;1311
000c72  e779              B        |L1.2920|
                  |L1.3188|
000c74  48f7              LDR      r0,|L1.4180|
000c76  e9dd1202          LDRD     r1,r2,[sp,#8]         ;1314
000c7a  c006              STM      r0!,{r1,r2}           ;1314
000c7c  f7fffffe          BL       WM__GetNextIVR
000c80  e772              B        |L1.2920|
;;;1317   
                          ENDP

                  WM_SetDefault PROC
;;;1326   */
;;;1327   void WM_SetDefault(void) {
000c82  b510              PUSH     {r4,lr}
;;;1328     GL_SetDefault();
000c84  f7fffffe          BL       GL_SetDefault
;;;1329     GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
000c88  f04f0000          MOV      r0,#0
000c8c  49f0              LDR      r1,|L1.4176|
000c8e  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1330   }
000c90  bd10              POP      {r4,pc}
;;;1331   
                          ENDP

                  _Paint1 PROC
;;;1335   */
;;;1336   static void _Paint1(WM_HWIN hWin, WM_Obj* pWin) {
000c92  b5fe              PUSH     {r1-r7,lr}
000c94  4605              MOV      r5,r0
000c96  460c              MOV      r4,r1
;;;1337     int Status = pWin->Status;
000c98  8ba6              LDRH     r6,[r4,#0x1c]
;;;1338     /* Send WM_PAINT if window is visible and a callback is defined */
;;;1339     if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
000c9a  6920              LDR      r0,[r4,#0x10]
000c9c  2800              CMP      r0,#0
000c9e  d039              BEQ      |L1.3348|
000ca0  f0160f02          TST      r6,#2
000ca4  d036              BEQ      |L1.3348|
;;;1340       WM_MESSAGE Msg;
;;;1341       WM__PaintCallbackCnt++;
000ca6  48ec              LDR      r0,|L1.4184|
000ca8  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000caa  f1000001          ADD      r0,r0,#1
000cae  49ea              LDR      r1,|L1.4184|
000cb0  7008              STRB     r0,[r1,#0]
;;;1342       if (Status & WM_SF_LATE_CLIP) {
000cb2  f4165f80          TST      r6,#0x1000
000cb6  d00e              BEQ      |L1.3286|
;;;1343         Msg.hWin   = hWin;
000cb8  f8ad5004          STRH     r5,[sp,#4]
;;;1344         Msg.MsgId  = WM_PAINT;
000cbc  f04f000f          MOV      r0,#0xf
000cc0  9000              STR      r0,[sp,#0]
;;;1345         Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000cc2  f1040008          ADD      r0,r4,#8
000cc6  9002              STR      r0,[sp,#8]
;;;1346         WM_SetDefault();
000cc8  f7fffffe          BL       WM_SetDefault
;;;1347         WM__SendMessage(hWin, &Msg);
000ccc  4669              MOV      r1,sp
000cce  4628              MOV      r0,r5
000cd0  f7fffffe          BL       WM__SendMessage
000cd4  e017              B        |L1.3334|
                  |L1.3286|
;;;1348       } else {
;;;1349         WM_ITERATE_START(&pWin->InvalidRect) {
000cd6  f1040008          ADD      r0,r4,#8
000cda  f7fffffe          BL       WM__InitIVRSearch
000cde  b190              CBZ      r0,|L1.3334|
000ce0  bf00              NOP      
                  |L1.3298|
;;;1350           Msg.hWin   = hWin;
000ce2  f8ad5004          STRH     r5,[sp,#4]
;;;1351           Msg.MsgId  = WM_PAINT;
000ce6  f04f000f          MOV      r0,#0xf
000cea  9000              STR      r0,[sp,#0]
;;;1352           Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000cec  f1040008          ADD      r0,r4,#8
000cf0  9002              STR      r0,[sp,#8]
;;;1353           WM_SetDefault();
000cf2  f7fffffe          BL       WM_SetDefault
;;;1354           WM__SendMessage(hWin, &Msg);
000cf6  4669              MOV      r1,sp
000cf8  4628              MOV      r0,r5
000cfa  f7fffffe          BL       WM__SendMessage
;;;1355         } WM_ITERATE_END();
000cfe  f7fffffe          BL       WM__GetNextIVR
000d02  2800              CMP      r0,#0
000d04  d1ed              BNE      |L1.3298|
                  |L1.3334|
;;;1356       }
;;;1357       WM__PaintCallbackCnt--;
000d06  48d4              LDR      r0,|L1.4184|
000d08  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000d0a  f1a00001          SUB      r0,r0,#1
000d0e  49d2              LDR      r1,|L1.4184|
000d10  7008              STRB     r0,[r1,#0]
;;;1358     }
000d12  bf00              NOP      
                  |L1.3348|
;;;1359   }
000d14  bdfe              POP      {r1-r7,pc}
;;;1360   /*********************************************************************
                          ENDP

                  _Paint1Trans PROC
;;;1382   #if WM_SUPPORT_TRANSPARENCY
;;;1383   static int _Paint1Trans(WM_HWIN hWin, WM_Obj* pWin) {
000d16  e92d41f0          PUSH     {r4-r8,lr}
000d1a  4605              MOV      r5,r0
000d1c  460c              MOV      r4,r1
;;;1384     int xPrev, yPrev;
;;;1385     WM_Obj* pAWin = WM_H2P(GUI_Context.hAWin);
000d1e  49cc              LDR      r1,|L1.4176|
000d20  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
000d24  f7fffffe          BL       GUI_ALLOC_h2p
000d28  4680              MOV      r8,r0
;;;1386     /* Check if we need to do any drawing */
;;;1387     if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
000d2a  4621              MOV      r1,r4
000d2c  f1080008          ADD      r0,r8,#8
000d30  f7fffffe          BL       GUI_RectsIntersect
000d34  b308              CBZ      r0,|L1.3450|
;;;1388       /* Save old values */
;;;1389       xPrev = GUI_Context.xOff;
000d36  48c6              LDR      r0,|L1.4176|
000d38  6c06              LDR      r6,[r0,#0x40]  ; GUI_Context
;;;1390       yPrev = GUI_Context.yOff;
000d3a  6c47              LDR      r7,[r0,#0x44]  ; GUI_Context
;;;1391       /* Set values for the current (transparent) window, rather than the one below */
;;;1392       GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
000d3c  f1080208          ADD      r2,r8,#8
000d40  4621              MOV      r1,r4
000d42  f1040008          ADD      r0,r4,#8
000d46  f7fffffe          BL       GUI__IntersectRects
;;;1393       WM__hATransWindow = hWin;
000d4a  48c4              LDR      r0,|L1.4188|
000d4c  8005              STRH     r5,[r0,#0]
;;;1394       GUI_Context.xOff = pWin->Rect.x0;
000d4e  f9b40000          LDRSH    r0,[r4,#0]
000d52  49bf              LDR      r1,|L1.4176|
000d54  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;1395       GUI_Context.yOff = pWin->Rect.y0;
000d56  f9b40002          LDRSH    r0,[r4,#2]
000d5a  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;1396       /* Do the actual drawing ... */
;;;1397       _Paint1(hWin, pWin);
000d5c  4621              MOV      r1,r4
000d5e  4628              MOV      r0,r5
000d60  f7fffffe          BL       _Paint1
;;;1398       /* Restore settings */
;;;1399       WM__hATransWindow = 0;
000d64  f04f0000          MOV      r0,#0
000d68  49bc              LDR      r1,|L1.4188|
000d6a  8008              STRH     r0,[r1,#0]
;;;1400       GUI_Context.xOff = xPrev;
000d6c  48b8              LDR      r0,|L1.4176|
000d6e  6406              STR      r6,[r0,#0x40]  ; GUI_Context
;;;1401       GUI_Context.yOff = yPrev;
000d70  6447              STR      r7,[r0,#0x44]  ; GUI_Context
;;;1402       return 1;                       /* Some drawing took place */
000d72  f04f0001          MOV      r0,#1
                  |L1.3446|
;;;1403     }
;;;1404     return 0;                         /* No invalid area, so nothing was drawn */
;;;1405   }
000d76  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3450|
000d7a  2000              MOVS     r0,#0                 ;1404
000d7c  e7fb              B        |L1.3446|
;;;1406   #endif
                          ENDP

                  _PaintTransChildren PROC
;;;1419   #if WM_SUPPORT_TRANSPARENCY
;;;1420   static void _PaintTransChildren(WM_HWIN hWin, WM_Obj* pWin) {
000d7e  e92d41fc          PUSH     {r2-r8,lr}
000d82  4607              MOV      r7,r0
000d84  460c              MOV      r4,r1
;;;1421     WM_HWIN hChild;
;;;1422     WM_Obj* pChild;
;;;1423     if (pWin->Status & WM_SF_ISVIS) {
000d86  8ba0              LDRH     r0,[r4,#0x1c]
000d88  f0100f02          TST      r0,#2
000d8c  d033              BEQ      |L1.3574|
;;;1424       for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000d8e  f9b46018          LDRSH    r6,[r4,#0x18]
000d92  e02e              B        |L1.3570|
                  |L1.3476|
;;;1425         pChild = WM_H2P(hChild);
000d94  4630              MOV      r0,r6
000d96  f7fffffe          BL       GUI_ALLOC_h2p
000d9a  4605              MOV      r5,r0
;;;1426         if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
000d9c  8ba8              LDRH     r0,[r5,#0x1c]
000d9e  f0000003          AND      r0,r0,#3
000da2  2803              CMP      r0,#3
000da4  d123              BNE      |L1.3566|
;;;1427   		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
;;;1428           /* Set invalid area of the window to draw */
;;;1429           if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
000da6  f1040108          ADD      r1,r4,#8
000daa  4628              MOV      r0,r5
000dac  f7fffffe          BL       GUI_RectsIntersect
000db0  b1e8              CBZ      r0,|L1.3566|
;;;1430             GUI_RECT InvalidRectPrev;
;;;1431             InvalidRectPrev = pWin->InvalidRect;
000db2  68a0              LDR      r0,[r4,#8]
000db4  9000              STR      r0,[sp,#0]
000db6  68e0              LDR      r0,[r4,#0xc]
000db8  9001              STR      r0,[sp,#4]
;;;1432             if(_Paint1Trans(hChild, pChild)) {
000dba  4629              MOV      r1,r5
000dbc  4630              MOV      r0,r6
000dbe  f7fffffe          BL       _Paint1Trans
000dc2  b178              CBZ      r0,|L1.3556|
;;;1433               #if GUI_SUPPORT_MEMDEV
;;;1434                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1435                    So the pointer(s) could be invalid after the last function call and needs
;;;1436                    to be restored.
;;;1437                 */
;;;1438                 pChild = WM_H2P(hChild);
000dc4  4630              MOV      r0,r6
000dc6  f7fffffe          BL       GUI_ALLOC_h2p
000dca  4605              MOV      r5,r0
;;;1439               #endif
;;;1440               _PaintTransChildren(hChild, pChild);
000dcc  4629              MOV      r1,r5
000dce  4630              MOV      r0,r6
000dd0  f7fffffe          BL       _PaintTransChildren
;;;1441               #if GUI_SUPPORT_MEMDEV
;;;1442                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1443                    So the pointer(s) could be invalid after the last function call and needs
;;;1444                    to be restored.
;;;1445                 */
;;;1446                 pChild = WM_H2P(hChild);
000dd4  4630              MOV      r0,r6
000dd6  f7fffffe          BL       GUI_ALLOC_h2p
000dda  4605              MOV      r5,r0
;;;1447                 pWin   = WM_H2P(hWin);
000ddc  4638              MOV      r0,r7
000dde  f7fffffe          BL       GUI_ALLOC_h2p
000de2  4604              MOV      r4,r0
                  |L1.3556|
;;;1448               #endif
;;;1449             }
;;;1450             pWin->InvalidRect = InvalidRectPrev;
000de4  9800              LDR      r0,[sp,#0]
000de6  60a0              STR      r0,[r4,#8]
000de8  9801              LDR      r0,[sp,#4]
000dea  60e0              STR      r0,[r4,#0xc]
;;;1451           }
000dec  bf00              NOP      
                  |L1.3566|
000dee  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;1424
                  |L1.3570|
000df2  2e00              CMP      r6,#0                 ;1424
000df4  d1ce              BNE      |L1.3476|
                  |L1.3574|
;;;1452         }
;;;1453       }
;;;1454     }
;;;1455   }
000df6  e8bd81fc          POP      {r2-r8,pc}
;;;1456   #endif
                          ENDP

                  _PaintTransTopSiblings PROC
;;;1469   #if WM_SUPPORT_TRANSPARENCY
;;;1470   static void _PaintTransTopSiblings(WM_HWIN hWin, WM_Obj* pWin) {
000dfa  e92d41f0          PUSH     {r4-r8,lr}
000dfe  4606              MOV      r6,r0
000e00  460c              MOV      r4,r1
;;;1471     WM_HWIN hParent;
;;;1472     WM_Obj* pParent;
;;;1473     hParent = pWin->hParent;
000e02  f9b47016          LDRSH    r7,[r4,#0x16]
;;;1474     hWin = pWin->hNext;
000e06  f9b4601a          LDRSH    r6,[r4,#0x1a]
;;;1475     while (hParent) { /* Go hierarchy up to desktop window */
000e0a  e021              B        |L1.3664|
                  |L1.3596|
;;;1476       for (; hWin; hWin = pWin->hNext) {
000e0c  e016              B        |L1.3644|
                  |L1.3598|
;;;1477         pWin = WM_H2P(hWin);
000e0e  4630              MOV      r0,r6
000e10  f7fffffe          BL       GUI_ALLOC_h2p
000e14  4604              MOV      r4,r0
;;;1478         /* paint window if it is transparent & visible */
;;;1479         if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_ISVIS)) ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
000e16  8ba0              LDRH     r0,[r4,#0x1c]
000e18  f0000003          AND      r0,r0,#3
000e1c  2803              CMP      r0,#3
000e1e  d107              BNE      |L1.3632|
;;;1480           _Paint1Trans(hWin, pWin);
000e20  4621              MOV      r1,r4
000e22  4630              MOV      r0,r6
000e24  f7fffffe          BL       _Paint1Trans
;;;1481           #if GUI_SUPPORT_MEMDEV
;;;1482             /* Within the paint event the application is alowed to deal with memory devices.
;;;1483                So the pointer(s) could be invalid after the last function call and needs
;;;1484                to be restored.
;;;1485             */
;;;1486             pWin   = WM_H2P(hWin);
000e28  4630              MOV      r0,r6
000e2a  f7fffffe          BL       GUI_ALLOC_h2p
000e2e  4604              MOV      r4,r0
                  |L1.3632|
;;;1487           #endif
;;;1488         }
;;;1489         /* paint transparent & visible children */
;;;1490         _PaintTransChildren(hWin, pWin);
000e30  4621              MOV      r1,r4
000e32  4630              MOV      r0,r6
000e34  f7fffffe          BL       _PaintTransChildren
000e38  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;1476
                  |L1.3644|
000e3c  2e00              CMP      r6,#0                 ;1476
000e3e  d1e6              BNE      |L1.3598|
;;;1491       }
;;;1492       pParent = WM_H2P(hParent);
000e40  4638              MOV      r0,r7
000e42  f7fffffe          BL       GUI_ALLOC_h2p
000e46  4605              MOV      r5,r0
;;;1493       hWin = pParent->hNext;
000e48  f9b5601a          LDRSH    r6,[r5,#0x1a]
;;;1494       hParent = pParent->hParent;
000e4c  f9b57016          LDRSH    r7,[r5,#0x16]
                  |L1.3664|
000e50  2f00              CMP      r7,#0                 ;1475
000e52  d1db              BNE      |L1.3596|
;;;1495     }
;;;1496   }
000e54  e8bd81f0          POP      {r4-r8,pc}
;;;1497   #endif
                          ENDP

                  WM__PaintWinAndOverlays PROC
;;;1518   */
;;;1519   void WM__PaintWinAndOverlays(WM_PAINTINFO* pInfo) {
000e58  b570              PUSH     {r4-r6,lr}
000e5a  4604              MOV      r4,r0
;;;1520     WM_HWIN hWin;
;;;1521     WM_Obj* pWin;
;;;1522     hWin = pInfo->hWin;
000e5c  f9b46000          LDRSH    r6,[r4,#0]
;;;1523     pWin = pInfo->pWin;
000e60  6865              LDR      r5,[r4,#4]
;;;1524     if (!pWin) {
000e62  b91d              CBNZ     r5,|L1.3692|
;;;1525       pWin = WM_H2P(hWin);
000e64  4630              MOV      r0,r6
000e66  f7fffffe          BL       GUI_ALLOC_h2p
000e6a  4605              MOV      r5,r0
                  |L1.3692|
;;;1526     }
;;;1527     #if WM_SUPPORT_TRANSPARENCY
;;;1528       /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
;;;1529       if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
000e6c  8ba8              LDRH     r0,[r5,#0x1c]
000e6e  f6400101          MOV      r1,#0x801
000e72  4008              ANDS     r0,r0,r1
000e74  2801              CMP      r0,#1
000e76  d007              BEQ      |L1.3720|
;;;1530     #endif
;;;1531     _Paint1(hWin, pWin);    /* Draw the window itself */
000e78  4629              MOV      r1,r5
000e7a  4630              MOV      r0,r6
000e7c  f7fffffe          BL       _Paint1
;;;1532     #if GUI_SUPPORT_MEMDEV
;;;1533       /* Within the paint event the application is alowed to deal with memory devices.
;;;1534          So the pointer(s) could be invalid after the last function call and needs
;;;1535          to be restored.
;;;1536       */
;;;1537       pWin = WM_H2P(hWin);
000e80  4630              MOV      r0,r6
000e82  f7fffffe          BL       GUI_ALLOC_h2p
000e86  4605              MOV      r5,r0
                  |L1.3720|
;;;1538     #endif
;;;1539     #if WM_SUPPORT_TRANSPARENCY
;;;1540       }
;;;1541       if (WM__TransWindowCnt != 0) {
000e88  4875              LDR      r0,|L1.4192|
000e8a  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
000e8c  b158              CBZ      r0,|L1.3750|
;;;1542         _PaintTransChildren(hWin, pWin);             /* Draw all transparent children */
000e8e  4629              MOV      r1,r5
000e90  4630              MOV      r0,r6
000e92  f7fffffe          BL       _PaintTransChildren
;;;1543         #if GUI_SUPPORT_MEMDEV
;;;1544           /* Within the paint event the application is alowed to deal with memory devices.
;;;1545              So the pointer(s) could be invalid after the last function call and needs
;;;1546              to be restored.
;;;1547           */
;;;1548           pWin = WM_H2P(hWin);
000e96  4630              MOV      r0,r6
000e98  f7fffffe          BL       GUI_ALLOC_h2p
000e9c  4605              MOV      r5,r0
;;;1549         #endif
;;;1550         _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
000e9e  4629              MOV      r1,r5
000ea0  4630              MOV      r0,r6
000ea2  f7fffffe          BL       _PaintTransTopSiblings
                  |L1.3750|
;;;1551       }
;;;1552     #endif
;;;1553   }
000ea6  bd70              POP      {r4-r6,pc}
;;;1554   
                          ENDP

                  _cbPaintMemDev PROC
;;;1567   #if GUI_SUPPORT_MEMDEV
;;;1568   static void _cbPaintMemDev(void* p) {
000ea8  b57c              PUSH     {r2-r6,lr}
000eaa  4605              MOV      r5,r0
;;;1569     GUI_RECT Rect;
;;;1570     WM_Obj* pWin = WM_H2P(GUI_Context.hAWin);
000eac  4968              LDR      r1,|L1.4176|
000eae  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
000eb2  f7fffffe          BL       GUI_ALLOC_h2p
000eb6  4604              MOV      r4,r0
;;;1571     Rect = pWin->InvalidRect;
000eb8  68a0              LDR      r0,[r4,#8]
000eba  9000              STR      r0,[sp,#0]
000ebc  68e0              LDR      r0,[r4,#0xc]
000ebe  9001              STR      r0,[sp,#4]
;;;1572     pWin->InvalidRect = GUI_Context.ClipRect;
000ec0  4863              LDR      r0,|L1.4176|
000ec2  6881              LDR      r1,[r0,#8]  ; GUI_Context
000ec4  60a1              STR      r1,[r4,#8]
000ec6  68c0              LDR      r0,[r0,#0xc]  ; GUI_Context
000ec8  60e0              STR      r0,[r4,#0xc]
;;;1573     WM__PaintWinAndOverlays((WM_PAINTINFO*)p);
000eca  4628              MOV      r0,r5
000ecc  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1574     pWin->InvalidRect = Rect;
000ed0  9800              LDR      r0,[sp,#0]
000ed2  60a0              STR      r0,[r4,#8]
000ed4  9801              LDR      r0,[sp,#4]
000ed6  60e0              STR      r0,[r4,#0xc]
;;;1575   }
000ed8  bd7c              POP      {r2-r6,pc}
;;;1576   #endif
                          ENDP

                  WM__Paint PROC
;;;1584   */
;;;1585   int WM__Paint(WM_HWIN hWin, WM_Obj* pWin) {
000eda  b5f0              PUSH     {r4-r7,lr}
000edc  b085              SUB      sp,sp,#0x14
000ede  4605              MOV      r5,r0
000ee0  460c              MOV      r4,r1
;;;1586     int Ret = 0;
000ee2  f04f0600          MOV      r6,#0
;;;1587     if (pWin->Status & WM_SF_INVALID) {
000ee6  8ba0              LDRH     r0,[r4,#0x1c]
000ee8  f0100f20          TST      r0,#0x20
000eec  d03f              BEQ      |L1.3950|
;;;1588       if (pWin->cb) {
000eee  6920              LDR      r0,[r4,#0x10]
000ef0  b358              CBZ      r0,|L1.3914|
;;;1589         if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
000ef2  4629              MOV      r1,r5
000ef4  f1040008          ADD      r0,r4,#8
000ef8  f7fffffe          BL       WM__ClipAtParentBorders
000efc  b328              CBZ      r0,|L1.3914|
;;;1590           WM_PAINTINFO Info;
;;;1591           Info.hWin = hWin;
000efe  f8ad500c          STRH     r5,[sp,#0xc]
;;;1592           WM_SelectWindow(hWin);
000f02  4628              MOV      r0,r5
000f04  f7fffffe          BL       WM_SelectWindow
;;;1593           #if GUI_SUPPORT_MEMDEV
;;;1594             Info.pWin = NULL; /* 'Invalidate' the window pointer, because it can 
000f08  4630              MOV      r0,r6
000f0a  9004              STR      r0,[sp,#0x10]
;;;1595                                   become invalid through the creation of a memory device
;;;1596                               */
;;;1597             if (pWin->Status & WM_SF_MEMDEV) {
000f0c  8ba0              LDRH     r0,[r4,#0x1c]
000f0e  f0100f04          TST      r0,#4
000f12  d013              BEQ      |L1.3900|
;;;1598               int Flags;
;;;1599               GUI_RECT r = pWin->InvalidRect;
000f14  68a0              LDR      r0,[r4,#8]
000f16  9001              STR      r0,[sp,#4]
000f18  68e0              LDR      r0,[r4,#0xc]
000f1a  9002              STR      r0,[sp,#8]
;;;1600               Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
000f1c  8ba0              LDRH     r0,[r4,#0x1c]
000f1e  f0000001          AND      r0,r0,#1
000f22  f0800701          EOR      r7,r0,#1
;;;1601               /*
;;;1602                * Currently we treat a desktop window as transparent, because per default it does not repaint itself.
;;;1603                */
;;;1604               if (pWin->hParent == 0) {
000f26  8ae0              LDRH     r0,[r4,#0x16]
000f28  b900              CBNZ     r0,|L1.3884|
;;;1605                 Flags = GUI_MEMDEV_HASTRANS;
000f2a  4637              MOV      r7,r6
                  |L1.3884|
;;;1606               }
;;;1607               GUI_MEMDEV_Draw(&r, _cbPaintMemDev, &Info, 0, Flags);
000f2c  2300              MOVS     r3,#0
000f2e  aa03              ADD      r2,sp,#0xc
000f30  494c              LDR      r1,|L1.4196|
000f32  a801              ADD      r0,sp,#4
000f34  9700              STR      r7,[sp,#0]
000f36  f7fffffe          BL       GUI_MEMDEV_Draw
;;;1608             } else
000f3a  e005              B        |L1.3912|
                  |L1.3900|
;;;1609           #endif
;;;1610           {
;;;1611             Info.pWin = pWin;
000f3c  9404              STR      r4,[sp,#0x10]
;;;1612             WM__PaintWinAndOverlays(&Info);
000f3e  a803              ADD      r0,sp,#0xc
000f40  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1613             Ret = 1;    /* Something has been done */
000f44  f04f0601          MOV      r6,#1
                  |L1.3912|
;;;1614           }
;;;1615         }
000f48  bf00              NOP      
                  |L1.3914|
;;;1616       }
;;;1617       /* We purposly clear the invalid flag after painting so we can still query the invalid rectangle while painting */
;;;1618       pWin->Status &=  ~WM_SF_INVALID; /* Clear invalid flag */
000f4a  8ba0              LDRH     r0,[r4,#0x1c]
000f4c  f0200020          BIC      r0,r0,#0x20
000f50  83a0              STRH     r0,[r4,#0x1c]
;;;1619       if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
000f52  8ba0              LDRH     r0,[r4,#0x1c]
000f54  f4105f00          TST      r0,#0x2000
000f58  d003              BEQ      |L1.3938|
;;;1620         pWin->Status |= WM_CF_MEMDEV;
000f5a  8ba0              LDRH     r0,[r4,#0x1c]
000f5c  f0400004          ORR      r0,r0,#4
000f60  83a0              STRH     r0,[r4,#0x1c]
                  |L1.3938|
;;;1621       }
;;;1622       WM__NumInvalidWindows--;
000f62  4841              LDR      r0,|L1.4200|
000f64  8800              LDRH     r0,[r0,#0]  ; WM__NumInvalidWindows
000f66  f1a00001          SUB      r0,r0,#1
000f6a  493f              LDR      r1,|L1.4200|
000f6c  8008              STRH     r0,[r1,#0]
                  |L1.3950|
;;;1623     }
;;;1624     return Ret;      /* Nothing done */
000f6e  4630              MOV      r0,r6
;;;1625   }
000f70  b005              ADD      sp,sp,#0x14
000f72  bdf0              POP      {r4-r7,pc}
;;;1626   
                          ENDP

                  _DrawNext PROC
;;;1630   */
;;;1631   static void _DrawNext(void) {
000f74  b570              PUSH     {r4-r6,lr}
000f76  b098              SUB      sp,sp,#0x60
;;;1632     int UpdateRem = 1;
000f78  f04f0601          MOV      r6,#1
;;;1633     WM_HWIN iWin = (NextDrawWin == WM_HWIN_NULL) ? WM__FirstWin : NextDrawWin;
000f7c  483b              LDR      r0,|L1.4204|
000f7e  8800              LDRH     r0,[r0,#0]  ; NextDrawWin
000f80  b918              CBNZ     r0,|L1.3978|
000f82  483b              LDR      r0,|L1.4208|
000f84  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
000f88  e002              B        |L1.3984|
                  |L1.3978|
000f8a  4838              LDR      r0,|L1.4204|
000f8c  f9b00000          LDRSH    r0,[r0,#0]  ; NextDrawWin
                  |L1.3984|
000f90  4604              MOV      r4,r0
;;;1634     GUI_CONTEXT ContextOld;
;;;1635     GUI_SaveContext(&ContextOld);
000f92  4668              MOV      r0,sp
000f94  f7fffffe          BL       GUI_SaveContext_W_M
;;;1636     /* Make sure the next window to redraw is valid */
;;;1637     for (; iWin && UpdateRem; ) {
000f98  e00d              B        |L1.4022|
                  |L1.3994|
;;;1638       WM_Obj* pWin = WM_H2P(iWin);
000f9a  4620              MOV      r0,r4
000f9c  f7fffffe          BL       GUI_ALLOC_h2p
000fa0  4605              MOV      r5,r0
;;;1639       if (WM__Paint(iWin, pWin)) {
000fa2  4629              MOV      r1,r5
000fa4  4620              MOV      r0,r4
000fa6  f7fffffe          BL       WM__Paint
000faa  b108              CBZ      r0,|L1.4016|
;;;1640         UpdateRem--;  /* Only the given number of windows at a time ... */
000fac  f1a60601          SUB      r6,r6,#1
                  |L1.4016|
;;;1641       }
;;;1642       iWin = pWin->hNextLin;
000fb0  f9b54014          LDRSH    r4,[r5,#0x14]
;;;1643     }  
000fb4  bf00              NOP      
                  |L1.4022|
000fb6  b10c              CBZ      r4,|L1.4028|
000fb8  2e00              CMP      r6,#0                 ;1637
000fba  d1ee              BNE      |L1.3994|
                  |L1.4028|
;;;1644     NextDrawWin = iWin;   /* Remember the window */
000fbc  482b              LDR      r0,|L1.4204|
000fbe  8004              STRH     r4,[r0,#0]
;;;1645     GUI_RestoreContext(&ContextOld);
000fc0  4668              MOV      r0,sp
000fc2  f7fffffe          BL       GUI_RestoreContext
;;;1646   }
000fc6  b018              ADD      sp,sp,#0x60
000fc8  bd70              POP      {r4-r6,pc}
;;;1647   
                          ENDP

                  WM_Exec1 PROC
;;;1651   */
;;;1652   int WM_Exec1(void) {
000fca  b510              PUSH     {r4,lr}
;;;1653     /* Poll PID if necessary */
;;;1654     if (WM_pfPollPID) {
000fcc  4829              LDR      r0,|L1.4212|
000fce  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000fd0  b110              CBZ      r0,|L1.4056|
;;;1655       WM_pfPollPID();
000fd2  4828              LDR      r0,|L1.4212|
000fd4  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000fd6  4780              BLX      r0
                  |L1.4056|
;;;1656     }
;;;1657     if (WM_pfHandlePID) {
000fd8  4827              LDR      r0,|L1.4216|
000fda  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000fdc  b128              CBZ      r0,|L1.4074|
;;;1658       if (WM_pfHandlePID())
000fde  4826              LDR      r0,|L1.4216|
000fe0  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000fe2  4780              BLX      r0
000fe4  b108              CBZ      r0,|L1.4074|
;;;1659         return 1;               /* We have done something ... */
000fe6  2001              MOVS     r0,#1
                  |L1.4072|
;;;1660     }
;;;1661     if (WM_IsActive) {
;;;1662       if (GUI_PollKeyMsg()) {
;;;1663         return 1;               /* We have done something ... */
;;;1664       }
;;;1665     }
;;;1666   #ifdef WIN32
;;;1667     if (WM_PollSimMsg()) {
;;;1668       return 1;               /* We have done something ... */
;;;1669     }
;;;1670   #endif
;;;1671     if (WM_IsActive && WM__NumInvalidWindows) {
;;;1672       WM_LOCK();
;;;1673       _DrawNext();
;;;1674       WM_UNLOCK();
;;;1675       return 1;               /* We have done something ... */
;;;1676     }
;;;1677     return 0;                  /* There was nothing to do ... */
;;;1678   }
000fe8  bd10              POP      {r4,pc}
                  |L1.4074|
000fea  4824              LDR      r0,|L1.4220|
000fec  7800              LDRB     r0,[r0,#0]            ;1661  ; WM_IsActive
000fee  b120              CBZ      r0,|L1.4090|
000ff0  f7fffffe          BL       GUI_PollKeyMsg
000ff4  b108              CBZ      r0,|L1.4090|
000ff6  2001              MOVS     r0,#1                 ;1663
000ff8  e7f6              B        |L1.4072|
                  |L1.4090|
000ffa  4820              LDR      r0,|L1.4220|
000ffc  7800              LDRB     r0,[r0,#0]            ;1671  ; WM_IsActive
000ffe  b130              CBZ      r0,|L1.4110|
001000  4819              LDR      r0,|L1.4200|
001002  8800              LDRH     r0,[r0,#0]            ;1671  ; WM__NumInvalidWindows
001004  b118              CBZ      r0,|L1.4110|
001006  f7fffffe          BL       _DrawNext
00100a  2001              MOVS     r0,#1                 ;1675
00100c  e7ec              B        |L1.4072|
                  |L1.4110|
00100e  2000              MOVS     r0,#0                 ;1677
001010  e7ea              B        |L1.4072|
;;;1679   
                          ENDP

                  WM_Exec PROC
;;;1683   */
;;;1684   int WM_Exec(void) {
001012  b510              PUSH     {r4,lr}
;;;1685     int r = 0;
001014  f04f0400          MOV      r4,#0
;;;1686     while (WM_Exec1()) {
001018  e001              B        |L1.4126|
                  |L1.4122|
;;;1687       r = 1;                  /* We have done something */
00101a  f04f0401          MOV      r4,#1
                  |L1.4126|
00101e  f7fffffe          BL       WM_Exec1
001022  2800              CMP      r0,#0                 ;1686
001024  d1f9              BNE      |L1.4122|
;;;1688     }
;;;1689     return r;
001026  4620              MOV      r0,r4
;;;1690   }
001028  bd10              POP      {r4,pc}
;;;1691   
                          ENDP

                  WM_DefaultProc PROC
;;;1755   */
;;;1756   void WM_DefaultProc(WM_MESSAGE* pMsg) {
00102a  e92d41f0          PUSH     {r4-r8,lr}
00102e  4604              MOV      r4,r0
;;;1757     WM_HWIN hWin = pMsg->hWin;
001030  f9b45004          LDRSH    r5,[r4,#4]
;;;1758     const void *p = pMsg->Data.p;
001034  68a6              LDR      r6,[r4,#8]
;;;1759     WM_Obj* pWin = WM_H2P(hWin);
001036  4628              MOV      r0,r5
001038  f7fffffe          BL       GUI_ALLOC_h2p
00103c  4607              MOV      r7,r0
;;;1760     /* Exec message */
;;;1761     switch (pMsg->MsgId) {
00103e  6820              LDR      r0,[r4,#0]
001040  2817              CMP      r0,#0x17
001042  d027              BEQ      |L1.4244|
001044  dc1c              BGT      |L1.4224|
001046  280e              CMP      r0,#0xe
001048  d027              BEQ      |L1.4250|
00104a  2814              CMP      r0,#0x14
00104c  d132              BNE      |L1.4276|
00104e  e01c              B        |L1.4234|
                  |L1.4176|
                          DCD      GUI_Context
                  |L1.4180|
                          DCD      _ClipContext
                  |L1.4184|
                          DCD      WM__PaintCallbackCnt
                  |L1.4188|
                          DCD      WM__hATransWindow
                  |L1.4192|
                          DCD      WM__TransWindowCnt
                  |L1.4196|
                          DCD      _cbPaintMemDev
                  |L1.4200|
                          DCD      WM__NumInvalidWindows
                  |L1.4204|
                          DCD      NextDrawWin
                  |L1.4208|
                          DCD      WM__FirstWin
                  |L1.4212|
                          DCD      WM_pfPollPID
                  |L1.4216|
                          DCD      WM_pfHandlePID
                  |L1.4220|
                          DCD      WM_IsActive
                  |L1.4224|
001080  2822              CMP      r0,#0x22
001082  d00f              BEQ      |L1.4260|
001084  2828              CMP      r0,#0x28
001086  d115              BNE      |L1.4276|
001088  e010              B        |L1.4268|
                  |L1.4234|
;;;1762     case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
;;;1763       WM__GetClientRectWin(pWin, (GUI_RECT*)p);
00108a  4631              MOV      r1,r6
00108c  4638              MOV      r0,r7
00108e  f7fffffe          BL       WM__GetClientRectWin
;;;1764       break;
001092  e00f              B        |L1.4276|
                  |L1.4244|
;;;1765     case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
;;;1766       pMsg->Data.v = (int)hWin;
001094  60a5              STR      r5,[r4,#8]
                  |L1.4246|
;;;1767       return;                       /* Message handled */
;;;1768     case WM_KEY:
;;;1769       WM_SendToParent(hWin, pMsg);
;;;1770       return;                       /* Message handled */
;;;1771      case WM_GET_BKCOLOR:
;;;1772       pMsg->Data.Color = GUI_INVALID_COLOR;
;;;1773       return;                       /* Message handled */
;;;1774     case WM_NOTIFY_ENABLE:
;;;1775       WM_InvalidateWindow(hWin);    
;;;1776       return;                       /* Message handled */
;;;1777     }
;;;1778     /* Message not handled. If it queries something, we return 0 to be on the safe side. */
;;;1779     pMsg->Data.v = 0;
;;;1780     pMsg->Data.p = 0;
;;;1781   }
001096  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4250|
00109a  4621              MOV      r1,r4                 ;1769
00109c  4628              MOV      r0,r5                 ;1769
00109e  f7fffffe          BL       WM_SendToParent
0010a2  e7f8              B        |L1.4246|
                  |L1.4260|
0010a4  f06f4070          MVN      r0,#0xf0000000        ;1772
0010a8  60a0              STR      r0,[r4,#8]            ;1772
0010aa  e7f4              B        |L1.4246|
                  |L1.4268|
0010ac  4628              MOV      r0,r5                 ;1775
0010ae  f7fffffe          BL       WM_InvalidateWindow
0010b2  e7f0              B        |L1.4246|
                  |L1.4276|
0010b4  bf00              NOP                            ;1764
0010b6  f04f0000          MOV      r0,#0                 ;1779
0010ba  60a0              STR      r0,[r4,#8]            ;1779
0010bc  60a0              STR      r0,[r4,#8]            ;1780
0010be  bf00              NOP      
0010c0  e7e9              B        |L1.4246|
;;;1782   
                          ENDP

                  cbBackWin PROC
;;;1699   */
;;;1700   static void cbBackWin( WM_MESSAGE* pMsg) {
0010c2  b570              PUSH     {r4-r6,lr}
0010c4  4604              MOV      r4,r0
;;;1701     const WM_KEY_INFO* pKeyInfo;
;;;1702     switch (pMsg->MsgId) {
0010c6  6820              LDR      r0,[r4,#0]
0010c8  280e              CMP      r0,#0xe
0010ca  d002              BEQ      |L1.4306|
0010cc  280f              CMP      r0,#0xf
0010ce  d119              BNE      |L1.4356|
0010d0  e007              B        |L1.4322|
                  |L1.4306|
;;;1703     case WM_KEY:
;;;1704       pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
0010d2  68a5              LDR      r5,[r4,#8]
;;;1705       if (pKeyInfo->PressedCnt == 1) {
0010d4  6868              LDR      r0,[r5,#4]
0010d6  2801              CMP      r0,#1
0010d8  d102              BNE      |L1.4320|
;;;1706         GUI_StoreKey(pKeyInfo->Key);
0010da  6828              LDR      r0,[r5,#0]
0010dc  f7fffffe          BL       GUI_StoreKey
                  |L1.4320|
;;;1707       }
;;;1708       break;
0010e0  e014              B        |L1.4364|
                  |L1.4322|
;;;1709     case WM_PAINT:
;;;1710       {
;;;1711         int LayerIndex;
;;;1712         #if GUI_NUM_LAYERS > 1
;;;1713           LayerIndex = _DesktopHandle2Index(pMsg->hWin);
;;;1714         #else
;;;1715           LayerIndex = 0;
0010e2  f04f0600          MOV      r6,#0
;;;1716         #endif
;;;1717         if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
0010e6  482d              LDR      r0,|L1.4508|
0010e8  f8500026          LDR      r0,[r0,r6,LSL #2]
0010ec  f06f4170          MVN      r1,#0xf0000000
0010f0  4288              CMP      r0,r1
0010f2  d006              BEQ      |L1.4354|
;;;1718           GUI_SetBkColor(WM__aBkColor[LayerIndex]);
0010f4  4929              LDR      r1,|L1.4508|
0010f6  f8510026          LDR      r0,[r1,r6,LSL #2]
0010fa  f7fffffe          BL       GUI_SetBkColor
;;;1719           GUI_Clear();
0010fe  f7fffffe          BL       GUI_Clear
                  |L1.4354|
;;;1720         }
;;;1721       }
;;;1722     default:
001102  bf00              NOP      
                  |L1.4356|
;;;1723       WM_DefaultProc(pMsg);
001104  4620              MOV      r0,r4
001106  f7fffffe          BL       WM_DefaultProc
00110a  bf00              NOP                            ;1702
                  |L1.4364|
00110c  bf00              NOP                            ;1708
;;;1724     }
;;;1725   }
00110e  bd70              POP      {r4-r6,pc}
;;;1726   
                          ENDP

                  WM_Activate PROC
;;;1730   */
;;;1731   void WM_Activate(void) {
001110  f04f0001          MOV      r0,#1
;;;1732     WM_IsActive = 1;       /* Running */
001114  4922              LDR      r1,|L1.4512|
001116  7008              STRB     r0,[r1,#0]
;;;1733   }
001118  4770              BX       lr
;;;1734   
                          ENDP

                  WM_Deactivate PROC
;;;1738   */
;;;1739   void WM_Deactivate(void) {
00111a  b510              PUSH     {r4,lr}
;;;1740     WM_IsActive = 0;       /* No clipping performed by WM */
00111c  f04f0000          MOV      r0,#0
001120  491f              LDR      r1,|L1.4512|
001122  7008              STRB     r0,[r1,#0]
;;;1741     WM_LOCK();
;;;1742     LCD_SetClipRectMax();
001124  f7fffffe          BL       LCD_SetClipRectMax
;;;1743     WM_UNLOCK();
;;;1744   }
001128  bd10              POP      {r4,pc}
;;;1745   
                          ENDP

                  WM_Init PROC
;;;1786   */
;;;1787   void WM_Init(void) {
00112a  b50e              PUSH     {r1-r3,lr}
;;;1788   	if (!_IsInited) {
00112c  481d              LDR      r0,|L1.4516|
00112e  7800              LDRB     r0,[r0,#0]  ; _IsInited
001130  bb98              CBNZ     r0,|L1.4506|
;;;1789   	  NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
001132  f04f0000          MOV      r0,#0
001136  491c              LDR      r1,|L1.4520|
001138  8008              STRH     r0,[r1,#0]
00113a  491c              LDR      r1,|L1.4524|
00113c  8008              STRH     r0,[r1,#0]
;;;1790   	  GUI_Context.WM__pUserClipRect = NULL;
00113e  491c              LDR      r1,|L1.4528|
001140  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1791   	  WM__NumWindows = WM__NumInvalidWindows =0;
001142  491c              LDR      r1,|L1.4532|
001144  8008              STRH     r0,[r1,#0]
001146  491c              LDR      r1,|L1.4536|
001148  8008              STRH     r0,[r1,#0]
;;;1792   	  /* Make sure we have at least one window. This greatly simplifies the
;;;1793   		  drawing routines as they do not have to check if the window is valid.
;;;1794   	  */
;;;1795       #if GUI_NUM_LAYERS == 1
;;;1796         WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
00114a  491c              LDR      r1,|L1.4540|
00114c  f04f0202          MOV      r2,#2
001150  f64073ff          MOV      r3,#0xfff
001154  e9cd2100          STRD     r2,r1,[sp,#0]
001158  9002              STR      r0,[sp,#8]
00115a  461a              MOV      r2,r3
00115c  4601              MOV      r1,r0
00115e  f7fffffe          BL       WM_CreateWindow
001162  4917              LDR      r1,|L1.4544|
001164  8008              STRH     r0,[r1,#0]
;;;1797         WM__aBkColor[0] = GUI_INVALID_COLOR;
001166  f06f4070          MVN      r0,#0xf0000000
00116a  490c              LDR      r1,|L1.4508|
00116c  6008              STR      r0,[r1,#0]  ; WM__aBkColor
;;;1798         WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
00116e  4914              LDR      r1,|L1.4544|
001170  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
001174  f7fffffe          BL       WM_InvalidateWindow
;;;1799       #else
;;;1800       {
;;;1801         int i;
;;;1802         for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;1803           WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
;;;1804           WM__aBkColor[i] = GUI_INVALID_COLOR;
;;;1805           WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
;;;1806         }
;;;1807       }
;;;1808       #endif
;;;1809       /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
;;;1810       WM__AddCriticalHandle(&WM__CHWinModal);
001178  4812              LDR      r0,|L1.4548|
00117a  f7fffffe          BL       WM__AddCriticalHandle
;;;1811       WM__AddCriticalHandle(&WM__CHWinLast);
00117e  4812              LDR      r0,|L1.4552|
001180  f7fffffe          BL       WM__AddCriticalHandle
;;;1812       #if GUI_SUPPORT_MOUSE
;;;1813         WM__AddCriticalHandle(&WM__CHWinMouseOver);
;;;1814       #endif
;;;1815   
;;;1816       WM_SelectWindow(WM__ahDesktopWin[0]);
001184  490e              LDR      r1,|L1.4544|
001186  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
00118a  f7fffffe          BL       WM_SelectWindow
;;;1817   	  WM_Activate();
00118e  f7fffffe          BL       WM_Activate
;;;1818       _IsInited =1;
001192  f04f0001          MOV      r0,#1
001196  4903              LDR      r1,|L1.4516|
001198  7008              STRB     r0,[r1,#0]
                  |L1.4506|
;;;1819   	}
;;;1820   }
00119a  bd0e              POP      {r1-r3,pc}
;;;1821   
                          ENDP

                  |L1.4508|
                          DCD      WM__aBkColor
                  |L1.4512|
                          DCD      WM_IsActive
                  |L1.4516|
                          DCD      _IsInited
                  |L1.4520|
                          DCD      WM__FirstWin
                  |L1.4524|
                          DCD      NextDrawWin
                  |L1.4528|
                          DCD      GUI_Context
                  |L1.4532|
                          DCD      WM__NumInvalidWindows
                  |L1.4536|
                          DCD      WM__NumWindows
                  |L1.4540|
                          DCD      cbBackWin
                  |L1.4544|
                          DCD      WM__ahDesktopWin
                  |L1.4548|
                          DCD      WM__CHWinModal
                  |L1.4552|
                          DCD      WM__CHWinLast

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  WM_PID__StateLast
                          %        12
                  _ClipContext
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  WM__NumWindows
000000  0000              DCB      0x00,0x00
                  WM__NumInvalidWindows
000002  0000              DCB      0x00,0x00
                  WM__FirstWin
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__pFirstCriticalHandle
                          DCD      0x00000000
                  WM__ahDesktopWin
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__aBkColor
                          DCD      0x00000000
                  WM_IsActive
000014  0000              DCB      0x00,0x00
                  WM__CreateFlags
000016  0000              DCB      0x00,0x00
                  WM__hCapture
000018  0000              DCB      0x00,0x00
                  WM__hWinFocus
00001a  0000              DCB      0x00,0x00
                  WM__CaptureReleaseAuto
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM_pfPollPID
                          DCD      0x00000000
                  WM__PaintCallbackCnt
000024  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__TransWindowCnt
                          DCD      0x00000000
                  WM__hATransWindow
00002c  0000              DCB      0x00,0x00
                  NextDrawWin
00002e  0000              DCB      0x00,0x00
                  _IsInited
000030  00                DCB      0x00
