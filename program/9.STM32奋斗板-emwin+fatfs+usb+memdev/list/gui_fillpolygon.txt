; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\gui_fillpolygon.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\gui_fillpolygon.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\gui_fillpolygon.crf GUI\Core\GUI_FillPolygon.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _DrawHLine PROC
;;;52     */
;;;53     static void _DrawHLine(int x0, int y, int x1) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;54       if (x0 < x1) {
000008  42ac              CMP      r4,r5
00000a  da07              BGE      |L1.28|
;;;55         LCD_HL_DrawHLine(x0, y, x1);
00000c  48d2              LDR      r0,|L1.856|
00000e  6d80              LDR      r0,[r0,#0x58]  ; GUI_Context
000010  462a              MOV      r2,r5
000012  4631              MOV      r1,r6
000014  6803              LDR      r3,[r0,#0]
000016  4620              MOV      r0,r4
000018  4798              BLX      r3
00001a  e006              B        |L1.42|
                  |L1.28|
;;;56       } else {
;;;57         LCD_HL_DrawHLine(x1, y, x0);
00001c  48ce              LDR      r0,|L1.856|
00001e  6d80              LDR      r0,[r0,#0x58]  ; GUI_Context
000020  4622              MOV      r2,r4
000022  4631              MOV      r1,r6
000024  6803              LDR      r3,[r0,#0]
000026  4628              MOV      r0,r5
000028  4798              BLX      r3
                  |L1.42|
;;;58       }
;;;59     }
00002a  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

                  _CheckYInterSect PROC
;;;74     */
;;;75     static int _CheckYInterSect(int y, int* px, const GUI_POINT*paPoint0, const GUI_POINT*paPoint1) {
00002c  e92d43f0          PUSH     {r4-r9,lr}
000030  4604              MOV      r4,r0
000032  468c              MOV      r12,r1
000034  4615              MOV      r5,r2
;;;76       int x0, y0, x1, y1;
;;;77       if (paPoint0->y <= (paPoint1)->y) {
000036  f9b50002          LDRSH    r0,[r5,#2]
00003a  f9b38002          LDRSH    r8,[r3,#2]
00003e  4540              CMP      r0,r8
000040  dc11              BGT      |L1.102|
;;;78         y0 = paPoint0->y;
000042  f9b51002          LDRSH    r1,[r5,#2]
;;;79         if (y0 > y)      /* Check if there is an intersection ... (early out) */
000046  42a1              CMP      r1,r4
000048  dd02              BLE      |L1.80|
;;;80           return 0;
00004a  2000              MOVS     r0,#0
                  |L1.76|
;;;81         y1 = paPoint1->y;
;;;82         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;83           return 0;
;;;84         x0 = paPoint0->x;
;;;85         x1 = paPoint1->x;
;;;86       } else {
;;;87         y0 = paPoint1->y;
;;;88         if (y0 > y)      /* Check if there is an intersection ... (early out) */
;;;89           return 0;
;;;90         y1 = paPoint0->y;
;;;91         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;92           return 0;
;;;93         x0 = paPoint1->x;
;;;94         x1 = paPoint0->x;
;;;95       }
;;;96     /* Calculate intersection */
;;;97       {
;;;98         I32 Mul = (I32)(x1 - x0) * (I32)(y - y0);
;;;99         if (Mul > 0) {
;;;100          Mul += (y1 - y0) >> 1;	          /* for proper rounding */
;;;101        } else {
;;;102          Mul -= ((y1 - y0) >> 1) - 1;	    /* for proper rounding */
;;;103        }
;;;104        x0 += Mul / (y1 - y0);
;;;105      }
;;;106      *px = x0;
;;;107      return 1;
;;;108    } 
00004c  e8bd83f0          POP      {r4-r9,pc}
                  |L1.80|
000050  f9b32002          LDRSH    r2,[r3,#2]            ;81
000054  42a2              CMP      r2,r4                 ;82
000056  da01              BGE      |L1.92|
000058  2000              MOVS     r0,#0                 ;83
00005a  e7f7              B        |L1.76|
                  |L1.92|
00005c  f9b56000          LDRSH    r6,[r5,#0]            ;84
000060  f9b37000          LDRSH    r7,[r3,#0]            ;85
000064  e00f              B        |L1.134|
                  |L1.102|
000066  f9b31002          LDRSH    r1,[r3,#2]            ;87
00006a  42a1              CMP      r1,r4                 ;88
00006c  dd01              BLE      |L1.114|
00006e  2000              MOVS     r0,#0                 ;89
000070  e7ec              B        |L1.76|
                  |L1.114|
000072  f9b52002          LDRSH    r2,[r5,#2]            ;90
000076  42a2              CMP      r2,r4                 ;91
000078  da01              BGE      |L1.126|
00007a  2000              MOVS     r0,#0                 ;92
00007c  e7e6              B        |L1.76|
                  |L1.126|
00007e  f9b36000          LDRSH    r6,[r3,#0]            ;93
000082  f9b57000          LDRSH    r7,[r5,#0]            ;94
                  |L1.134|
000086  eba70806          SUB      r8,r7,r6              ;98
00008a  eba40901          SUB      r9,r4,r1              ;98
00008e  fb08f009          MUL      r0,r8,r9              ;98
000092  2800              CMP      r0,#0                 ;99
000094  dd04              BLE      |L1.160|
000096  eba20801          SUB      r8,r2,r1              ;100
00009a  eb000068          ADD      r0,r0,r8,ASR #1       ;100
00009e  e007              B        |L1.176|
                  |L1.160|
0000a0  eba20801          SUB      r8,r2,r1              ;102
0000a4  f04f0901          MOV      r9,#1                 ;102
0000a8  ebc90868          RSB      r8,r9,r8,ASR #1       ;102
0000ac  eba00008          SUB      r0,r0,r8              ;102
                  |L1.176|
0000b0  eba20801          SUB      r8,r2,r1              ;104
0000b4  fb90f8f8          SDIV     r8,r0,r8              ;104
0000b8  4446              ADD      r6,r6,r8              ;104
0000ba  f8cc6000          STR      r6,[r12,#0]           ;106
0000be  f04f0001          MOV      r0,#1                 ;107
0000c2  e7c3              B        |L1.76|
;;;109    
                          ENDP

                  _Add PROC
;;;115    */
;;;116    static void _Add(int x) {
0000c4  4601              MOV      r1,r0
;;;117      if (GL_FP_Cnt < GUI_FP_MAXCOUNT) {
0000c6  48a5              LDR      r0,|L1.860|
0000c8  6800              LDR      r0,[r0,#0]  ; GL_FP_Cnt
0000ca  280c              CMP      r0,#0xc
0000cc  da20              BGE      |L1.272|
;;;118        int i;
;;;119        /* Move all entries to the right (bigger x-value) */
;;;120        for (i=GL_FP_Cnt; i ; i--) {
0000ce  4aa3              LDR      r2,|L1.860|
0000d0  6810              LDR      r0,[r2,#0]  ; GL_FP_Cnt
0000d2  e00f              B        |L1.244|
                  |L1.212|
;;;121          if (_aX[i-1] < x)
0000d4  1e42              SUBS     r2,r0,#1
0000d6  4ba2              LDR      r3,|L1.864|
0000d8  f9332012          LDRSH    r2,[r3,r2,LSL #1]
0000dc  428a              CMP      r2,r1
0000de  da00              BGE      |L1.226|
;;;122            break;
0000e0  e00a              B        |L1.248|
                  |L1.226|
;;;123          _aX[i] = _aX[i-1];
0000e2  f1a00201          SUB      r2,r0,#1
0000e6  4b9e              LDR      r3,|L1.864|
0000e8  f8332012          LDRH     r2,[r3,r2,LSL #1]
0000ec  f8232010          STRH     r2,[r3,r0,LSL #1]
0000f0  f1a00001          SUB      r0,r0,#1              ;120
                  |L1.244|
0000f4  2800              CMP      r0,#0                 ;120
0000f6  d1ed              BNE      |L1.212|
                  |L1.248|
0000f8  bf00              NOP                            ;122
;;;124        }
;;;125        /* Insert new entry */
;;;126        _aX[i]    = x;
0000fa  b20a              SXTH     r2,r1
0000fc  4b98              LDR      r3,|L1.864|
0000fe  f8232010          STRH     r2,[r3,r0,LSL #1]
;;;127        GL_FP_Cnt++;
000102  4a96              LDR      r2,|L1.860|
000104  6812              LDR      r2,[r2,#0]  ; GL_FP_Cnt
000106  f1020201          ADD      r2,r2,#1
00010a  4b94              LDR      r3,|L1.860|
00010c  601a              STR      r2,[r3,#0]  ; GL_FP_Cnt
;;;128      }
00010e  bf00              NOP      
                  |L1.272|
;;;129    }
000110  4770              BX       lr
;;;130    
                          ENDP

                  _Init PROC
;;;136    */
;;;137    static void _Init(void) {
000112  f04f0000          MOV      r0,#0
;;;138      GL_FP_Cnt = 0;
000116  4991              LDR      r1,|L1.860|
000118  6008              STR      r0,[r1,#0]  ; GL_FP_Cnt
;;;139    }
00011a  4770              BX       lr
;;;140    
                          ENDP

                  _Flush PROC
;;;146    */
;;;147    static void _Flush(int x0, int y) {
00011c  e92d47f0          PUSH     {r4-r10,lr}
000120  4604              MOV      r4,r0
000122  4688              MOV      r8,r1
;;;148      int i, x = 0;
000124  f04f0900          MOV      r9,#0
;;;149      char On=0;
000128  464e              MOV      r6,r9
;;;150      for (i=0; i<GL_FP_Cnt; i++) {
00012a  4635              MOV      r5,r6
00012c  e010              B        |L1.336|
                  |L1.302|
;;;151        int xNew = _aX[i];
00012e  488c              LDR      r0,|L1.864|
000130  f9307015          LDRSH    r7,[r0,r5,LSL #1]
;;;152        if (On) {
000134  b13e              CBZ      r6,|L1.326|
;;;153          LCD_HL_DrawHLine(x0 + x, y, x0 + xNew);
000136  19e2              ADDS     r2,r4,r7
000138  eb040009          ADD      r0,r4,r9
00013c  4986              LDR      r1,|L1.856|
00013e  6d89              LDR      r1,[r1,#0x58]  ; GUI_Context
000140  680b              LDR      r3,[r1,#0]
000142  4641              MOV      r1,r8
000144  4798              BLX      r3
                  |L1.326|
;;;154        }
;;;155        On ^= 1;
000146  f0860601          EOR      r6,r6,#1
;;;156        x = xNew;
00014a  46b9              MOV      r9,r7
00014c  f1050501          ADD      r5,r5,#1              ;150
                  |L1.336|
000150  4882              LDR      r0,|L1.860|
000152  6800              LDR      r0,[r0,#0]            ;150  ; GL_FP_Cnt
000154  4285              CMP      r5,r0                 ;150
000156  dbea              BLT      |L1.302|
;;;157      }
;;;158    }
000158  e8bd87f0          POP      {r4-r10,pc}
;;;159    
                          ENDP

                  _AddPoint PROC
;;;167    */
;;;168    static void _AddPoint(int x, int y, int y0, int y1, int xOff, int yOff) {
00015c  e92d47f0          PUSH     {r4-r10,lr}
000160  4604              MOV      r4,r0
000162  460d              MOV      r5,r1
000164  4616              MOV      r6,r2
000166  461f              MOV      r7,r3
000168  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;169      if ((y0 ^ y1) >= 0) {
00016c  ea960007          EORS     r0,r6,r7
000170  d409              BMI      |L1.390|
;;;170        x += xOff;
000172  4444              ADD      r4,r4,r8
;;;171        LCD_HL_DrawHLine(x, y + yOff, x);    /* V-point, not crossing the polygon */
000174  eb050109          ADD      r1,r5,r9
000178  4877              LDR      r0,|L1.856|
00017a  6d80              LDR      r0,[r0,#0x58]  ; GUI_Context
00017c  4622              MOV      r2,r4
00017e  6803              LDR      r3,[r0,#0]
000180  4620              MOV      r0,r4
000182  4798              BLX      r3
000184  e002              B        |L1.396|
                  |L1.390|
;;;172      } else {
;;;173        _Add(x);
000186  4620              MOV      r0,r4
000188  f7fffffe          BL       _Add
                  |L1.396|
;;;174      }
;;;175    }
00018c  e8bd87f0          POP      {r4-r10,pc}
;;;176    
                          ENDP

                  _GetPrevPointDiffy PROC
;;;182    */
;;;183    static int _GetPrevPointDiffy(const GUI_POINT* paPoint, int i,
000190  b570              PUSH     {r4-r6,lr}
;;;184                                  const int NumPoints, const int y0) {
000192  4605              MOV      r5,r0
;;;185      int j, y1;
;;;186      for (j = 0; j < (NumPoints - 1) ; j++) {
000194  f04f0600          MOV      r6,#0
000198  e010              B        |L1.444|
                  |L1.410|
;;;187        i = (i != 0) ? i - 1 : NumPoints - 1;
00019a  b111              CBZ      r1,|L1.418|
00019c  f1a10001          SUB      r0,r1,#1
0001a0  e001              B        |L1.422|
                  |L1.418|
0001a2  f1a20001          SUB      r0,r2,#1
                  |L1.422|
0001a6  4601              MOV      r1,r0
;;;188        y1 = (paPoint + i)->y;
0001a8  eb050081          ADD      r0,r5,r1,LSL #2
0001ac  f9b04002          LDRSH    r4,[r0,#2]
;;;189        if (y1 != y0) {
0001b0  429c              CMP      r4,r3
0001b2  d001              BEQ      |L1.440|
;;;190          return y1;
0001b4  4620              MOV      r0,r4
                  |L1.438|
;;;191        }
;;;192      }
;;;193      return y0;
;;;194    }
0001b6  bd70              POP      {r4-r6,pc}
                  |L1.440|
0001b8  f1060601          ADD      r6,r6,#1              ;186
                  |L1.444|
0001bc  1e50              SUBS     r0,r2,#1              ;186
0001be  42b0              CMP      r0,r6                 ;186
0001c0  dceb              BGT      |L1.410|
0001c2  4618              MOV      r0,r3                 ;193
0001c4  e7f7              B        |L1.438|
;;;195    
                          ENDP

                  GL_FillPolygon PROC
;;;207    */
;;;208    void GL_FillPolygon  (const GUI_POINT*paPoint, int NumPoints, int xOff, int yOff) {
0001c6  e92d4ff0          PUSH     {r4-r11,lr}
0001ca  b087              SUB      sp,sp,#0x1c
0001cc  4606              MOV      r6,r0
0001ce  4689              MOV      r9,r1
0001d0  4692              MOV      r10,r2
0001d2  461f              MOV      r7,r3
;;;209      int i, y;
;;;210      int yMin = GUI_YMAX;
0001d4  f64070ff          MOV      r0,#0xfff
0001d8  9006              STR      r0,[sp,#0x18]
;;;211      int yMax = GUI_YMIN;
0001da  f1c00000          RSB      r0,r0,#0
0001de  9005              STR      r0,[sp,#0x14]
;;;212    /* First step : find uppermost and lowermost coordinates */
;;;213      for (i=0; i<NumPoints; i++) {
0001e0  f04f0500          MOV      r5,#0
0001e4  e00d              B        |L1.514|
                  |L1.486|
;;;214        y = (paPoint + i)->y;
0001e6  eb060085          ADD      r0,r6,r5,LSL #2
0001ea  f9b04002          LDRSH    r4,[r0,#2]
;;;215        if (y < yMin)
0001ee  9806              LDR      r0,[sp,#0x18]
0001f0  4284              CMP      r4,r0
0001f2  da00              BGE      |L1.502|
;;;216          yMin = y;
0001f4  9406              STR      r4,[sp,#0x18]
                  |L1.502|
;;;217        if (y > yMax)
0001f6  9805              LDR      r0,[sp,#0x14]
0001f8  4284              CMP      r4,r0
0001fa  dd00              BLE      |L1.510|
;;;218          yMax = y;
0001fc  9405              STR      r4,[sp,#0x14]
                  |L1.510|
0001fe  f1050501          ADD      r5,r5,#1              ;213
                  |L1.514|
000202  454d              CMP      r5,r9                 ;213
000204  dbef              BLT      |L1.486|
;;;219      }
;;;220    /* Use Clipping rect to reduce calculation (if possible) */
;;;221      if (GUI_Context.pClipRect_HL) {
000206  4854              LDR      r0,|L1.856|
000208  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
00020a  b1e8              CBZ      r0,|L1.584|
;;;222        if (yMax > (GUI_Context.pClipRect_HL->y1 - yOff))
00020c  4852              LDR      r0,|L1.856|
00020e  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
000210  f9b00006          LDRSH    r0,[r0,#6]
000214  1bc1              SUBS     r1,r0,r7
000216  9805              LDR      r0,[sp,#0x14]
000218  4281              CMP      r1,r0
00021a  da06              BGE      |L1.554|
;;;223          yMax = (GUI_Context.pClipRect_HL->y1 - yOff);
00021c  484e              LDR      r0,|L1.856|
00021e  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
000220  f9b00006          LDRSH    r0,[r0,#6]
000224  eba00007          SUB      r0,r0,r7
000228  9005              STR      r0,[sp,#0x14]
                  |L1.554|
;;;224        if (yMin < (GUI_Context.pClipRect_HL->y0 - yOff))
00022a  484b              LDR      r0,|L1.856|
00022c  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
00022e  f9b00002          LDRSH    r0,[r0,#2]
000232  1bc1              SUBS     r1,r0,r7
000234  9806              LDR      r0,[sp,#0x18]
000236  4281              CMP      r1,r0
000238  dd06              BLE      |L1.584|
;;;225          yMin = (GUI_Context.pClipRect_HL->y0 - yOff);
00023a  4847              LDR      r0,|L1.856|
00023c  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
00023e  f9b00002          LDRSH    r0,[r0,#2]
000242  eba00007          SUB      r0,r0,r7
000246  9006              STR      r0,[sp,#0x18]
                  |L1.584|
;;;226      }
;;;227    /* Second step: Calculate and draw horizontal lines */
;;;228      for (y=yMin; y<=yMax; y++) {
000248  9c06              LDR      r4,[sp,#0x18]
00024a  e060              B        |L1.782|
                  |L1.588|
;;;229        _Init();
00024c  f7fffffe          BL       _Init
;;;230        /* find next intersection and count lines*/
;;;231        for (i=0; i<NumPoints; i++) {
000250  f04f0500          MOV      r5,#0
000254  e053              B        |L1.766|
                  |L1.598|
;;;232          int i1 = (i < (NumPoints - 1)) ? i + 1 : 0;
000256  f1a90001          SUB      r0,r9,#1
00025a  42a8              CMP      r0,r5
00025c  dd02              BLE      |L1.612|
00025e  f1050001          ADD      r0,r5,#1
000262  e001              B        |L1.616|
                  |L1.612|
000264  f04f0000          MOV      r0,#0
                  |L1.616|
000268  9004              STR      r0,[sp,#0x10]
;;;233          int y0 = (paPoint + i )->y;
00026a  eb060085          ADD      r0,r6,r5,LSL #2
00026e  f9b0b002          LDRSH    r11,[r0,#2]
;;;234          int y1 = (paPoint + i1)->y;
000272  9804              LDR      r0,[sp,#0x10]
000274  eb060080          ADD      r0,r6,r0,LSL #2
000278  f9b08002          LDRSH    r8,[r0,#2]
;;;235          /* Check if starting point is on line */
;;;236          if (y0 == y) {
00027c  45a3              CMP      r11,r4
00027e  d124              BNE      |L1.714|
;;;237            if (y1 == y) {  /* Add the entire line */
000280  45a0              CMP      r8,r4
000282  d10c              BNE      |L1.670|
;;;238              _DrawHLine((paPoint + i )->x + xOff , y + yOff, (paPoint + i1)->x + xOff);
000284  9b04              LDR      r3,[sp,#0x10]
000286  f9363023          LDRSH    r3,[r6,r3,LSL #2]
00028a  eb03020a          ADD      r2,r3,r10
00028e  19e1              ADDS     r1,r4,r7
000290  f9363025          LDRSH    r3,[r6,r5,LSL #2]
000294  eb03000a          ADD      r0,r3,r10
000298  f7fffffe          BL       _DrawHLine
00029c  e02d              B        |L1.762|
                  |L1.670|
;;;239            } else {        /* Add only one point */
;;;240              int yPrev = _GetPrevPointDiffy(paPoint, i, NumPoints, y);
00029e  4623              MOV      r3,r4
0002a0  464a              MOV      r2,r9
0002a2  4629              MOV      r1,r5
0002a4  4630              MOV      r0,r6
0002a6  f7fffffe          BL       _GetPrevPointDiffy
0002aa  9003              STR      r0,[sp,#0xc]
;;;241              if (yPrev != y) {
0002ac  9803              LDR      r0,[sp,#0xc]
0002ae  42a0              CMP      r0,r4
0002b0  d00a              BEQ      |L1.712|
;;;242                _AddPoint((paPoint + i)->x, y, yPrev - y, y1 - y, xOff, yOff);
0002b2  eba80304          SUB      r3,r8,r4
0002b6  e9cda700          STRD     r10,r7,[sp,#0]
0002ba  9903              LDR      r1,[sp,#0xc]
0002bc  1b0a              SUBS     r2,r1,r4
0002be  f9360025          LDRSH    r0,[r6,r5,LSL #2]
0002c2  4621              MOV      r1,r4
0002c4  f7fffffe          BL       _AddPoint
                  |L1.712|
;;;243              } 
;;;244            }
0002c8  e017              B        |L1.762|
                  |L1.714|
;;;245          } else if (y1 != y) {  /* Ignore if end-point is on the line */
0002ca  45a0              CMP      r8,r4
0002cc  d015              BEQ      |L1.762|
;;;246            if (((y1 >= y) && (y0 <= y)) || ((y0 >= y) && (y1 <= y))) {
0002ce  45a0              CMP      r8,r4
0002d0  db01              BLT      |L1.726|
0002d2  45a3              CMP      r11,r4
0002d4  dd03              BLE      |L1.734|
                  |L1.726|
0002d6  45a3              CMP      r11,r4
0002d8  db0f              BLT      |L1.762|
0002da  45a0              CMP      r8,r4
0002dc  dc0d              BGT      |L1.762|
                  |L1.734|
;;;247              int xIntersect;
;;;248              if (_CheckYInterSect(y, &xIntersect, paPoint + i, paPoint + i1)) {
0002de  9804              LDR      r0,[sp,#0x10]
0002e0  eb060380          ADD      r3,r6,r0,LSL #2
0002e4  eb060285          ADD      r2,r6,r5,LSL #2
0002e8  a903              ADD      r1,sp,#0xc
0002ea  4620              MOV      r0,r4
0002ec  f7fffffe          BL       _CheckYInterSect
0002f0  b110              CBZ      r0,|L1.760|
;;;249                _Add(xIntersect);
0002f2  9803              LDR      r0,[sp,#0xc]
0002f4  f7fffffe          BL       _Add
                  |L1.760|
;;;250              }
;;;251            }
0002f8  bf00              NOP      
                  |L1.762|
0002fa  f1050501          ADD      r5,r5,#1              ;231
                  |L1.766|
0002fe  454d              CMP      r5,r9                 ;231
000300  dba9              BLT      |L1.598|
;;;252          }
;;;253        }
;;;254        _Flush(xOff, y + yOff);
000302  19e1              ADDS     r1,r4,r7
000304  4650              MOV      r0,r10
000306  f7fffffe          BL       _Flush
00030a  f1040401          ADD      r4,r4,#1              ;228
                  |L1.782|
00030e  9805              LDR      r0,[sp,#0x14]         ;228
000310  4284              CMP      r4,r0                 ;228
000312  dd9b              BLE      |L1.588|
;;;255      }  
;;;256    }
000314  b007              ADD      sp,sp,#0x1c
000316  e8bd8ff0          POP      {r4-r11,pc}
;;;257    
                          ENDP

                  GUI_FillPolygon PROC
;;;261    */
;;;262    void GUI_FillPolygon(const GUI_POINT* pPoints, int NumPoints, int x0, int y0) {
00031a  e92d41f0          PUSH     {r4-r8,lr}
00031e  4606              MOV      r6,r0
000320  460f              MOV      r7,r1
000322  4614              MOV      r4,r2
000324  461d              MOV      r5,r3
;;;263      GUI_LOCK();
;;;264      #if (GUI_WINSUPPORT)
;;;265        WM_ADDORG(x0, y0);
000326  480c              LDR      r0,|L1.856|
000328  6c00              LDR      r0,[r0,#0x40]  ; GUI_Context
00032a  4404              ADD      r4,r4,r0
00032c  480a              LDR      r0,|L1.856|
00032e  6c40              LDR      r0,[r0,#0x44]  ; GUI_Context
000330  4405              ADD      r5,r5,r0
;;;266        WM_ITERATE_START(NULL); {
000332  f04f0000          MOV      r0,#0
000336  f7fffffe          BL       WM__InitIVRSearch
00033a  b150              CBZ      r0,|L1.850|
00033c  bf00              NOP      
                  |L1.830|
;;;267      #endif
;;;268      GL_FillPolygon (pPoints, NumPoints, x0, y0);
00033e  462b              MOV      r3,r5
000340  4622              MOV      r2,r4
000342  4639              MOV      r1,r7
000344  4630              MOV      r0,r6
000346  f7fffffe          BL       GL_FillPolygon
;;;269      #if (GUI_WINSUPPORT)
;;;270        } WM_ITERATE_END();
00034a  f7fffffe          BL       WM__GetNextIVR
00034e  2800              CMP      r0,#0
000350  d1f5              BNE      |L1.830|
                  |L1.850|
;;;271      #endif
;;;272      GUI_UNLOCK();
;;;273    }
000352  e8bd81f0          POP      {r4-r8,pc}
;;;274    
                          ENDP

000356  0000              DCW      0x0000
                  |L1.856|
                          DCD      GUI_Context
                  |L1.860|
                          DCD      GL_FP_Cnt
                  |L1.864|
                          DCD      _aX

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  _aX
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  GL_FP_Cnt
                          DCD      0x00000000
