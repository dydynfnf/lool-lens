; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jquant2.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jquant2.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jquant2.crf GUI\JPEG\jquant2.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prescan_quantize PROC
;;;223    METHODDEF(void)
;;;224    prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;225    		  JSAMPARRAY output_buf, int num_rows)
;;;226    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;227      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00000a  f8d4c1cc          LDR      r12,[r4,#0x1cc]
;;;228      register JSAMPROW ptr;
;;;229      register histptr histp;
;;;230      register hist3d histogram = cquantize->histogram;
00000e  f8dc8018          LDR      r8,[r12,#0x18]
;;;231      int row;
;;;232      JDIMENSION col;
;;;233      JDIMENSION width = cinfo->output_width;
000012  f8d49070          LDR      r9,[r4,#0x70]
;;;234    
;;;235      GUI_USE_PARA(output_buf);
000016  bf00              NOP      
;;;236      for (row = 0; row < num_rows; row++) {
000018  f04f0200          MOV      r2,#0
00001c  e02e              B        |L1.124|
                  |L1.30|
;;;237        ptr = input_buf[row];
00001e  f8551022          LDR      r1,[r5,r2,LSL #2]
;;;238        for (col = width; col > 0; col--) {
000022  464f              MOV      r7,r9
000024  e026              B        |L1.116|
                  |L1.38|
;;;239          /* get pixel value and index into the histogram */
;;;240          histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
000026  f891a000          LDRB     r10,[r1,#0]
00002a  ea4f0aea          ASR      r10,r10,#3
00002e  f858a02a          LDR      r10,[r8,r10,LSL #2]
000032  f891b001          LDRB     r11,[r1,#1]
000036  ea4f0bab          ASR      r11,r11,#2
00003a  eb0a1a8b          ADD      r10,r10,r11,LSL #6
00003e  f891b002          LDRB     r11,[r1,#2]
000042  ea4f0beb          ASR      r11,r11,#3
000046  eb0a004b          ADD      r0,r10,r11,LSL #1
;;;241    			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
;;;242    			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
;;;243          /* increment, check for overflow and undo increment if so. */
;;;244          if (++(*histp) <= 0)
00004a  f8b0a000          LDRH     r10,[r0,#0]
00004e  f10a0a01          ADD      r10,r10,#1
000052  fa1ffa8a          UXTH     r10,r10
000056  f8a0a000          STRH     r10,[r0,#0]
00005a  f1ba0f00          CMP      r10,#0
00005e  dc05              BGT      |L1.108|
;;;245    	(*histp)--;
000060  f8b0a000          LDRH     r10,[r0,#0]
000064  f1aa0a01          SUB      r10,r10,#1
000068  f8a0a000          STRH     r10,[r0,#0]
                  |L1.108|
;;;246          ptr += 3;
00006c  f1010103          ADD      r1,r1,#3
000070  f1a70701          SUB      r7,r7,#1              ;238
                  |L1.116|
000074  2f00              CMP      r7,#0                 ;238
000076  d1d6              BNE      |L1.38|
000078  f1020201          ADD      r2,r2,#1              ;236
                  |L1.124|
00007c  429a              CMP      r2,r3                 ;236
00007e  dbce              BLT      |L1.30|
;;;247        }
;;;248      }
;;;249    }
000080  e8bd8ff0          POP      {r4-r11,pc}
;;;250    
                          ENDP

                  find_biggest_color_pop PROC
;;;273    LOCAL(boxptr)
;;;274    find_biggest_color_pop (boxptr boxlist, int numboxes)
000084  b570              PUSH     {r4-r6,lr}
;;;275    /* Find the splittable box with the largest color population */
;;;276    /* Returns NULL if no splittable boxes remain */
;;;277    {
000086  4602              MOV      r2,r0
000088  460b              MOV      r3,r1
;;;278      register boxptr boxp;
;;;279      register int i;
;;;280      register long maxc = 0;
00008a  f04f0500          MOV      r5,#0
;;;281      boxptr which = NULL;
00008e  4628              MOV      r0,r5
;;;282      
;;;283      for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
000090  4604              MOV      r4,r0
000092  4611              MOV      r1,r2
000094  e00b              B        |L1.174|
                  |L1.150|
;;;284        if (boxp->colorcount > maxc && boxp->volume > 0) {
000096  69ce              LDR      r6,[r1,#0x1c]
000098  42ae              CMP      r6,r5
00009a  dd04              BLE      |L1.166|
00009c  698e              LDR      r6,[r1,#0x18]
00009e  2e00              CMP      r6,#0
0000a0  dd01              BLE      |L1.166|
;;;285          which = boxp;
0000a2  4608              MOV      r0,r1
;;;286          maxc = boxp->colorcount;
0000a4  69cd              LDR      r5,[r1,#0x1c]
                  |L1.166|
0000a6  f1040401          ADD      r4,r4,#1              ;283
0000aa  f1010120          ADD      r1,r1,#0x20           ;283
                  |L1.174|
0000ae  429c              CMP      r4,r3                 ;283
0000b0  dbf1              BLT      |L1.150|
;;;287        }
;;;288      }
;;;289      return which;
;;;290    }
0000b2  bd70              POP      {r4-r6,pc}
;;;291    
                          ENDP

                  find_biggest_volume PROC
;;;293    LOCAL(boxptr)
;;;294    find_biggest_volume (boxptr boxlist, int numboxes)
0000b4  b570              PUSH     {r4-r6,lr}
;;;295    /* Find the splittable box with the largest (scaled) volume */
;;;296    /* Returns NULL if no splittable boxes remain */
;;;297    {
0000b6  4602              MOV      r2,r0
0000b8  460b              MOV      r3,r1
;;;298      register boxptr boxp;
;;;299      register int i;
;;;300      register INT32 maxv = 0;
0000ba  f04f0500          MOV      r5,#0
;;;301      boxptr which = NULL;
0000be  4628              MOV      r0,r5
;;;302      
;;;303      for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
0000c0  4604              MOV      r4,r0
0000c2  4611              MOV      r1,r2
0000c4  e008              B        |L1.216|
                  |L1.198|
;;;304        if (boxp->volume > maxv) {
0000c6  698e              LDR      r6,[r1,#0x18]
0000c8  42ae              CMP      r6,r5
0000ca  dd01              BLE      |L1.208|
;;;305          which = boxp;
0000cc  4608              MOV      r0,r1
;;;306          maxv = boxp->volume;
0000ce  698d              LDR      r5,[r1,#0x18]
                  |L1.208|
0000d0  f1040401          ADD      r4,r4,#1              ;303
0000d4  f1010120          ADD      r1,r1,#0x20           ;303
                  |L1.216|
0000d8  429c              CMP      r4,r3                 ;303
0000da  dbf4              BLT      |L1.198|
;;;307        }
;;;308      }
;;;309      return which;
;;;310    }
0000dc  bd70              POP      {r4-r6,pc}
;;;311    
                          ENDP

                  update_box PROC
;;;313    LOCAL(void)
;;;314    update_box (j_decompress_ptr cinfo, boxptr boxp)
0000de  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;315    /* Shrink the min/max bounds of a box to enclose only nonzero elements, */
;;;316    /* and recompute its volume and population */
;;;317    {
0000e2  b085              SUB      sp,sp,#0x14
0000e4  460b              MOV      r3,r1
;;;318      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0000e6  f8ddb014          LDR      r11,[sp,#0x14]
0000ea  f8dbb1cc          LDR      r11,[r11,#0x1cc]
0000ee  f8cdb010          STR      r11,[sp,#0x10]
;;;319      hist3d histogram = cquantize->histogram;
0000f2  f8ddb010          LDR      r11,[sp,#0x10]
0000f6  f8dba018          LDR      r10,[r11,#0x18]
;;;320      histptr histp;
;;;321      int c0,c1,c2;
;;;322      int c0min,c0max,c1min,c1max,c2min,c2max;
;;;323      INT32 dist0,dist1,dist2;
;;;324      long ccount;
;;;325      
;;;326      c0min = boxp->c0min;  c0max = boxp->c0max;
0000fa  681f              LDR      r7,[r3,#0]
0000fc  f8d3c004          LDR      r12,[r3,#4]
;;;327      c1min = boxp->c1min;  c1max = boxp->c1max;
000100  689e              LDR      r6,[r3,#8]
000102  f8d3800c          LDR      r8,[r3,#0xc]
;;;328      c2min = boxp->c2min;  c2max = boxp->c2max;
000106  691c              LDR      r4,[r3,#0x10]
000108  f8d39014          LDR      r9,[r3,#0x14]
;;;329      
;;;330      if (c0max > c0min)
00010c  45bc              CMP      r12,r7
00010e  dd1f              BLE      |L1.336|
;;;331        for (c0 = c0min; c0 <= c0max; c0++)
000110  4638              MOV      r0,r7
000112  e01b              B        |L1.332|
                  |L1.276|
;;;332          for (c1 = c1min; c1 <= c1max; c1++) {
000114  4631              MOV      r1,r6
000116  e015              B        |L1.324|
                  |L1.280|
;;;333    	histp = & histogram[c0][c1][c2min];
000118  f85ab020          LDR      r11,[r10,r0,LSL #2]
00011c  eb0b1b81          ADD      r11,r11,r1,LSL #6
000120  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;334    	for (c2 = c2min; c2 <= c2max; c2++)
000124  4622              MOV      r2,r4
000126  e009              B        |L1.316|
                  |L1.296|
;;;335    	  if (*histp++ != 0) {
000128  f835bb02          LDRH     r11,[r5],#2
00012c  f1bb0f00          CMP      r11,#0
000130  d002              BEQ      |L1.312|
;;;336    	    boxp->c0min = c0min = c0;
000132  4607              MOV      r7,r0
000134  6018              STR      r0,[r3,#0]
;;;337    	    goto have_c0min;
000136  e00c              B        |L1.338|
                  |L1.312|
000138  f1020201          ADD      r2,r2,#1              ;334
                  |L1.316|
00013c  454a              CMP      r2,r9                 ;334
00013e  ddf3              BLE      |L1.296|
000140  f1010101          ADD      r1,r1,#1              ;332
                  |L1.324|
000144  4541              CMP      r1,r8                 ;332
000146  dde7              BLE      |L1.280|
000148  f1000001          ADD      r0,r0,#1              ;331
                  |L1.332|
00014c  4560              CMP      r0,r12                ;331
00014e  dde1              BLE      |L1.276|
                  |L1.336|
;;;338    	  }
;;;339          }
;;;340     have_c0min:
000150  bf00              NOP      
                  |L1.338|
;;;341      if (c0max > c0min)
000152  45bc              CMP      r12,r7
000154  dd1f              BLE      |L1.406|
;;;342        for (c0 = c0max; c0 >= c0min; c0--)
000156  4660              MOV      r0,r12
000158  e01b              B        |L1.402|
                  |L1.346|
;;;343          for (c1 = c1min; c1 <= c1max; c1++) {
00015a  4631              MOV      r1,r6
00015c  e015              B        |L1.394|
                  |L1.350|
;;;344    	histp = & histogram[c0][c1][c2min];
00015e  f85ab020          LDR      r11,[r10,r0,LSL #2]
000162  eb0b1b81          ADD      r11,r11,r1,LSL #6
000166  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;345    	for (c2 = c2min; c2 <= c2max; c2++)
00016a  4622              MOV      r2,r4
00016c  e009              B        |L1.386|
                  |L1.366|
;;;346    	  if (*histp++ != 0) {
00016e  f835bb02          LDRH     r11,[r5],#2
000172  f1bb0f00          CMP      r11,#0
000176  d002              BEQ      |L1.382|
;;;347    	    boxp->c0max = c0max = c0;
000178  4684              MOV      r12,r0
00017a  6058              STR      r0,[r3,#4]
;;;348    	    goto have_c0max;
00017c  e00c              B        |L1.408|
                  |L1.382|
00017e  f1020201          ADD      r2,r2,#1              ;345
                  |L1.386|
000182  454a              CMP      r2,r9                 ;345
000184  ddf3              BLE      |L1.366|
000186  f1010101          ADD      r1,r1,#1              ;343
                  |L1.394|
00018a  4541              CMP      r1,r8                 ;343
00018c  dde7              BLE      |L1.350|
00018e  f1a00001          SUB      r0,r0,#1              ;342
                  |L1.402|
000192  42b8              CMP      r0,r7                 ;342
000194  dae1              BGE      |L1.346|
                  |L1.406|
;;;349    	  }
;;;350          }
;;;351     have_c0max:
000196  bf00              NOP      
                  |L1.408|
;;;352      if (c1max > c1min)
000198  45b0              CMP      r8,r6
00019a  dd1f              BLE      |L1.476|
;;;353        for (c1 = c1min; c1 <= c1max; c1++)
00019c  4631              MOV      r1,r6
00019e  e01b              B        |L1.472|
                  |L1.416|
;;;354          for (c0 = c0min; c0 <= c0max; c0++) {
0001a0  4638              MOV      r0,r7
0001a2  e015              B        |L1.464|
                  |L1.420|
;;;355    	histp = & histogram[c0][c1][c2min];
0001a4  f85ab020          LDR      r11,[r10,r0,LSL #2]
0001a8  eb0b1b81          ADD      r11,r11,r1,LSL #6
0001ac  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;356    	for (c2 = c2min; c2 <= c2max; c2++)
0001b0  4622              MOV      r2,r4
0001b2  e009              B        |L1.456|
                  |L1.436|
;;;357    	  if (*histp++ != 0) {
0001b4  f835bb02          LDRH     r11,[r5],#2
0001b8  f1bb0f00          CMP      r11,#0
0001bc  d002              BEQ      |L1.452|
;;;358    	    boxp->c1min = c1min = c1;
0001be  460e              MOV      r6,r1
0001c0  6099              STR      r1,[r3,#8]
;;;359    	    goto have_c1min;
0001c2  e00c              B        |L1.478|
                  |L1.452|
0001c4  f1020201          ADD      r2,r2,#1              ;356
                  |L1.456|
0001c8  454a              CMP      r2,r9                 ;356
0001ca  ddf3              BLE      |L1.436|
0001cc  f1000001          ADD      r0,r0,#1              ;354
                  |L1.464|
0001d0  4560              CMP      r0,r12                ;354
0001d2  dde7              BLE      |L1.420|
0001d4  f1010101          ADD      r1,r1,#1              ;353
                  |L1.472|
0001d8  4541              CMP      r1,r8                 ;353
0001da  dde1              BLE      |L1.416|
                  |L1.476|
;;;360    	  }
;;;361          }
;;;362     have_c1min:
0001dc  bf00              NOP      
                  |L1.478|
;;;363      if (c1max > c1min)
0001de  45b0              CMP      r8,r6
0001e0  dd1f              BLE      |L1.546|
;;;364        for (c1 = c1max; c1 >= c1min; c1--)
0001e2  4641              MOV      r1,r8
0001e4  e01b              B        |L1.542|
                  |L1.486|
;;;365          for (c0 = c0min; c0 <= c0max; c0++) {
0001e6  4638              MOV      r0,r7
0001e8  e015              B        |L1.534|
                  |L1.490|
;;;366    	histp = & histogram[c0][c1][c2min];
0001ea  f85ab020          LDR      r11,[r10,r0,LSL #2]
0001ee  eb0b1b81          ADD      r11,r11,r1,LSL #6
0001f2  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;367    	for (c2 = c2min; c2 <= c2max; c2++)
0001f6  4622              MOV      r2,r4
0001f8  e009              B        |L1.526|
                  |L1.506|
;;;368    	  if (*histp++ != 0) {
0001fa  f835bb02          LDRH     r11,[r5],#2
0001fe  f1bb0f00          CMP      r11,#0
000202  d002              BEQ      |L1.522|
;;;369    	    boxp->c1max = c1max = c1;
000204  4688              MOV      r8,r1
000206  60d9              STR      r1,[r3,#0xc]
;;;370    	    goto have_c1max;
000208  e00c              B        |L1.548|
                  |L1.522|
00020a  f1020201          ADD      r2,r2,#1              ;367
                  |L1.526|
00020e  454a              CMP      r2,r9                 ;367
000210  ddf3              BLE      |L1.506|
000212  f1000001          ADD      r0,r0,#1              ;365
                  |L1.534|
000216  4560              CMP      r0,r12                ;365
000218  dde7              BLE      |L1.490|
00021a  f1a10101          SUB      r1,r1,#1              ;364
                  |L1.542|
00021e  42b1              CMP      r1,r6                 ;364
000220  dae1              BGE      |L1.486|
                  |L1.546|
;;;371    	  }
;;;372          }
;;;373     have_c1max:
000222  bf00              NOP      
                  |L1.548|
;;;374      if (c2max > c2min)
000224  45a1              CMP      r9,r4
000226  dd21              BLE      |L1.620|
;;;375        for (c2 = c2min; c2 <= c2max; c2++)
000228  4622              MOV      r2,r4
00022a  e01d              B        |L1.616|
                  |L1.556|
;;;376          for (c0 = c0min; c0 <= c0max; c0++) {
00022c  4638              MOV      r0,r7
00022e  e017              B        |L1.608|
                  |L1.560|
;;;377    	histp = & histogram[c0][c1min][c2];
000230  f85ab020          LDR      r11,[r10,r0,LSL #2]
000234  eb0b1b86          ADD      r11,r11,r6,LSL #6
000238  eb0b0542          ADD      r5,r11,r2,LSL #1
;;;378    	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
00023c  4631              MOV      r1,r6
00023e  e00b              B        |L1.600|
                  |L1.576|
;;;379    	  if (*histp != 0) {
000240  f8b5b000          LDRH     r11,[r5,#0]
000244  f1bb0f00          CMP      r11,#0
000248  d002              BEQ      |L1.592|
;;;380    	    boxp->c2min = c2min = c2;
00024a  4614              MOV      r4,r2
00024c  611a              STR      r2,[r3,#0x10]
;;;381    	    goto have_c2min;
00024e  e00e              B        |L1.622|
                  |L1.592|
000250  f1010101          ADD      r1,r1,#1              ;378
000254  f1050540          ADD      r5,r5,#0x40           ;378
                  |L1.600|
000258  4541              CMP      r1,r8                 ;378
00025a  ddf1              BLE      |L1.576|
00025c  f1000001          ADD      r0,r0,#1              ;376
                  |L1.608|
000260  4560              CMP      r0,r12                ;376
000262  dde5              BLE      |L1.560|
000264  f1020201          ADD      r2,r2,#1              ;375
                  |L1.616|
000268  454a              CMP      r2,r9                 ;375
00026a  dddf              BLE      |L1.556|
                  |L1.620|
;;;382    	  }
;;;383          }
;;;384     have_c2min:
00026c  bf00              NOP      
                  |L1.622|
;;;385      if (c2max > c2min)
00026e  45a1              CMP      r9,r4
000270  dd21              BLE      |L1.694|
;;;386        for (c2 = c2max; c2 >= c2min; c2--)
000272  464a              MOV      r2,r9
000274  e01d              B        |L1.690|
                  |L1.630|
;;;387          for (c0 = c0min; c0 <= c0max; c0++) {
000276  4638              MOV      r0,r7
000278  e017              B        |L1.682|
                  |L1.634|
;;;388    	histp = & histogram[c0][c1min][c2];
00027a  f85ab020          LDR      r11,[r10,r0,LSL #2]
00027e  eb0b1b86          ADD      r11,r11,r6,LSL #6
000282  eb0b0542          ADD      r5,r11,r2,LSL #1
;;;389    	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
000286  4631              MOV      r1,r6
000288  e00b              B        |L1.674|
                  |L1.650|
;;;390    	  if (*histp != 0) {
00028a  f8b5b000          LDRH     r11,[r5,#0]
00028e  f1bb0f00          CMP      r11,#0
000292  d002              BEQ      |L1.666|
;;;391    	    boxp->c2max = c2max = c2;
000294  4691              MOV      r9,r2
000296  615a              STR      r2,[r3,#0x14]
;;;392    	    goto have_c2max;
000298  e00e              B        |L1.696|
                  |L1.666|
00029a  f1010101          ADD      r1,r1,#1              ;389
00029e  f1050540          ADD      r5,r5,#0x40           ;389
                  |L1.674|
0002a2  4541              CMP      r1,r8                 ;389
0002a4  ddf1              BLE      |L1.650|
0002a6  f1000001          ADD      r0,r0,#1              ;387
                  |L1.682|
0002aa  4560              CMP      r0,r12                ;387
0002ac  dde5              BLE      |L1.634|
0002ae  f1a20201          SUB      r2,r2,#1              ;386
                  |L1.690|
0002b2  42a2              CMP      r2,r4                 ;386
0002b4  dadf              BGE      |L1.630|
                  |L1.694|
;;;393    	  }
;;;394          }
;;;395     have_c2max:
0002b6  bf00              NOP      
                  |L1.696|
;;;396    
;;;397      /* Update box volume.
;;;398       * We use 2-norm rather than real volume here; this biases the method
;;;399       * against making long narrow boxes, and it has the side benefit that
;;;400       * a box is splittable iff norm > 0.
;;;401       * Since the differences are expressed in histogram-cell units,
;;;402       * we have to shift back to JSAMPLE units to get consistent distances;
;;;403       * after which, we scale according to the selected distance scale factors.
;;;404       */
;;;405      dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
0002b8  ebac0b07          SUB      r11,r12,r7
0002bc  ea4f1e0b          LSL      lr,r11,#4
0002c0  f8cde00c          STR      lr,[sp,#0xc]
;;;406      dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
0002c4  eba80b06          SUB      r11,r8,r6
0002c8  ea4f0b8b          LSL      r11,r11,#2
0002cc  eb0b0b4b          ADD      r11,r11,r11,LSL #1
0002d0  f8cdb008          STR      r11,[sp,#8]
;;;407      dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
0002d4  eba90b04          SUB      r11,r9,r4
0002d8  ea4f0bcb          LSL      r11,r11,#3
0002dc  f8cdb004          STR      r11,[sp,#4]
;;;408      boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
0002e0  f8dde00c          LDR      lr,[sp,#0xc]
0002e4  fb0efe0e          MUL      lr,lr,lr
0002e8  f8ddb008          LDR      r11,[sp,#8]
0002ec  fb0bee0b          MLA      lr,r11,r11,lr
0002f0  f8ddb004          LDR      r11,[sp,#4]
0002f4  fb0beb0b          MLA      r11,r11,r11,lr
0002f8  f8c3b018          STR      r11,[r3,#0x18]
;;;409      
;;;410      /* Now scan remaining volume of box and compute population */
;;;411      ccount = 0;
0002fc  f04f0b00          MOV      r11,#0
000300  f8cdb000          STR      r11,[sp,#0]
;;;412      for (c0 = c0min; c0 <= c0max; c0++)
000304  4638              MOV      r0,r7
000306  e020              B        |L1.842|
                  |L1.776|
;;;413        for (c1 = c1min; c1 <= c1max; c1++) {
000308  4631              MOV      r1,r6
00030a  e01a              B        |L1.834|
                  |L1.780|
;;;414          histp = & histogram[c0][c1][c2min];
00030c  f85ab020          LDR      r11,[r10,r0,LSL #2]
000310  eb0b1b81          ADD      r11,r11,r1,LSL #6
000314  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;415          for (c2 = c2min; c2 <= c2max; c2++, histp++)
000318  4622              MOV      r2,r4
00031a  e00e              B        |L1.826|
                  |L1.796|
;;;416    	if (*histp != 0) {
00031c  f8b5b000          LDRH     r11,[r5,#0]
000320  f1bb0f00          CMP      r11,#0
000324  d005              BEQ      |L1.818|
;;;417    	  ccount++;
000326  f8ddb000          LDR      r11,[sp,#0]
00032a  f10b0b01          ADD      r11,r11,#1
00032e  f8cdb000          STR      r11,[sp,#0]
                  |L1.818|
000332  f1020201          ADD      r2,r2,#1              ;415
000336  f1050502          ADD      r5,r5,#2              ;415
                  |L1.826|
00033a  454a              CMP      r2,r9                 ;415
00033c  ddee              BLE      |L1.796|
00033e  f1010101          ADD      r1,r1,#1              ;413
                  |L1.834|
000342  4541              CMP      r1,r8                 ;413
000344  dde2              BLE      |L1.780|
000346  f1000001          ADD      r0,r0,#1              ;412
                  |L1.842|
00034a  4560              CMP      r0,r12                ;412
00034c  dddc              BLE      |L1.776|
;;;418    	}
;;;419        }
;;;420      boxp->colorcount = ccount;
00034e  f8ddb000          LDR      r11,[sp,#0]
000352  f8c3b01c          STR      r11,[r3,#0x1c]
;;;421    }
000356  b007              ADD      sp,sp,#0x1c
000358  e8bd8ff0          POP      {r4-r11,pc}
;;;422    
                          ENDP

                  median_cut PROC
;;;424    LOCAL(int)
;;;425    median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
00035c  e92d4fff          PUSH     {r0-r11,lr}
;;;426    	    int desired_colors)
;;;427    /* Repeatedly select and split the largest box until we have enough boxes */
;;;428    {
000360  b083              SUB      sp,sp,#0xc
000362  4688              MOV      r8,r1
000364  4616              MOV      r6,r2
000366  4699              MOV      r9,r3
;;;429      int n,lb;
;;;430      int c0,c1,c2,cmax;
;;;431      register boxptr b1,b2;
;;;432    
;;;433      while (numboxes < desired_colors) {
000368  e07f              B        |L1.1130|
                  |L1.874|
;;;434        /* Select box to split.
;;;435         * Current algorithm: by population for first half, then by volume.
;;;436         */
;;;437        if (numboxes*2 <= desired_colors) {
00036a  ebb90f46          CMP      r9,r6,LSL #1
00036e  db05              BLT      |L1.892|
;;;438          b1 = find_biggest_color_pop(boxlist, numboxes);
000370  4631              MOV      r1,r6
000372  4640              MOV      r0,r8
000374  f7fffffe          BL       find_biggest_color_pop
000378  4604              MOV      r4,r0
00037a  e004              B        |L1.902|
                  |L1.892|
;;;439        } else {
;;;440          b1 = find_biggest_volume(boxlist, numboxes);
00037c  4631              MOV      r1,r6
00037e  4640              MOV      r0,r8
000380  f7fffffe          BL       find_biggest_volume
000384  4604              MOV      r4,r0
                  |L1.902|
;;;441        }
;;;442        if (b1 == NULL)		/* no splittable boxes left! */
000386  b904              CBNZ     r4,|L1.906|
;;;443          break;
000388  e072              B        |L1.1136|
                  |L1.906|
;;;444        b2 = &boxlist[numboxes];	/* where new box will go */
00038a  eb081546          ADD      r5,r8,r6,LSL #5
;;;445        /* Copy the color bounds to the new box. */
;;;446        b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
00038e  6860              LDR      r0,[r4,#4]
000390  6068              STR      r0,[r5,#4]
000392  68e0              LDR      r0,[r4,#0xc]
000394  60e8              STR      r0,[r5,#0xc]
000396  6960              LDR      r0,[r4,#0x14]
000398  6168              STR      r0,[r5,#0x14]
;;;447        b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
00039a  6820              LDR      r0,[r4,#0]
00039c  6028              STR      r0,[r5,#0]
00039e  68a0              LDR      r0,[r4,#8]
0003a0  60a8              STR      r0,[r5,#8]
0003a2  6920              LDR      r0,[r4,#0x10]
0003a4  6128              STR      r0,[r5,#0x10]
;;;448        /* Choose which axis to split the box on.
;;;449         * Current algorithm: longest scaled axis.
;;;450         * See notes in update_box about scaling distances.
;;;451         */
;;;452        c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
0003a6  e9d41000          LDRD     r1,r0,[r4,#0]
0003aa  eba00001          SUB      r0,r0,r1
0003ae  ea4f1000          LSL      r0,r0,#4
0003b2  9001              STR      r0,[sp,#4]
;;;453        c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
0003b4  e9d41002          LDRD     r1,r0,[r4,#8]
0003b8  eba00001          SUB      r0,r0,r1
0003bc  ea4f0080          LSL      r0,r0,#2
0003c0  eb000a40          ADD      r10,r0,r0,LSL #1
;;;454        c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
0003c4  e9d41004          LDRD     r1,r0,[r4,#0x10]
0003c8  eba00001          SUB      r0,r0,r1
0003cc  ea4f0bc0          LSL      r11,r0,#3
;;;455        /* We want to break any ties in favor of green, then red, blue last.
;;;456         * This code does the right thing for R,G,B or B,G,R color orders only.
;;;457         */
;;;458    #if RGB_RED == 0
;;;459        cmax = c1; n = 1;
0003d0  f8cda000          STR      r10,[sp,#0]
0003d4  f04f0001          MOV      r0,#1
0003d8  9002              STR      r0,[sp,#8]
;;;460        if (c0 > cmax) { cmax = c0; n = 0; }
0003da  e9dda000          LDRD     r10,r0,[sp,#0]
0003de  4550              CMP      r0,r10
0003e0  dd04              BLE      |L1.1004|
0003e2  9801              LDR      r0,[sp,#4]
0003e4  9000              STR      r0,[sp,#0]
0003e6  f04f0000          MOV      r0,#0
0003ea  9002              STR      r0,[sp,#8]
                  |L1.1004|
;;;461        if (c2 > cmax) { n = 2; }
0003ec  9800              LDR      r0,[sp,#0]
0003ee  4583              CMP      r11,r0
0003f0  dd02              BLE      |L1.1016|
0003f2  f04f0002          MOV      r0,#2
0003f6  9002              STR      r0,[sp,#8]
                  |L1.1016|
;;;462    #else
;;;463        cmax = c1; n = 1;
;;;464        if (c2 > cmax) { cmax = c2; n = 2; }
;;;465        if (c0 > cmax) { n = 0; }
;;;466    #endif
;;;467        /* Choose split point along selected axis, and update box bounds.
;;;468         * Current algorithm: split at halfway point.
;;;469         * (Since the box has been shrunk to minimum volume,
;;;470         * any split will produce two nonempty subboxes.)
;;;471         * Note that lb value is max for lower box, so must be < old max.
;;;472         */
;;;473        switch (n) {
0003f8  9802              LDR      r0,[sp,#8]
0003fa  b120              CBZ      r0,|L1.1030|
0003fc  2801              CMP      r0,#1
0003fe  d00f              BEQ      |L1.1056|
000400  2802              CMP      r0,#2
000402  d127              BNE      |L1.1108|
000404  e019              B        |L1.1082|
                  |L1.1030|
;;;474        case 0:
;;;475          lb = (b1->c0max + b1->c0min) / 2;
000406  e9d42100          LDRD     r2,r1,[r4,#0]
00040a  eb010002          ADD      r0,r1,r2
00040e  eb0071d0          ADD      r1,r0,r0,LSR #31
000412  ea4f0761          ASR      r7,r1,#1
;;;476          b1->c0max = lb;
000416  6067              STR      r7,[r4,#4]
;;;477          b2->c0min = lb+1;
000418  f1070001          ADD      r0,r7,#1
00041c  6028              STR      r0,[r5,#0]
;;;478          break;
00041e  e019              B        |L1.1108|
                  |L1.1056|
;;;479        case 1:
;;;480          lb = (b1->c1max + b1->c1min) / 2;
000420  e9d42102          LDRD     r2,r1,[r4,#8]
000424  eb010002          ADD      r0,r1,r2
000428  eb0071d0          ADD      r1,r0,r0,LSR #31
00042c  ea4f0761          ASR      r7,r1,#1
;;;481          b1->c1max = lb;
000430  60e7              STR      r7,[r4,#0xc]
;;;482          b2->c1min = lb+1;
000432  f1070001          ADD      r0,r7,#1
000436  60a8              STR      r0,[r5,#8]
;;;483          break;
000438  e00c              B        |L1.1108|
                  |L1.1082|
;;;484        case 2:
;;;485          lb = (b1->c2max + b1->c2min) / 2;
00043a  e9d42104          LDRD     r2,r1,[r4,#0x10]
00043e  eb010002          ADD      r0,r1,r2
000442  eb0071d0          ADD      r1,r0,r0,LSR #31
000446  ea4f0761          ASR      r7,r1,#1
;;;486          b1->c2max = lb;
00044a  6167              STR      r7,[r4,#0x14]
;;;487          b2->c2min = lb+1;
00044c  f1070001          ADD      r0,r7,#1
000450  6128              STR      r0,[r5,#0x10]
;;;488          break;
000452  bf00              NOP      
                  |L1.1108|
000454  bf00              NOP                            ;478
;;;489        }
;;;490        /* Update stats for boxes */
;;;491        update_box(cinfo, b1);
000456  4621              MOV      r1,r4
000458  9803              LDR      r0,[sp,#0xc]
00045a  f7fffffe          BL       update_box
;;;492        update_box(cinfo, b2);
00045e  4629              MOV      r1,r5
000460  9803              LDR      r0,[sp,#0xc]
000462  f7fffffe          BL       update_box
;;;493        numboxes++;
000466  f1060601          ADD      r6,r6,#1
                  |L1.1130|
00046a  454e              CMP      r6,r9                 ;433
00046c  f6ffaf7d          BLT      |L1.874|
                  |L1.1136|
000470  bf00              NOP                            ;443
;;;494      }
;;;495      return numboxes;
000472  4630              MOV      r0,r6
;;;496    }
000474  b007              ADD      sp,sp,#0x1c
000476  e8bd8ff0          POP      {r4-r11,pc}
;;;497    
                          ENDP

                  compute_color PROC
;;;499    LOCAL(void)
;;;500    compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
00047a  e92d4ff0          PUSH     {r4-r11,lr}
;;;501    /* Compute representative color for a box, put it in colormap[icolor] */
;;;502    {
00047e  b088              SUB      sp,sp,#0x20
000480  4603              MOV      r3,r0
000482  4614              MOV      r4,r2
;;;503      /* Current algorithm: mean weighted by pixels (not colors) */
;;;504      /* Note it is important to get the rounding correct! */
;;;505      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000484  f8d3b1cc          LDR      r11,[r3,#0x1cc]
000488  f8cdb01c          STR      r11,[sp,#0x1c]
;;;506      hist3d histogram = cquantize->histogram;
00048c  f8ddb01c          LDR      r11,[sp,#0x1c]
000490  f8dbb018          LDR      r11,[r11,#0x18]
000494  f8cdb018          STR      r11,[sp,#0x18]
;;;507      histptr histp;
;;;508      int c0,c1,c2;
;;;509      int c0min,c0max,c1min,c1max,c2min,c2max;
;;;510      long count;
;;;511      long total = 0;
000498  f04f0000          MOV      r0,#0
;;;512      long c0total = 0;
00049c  4684              MOV      r12,r0
;;;513      long c1total = 0;
00049e  4680              MOV      r8,r0
;;;514      long c2total = 0;
0004a0  4681              MOV      r9,r0
;;;515      
;;;516      c0min = boxp->c0min;  c0max = boxp->c0max;
0004a2  f8d1b000          LDR      r11,[r1,#0]
0004a6  f8cdb014          STR      r11,[sp,#0x14]
0004aa  f8d1b004          LDR      r11,[r1,#4]
0004ae  f8cdb010          STR      r11,[sp,#0x10]
;;;517      c1min = boxp->c1min;  c1max = boxp->c1max;
0004b2  f8d1b008          LDR      r11,[r1,#8]
0004b6  f8cdb00c          STR      r11,[sp,#0xc]
0004ba  f8d1b00c          LDR      r11,[r1,#0xc]
0004be  f8cdb008          STR      r11,[sp,#8]
;;;518      c2min = boxp->c2min;  c2max = boxp->c2max;
0004c2  f8d1b010          LDR      r11,[r1,#0x10]
0004c6  f8cdb004          STR      r11,[sp,#4]
0004ca  f8d1b014          LDR      r11,[r1,#0x14]
0004ce  f8cdb000          STR      r11,[sp,#0]
;;;519      
;;;520      for (c0 = c0min; c0 <= c0max; c0++)
0004d2  9d05              LDR      r5,[sp,#0x14]
0004d4  e031              B        |L1.1338|
                  |L1.1238|
;;;521        for (c1 = c1min; c1 <= c1max; c1++) {
0004d6  9e03              LDR      r6,[sp,#0xc]
0004d8  e029              B        |L1.1326|
                  |L1.1242|
;;;522          histp = & histogram[c0][c1][c2min];
0004da  f8ddb018          LDR      r11,[sp,#0x18]
0004de  f85bb025          LDR      r11,[r11,r5,LSL #2]
0004e2  eb0b1e86          ADD      lr,r11,r6,LSL #6
0004e6  f8ddb004          LDR      r11,[sp,#4]
0004ea  eb0e0a4b          ADD      r10,lr,r11,LSL #1
;;;523          for (c2 = c2min; c2 <= c2max; c2++) {
0004ee  9f01              LDR      r7,[sp,#4]
0004f0  e017              B        |L1.1314|
                  |L1.1266|
;;;524    	if ((count = *histp++) != 0) {
0004f2  f83a2b02          LDRH     r2,[r10],#2
0004f6  b192              CBZ      r2,|L1.1310|
;;;525    	  total += count;
0004f8  4410              ADD      r0,r0,r2
;;;526    	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
0004fa  f04f0b04          MOV      r11,#4
0004fe  eb0b0bc5          ADD      r11,r11,r5,LSL #3
000502  fb0bcc02          MLA      r12,r11,r2,r12
;;;527    	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
000506  f04f0b02          MOV      r11,#2
00050a  eb0b0b86          ADD      r11,r11,r6,LSL #2
00050e  fb0b8802          MLA      r8,r11,r2,r8
;;;528    	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
000512  f04f0b04          MOV      r11,#4
000516  eb0b0bc7          ADD      r11,r11,r7,LSL #3
00051a  fb0b9902          MLA      r9,r11,r2,r9
                  |L1.1310|
00051e  f1070701          ADD      r7,r7,#1              ;523
                  |L1.1314|
000522  f8ddb000          LDR      r11,[sp,#0]           ;523
000526  455f              CMP      r7,r11                ;523
000528  dde3              BLE      |L1.1266|
00052a  f1060601          ADD      r6,r6,#1              ;521
                  |L1.1326|
00052e  f8ddb008          LDR      r11,[sp,#8]           ;521
000532  455e              CMP      r6,r11                ;521
000534  ddd1              BLE      |L1.1242|
000536  f1050501          ADD      r5,r5,#1              ;520
                  |L1.1338|
00053a  f8ddb010          LDR      r11,[sp,#0x10]        ;520
00053e  455d              CMP      r5,r11                ;520
000540  ddc9              BLE      |L1.1238|
;;;529    	}
;;;530          }
;;;531        }
;;;532      
;;;533      cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
000542  eb0c0b60          ADD      r11,r12,r0,ASR #1
000546  fb9bfbf0          SDIV     r11,r11,r0
00054a  f8d3e088          LDR      lr,[r3,#0x88]
00054e  f8dee000          LDR      lr,[lr,#0]
000552  f80eb004          STRB     r11,[lr,r4]
;;;534      cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
000556  eb080b60          ADD      r11,r8,r0,ASR #1
00055a  fb9bfbf0          SDIV     r11,r11,r0
00055e  f8d3e088          LDR      lr,[r3,#0x88]
000562  f8dee004          LDR      lr,[lr,#4]
000566  f80eb004          STRB     r11,[lr,r4]
;;;535      cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
00056a  eb090b60          ADD      r11,r9,r0,ASR #1
00056e  fb9bfbf0          SDIV     r11,r11,r0
000572  f8d3e088          LDR      lr,[r3,#0x88]
000576  f8dee008          LDR      lr,[lr,#8]
00057a  f80eb004          STRB     r11,[lr,r4]
;;;536    }
00057e  b008              ADD      sp,sp,#0x20
000580  e8bd8ff0          POP      {r4-r11,pc}
;;;537    
                          ENDP

                  select_colors PROC
;;;539    LOCAL(void)
;;;540    select_colors (j_decompress_ptr cinfo, int desired_colors)
000584  e92d41f0          PUSH     {r4-r8,lr}
;;;541    /* Master routine for color selection */
;;;542    {
000588  4605              MOV      r5,r0
00058a  4688              MOV      r8,r1
;;;543      boxptr boxlist;
;;;544      int numboxes;
;;;545      int i;
;;;546    
;;;547      /* Allocate workspace for box list */
;;;548      boxlist = (boxptr) (*cinfo->mem->alloc_small)
00058c  ea4f1248          LSL      r2,r8,#5
000590  6868              LDR      r0,[r5,#4]
000592  f04f0101          MOV      r1,#1
000596  6803              LDR      r3,[r0,#0]
000598  4628              MOV      r0,r5
00059a  4798              BLX      r3
00059c  4604              MOV      r4,r0
;;;549        ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
;;;550      /* Initialize one box containing whole space */
;;;551      numboxes = 1;
00059e  f04f0601          MOV      r6,#1
;;;552      boxlist[0].c0min = 0;
0005a2  f04f0000          MOV      r0,#0
0005a6  6020              STR      r0,[r4,#0]
;;;553      boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
0005a8  f04f001f          MOV      r0,#0x1f
0005ac  6060              STR      r0,[r4,#4]
;;;554      boxlist[0].c1min = 0;
0005ae  f04f0000          MOV      r0,#0
0005b2  60a0              STR      r0,[r4,#8]
;;;555      boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
0005b4  f04f003f          MOV      r0,#0x3f
0005b8  60e0              STR      r0,[r4,#0xc]
;;;556      boxlist[0].c2min = 0;
0005ba  f04f0000          MOV      r0,#0
0005be  6120              STR      r0,[r4,#0x10]
;;;557      boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
0005c0  f04f001f          MOV      r0,#0x1f
0005c4  6160              STR      r0,[r4,#0x14]
;;;558      /* Shrink it to actually-used volume and set its statistics */
;;;559      update_box(cinfo, & boxlist[0]);
0005c6  4621              MOV      r1,r4
0005c8  4628              MOV      r0,r5
0005ca  f7fffffe          BL       update_box
;;;560      /* Perform median-cut to produce final box list */
;;;561      numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
0005ce  4643              MOV      r3,r8
0005d0  4632              MOV      r2,r6
0005d2  4621              MOV      r1,r4
0005d4  4628              MOV      r0,r5
0005d6  f7fffffe          BL       median_cut
0005da  4606              MOV      r6,r0
;;;562      /* Compute the representative color for each box, fill colormap */
;;;563      for (i = 0; i < numboxes; i++)
0005dc  f04f0700          MOV      r7,#0
0005e0  e007              B        |L1.1522|
                  |L1.1506|
;;;564        compute_color(cinfo, & boxlist[i], i);
0005e2  eb041147          ADD      r1,r4,r7,LSL #5
0005e6  463a              MOV      r2,r7
0005e8  4628              MOV      r0,r5
0005ea  f7fffffe          BL       compute_color
0005ee  f1070701          ADD      r7,r7,#1              ;563
                  |L1.1522|
0005f2  42b7              CMP      r7,r6                 ;563
0005f4  dbf5              BLT      |L1.1506|
;;;565      cinfo->actual_number_of_colors = numboxes;
0005f6  f8c56084          STR      r6,[r5,#0x84]
;;;566      TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
0005fa  f04f0060          MOV      r0,#0x60
0005fe  6829              LDR      r1,[r5,#0]
000600  6148              STR      r0,[r1,#0x14]
000602  6828              LDR      r0,[r5,#0]
000604  6186              STR      r6,[r0,#0x18]
000606  6828              LDR      r0,[r5,#0]
000608  f04f0101          MOV      r1,#1
00060c  6842              LDR      r2,[r0,#4]
00060e  4628              MOV      r0,r5
000610  4790              BLX      r2
;;;567    }
000612  e8bd81f0          POP      {r4-r8,pc}
;;;568    
                          ENDP

                  find_nearby_colors PROC
;;;646    LOCAL(int)
;;;647    find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
000616  e92d4fff          PUSH     {r0-r11,lr}
;;;648    		    JSAMPLE colorlist[])
;;;649    /* Locate the colormap entries close enough to an update box to be candidates
;;;650     * for the nearest entry to some cell(s) in the update box.  The update box
;;;651     * is specified by the center coordinates of its first cell.  The number of
;;;652     * candidate colormap entries is returned, and their colormap indexes are
;;;653     * placed in colorlist[].
;;;654     * This routine uses Heckbert's "locally sorted search" criterion to select
;;;655     * the colors that need further consideration.
;;;656     */
;;;657    {
00061a  f5ad6d83          SUB      sp,sp,#0x418
00061e  460d              MOV      r5,r1
000620  4616              MOV      r6,r2
000622  461f              MOV      r7,r3
;;;658      int numcolors = cinfo->actual_number_of_colors;
000624  f8dd0418          LDR      r0,[sp,#0x418]
000628  f8d00084          LDR      r0,[r0,#0x84]
00062c  f8cd0414          STR      r0,[sp,#0x414]
;;;659      int maxc0, maxc1, maxc2;
;;;660      int centerc0, centerc1, centerc2;
;;;661      int i, x, ncolors;
;;;662      INT32 minmaxdist, min_dist, max_dist, tdist;
;;;663      INT32 mindist[MAXNUMCOLORS];	/* min distance to colormap entry i */
;;;664    
;;;665      /* Compute true coordinates of update box's upper corner and center.
;;;666       * Actually we compute the coordinates of the center of the upper-corner
;;;667       * histogram cell, which are the upper bounds of the volume we care about.
;;;668       * Note that since ">>" rounds down, the "center" values may be closer to
;;;669       * min than to max; hence comparisons to them must be "<=", not "<".
;;;670       */
;;;671      maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
000630  f1050c18          ADD      r12,r5,#0x18
;;;672      centerc0 = (minc0 + maxc0) >> 1;
000634  eb05000c          ADD      r0,r5,r12
000638  ea4f0060          ASR      r0,r0,#1
00063c  f8cd0410          STR      r0,[sp,#0x410]
;;;673      maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
000640  f106081c          ADD      r8,r6,#0x1c
;;;674      centerc1 = (minc1 + maxc1) >> 1;
000644  eb060008          ADD      r0,r6,r8
000648  ea4f0060          ASR      r0,r0,#1
00064c  f8cd040c          STR      r0,[sp,#0x40c]
;;;675      maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
000650  f1070918          ADD      r9,r7,#0x18
;;;676      centerc2 = (minc2 + maxc2) >> 1;
000654  eb070009          ADD      r0,r7,r9
000658  ea4f0060          ASR      r0,r0,#1
00065c  f8cd0408          STR      r0,[sp,#0x408]
;;;677    
;;;678      /* For each color in colormap, find:
;;;679       *  1. its minimum squared-distance to any point in the update box
;;;680       *     (zero if color is within update box);
;;;681       *  2. its maximum squared-distance to any point in the update box.
;;;682       * Both of these can be found by considering only the corners of the box.
;;;683       * We save the minimum distance for each color in mindist[];
;;;684       * only the smallest maximum distance is of interest.
;;;685       */
;;;686      minmaxdist = 0x7FFFFFFFL;
000660  f06f4000          MVN      r0,#0x80000000
000664  f8cd0400          STR      r0,[sp,#0x400]
;;;687    
;;;688      for (i = 0; i < numcolors; i++) {
000668  f04f0300          MOV      r3,#0
00066c  e09e              B        |L1.1964|
                  |L1.1646|
;;;689        /* We compute the squared-c0-distance term, then add in the other two. */
;;;690        x = GETJSAMPLE(cinfo->colormap[0][i]);
00066e  f8dd0418          LDR      r0,[sp,#0x418]
000672  f8d00088          LDR      r0,[r0,#0x88]
000676  6800              LDR      r0,[r0,#0]
000678  5cc2              LDRB     r2,[r0,r3]
;;;691        if (x < minc0) {
00067a  42aa              CMP      r2,r5
00067c  da0c              BGE      |L1.1688|
;;;692          tdist = (x - minc0) * C0_SCALE;
00067e  eba20005          SUB      r0,r2,r5
000682  ea4f0140          LSL      r1,r0,#1
;;;693          min_dist = tdist*tdist;
000686  fb01fa01          MUL      r10,r1,r1
;;;694          tdist = (x - maxc0) * C0_SCALE;
00068a  eba2000c          SUB      r0,r2,r12
00068e  ea4f0140          LSL      r1,r0,#1
;;;695          max_dist = tdist*tdist;
000692  fb01f401          MUL      r4,r1,r1
000696  e021              B        |L1.1756|
                  |L1.1688|
;;;696        } else if (x > maxc0) {
000698  4562              CMP      r2,r12
00069a  dd0c              BLE      |L1.1718|
;;;697          tdist = (x - maxc0) * C0_SCALE;
00069c  eba2000c          SUB      r0,r2,r12
0006a0  ea4f0140          LSL      r1,r0,#1
;;;698          min_dist = tdist*tdist;
0006a4  fb01fa01          MUL      r10,r1,r1
;;;699          tdist = (x - minc0) * C0_SCALE;
0006a8  eba20005          SUB      r0,r2,r5
0006ac  ea4f0140          LSL      r1,r0,#1
;;;700          max_dist = tdist*tdist;
0006b0  fb01f401          MUL      r4,r1,r1
0006b4  e012              B        |L1.1756|
                  |L1.1718|
;;;701        } else {
;;;702          /* within cell range so no contribution to min_dist */
;;;703          min_dist = 0;
0006b6  f04f0a00          MOV      r10,#0
;;;704          if (x <= centerc0) {
0006ba  f8dd0410          LDR      r0,[sp,#0x410]
0006be  4282              CMP      r2,r0
0006c0  dc06              BGT      |L1.1744|
;;;705    	tdist = (x - maxc0) * C0_SCALE;
0006c2  eba2000c          SUB      r0,r2,r12
0006c6  ea4f0140          LSL      r1,r0,#1
;;;706    	max_dist = tdist*tdist;
0006ca  fb01f401          MUL      r4,r1,r1
0006ce  e005              B        |L1.1756|
                  |L1.1744|
;;;707          } else {
;;;708    	tdist = (x - minc0) * C0_SCALE;
0006d0  eba20005          SUB      r0,r2,r5
0006d4  ea4f0140          LSL      r1,r0,#1
;;;709    	max_dist = tdist*tdist;
0006d8  fb01f401          MUL      r4,r1,r1
                  |L1.1756|
;;;710          }
;;;711        }
;;;712    
;;;713        x = GETJSAMPLE(cinfo->colormap[1][i]);
0006dc  f8dd0418          LDR      r0,[sp,#0x418]
0006e0  f8d00088          LDR      r0,[r0,#0x88]
0006e4  6840              LDR      r0,[r0,#4]
0006e6  5cc2              LDRB     r2,[r0,r3]
;;;714        if (x < minc1) {
0006e8  42b2              CMP      r2,r6
0006ea  da0c              BGE      |L1.1798|
;;;715          tdist = (x - minc1) * C1_SCALE;
0006ec  eba20006          SUB      r0,r2,r6
0006f0  eb000140          ADD      r1,r0,r0,LSL #1
;;;716          min_dist += tdist*tdist;
0006f4  fb01aa01          MLA      r10,r1,r1,r10
;;;717          tdist = (x - maxc1) * C1_SCALE;
0006f8  eba20008          SUB      r0,r2,r8
0006fc  eb000140          ADD      r1,r0,r0,LSL #1
;;;718          max_dist += tdist*tdist;
000700  fb014401          MLA      r4,r1,r1,r4
000704  e01f              B        |L1.1862|
                  |L1.1798|
;;;719        } else if (x > maxc1) {
000706  4542              CMP      r2,r8
000708  dd0c              BLE      |L1.1828|
;;;720          tdist = (x - maxc1) * C1_SCALE;
00070a  eba20008          SUB      r0,r2,r8
00070e  eb000140          ADD      r1,r0,r0,LSL #1
;;;721          min_dist += tdist*tdist;
000712  fb01aa01          MLA      r10,r1,r1,r10
;;;722          tdist = (x - minc1) * C1_SCALE;
000716  eba20006          SUB      r0,r2,r6
00071a  eb000140          ADD      r1,r0,r0,LSL #1
;;;723          max_dist += tdist*tdist;
00071e  fb014401          MLA      r4,r1,r1,r4
000722  e010              B        |L1.1862|
                  |L1.1828|
;;;724        } else {
;;;725          /* within cell range so no contribution to min_dist */
;;;726          if (x <= centerc1) {
000724  f8dd040c          LDR      r0,[sp,#0x40c]
000728  4282              CMP      r2,r0
00072a  dc06              BGT      |L1.1850|
;;;727    	tdist = (x - maxc1) * C1_SCALE;
00072c  eba20008          SUB      r0,r2,r8
000730  eb000140          ADD      r1,r0,r0,LSL #1
;;;728    	max_dist += tdist*tdist;
000734  fb014401          MLA      r4,r1,r1,r4
000738  e005              B        |L1.1862|
                  |L1.1850|
;;;729          } else {
;;;730    	tdist = (x - minc1) * C1_SCALE;
00073a  eba20006          SUB      r0,r2,r6
00073e  eb000140          ADD      r1,r0,r0,LSL #1
;;;731    	max_dist += tdist*tdist;
000742  fb014401          MLA      r4,r1,r1,r4
                  |L1.1862|
;;;732          }
;;;733        }
;;;734    
;;;735        x = GETJSAMPLE(cinfo->colormap[2][i]);
000746  f8dd0418          LDR      r0,[sp,#0x418]
00074a  f8d00088          LDR      r0,[r0,#0x88]
00074e  6880              LDR      r0,[r0,#8]
000750  5cc2              LDRB     r2,[r0,r3]
;;;736        if (x < minc2) {
000752  42ba              CMP      r2,r7
000754  da08              BGE      |L1.1896|
;;;737          tdist = (x - minc2) * C2_SCALE;
000756  eba20107          SUB      r1,r2,r7
;;;738          min_dist += tdist*tdist;
00075a  fb01aa01          MLA      r10,r1,r1,r10
;;;739          tdist = (x - maxc2) * C2_SCALE;
00075e  eba20109          SUB      r1,r2,r9
;;;740          max_dist += tdist*tdist;
000762  fb014401          MLA      r4,r1,r1,r4
000766  e017              B        |L1.1944|
                  |L1.1896|
;;;741        } else if (x > maxc2) {
000768  454a              CMP      r2,r9
00076a  dd08              BLE      |L1.1918|
;;;742          tdist = (x - maxc2) * C2_SCALE;
00076c  eba20109          SUB      r1,r2,r9
;;;743          min_dist += tdist*tdist;
000770  fb01aa01          MLA      r10,r1,r1,r10
;;;744          tdist = (x - minc2) * C2_SCALE;
000774  eba20107          SUB      r1,r2,r7
;;;745          max_dist += tdist*tdist;
000778  fb014401          MLA      r4,r1,r1,r4
00077c  e00c              B        |L1.1944|
                  |L1.1918|
;;;746        } else {
;;;747          /* within cell range so no contribution to min_dist */
;;;748          if (x <= centerc2) {
00077e  f8dd0408          LDR      r0,[sp,#0x408]
000782  4282              CMP      r2,r0
000784  dc04              BGT      |L1.1936|
;;;749    	tdist = (x - maxc2) * C2_SCALE;
000786  eba20109          SUB      r1,r2,r9
;;;750    	max_dist += tdist*tdist;
00078a  fb014401          MLA      r4,r1,r1,r4
00078e  e003              B        |L1.1944|
                  |L1.1936|
;;;751          } else {
;;;752    	tdist = (x - minc2) * C2_SCALE;
000790  eba20107          SUB      r1,r2,r7
;;;753    	max_dist += tdist*tdist;
000794  fb014401          MLA      r4,r1,r1,r4
                  |L1.1944|
;;;754          }
;;;755        }
;;;756    
;;;757        mindist[i] = min_dist;	/* save away the results */
000798  f84da023          STR      r10,[sp,r3,LSL #2]
;;;758        if (max_dist < minmaxdist)
00079c  f8dd0400          LDR      r0,[sp,#0x400]
0007a0  4284              CMP      r4,r0
0007a2  da01              BGE      |L1.1960|
;;;759          minmaxdist = max_dist;
0007a4  f8cd4400          STR      r4,[sp,#0x400]
                  |L1.1960|
0007a8  f1030301          ADD      r3,r3,#1              ;688
                  |L1.1964|
0007ac  f8dd0414          LDR      r0,[sp,#0x414]        ;688
0007b0  4283              CMP      r3,r0                 ;688
0007b2  f6ffaf5c          BLT      |L1.1646|
;;;760      }
;;;761    
;;;762      /* Now we know that no cell in the update box is more than minmaxdist
;;;763       * away from some colormap entry.  Therefore, only colors that are
;;;764       * within minmaxdist of some part of the box need be considered.
;;;765       */
;;;766      ncolors = 0;
0007b6  f04f0000          MOV      r0,#0
0007ba  f8cd0404          STR      r0,[sp,#0x404]
;;;767      for (i = 0; i < numcolors; i++) {
0007be  4603              MOV      r3,r0
0007c0  e011              B        |L1.2022|
                  |L1.1986|
;;;768        if (mindist[i] <= minmaxdist)
0007c2  f85db023          LDR      r11,[sp,r3,LSL #2]
0007c6  f8dd0400          LDR      r0,[sp,#0x400]
0007ca  4583              CMP      r11,r0
0007cc  dc09              BGT      |L1.2018|
;;;769          colorlist[ncolors++] = (JSAMPLE) i;
0007ce  f8dd0404          LDR      r0,[sp,#0x404]
0007d2  f1000e01          ADD      lr,r0,#1
0007d6  f8cde404          STR      lr,[sp,#0x404]
0007da  f8dde44c          LDR      lr,[sp,#0x44c]
0007de  f80e3000          STRB     r3,[lr,r0]
                  |L1.2018|
0007e2  f1030301          ADD      r3,r3,#1              ;767
                  |L1.2022|
0007e6  f8dd0414          LDR      r0,[sp,#0x414]        ;767
0007ea  4283              CMP      r3,r0                 ;767
0007ec  dbe9              BLT      |L1.1986|
;;;770      }
;;;771      return ncolors;
0007ee  f8dd0404          LDR      r0,[sp,#0x404]
;;;772    }
0007f2  f50d6d85          ADD      sp,sp,#0x428
0007f6  e8bd8ff0          POP      {r4-r11,pc}
;;;773    
                          ENDP

                  find_best_colors PROC
;;;775    LOCAL(void)
;;;776    find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
0007fa  e92d4fff          PUSH     {r0-r11,lr}
;;;777    		  int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])
;;;778    /* Find the closest colormap entry for each cell in the update box,
;;;779     * given the list of candidate colors prepared by find_nearby_colors.
;;;780     * Return the indexes of the closest entries in the bestcolor[] array.
;;;781     * This routine uses Thomas' incremental distance calculation method to
;;;782     * find the distance from a colormap entry to successive cells in the box.
;;;783     */
;;;784    {
0007fe  f5ad7d05          SUB      sp,sp,#0x214
000802  4604              MOV      r4,r0
;;;785      int ic0, ic1, ic2;
;;;786      int i, icolor;
;;;787      register INT32 * bptr;	/* pointer into bestdist[] array */
;;;788      JSAMPLE * cptr;		/* pointer into bestcolor[] array */
;;;789      INT32 dist0, dist1;		/* initial distance values */
;;;790      register INT32 dist2;		/* current distance in inner loop */
;;;791      INT32 xx0, xx1;		/* distance increments */
;;;792      register INT32 xx2;
;;;793      INT32 inc0, inc1, inc2;	/* initial values for increments */
;;;794      /* This array holds the distance to the nearest-so-far color for each cell */
;;;795      INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
;;;796    
;;;797      /* Initialize best-distance for each cell of the update box */
;;;798      bptr = bestdist;
000804  466a              MOV      r2,sp
;;;799      for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
000806  f04f007f          MOV      r0,#0x7f
00080a  e005              B        |L1.2072|
                  |L1.2060|
;;;800        *bptr++ = 0x7FFFFFFFL;
00080c  f06f4b00          MVN      r11,#0x80000000
000810  f842bb04          STR      r11,[r2],#4
000814  f1a00001          SUB      r0,r0,#1              ;799
                  |L1.2072|
000818  2800              CMP      r0,#0                 ;799
00081a  daf7              BGE      |L1.2060|
;;;801      
;;;802      /* For each color selected by find_nearby_colors,
;;;803       * compute its distance to the center of each cell in the box.
;;;804       * If that's less than best-so-far, update best distance and color number.
;;;805       */
;;;806      
;;;807      /* Nominal steps between cell centers ("x" in Thomas article) */
;;;808    #define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
;;;809    #define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
;;;810    #define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
;;;811      
;;;812      for (i = 0; i < numcolors; i++) {
00081c  f04f0000          MOV      r0,#0
000820  e08f              B        |L1.2370|
                  |L1.2082|
;;;813        icolor = GETJSAMPLE(colorlist[i]);
000822  f8ddb24c          LDR      r11,[sp,#0x24c]
000826  f81b1000          LDRB     r1,[r11,r0]
;;;814        /* Compute (square of) distance from minc0/c1/c2 to this color */
;;;815        inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
00082a  f8d4b088          LDR      r11,[r4,#0x88]
00082e  f8dbb000          LDR      r11,[r11,#0]
000832  f81be001          LDRB     lr,[r11,r1]
000836  f8ddb218          LDR      r11,[sp,#0x218]
00083a  ebab0b0e          SUB      r11,r11,lr
00083e  ea4f064b          LSL      r6,r11,#1
;;;816        dist0 = inc0*inc0;
000842  fb06f506          MUL      r5,r6,r6
;;;817        inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
000846  f8d4b088          LDR      r11,[r4,#0x88]
00084a  f8dbb004          LDR      r11,[r11,#4]
00084e  f81be001          LDRB     lr,[r11,r1]
000852  f8ddb21c          LDR      r11,[sp,#0x21c]
000856  ebab0b0e          SUB      r11,r11,lr
00085a  eb0b074b          ADD      r7,r11,r11,LSL #1
;;;818        dist0 += inc1*inc1;
00085e  fb075507          MLA      r5,r7,r7,r5
;;;819        inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
000862  f8d4b088          LDR      r11,[r4,#0x88]
000866  f8dbb008          LDR      r11,[r11,#8]
00086a  f81be001          LDRB     lr,[r11,r1]
00086e  f8ddb220          LDR      r11,[sp,#0x220]
000872  ebab030e          SUB      r3,r11,lr
;;;820        dist0 += inc2*inc2;
000876  fb035503          MLA      r5,r3,r3,r5
;;;821        /* Form the initial difference increments */
;;;822        inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
00087a  f44f7b80          MOV      r11,#0x100
00087e  eb0b1646          ADD      r6,r11,r6,LSL #5
;;;823        inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
000882  eb070b47          ADD      r11,r7,r7,LSL #1
000886  f04f0e90          MOV      lr,#0x90
00088a  eb0e07cb          ADD      r7,lr,r11,LSL #3
;;;824        inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
00088e  f04f0b40          MOV      r11,#0x40
000892  eb0b1303          ADD      r3,r11,r3,LSL #4
;;;825        /* Now loop over all cells in box, updating distance per Thomas method */
;;;826        bptr = bestdist;
000896  466a              MOV      r2,sp
;;;827        cptr = bestcolor;
000898  f8dda250          LDR      r10,[sp,#0x250]
;;;828        xx0 = inc0;
00089c  9682              STR      r6,[sp,#0x208]
;;;829        for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
00089e  f04f0803          MOV      r8,#3
0008a2  e049              B        |L1.2360|
                  |L1.2212|
;;;830          dist1 = dist0;
0008a4  9583              STR      r5,[sp,#0x20c]
;;;831          xx1 = inc1;
0008a6  9781              STR      r7,[sp,#0x204]
;;;832          for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
0008a8  f04f0907          MOV      r9,#7
0008ac  e036              B        |L1.2332|
                  |L1.2222|
;;;833    	dist2 = dist1;
0008ae  f8ddc20c          LDR      r12,[sp,#0x20c]
;;;834    	xx2 = inc2;
0008b2  9380              STR      r3,[sp,#0x200]
;;;835    	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
0008b4  f04f0b03          MOV      r11,#3
0008b8  f8cdb210          STR      r11,[sp,#0x210]
0008bc  e01a              B        |L1.2292|
                  |L1.2238|
;;;836    	  if (dist2 < *bptr) {
0008be  f8d2b000          LDR      r11,[r2,#0]
0008c2  45e3              CMP      r11,r12
0008c4  dd03              BLE      |L1.2254|
;;;837    	    *bptr = dist2;
0008c6  f8c2c000          STR      r12,[r2,#0]
;;;838    	    *cptr = (JSAMPLE) icolor;
0008ca  f88a1000          STRB     r1,[r10,#0]
                  |L1.2254|
;;;839    	  }
;;;840    	  dist2 += xx2;
0008ce  f8ddb200          LDR      r11,[sp,#0x200]
0008d2  44dc              ADD      r12,r12,r11
;;;841    	  xx2 += 2 * STEP_C2 * STEP_C2;
0008d4  f8ddb200          LDR      r11,[sp,#0x200]
0008d8  f10b0b80          ADD      r11,r11,#0x80
0008dc  f8cdb200          STR      r11,[sp,#0x200]
;;;842    	  bptr++;
0008e0  f1020204          ADD      r2,r2,#4
;;;843    	  cptr++;
0008e4  f10a0a01          ADD      r10,r10,#1
0008e8  f8ddb210          LDR      r11,[sp,#0x210]       ;835
0008ec  f1ab0b01          SUB      r11,r11,#1            ;835
0008f0  f8cdb210          STR      r11,[sp,#0x210]       ;835
                  |L1.2292|
0008f4  f8ddb210          LDR      r11,[sp,#0x210]       ;835
0008f8  f1bb0f00          CMP      r11,#0                ;835
0008fc  dadf              BGE      |L1.2238|
;;;844    	}
;;;845    	dist1 += xx1;
0008fe  f8dde204          LDR      lr,[sp,#0x204]
000902  f8ddb20c          LDR      r11,[sp,#0x20c]
000906  44f3              ADD      r11,r11,lr
000908  f8cdb20c          STR      r11,[sp,#0x20c]
;;;846    	xx1 += 2 * STEP_C1 * STEP_C1;
00090c  f8ddb204          LDR      r11,[sp,#0x204]
000910  f50b7b90          ADD      r11,r11,#0x120
000914  f8cdb204          STR      r11,[sp,#0x204]
000918  f1a90901          SUB      r9,r9,#1              ;832
                  |L1.2332|
00091c  f1b90f00          CMP      r9,#0                 ;832
000920  dac5              BGE      |L1.2222|
;;;847          }
;;;848          dist0 += xx0;
000922  f8ddb208          LDR      r11,[sp,#0x208]
000926  445d              ADD      r5,r5,r11
;;;849          xx0 += 2 * STEP_C0 * STEP_C0;
000928  f8ddb208          LDR      r11,[sp,#0x208]
00092c  f50b7b00          ADD      r11,r11,#0x200
000930  f8cdb208          STR      r11,[sp,#0x208]
000934  f1a80801          SUB      r8,r8,#1              ;829
                  |L1.2360|
000938  f1b80f00          CMP      r8,#0                 ;829
00093c  dab2              BGE      |L1.2212|
00093e  f1000001          ADD      r0,r0,#1              ;812
                  |L1.2370|
000942  f8ddb248          LDR      r11,[sp,#0x248]       ;812
000946  4558              CMP      r0,r11                ;812
000948  f6ffaf6b          BLT      |L1.2082|
;;;850        }
;;;851      }
;;;852    }
00094c  f50d7d09          ADD      sp,sp,#0x224
000950  e8bd8ff0          POP      {r4-r11,pc}
;;;853    
                          ENDP

                  fill_inverse_cmap PROC
;;;855    LOCAL(void)
;;;856    fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
000954  e92d4ff0          PUSH     {r4-r11,lr}
;;;857    /* Fill the inverse-colormap entries in the update box that contains */
;;;858    /* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
;;;859    /* we can fill as many others as we wish.) */
;;;860    {
000958  b0eb              SUB      sp,sp,#0x1ac
00095a  4681              MOV      r9,r0
00095c  460c              MOV      r4,r1
00095e  4615              MOV      r5,r2
000960  461e              MOV      r6,r3
;;;861      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000962  f8d901cc          LDR      r0,[r9,#0x1cc]
000966  906a              STR      r0,[sp,#0x1a8]
;;;862      hist3d histogram = cquantize->histogram;
000968  986a              LDR      r0,[sp,#0x1a8]
00096a  6980              LDR      r0,[r0,#0x18]
00096c  9069              STR      r0,[sp,#0x1a4]
;;;863      int minc0, minc1, minc2;	/* lower left corner of update box */
;;;864      int ic0, ic1, ic2;
;;;865      register JSAMPLE * cptr;	/* pointer into bestcolor[] array */
;;;866      register histptr cachep;	/* pointer into main cache array */
;;;867      /* This array lists the candidate colormap indexes. */
;;;868      JSAMPLE colorlist[MAXNUMCOLORS];
;;;869      int numcolors;		/* number of candidate colors */
;;;870      /* This array holds the actually closest colormap index for each cell. */
;;;871      JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
;;;872    
;;;873      /* Convert cell coordinates to update box ID */
;;;874      c0 >>= BOX_C0_LOG;
00096e  ea4f04a4          ASR      r4,r4,#2
;;;875      c1 >>= BOX_C1_LOG;
000972  ea4f05e5          ASR      r5,r5,#3
;;;876      c2 >>= BOX_C2_LOG;
000976  ea4f06a6          ASR      r6,r6,#2
;;;877    
;;;878      /* Compute true coordinates of update box's origin corner.
;;;879       * Actually we compute the coordinates of the center of the corner
;;;880       * histogram cell, which are the lower bounds of the volume we care about.
;;;881       */
;;;882      minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
00097a  f04f0004          MOV      r0,#4
00097e  eb001044          ADD      r0,r0,r4,LSL #5
000982  9068              STR      r0,[sp,#0x1a0]
;;;883      minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
000984  f04f0002          MOV      r0,#2
000988  eb001045          ADD      r0,r0,r5,LSL #5
00098c  9067              STR      r0,[sp,#0x19c]
;;;884      minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
00098e  f04f0004          MOV      r0,#4
000992  eb001046          ADD      r0,r0,r6,LSL #5
000996  9066              STR      r0,[sp,#0x198]
;;;885      
;;;886      /* Determine which colormap entries are close enough to be candidates
;;;887       * for the nearest entry to some cell in the update box.
;;;888       */
;;;889      numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
000998  a825              ADD      r0,sp,#0x94
00099a  9000              STR      r0,[sp,#0]
00099c  4648              MOV      r0,r9
00099e  9b66              LDR      r3,[sp,#0x198]
0009a0  9a67              LDR      r2,[sp,#0x19c]
0009a2  9968              LDR      r1,[sp,#0x1a0]
0009a4  f7fffffe          BL       find_nearby_colors
0009a8  9024              STR      r0,[sp,#0x90]
;;;890    
;;;891      /* Determine the actually nearest colors. */
;;;892      find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
0009aa  a904              ADD      r1,sp,#0x10
0009ac  aa25              ADD      r2,sp,#0x94
0009ae  9824              LDR      r0,[sp,#0x90]
0009b0  e9cd2101          STRD     r2,r1,[sp,#4]
0009b4  9000              STR      r0,[sp,#0]
0009b6  4648              MOV      r0,r9
0009b8  9b66              LDR      r3,[sp,#0x198]
0009ba  9a67              LDR      r2,[sp,#0x19c]
0009bc  9968              LDR      r1,[sp,#0x1a0]
0009be  f7fffffe          BL       find_best_colors
;;;893    		   bestcolor);
;;;894    
;;;895      /* Save the best color numbers (plus 1) in the main cache array */
;;;896      c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
0009c2  ea4f0484          LSL      r4,r4,#2
;;;897      c1 <<= BOX_C1_LOG;
0009c6  ea4f05c5          LSL      r5,r5,#3
;;;898      c2 <<= BOX_C2_LOG;
0009ca  ea4f0686          LSL      r6,r6,#2
;;;899      cptr = bestcolor;
0009ce  a804              ADD      r0,sp,#0x10
0009d0  9065              STR      r0,[sp,#0x194]
;;;900      for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
0009d2  f04f0700          MOV      r7,#0
0009d6  e024              B        |L1.2594|
                  |L1.2520|
;;;901        for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
0009d8  f04f0800          MOV      r8,#0
0009dc  e01c              B        |L1.2584|
                  |L1.2526|
;;;902          cachep = & histogram[c0+ic0][c1+ic1][c2];
0009de  eb040107          ADD      r1,r4,r7
0009e2  9869              LDR      r0,[sp,#0x1a4]
0009e4  f8500021          LDR      r0,[r0,r1,LSL #2]
0009e8  eb050108          ADD      r1,r5,r8
0009ec  eb001081          ADD      r0,r0,r1,LSL #6
0009f0  eb000b46          ADD      r11,r0,r6,LSL #1
;;;903          for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
0009f4  f04f0a00          MOV      r10,#0
0009f8  e009              B        |L1.2574|
                  |L1.2554|
;;;904    	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
0009fa  9865              LDR      r0,[sp,#0x194]
0009fc  f8101b01          LDRB     r1,[r0],#1
000a00  f1010101          ADD      r1,r1,#1
000a04  9065              STR      r0,[sp,#0x194]
000a06  f82b1b02          STRH     r1,[r11],#2
000a0a  f10a0a01          ADD      r10,r10,#1            ;903
                  |L1.2574|
000a0e  f1ba0f04          CMP      r10,#4                ;903
000a12  dbf2              BLT      |L1.2554|
000a14  f1080801          ADD      r8,r8,#1              ;901
                  |L1.2584|
000a18  f1b80f08          CMP      r8,#8                 ;901
000a1c  dbdf              BLT      |L1.2526|
000a1e  f1070701          ADD      r7,r7,#1              ;900
                  |L1.2594|
000a22  2f04              CMP      r7,#4                 ;900
000a24  dbd8              BLT      |L1.2520|
;;;905          }
;;;906        }
;;;907      }
;;;908    }
000a26  b06b              ADD      sp,sp,#0x1ac
000a28  e8bd8ff0          POP      {r4-r11,pc}
;;;909    
                          ENDP

                  pass2_no_dither PROC
;;;915    METHODDEF(void)
;;;916    pass2_no_dither (j_decompress_ptr cinfo,
000a2c  e92d4fff          PUSH     {r0-r11,lr}
;;;917    		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
;;;918    /* This version performs no dithering */
;;;919    {
000a30  b085              SUB      sp,sp,#0x14
000a32  4606              MOV      r6,r0
000a34  468b              MOV      r11,r1
;;;920      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000a36  f8d601cc          LDR      r0,[r6,#0x1cc]
000a3a  9004              STR      r0,[sp,#0x10]
;;;921      hist3d histogram = cquantize->histogram;
000a3c  9804              LDR      r0,[sp,#0x10]
000a3e  6980              LDR      r0,[r0,#0x18]
000a40  9003              STR      r0,[sp,#0xc]
;;;922      register JSAMPROW inptr, outptr;
;;;923      register histptr cachep;
;;;924      register int c0, c1, c2;
;;;925      int row;
;;;926      JDIMENSION col;
;;;927      JDIMENSION width = cinfo->output_width;
000a42  6f30              LDR      r0,[r6,#0x70]
000a44  9000              STR      r0,[sp,#0]
;;;928    
;;;929      for (row = 0; row < num_rows; row++) {
000a46  f04f0500          MOV      r5,#0
000a4a  e036              B        |L1.2746|
                  |L1.2636|
;;;930        inptr = input_buf[row];
000a4c  f85b4025          LDR      r4,[r11,r5,LSL #2]
;;;931        outptr = output_buf[row];
000a50  9807              LDR      r0,[sp,#0x1c]
000a52  f8500025          LDR      r0,[r0,r5,LSL #2]
000a56  9002              STR      r0,[sp,#8]
;;;932        for (col = width; col > 0; col--) {
000a58  9800              LDR      r0,[sp,#0]
000a5a  9001              STR      r0,[sp,#4]
000a5c  e028              B        |L1.2736|
                  |L1.2654|
;;;933          /* get pixel value and index into the cache */
;;;934          c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
000a5e  f8141b01          LDRB     r1,[r4],#1
000a62  ea4f08e1          ASR      r8,r1,#3
;;;935          c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
000a66  f8141b01          LDRB     r1,[r4],#1
000a6a  ea4f09a1          ASR      r9,r1,#2
;;;936          c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
000a6e  f8141b01          LDRB     r1,[r4],#1
000a72  ea4f0ae1          ASR      r10,r1,#3
;;;937          cachep = & histogram[c0][c1][c2];
000a76  9803              LDR      r0,[sp,#0xc]
000a78  f8500028          LDR      r0,[r0,r8,LSL #2]
000a7c  eb001089          ADD      r0,r0,r9,LSL #6
000a80  eb00074a          ADD      r7,r0,r10,LSL #1
;;;938          /* If we have not seen this color before, find nearest colormap entry */
;;;939          /* and update the cache */
;;;940          if (*cachep == 0)
000a84  8838              LDRH     r0,[r7,#0]
000a86  b928              CBNZ     r0,|L1.2708|
;;;941    	fill_inverse_cmap(cinfo, c0,c1,c2);
000a88  4653              MOV      r3,r10
000a8a  464a              MOV      r2,r9
000a8c  4641              MOV      r1,r8
000a8e  4630              MOV      r0,r6
000a90  f7fffffe          BL       fill_inverse_cmap
                  |L1.2708|
;;;942          /* Now emit the colormap index for this cell */
;;;943          *outptr++ = (JSAMPLE) (*cachep - 1);
000a94  8838              LDRH     r0,[r7,#0]
000a96  f1a00001          SUB      r0,r0,#1
000a9a  b2c1              UXTB     r1,r0
000a9c  9802              LDR      r0,[sp,#8]
000a9e  7001              STRB     r1,[r0,#0]
000aa0  9802              LDR      r0,[sp,#8]
000aa2  f1000001          ADD      r0,r0,#1
000aa6  9002              STR      r0,[sp,#8]
000aa8  9801              LDR      r0,[sp,#4]            ;932
000aaa  f1a00001          SUB      r0,r0,#1              ;932
000aae  9001              STR      r0,[sp,#4]            ;932
                  |L1.2736|
000ab0  9801              LDR      r0,[sp,#4]            ;932
000ab2  2800              CMP      r0,#0                 ;932
000ab4  d1d3              BNE      |L1.2654|
000ab6  f1050501          ADD      r5,r5,#1              ;929
                  |L1.2746|
000aba  9808              LDR      r0,[sp,#0x20]         ;929
000abc  4285              CMP      r5,r0                 ;929
000abe  dbc5              BLT      |L1.2636|
;;;944        }
;;;945      }
;;;946    }
000ac0  b009              ADD      sp,sp,#0x24
000ac2  e8bd8ff0          POP      {r4-r11,pc}
;;;947    
                          ENDP

                  pass2_fs_dither PROC
;;;949    METHODDEF(void)
;;;950    pass2_fs_dither (j_decompress_ptr cinfo,
000ac6  e92d4fff          PUSH     {r0-r11,lr}
;;;951    		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
;;;952    /* This version performs Floyd-Steinberg dithering */
;;;953    {
000aca  b093              SUB      sp,sp,#0x4c
000acc  4680              MOV      r8,r0
;;;954      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000ace  f8d891cc          LDR      r9,[r8,#0x1cc]
;;;955      hist3d histogram = cquantize->histogram;
000ad2  f8d90018          LDR      r0,[r9,#0x18]
000ad6  9012              STR      r0,[sp,#0x48]
;;;956      register LOCFSERROR cur0, cur1, cur2;	/* current error or pixel value */
;;;957      LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
;;;958      LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
;;;959      register FSERRPTR errorptr;	/* => fserrors[] at column before current */
;;;960      JSAMPROW inptr;		/* => current input pixel */
;;;961      JSAMPROW outptr;		/* => current output pixel */
;;;962      histptr cachep;
;;;963      int dir;			/* +1 or -1 depending on direction */
;;;964      int dir3;			/* 3*dir, for advancing inptr & errorptr */
;;;965      int row;
;;;966      JDIMENSION col;
;;;967      JDIMENSION width = cinfo->output_width;
000ad8  f8d80070          LDR      r0,[r8,#0x70]
000adc  9006              STR      r0,[sp,#0x18]
;;;968      JSAMPLE *range_limit = cinfo->sample_range_limit;
000ade  f8d80144          LDR      r0,[r8,#0x144]
000ae2  9005              STR      r0,[sp,#0x14]
;;;969      int *error_limit = cquantize->error_limiter;
000ae4  f8d90028          LDR      r0,[r9,#0x28]
000ae8  9004              STR      r0,[sp,#0x10]
;;;970      JSAMPROW colormap0 = cinfo->colormap[0];
000aea  f8d80088          LDR      r0,[r8,#0x88]
000aee  6800              LDR      r0,[r0,#0]
000af0  9003              STR      r0,[sp,#0xc]
;;;971      JSAMPROW colormap1 = cinfo->colormap[1];
000af2  f8d80088          LDR      r0,[r8,#0x88]
000af6  6840              LDR      r0,[r0,#4]
000af8  9002              STR      r0,[sp,#8]
;;;972      JSAMPROW colormap2 = cinfo->colormap[2];
000afa  f8d80088          LDR      r0,[r8,#0x88]
000afe  6880              LDR      r0,[r0,#8]
000b00  9001              STR      r0,[sp,#4]
;;;973      SHIFT_TEMPS
;;;974    
;;;975      for (row = 0; row < num_rows; row++) {
000b02  f04f0000          MOV      r0,#0
000b06  9008              STR      r0,[sp,#0x20]
000b08  e0e1              B        |L1.3278|
                  |L1.2826|
;;;976        inptr = input_buf[row];
000b0a  9908              LDR      r1,[sp,#0x20]
000b0c  9814              LDR      r0,[sp,#0x50]
000b0e  f850b021          LDR      r11,[r0,r1,LSL #2]
;;;977        outptr = output_buf[row];
000b12  9908              LDR      r1,[sp,#0x20]
000b14  9815              LDR      r0,[sp,#0x54]
000b16  f8500021          LDR      r0,[r0,r1,LSL #2]
000b1a  900b              STR      r0,[sp,#0x2c]
;;;978        if (cquantize->on_odd_row) {
000b1c  f8d90024          LDR      r0,[r9,#0x24]
000b20  b1f0              CBZ      r0,|L1.2912|
;;;979          /* work right to left in this row */
;;;980          inptr += (width-1) * 3;	/* so point to rightmost pixel */
000b22  9806              LDR      r0,[sp,#0x18]
000b24  f1a00001          SUB      r0,r0,#1
000b28  eb000040          ADD      r0,r0,r0,LSL #1
000b2c  4483              ADD      r11,r11,r0
;;;981          outptr += width-1;
000b2e  9806              LDR      r0,[sp,#0x18]
000b30  f1a00001          SUB      r0,r0,#1
000b34  990b              LDR      r1,[sp,#0x2c]
000b36  4408              ADD      r0,r0,r1
000b38  900b              STR      r0,[sp,#0x2c]
;;;982          dir = -1;
000b3a  f04f30ff          MOV      r0,#0xffffffff
000b3e  9009              STR      r0,[sp,#0x24]
;;;983          dir3 = -3;
000b40  f06f0a02          MVN      r10,#2
;;;984          errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
000b44  f8d91020          LDR      r1,[r9,#0x20]
000b48  9806              LDR      r0,[sp,#0x18]
000b4a  f1000001          ADD      r0,r0,#1
000b4e  eb000040          ADD      r0,r0,r0,LSL #1
000b52  eb010740          ADD      r7,r1,r0,LSL #1
;;;985          cquantize->on_odd_row = FALSE; /* flip for next time */
000b56  f04f0000          MOV      r0,#0
000b5a  f8c90024          STR      r0,[r9,#0x24]
000b5e  e008              B        |L1.2930|
                  |L1.2912|
;;;986        } else {
;;;987          /* work left to right in this row */
;;;988          dir = 1;
000b60  f04f0001          MOV      r0,#1
000b64  9009              STR      r0,[sp,#0x24]
;;;989          dir3 = 3;
000b66  f04f0a03          MOV      r10,#3
;;;990          errorptr = cquantize->fserrors; /* => entry before first real column */
000b6a  f8d97020          LDR      r7,[r9,#0x20]
;;;991          cquantize->on_odd_row = TRUE; /* flip for next time */
000b6e  f8c90024          STR      r0,[r9,#0x24]
                  |L1.2930|
;;;992        }
;;;993        /* Preset error values: no error propagated to first pixel from left */
;;;994        cur0 = cur1 = cur2 = 0;
000b72  f04f0000          MOV      r0,#0
000b76  4606              MOV      r6,r0
000b78  4605              MOV      r5,r0
000b7a  4604              MOV      r4,r0
;;;995        /* and no error propagated to row below yet */
;;;996        belowerr0 = belowerr1 = belowerr2 = 0;
000b7c  900f              STR      r0,[sp,#0x3c]
000b7e  9010              STR      r0,[sp,#0x40]
000b80  9011              STR      r0,[sp,#0x44]
;;;997        bpreverr0 = bpreverr1 = bpreverr2 = 0;
000b82  900c              STR      r0,[sp,#0x30]
000b84  900d              STR      r0,[sp,#0x34]
000b86  900e              STR      r0,[sp,#0x38]
;;;998    
;;;999        for (col = width; col > 0; col--) {
000b88  9806              LDR      r0,[sp,#0x18]
000b8a  9007              STR      r0,[sp,#0x1c]
000b8c  e08e              B        |L1.3244|
                  |L1.2958|
;;;1000         /* curN holds the error propagated from the previous pixel on the
;;;1001          * current line.  Add the error propagated from the previous line
;;;1002          * to form the complete error correction term for this pixel, and
;;;1003          * round the error term (which is expressed * 16) to an integer.
;;;1004          * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
;;;1005          * for either sign of the error value.
;;;1006          * Note: errorptr points to *previous* column's array entry.
;;;1007          */
;;;1008         cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
000b8e  f937001a          LDRSH    r0,[r7,r10,LSL #1]
000b92  4420              ADD      r0,r0,r4
000b94  f1000008          ADD      r0,r0,#8
000b98  ea4f1420          ASR      r4,r0,#4
;;;1009         cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
000b9c  f10a0001          ADD      r0,r10,#1
000ba0  f9370010          LDRSH    r0,[r7,r0,LSL #1]
000ba4  4428              ADD      r0,r0,r5
000ba6  f1000008          ADD      r0,r0,#8
000baa  ea4f1520          ASR      r5,r0,#4
;;;1010         cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
000bae  f10a0002          ADD      r0,r10,#2
000bb2  f9370010          LDRSH    r0,[r7,r0,LSL #1]
000bb6  4430              ADD      r0,r0,r6
000bb8  f1000008          ADD      r0,r0,#8
000bbc  ea4f1620          ASR      r6,r0,#4
;;;1011         /* Limit the error using transfer function set by init_error_limit.
;;;1012          * See comments with init_error_limit for rationale.
;;;1013          */
;;;1014         cur0 = error_limit[cur0];
000bc0  9804              LDR      r0,[sp,#0x10]
000bc2  f8504024          LDR      r4,[r0,r4,LSL #2]
;;;1015         cur1 = error_limit[cur1];
000bc6  9804              LDR      r0,[sp,#0x10]
000bc8  f8505025          LDR      r5,[r0,r5,LSL #2]
;;;1016         cur2 = error_limit[cur2];
000bcc  9804              LDR      r0,[sp,#0x10]
000bce  f8506026          LDR      r6,[r0,r6,LSL #2]
;;;1017         /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
;;;1018          * The maximum error is +- MAXJSAMPLE (or less with error limiting);
;;;1019          * this sets the required size of the range_limit array.
;;;1020          */
;;;1021         cur0 += GETJSAMPLE(inptr[0]);
000bd2  f89b0000          LDRB     r0,[r11,#0]
000bd6  4404              ADD      r4,r4,r0
;;;1022         cur1 += GETJSAMPLE(inptr[1]);
000bd8  f89b0001          LDRB     r0,[r11,#1]
000bdc  4405              ADD      r5,r5,r0
;;;1023         cur2 += GETJSAMPLE(inptr[2]);
000bde  f89b0002          LDRB     r0,[r11,#2]
000be2  4406              ADD      r6,r6,r0
;;;1024         cur0 = GETJSAMPLE(range_limit[cur0]);
000be4  9805              LDR      r0,[sp,#0x14]
000be6  5d04              LDRB     r4,[r0,r4]
;;;1025         cur1 = GETJSAMPLE(range_limit[cur1]);
000be8  9805              LDR      r0,[sp,#0x14]
000bea  5d45              LDRB     r5,[r0,r5]
;;;1026         cur2 = GETJSAMPLE(range_limit[cur2]);
000bec  9805              LDR      r0,[sp,#0x14]
000bee  5d86              LDRB     r6,[r0,r6]
;;;1027         /* Index into the cache with adjusted pixel value */
;;;1028         cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
000bf0  ea4f01e4          ASR      r1,r4,#3
000bf4  9812              LDR      r0,[sp,#0x48]
000bf6  f8500021          LDR      r0,[r0,r1,LSL #2]
000bfa  ea4f01a5          ASR      r1,r5,#2
000bfe  eb001081          ADD      r0,r0,r1,LSL #6
000c02  ea4f01e6          ASR      r1,r6,#3
000c06  eb000041          ADD      r0,r0,r1,LSL #1
000c0a  900a              STR      r0,[sp,#0x28]
;;;1029         /* If we have not seen this color before, find nearest colormap */
;;;1030         /* entry and update the cache */
;;;1031         if (*cachep == 0)
000c0c  980a              LDR      r0,[sp,#0x28]
000c0e  8800              LDRH     r0,[r0,#0]
000c10  b928              CBNZ     r0,|L1.3102|
;;;1032   	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
000c12  10f3              ASRS     r3,r6,#3
000c14  10aa              ASRS     r2,r5,#2
000c16  10e1              ASRS     r1,r4,#3
000c18  4640              MOV      r0,r8
000c1a  f7fffffe          BL       fill_inverse_cmap
                  |L1.3102|
;;;1033         /* Now emit the colormap index for this cell */
;;;1034         { register int pixcode = *cachep - 1;
000c1e  990a              LDR      r1,[sp,#0x28]
000c20  8809              LDRH     r1,[r1,#0]
000c22  f1a10001          SUB      r0,r1,#1
;;;1035   	*outptr = (JSAMPLE) pixcode;
000c26  990b              LDR      r1,[sp,#0x2c]
000c28  7008              STRB     r0,[r1,#0]
;;;1036   	/* Compute representation error for this pixel */
;;;1037   	cur0 -= GETJSAMPLE(colormap0[pixcode]);
000c2a  9903              LDR      r1,[sp,#0xc]
000c2c  5c09              LDRB     r1,[r1,r0]
000c2e  eba40401          SUB      r4,r4,r1
;;;1038   	cur1 -= GETJSAMPLE(colormap1[pixcode]);
000c32  9902              LDR      r1,[sp,#8]
000c34  5c09              LDRB     r1,[r1,r0]
000c36  eba50501          SUB      r5,r5,r1
;;;1039   	cur2 -= GETJSAMPLE(colormap2[pixcode]);
000c3a  9901              LDR      r1,[sp,#4]
000c3c  5c09              LDRB     r1,[r1,r0]
000c3e  eba60601          SUB      r6,r6,r1
;;;1040         }
;;;1041         /* Compute error fractions to be propagated to adjacent pixels.
;;;1042          * Add these into the running sums, and simultaneously shift the
;;;1043          * next-line error sums left by 1 column.
;;;1044          */
;;;1045         { register LOCFSERROR bnexterr, delta;
;;;1046   
;;;1047   	bnexterr = cur0;	/* Process component 0 */
000c42  4620              MOV      r0,r4
;;;1048   	delta = cur0 * 2;
000c44  ea4f0144          LSL      r1,r4,#1
;;;1049   	cur0 += delta;		/* form error * 3 */
000c48  440c              ADD      r4,r4,r1
;;;1050   	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
000c4a  9a0e              LDR      r2,[sp,#0x38]
000c4c  4422              ADD      r2,r2,r4
000c4e  b212              SXTH     r2,r2
000c50  803a              STRH     r2,[r7,#0]
;;;1051   	cur0 += delta;		/* form error * 5 */
000c52  440c              ADD      r4,r4,r1
;;;1052   	bpreverr0 = belowerr0 + cur0;
000c54  9a11              LDR      r2,[sp,#0x44]
000c56  4422              ADD      r2,r2,r4
000c58  920e              STR      r2,[sp,#0x38]
;;;1053   	belowerr0 = bnexterr;
000c5a  9011              STR      r0,[sp,#0x44]
;;;1054   	cur0 += delta;		/* form error * 7 */
000c5c  440c              ADD      r4,r4,r1
;;;1055   	bnexterr = cur1;	/* Process component 1 */
000c5e  4628              MOV      r0,r5
;;;1056   	delta = cur1 * 2;
000c60  ea4f0145          LSL      r1,r5,#1
;;;1057   	cur1 += delta;		/* form error * 3 */
000c64  440d              ADD      r5,r5,r1
;;;1058   	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
000c66  9a0d              LDR      r2,[sp,#0x34]
000c68  442a              ADD      r2,r2,r5
000c6a  b212              SXTH     r2,r2
000c6c  807a              STRH     r2,[r7,#2]
;;;1059   	cur1 += delta;		/* form error * 5 */
000c6e  440d              ADD      r5,r5,r1
;;;1060   	bpreverr1 = belowerr1 + cur1;
000c70  9a10              LDR      r2,[sp,#0x40]
000c72  442a              ADD      r2,r2,r5
000c74  920d              STR      r2,[sp,#0x34]
;;;1061   	belowerr1 = bnexterr;
000c76  9010              STR      r0,[sp,#0x40]
;;;1062   	cur1 += delta;		/* form error * 7 */
000c78  440d              ADD      r5,r5,r1
;;;1063   	bnexterr = cur2;	/* Process component 2 */
000c7a  4630              MOV      r0,r6
;;;1064   	delta = cur2 * 2;
000c7c  ea4f0146          LSL      r1,r6,#1
;;;1065   	cur2 += delta;		/* form error * 3 */
000c80  440e              ADD      r6,r6,r1
;;;1066   	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
000c82  9a0c              LDR      r2,[sp,#0x30]
000c84  4432              ADD      r2,r2,r6
000c86  b212              SXTH     r2,r2
000c88  80ba              STRH     r2,[r7,#4]
;;;1067   	cur2 += delta;		/* form error * 5 */
000c8a  440e              ADD      r6,r6,r1
;;;1068   	bpreverr2 = belowerr2 + cur2;
000c8c  9a0f              LDR      r2,[sp,#0x3c]
000c8e  4432              ADD      r2,r2,r6
000c90  920c              STR      r2,[sp,#0x30]
;;;1069   	belowerr2 = bnexterr;
000c92  900f              STR      r0,[sp,#0x3c]
;;;1070   	cur2 += delta;		/* form error * 7 */
000c94  440e              ADD      r6,r6,r1
;;;1071         }
;;;1072         /* At this point curN contains the 7/16 error value to be propagated
;;;1073          * to the next pixel on the current line, and all the errors for the
;;;1074          * next line have been shifted over.  We are therefore ready to move on.
;;;1075          */
;;;1076         inptr += dir3;		/* Advance pixel pointers to next column */
000c96  44d3              ADD      r11,r11,r10
;;;1077         outptr += dir;
000c98  9909              LDR      r1,[sp,#0x24]
000c9a  980b              LDR      r0,[sp,#0x2c]
000c9c  4408              ADD      r0,r0,r1
000c9e  900b              STR      r0,[sp,#0x2c]
;;;1078         errorptr += dir3;		/* advance errorptr to current column */
000ca0  eb07074a          ADD      r7,r7,r10,LSL #1
000ca4  9807              LDR      r0,[sp,#0x1c]         ;999
000ca6  f1a00001          SUB      r0,r0,#1              ;999
000caa  9007              STR      r0,[sp,#0x1c]         ;999
                  |L1.3244|
000cac  9807              LDR      r0,[sp,#0x1c]         ;999
000cae  2800              CMP      r0,#0                 ;999
000cb0  f47faf6d          BNE      |L1.2958|
;;;1079       }
;;;1080       /* Post-loop cleanup: we must unload the final error values into the
;;;1081        * final fserrors[] entry.  Note we need not unload belowerrN because
;;;1082        * it is for the dummy column before or after the actual array.
;;;1083        */
;;;1084       errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
000cb4  980e              LDR      r0,[sp,#0x38]
000cb6  b200              SXTH     r0,r0
000cb8  8038              STRH     r0,[r7,#0]
;;;1085       errorptr[1] = (FSERROR) bpreverr1;
000cba  980d              LDR      r0,[sp,#0x34]
000cbc  b200              SXTH     r0,r0
000cbe  8078              STRH     r0,[r7,#2]
;;;1086       errorptr[2] = (FSERROR) bpreverr2;
000cc0  980c              LDR      r0,[sp,#0x30]
000cc2  b200              SXTH     r0,r0
000cc4  80b8              STRH     r0,[r7,#4]
000cc6  9808              LDR      r0,[sp,#0x20]         ;975
000cc8  f1000001          ADD      r0,r0,#1              ;975
000ccc  9008              STR      r0,[sp,#0x20]         ;975
                  |L1.3278|
000cce  9916              LDR      r1,[sp,#0x58]         ;975
000cd0  9808              LDR      r0,[sp,#0x20]         ;975
000cd2  4288              CMP      r0,r1                 ;975
000cd4  f6ffaf19          BLT      |L1.2826|
;;;1087     }
;;;1088   }
000cd8  b017              ADD      sp,sp,#0x5c
000cda  e8bd8ff0          POP      {r4-r11,pc}
;;;1089   
                          ENDP

                  init_error_limit PROC
;;;1108   LOCAL(void)
;;;1109   init_error_limit (j_decompress_ptr cinfo)
000cde  e92d41f0          PUSH     {r4-r8,lr}
;;;1110   /* Allocate and fill in the error_limiter table */
;;;1111   {
000ce2  4607              MOV      r7,r0
;;;1112     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000ce4  f8d781cc          LDR      r8,[r7,#0x1cc]
;;;1113     int * table;
;;;1114     int in, out;
;;;1115   
;;;1116     table = (int *) (*cinfo->mem->alloc_small)
000ce8  6878              LDR      r0,[r7,#4]
000cea  f24072fc          MOV      r2,#0x7fc
000cee  f04f0101          MOV      r1,#1
000cf2  6803              LDR      r3,[r0,#0]
000cf4  4638              MOV      r0,r7
000cf6  4798              BLX      r3
000cf8  4605              MOV      r5,r0
;;;1117       ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
;;;1118     table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
000cfa  f505757f          ADD      r5,r5,#0x3fc
;;;1119     cquantize->error_limiter = table;
000cfe  f8c85028          STR      r5,[r8,#0x28]
;;;1120   
;;;1121   #define STEPSIZE ((MAXJSAMPLE+1)/16)
;;;1122     /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
;;;1123     out = 0;
000d02  f04f0600          MOV      r6,#0
;;;1124     for (in = 0; in < STEPSIZE; in++, out++) {
000d06  4634              MOV      r4,r6
000d08  e00b              B        |L1.3362|
                  |L1.3338|
;;;1125       table[in] = out; table[-in] = -out;
000d0a  f8456024          STR      r6,[r5,r4,LSL #2]
000d0e  f1c60000          RSB      r0,r6,#0
000d12  f1c40100          RSB      r1,r4,#0
000d16  f8450021          STR      r0,[r5,r1,LSL #2]
000d1a  f1040401          ADD      r4,r4,#1              ;1124
000d1e  f1060601          ADD      r6,r6,#1              ;1124
                  |L1.3362|
000d22  2c10              CMP      r4,#0x10              ;1124
000d24  dbf1              BLT      |L1.3338|
;;;1126     }
;;;1127     /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
;;;1128     for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
000d26  e00e              B        |L1.3398|
                  |L1.3368|
;;;1129       table[in] = out; table[-in] = -out;
000d28  f8456024          STR      r6,[r5,r4,LSL #2]
000d2c  f1c60000          RSB      r0,r6,#0
000d30  f1c40100          RSB      r1,r4,#0
000d34  f8450021          STR      r0,[r5,r1,LSL #2]
000d38  f1040401          ADD      r4,r4,#1              ;1128
000d3c  f0040001          AND      r0,r4,#1              ;1128
000d40  f0800001          EOR      r0,r0,#1              ;1128
000d44  4406              ADD      r6,r6,r0              ;1128
                  |L1.3398|
000d46  2c30              CMP      r4,#0x30              ;1128
000d48  dbee              BLT      |L1.3368|
;;;1130     }
;;;1131     /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
;;;1132     for (; in <= MAXJSAMPLE; in++) {
000d4a  e009              B        |L1.3424|
                  |L1.3404|
;;;1133       table[in] = out; table[-in] = -out;
000d4c  f8456024          STR      r6,[r5,r4,LSL #2]
000d50  f1c60000          RSB      r0,r6,#0
000d54  f1c40100          RSB      r1,r4,#0
000d58  f8450021          STR      r0,[r5,r1,LSL #2]
000d5c  f1040401          ADD      r4,r4,#1              ;1132
                  |L1.3424|
000d60  2cff              CMP      r4,#0xff              ;1132
000d62  ddf3              BLE      |L1.3404|
;;;1134     }
;;;1135   #undef STEPSIZE
;;;1136   }
000d64  e8bd81f0          POP      {r4-r8,pc}
;;;1137   
                          ENDP

                  finish_pass1 PROC
;;;1143   METHODDEF(void)
;;;1144   finish_pass1 (j_decompress_ptr cinfo)
000d68  b570              PUSH     {r4-r6,lr}
;;;1145   {
000d6a  4604              MOV      r4,r0
;;;1146     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000d6c  f8d451cc          LDR      r5,[r4,#0x1cc]
;;;1147   
;;;1148     /* Select the representative colors and fill in cinfo->colormap */
;;;1149     cinfo->colormap = cquantize->sv_colormap;
000d70  6928              LDR      r0,[r5,#0x10]
000d72  f8c40088          STR      r0,[r4,#0x88]
;;;1150     select_colors(cinfo, cquantize->desired);
000d76  4620              MOV      r0,r4
000d78  6969              LDR      r1,[r5,#0x14]
000d7a  f7fffffe          BL       select_colors
;;;1151     /* Force next pass to zero the color index table */
;;;1152     cquantize->needs_zeroed = TRUE;
000d7e  f04f0001          MOV      r0,#1
000d82  61e8              STR      r0,[r5,#0x1c]
;;;1153   }
000d84  bd70              POP      {r4-r6,pc}
;;;1154   
                          ENDP

                  finish_pass2 PROC
;;;1156   METHODDEF(void)
;;;1157   finish_pass2 (j_decompress_ptr cinfo)
000d86  bf00              NOP      
;;;1158   {
;;;1159     GUI_USE_PARA(cinfo);
;;;1160     /* no work */
;;;1161   }
000d88  4770              BX       lr
;;;1162   
                          ENDP

                  start_pass_2_quant PROC
;;;1168   METHODDEF(void)
;;;1169   start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
000d8a  e92d47f0          PUSH     {r4-r10,lr}
;;;1170   {
000d8e  4604              MOV      r4,r0
000d90  460f              MOV      r7,r1
;;;1171     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000d92  f8d451cc          LDR      r5,[r4,#0x1cc]
;;;1172     hist3d histogram = cquantize->histogram;
000d96  f8d59018          LDR      r9,[r5,#0x18]
;;;1173     int i;
;;;1174   
;;;1175     /* Only F-S dithering or no dithering is supported. */
;;;1176     /* If user asks for ordered dither, give him F-S. */
;;;1177     if (cinfo->dither_mode != JDITHER_NONE)
000d9a  f8940058          LDRB     r0,[r4,#0x58]
000d9e  b118              CBZ      r0,|L1.3496|
;;;1178       cinfo->dither_mode = JDITHER_FS;
000da0  f04f0002          MOV      r0,#2
000da4  f8840058          STRB     r0,[r4,#0x58]
                  |L1.3496|
;;;1179   
;;;1180     if (is_pre_scan) {
000da8  b13f              CBZ      r7,|L1.3514|
;;;1181       /* Set up method pointers */
;;;1182       cquantize->pub.color_quantize = prescan_quantize;
000daa  4879              LDR      r0,|L1.3984|
000dac  6068              STR      r0,[r5,#4]
;;;1183       cquantize->pub.finish_pass = finish_pass1;
000dae  4879              LDR      r0,|L1.3988|
000db0  60a8              STR      r0,[r5,#8]
;;;1184       cquantize->needs_zeroed = TRUE; /* Always zero histogram */
000db2  f04f0001          MOV      r0,#1
000db6  61e8              STR      r0,[r5,#0x1c]
000db8  e04a              B        |L1.3664|
                  |L1.3514|
;;;1185     } else {
;;;1186       /* Set up method pointers */
;;;1187       if (cinfo->dither_mode == JDITHER_FS)
000dba  f8940058          LDRB     r0,[r4,#0x58]
000dbe  2802              CMP      r0,#2
000dc0  d102              BNE      |L1.3528|
;;;1188         cquantize->pub.color_quantize = pass2_fs_dither;
000dc2  4875              LDR      r0,|L1.3992|
000dc4  6068              STR      r0,[r5,#4]
000dc6  e001              B        |L1.3532|
                  |L1.3528|
;;;1189       else
;;;1190         cquantize->pub.color_quantize = pass2_no_dither;
000dc8  4874              LDR      r0,|L1.3996|
000dca  6068              STR      r0,[r5,#4]
                  |L1.3532|
;;;1191       cquantize->pub.finish_pass = finish_pass2;
000dcc  4874              LDR      r0,|L1.4000|
000dce  60a8              STR      r0,[r5,#8]
;;;1192   
;;;1193       /* Make sure color count is acceptable */
;;;1194       i = cinfo->actual_number_of_colors;
000dd0  f8d46084          LDR      r6,[r4,#0x84]
;;;1195       if (i < 1)
000dd4  2e01              CMP      r6,#1
000dd6  da0b              BGE      |L1.3568|
;;;1196         ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
000dd8  f04f0038          MOV      r0,#0x38
000ddc  6821              LDR      r1,[r4,#0]
000dde  6148              STR      r0,[r1,#0x14]
000de0  f04f0001          MOV      r0,#1
000de4  6821              LDR      r1,[r4,#0]
000de6  6188              STR      r0,[r1,#0x18]
000de8  6820              LDR      r0,[r4,#0]
000dea  6801              LDR      r1,[r0,#0]
000dec  4620              MOV      r0,r4
000dee  4788              BLX      r1
                  |L1.3568|
;;;1197       if (i > MAXNUMCOLORS)
000df0  f5b67f80          CMP      r6,#0x100
000df4  dd0b              BLE      |L1.3598|
;;;1198         ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
000df6  f04f0039          MOV      r0,#0x39
000dfa  6821              LDR      r1,[r4,#0]
000dfc  6148              STR      r0,[r1,#0x14]
000dfe  f44f7080          MOV      r0,#0x100
000e02  6821              LDR      r1,[r4,#0]
000e04  6188              STR      r0,[r1,#0x18]
000e06  6820              LDR      r0,[r4,#0]
000e08  6801              LDR      r1,[r0,#0]
000e0a  4620              MOV      r0,r4
000e0c  4788              BLX      r1
                  |L1.3598|
;;;1199   
;;;1200       if (cinfo->dither_mode == JDITHER_FS) {
000e0e  f8940058          LDRB     r0,[r4,#0x58]
000e12  2802              CMP      r0,#2
000e14  d11c              BNE      |L1.3664|
;;;1201         size_t arraysize = (size_t) ((cinfo->output_width + 2) *
000e16  6f20              LDR      r0,[r4,#0x70]
000e18  f1000002          ADD      r0,r0,#2
000e1c  eb000040          ADD      r0,r0,r0,LSL #1
000e20  ea4f0840          LSL      r8,r0,#1
;;;1202   				   (3 * SIZEOF(FSERROR)));
;;;1203         /* Allocate Floyd-Steinberg workspace if we didn't already. */
;;;1204         if (cquantize->fserrors == NULL)
000e24  6a28              LDR      r0,[r5,#0x20]
000e26  b930              CBNZ     r0,|L1.3638|
;;;1205   	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
000e28  6860              LDR      r0,[r4,#4]
000e2a  4642              MOV      r2,r8
000e2c  2101              MOVS     r1,#1
000e2e  6843              LDR      r3,[r0,#4]
000e30  4620              MOV      r0,r4
000e32  4798              BLX      r3
000e34  6228              STR      r0,[r5,#0x20]
                  |L1.3638|
;;;1206   	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
;;;1207         /* Initialize the propagated errors to zero. */
;;;1208         jzero_far((void FAR *) cquantize->fserrors, arraysize);
000e36  4641              MOV      r1,r8
000e38  6a28              LDR      r0,[r5,#0x20]
000e3a  f7fffffe          BL       jzero_far
;;;1209         /* Make the error-limit table if we didn't already. */
;;;1210         if (cquantize->error_limiter == NULL)
000e3e  6aa8              LDR      r0,[r5,#0x28]
000e40  b910              CBNZ     r0,|L1.3656|
;;;1211   	init_error_limit(cinfo);
000e42  4620              MOV      r0,r4
000e44  f7fffffe          BL       init_error_limit
                  |L1.3656|
;;;1212         cquantize->on_odd_row = FALSE;
000e48  f04f0000          MOV      r0,#0
000e4c  6268              STR      r0,[r5,#0x24]
;;;1213       }
000e4e  bf00              NOP      
                  |L1.3664|
;;;1214   
;;;1215     }
;;;1216     /* Zero the histogram or inverse color map, if necessary */
;;;1217     if (cquantize->needs_zeroed) {
000e50  69e8              LDR      r0,[r5,#0x1c]
000e52  b178              CBZ      r0,|L1.3700|
;;;1218       for (i = 0; i < HIST_C0_ELEMS; i++) {
000e54  f04f0600          MOV      r6,#0
000e58  e007              B        |L1.3690|
                  |L1.3674|
;;;1219         jzero_far((void FAR *) histogram[i],
000e5a  f8590026          LDR      r0,[r9,r6,LSL #2]
000e5e  f44f5180          MOV      r1,#0x1000
000e62  f7fffffe          BL       jzero_far
000e66  f1060601          ADD      r6,r6,#1              ;1218
                  |L1.3690|
000e6a  2e20              CMP      r6,#0x20              ;1218
000e6c  dbf5              BLT      |L1.3674|
;;;1220   		HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
;;;1221       }
;;;1222       cquantize->needs_zeroed = FALSE;
000e6e  f04f0000          MOV      r0,#0
000e72  61e8              STR      r0,[r5,#0x1c]
                  |L1.3700|
;;;1223     }
;;;1224   }
000e74  e8bd87f0          POP      {r4-r10,pc}
;;;1225   
                          ENDP

                  new_color_map_2_quant PROC
;;;1231   METHODDEF(void)
;;;1232   new_color_map_2_quant (j_decompress_ptr cinfo)
000e78  f8d011cc          LDR      r1,[r0,#0x1cc]
;;;1233   {
;;;1234     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;1235   
;;;1236     /* Reset the inverse color map */
;;;1237     cquantize->needs_zeroed = TRUE;
000e7c  f04f0201          MOV      r2,#1
000e80  61ca              STR      r2,[r1,#0x1c]
;;;1238   }
000e82  4770              BX       lr
;;;1239   
                          ENDP

                  jinit_2pass_quantizer PROC
;;;1245   GLOBAL(void)
;;;1246   jinit_2pass_quantizer (j_decompress_ptr cinfo)
000e84  e92d41f0          PUSH     {r4-r8,lr}
;;;1247   {
000e88  4604              MOV      r4,r0
;;;1248     my_cquantize_ptr cquantize;
;;;1249     int i;
;;;1250   
;;;1251     cquantize = (my_cquantize_ptr)
000e8a  6860              LDR      r0,[r4,#4]
000e8c  f04f022c          MOV      r2,#0x2c
000e90  f04f0101          MOV      r1,#1
000e94  6803              LDR      r3,[r0,#0]
000e96  4620              MOV      r0,r4
000e98  4798              BLX      r3
000e9a  4605              MOV      r5,r0
;;;1252       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1253   				SIZEOF(my_cquantizer));
;;;1254     cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
000e9c  f8c451cc          STR      r5,[r4,#0x1cc]
;;;1255     cquantize->pub.start_pass = start_pass_2_quant;
000ea0  4840              LDR      r0,|L1.4004|
000ea2  6028              STR      r0,[r5,#0]
;;;1256     cquantize->pub.new_color_map = new_color_map_2_quant;
000ea4  4840              LDR      r0,|L1.4008|
000ea6  60e8              STR      r0,[r5,#0xc]
;;;1257     cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
000ea8  f04f0000          MOV      r0,#0
000eac  6228              STR      r0,[r5,#0x20]
;;;1258     cquantize->error_limiter = NULL;
000eae  62a8              STR      r0,[r5,#0x28]
;;;1259   
;;;1260     /* Make sure jdmaster didn't give me a case I can't handle */
;;;1261     if (cinfo->out_color_components != 3)
000eb0  6fa0              LDR      r0,[r4,#0x78]
000eb2  2803              CMP      r0,#3
000eb4  d007              BEQ      |L1.3782|
;;;1262       ERREXIT(cinfo, JERR_NOTIMPL);
000eb6  f04f002f          MOV      r0,#0x2f
000eba  6821              LDR      r1,[r4,#0]
000ebc  6148              STR      r0,[r1,#0x14]
000ebe  6820              LDR      r0,[r4,#0]
000ec0  6801              LDR      r1,[r0,#0]
000ec2  4620              MOV      r0,r4
000ec4  4788              BLX      r1
                  |L1.3782|
;;;1263   
;;;1264     /* Allocate the histogram/inverse colormap storage */
;;;1265     cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
000ec6  6860              LDR      r0,[r4,#4]
000ec8  2280              MOVS     r2,#0x80
000eca  2101              MOVS     r1,#1
000ecc  6803              LDR      r3,[r0,#0]
000ece  4620              MOV      r0,r4
000ed0  4798              BLX      r3
000ed2  61a8              STR      r0,[r5,#0x18]
;;;1266       ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
;;;1267     for (i = 0; i < HIST_C0_ELEMS; i++) {
000ed4  f04f0600          MOV      r6,#0
000ed8  e00b              B        |L1.3826|
                  |L1.3802|
;;;1268       cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
000eda  6860              LDR      r0,[r4,#4]
000edc  f44f5280          MOV      r2,#0x1000
000ee0  2101              MOVS     r1,#1
000ee2  6843              LDR      r3,[r0,#4]
000ee4  4620              MOV      r0,r4
000ee6  4798              BLX      r3
000ee8  69a9              LDR      r1,[r5,#0x18]
000eea  f8410026          STR      r0,[r1,r6,LSL #2]
000eee  f1060601          ADD      r6,r6,#1              ;1267
                  |L1.3826|
000ef2  2e20              CMP      r6,#0x20              ;1267
000ef4  dbf1              BLT      |L1.3802|
;;;1269         ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1270          HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
;;;1271     }
;;;1272     cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
000ef6  f04f0001          MOV      r0,#1
000efa  61e8              STR      r0,[r5,#0x1c]
;;;1273   
;;;1274     /* Allocate storage for the completed colormap, if required.
;;;1275      * We do this now since it is FAR storage and may affect
;;;1276      * the memory manager's space calculations.
;;;1277      */
;;;1278     if (cinfo->enable_2pass_quant) {
000efc  6ee0              LDR      r0,[r4,#0x6c]
000efe  b340              CBZ      r0,|L1.3922|
;;;1279       /* Make sure color count is acceptable */
;;;1280       int desired = cinfo->desired_number_of_colors;
000f00  6e27              LDR      r7,[r4,#0x60]
;;;1281       /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
;;;1282       if (desired < 8)
000f02  2f08              CMP      r7,#8
000f04  da0b              BGE      |L1.3870|
;;;1283         ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
000f06  f04f0038          MOV      r0,#0x38
000f0a  6821              LDR      r1,[r4,#0]
000f0c  6148              STR      r0,[r1,#0x14]
000f0e  f04f0008          MOV      r0,#8
000f12  6821              LDR      r1,[r4,#0]
000f14  6188              STR      r0,[r1,#0x18]
000f16  6820              LDR      r0,[r4,#0]
000f18  6801              LDR      r1,[r0,#0]
000f1a  4620              MOV      r0,r4
000f1c  4788              BLX      r1
                  |L1.3870|
;;;1284       /* Make sure colormap indexes can be represented by JSAMPLEs */
;;;1285       if (desired > MAXNUMCOLORS)
000f1e  f5b77f80          CMP      r7,#0x100
000f22  dd0b              BLE      |L1.3900|
;;;1286         ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
000f24  f04f0039          MOV      r0,#0x39
000f28  6821              LDR      r1,[r4,#0]
000f2a  6148              STR      r0,[r1,#0x14]
000f2c  f44f7080          MOV      r0,#0x100
000f30  6821              LDR      r1,[r4,#0]
000f32  6188              STR      r0,[r1,#0x18]
000f34  6820              LDR      r0,[r4,#0]
000f36  6801              LDR      r1,[r0,#0]
000f38  4620              MOV      r0,r4
000f3a  4788              BLX      r1
                  |L1.3900|
;;;1287       cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
000f3c  6860              LDR      r0,[r4,#4]
000f3e  2303              MOVS     r3,#3
000f40  463a              MOV      r2,r7
000f42  2101              MOVS     r1,#1
000f44  f8d0c008          LDR      r12,[r0,#8]
000f48  4620              MOV      r0,r4
000f4a  47e0              BLX      r12
000f4c  6128              STR      r0,[r5,#0x10]
;;;1288         ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
;;;1289       cquantize->desired = desired;
000f4e  616f              STR      r7,[r5,#0x14]
;;;1290     } else
000f50  e002              B        |L1.3928|
                  |L1.3922|
;;;1291       cquantize->sv_colormap = NULL;
000f52  f04f0000          MOV      r0,#0
000f56  6128              STR      r0,[r5,#0x10]
                  |L1.3928|
;;;1292   
;;;1293     /* Only F-S dithering or no dithering is supported. */
;;;1294     /* If user asks for ordered dither, give him F-S. */
;;;1295     if (cinfo->dither_mode != JDITHER_NONE)
000f58  f8940058          LDRB     r0,[r4,#0x58]
000f5c  b118              CBZ      r0,|L1.3942|
;;;1296       cinfo->dither_mode = JDITHER_FS;
000f5e  f04f0002          MOV      r0,#2
000f62  f8840058          STRB     r0,[r4,#0x58]
                  |L1.3942|
;;;1297   
;;;1298     /* Allocate Floyd-Steinberg workspace if necessary.
;;;1299      * This isn't really needed until pass 2, but again it is FAR storage.
;;;1300      * Although we will cope with a later change in dither_mode,
;;;1301      * we do not promise to honor max_memory_to_use if dither_mode changes.
;;;1302      */
;;;1303     if (cinfo->dither_mode == JDITHER_FS) {
000f66  f8940058          LDRB     r0,[r4,#0x58]
000f6a  2802              CMP      r0,#2
000f6c  d10d              BNE      |L1.3978|
;;;1304       cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
000f6e  6f20              LDR      r0,[r4,#0x70]
000f70  1c80              ADDS     r0,r0,#2
000f72  eb000040          ADD      r0,r0,r0,LSL #1
000f76  0042              LSLS     r2,r0,#1
000f78  6860              LDR      r0,[r4,#4]
000f7a  2101              MOVS     r1,#1
000f7c  6843              LDR      r3,[r0,#4]
000f7e  4620              MOV      r0,r4
000f80  4798              BLX      r3
000f82  6228              STR      r0,[r5,#0x20]
;;;1305         ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1306          (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
;;;1307       /* Might as well create the error-limiting table too. */
;;;1308       init_error_limit(cinfo);
000f84  4620              MOV      r0,r4
000f86  f7fffffe          BL       init_error_limit
                  |L1.3978|
;;;1309     }
;;;1310   }
000f8a  e8bd81f0          POP      {r4-r8,pc}
;;;1311   
                          ENDP

000f8e  0000              DCW      0x0000
                  |L1.3984|
                          DCD      prescan_quantize
                  |L1.3988|
                          DCD      finish_pass1
                  |L1.3992|
                          DCD      pass2_fs_dither
                  |L1.3996|
                          DCD      pass2_no_dither
                  |L1.4000|
                          DCD      finish_pass2
                  |L1.4004|
                          DCD      start_pass_2_quant
                  |L1.4008|
                          DCD      new_color_map_2_quant
