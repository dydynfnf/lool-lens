; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\gui_jpeg.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\gui_jpeg.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\gui_jpeg.crf GUI\JPEG\GUI_JPEG.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _InitSource PROC
;;;61     
;;;62     static void _InitSource (j_decompress_ptr cinfo) {
000000  6981              LDR      r1,[r0,#0x18]
;;;63       SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
;;;64     
;;;65       /* We reset the empty-input-file flag for each image,
;;;66        * but we don't clear the input buffer.
;;;67        * This is correct behavior for reading a series of images from one source.
;;;68        */
;;;69       pSrc->start_of_file = TRUE;
000002  f04f0201          MOV      r2,#1
000006  628a              STR      r2,[r1,#0x28]
;;;70     }
000008  4770              BX       lr
;;;71     
                          ENDP

                  _FillInputBuffer PROC
;;;104    
;;;105    static boolean _FillInputBuffer(j_decompress_ptr cinfo) {
00000a  e92d41f0          PUSH     {r4-r8,lr}
00000e  4605              MOV      r5,r0
;;;106      SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
000010  69ac              LDR      r4,[r5,#0x18]
;;;107      size_t nbytes;
;;;108      int RemBytes = pSrc->FileSize - pSrc->Off;
000012  e9d40108          LDRD     r0,r1,[r4,#0x20]
000016  eba00701          SUB      r7,r0,r1
;;;109      if (RemBytes > 0) {
00001a  2f00              CMP      r7,#0
00001c  dd0f              BLE      |L1.62|
;;;110        nbytes = (RemBytes > INPUT_BUF_SIZE) ? INPUT_BUF_SIZE : RemBytes;
00001e  f5b75f80          CMP      r7,#0x1000
000022  dd02              BLE      |L1.42|
000024  f44f5080          MOV      r0,#0x1000
000028  e000              B        |L1.44|
                  |L1.42|
00002a  4638              MOV      r0,r7
                  |L1.44|
00002c  4606              MOV      r6,r0
;;;111        pSrc->pub.next_input_byte = pSrc->pFileData + pSrc->Off;
00002e  6a61              LDR      r1,[r4,#0x24]
000030  69e0              LDR      r0,[r4,#0x1c]
000032  4408              ADD      r0,r0,r1
000034  6020              STR      r0,[r4,#0]
;;;112        pSrc->Off += nbytes;
000036  6a60              LDR      r0,[r4,#0x24]
000038  4430              ADD      r0,r0,r6
00003a  6260              STR      r0,[r4,#0x24]
00003c  e017              B        |L1.110|
                  |L1.62|
;;;113      } else {
;;;114        if (pSrc->start_of_file)	/* Treat empty input file as fatal error */
00003e  6aa0              LDR      r0,[r4,#0x28]
000040  b138              CBZ      r0,|L1.82|
;;;115          ERREXIT(cinfo, JERR_INPUT_EMPTY);
000042  f04f002a          MOV      r0,#0x2a
000046  6829              LDR      r1,[r5,#0]
000048  6148              STR      r0,[r1,#0x14]
00004a  6828              LDR      r0,[r5,#0]
00004c  6801              LDR      r1,[r0,#0]
00004e  4628              MOV      r0,r5
000050  4788              BLX      r1
                  |L1.82|
;;;116        WARNMS(cinfo, JWRN_JPEG_EOF);
000052  f04f0078          MOV      r0,#0x78
000056  6829              LDR      r1,[r5,#0]
000058  6148              STR      r0,[r1,#0x14]
00005a  6828              LDR      r0,[r5,#0]
00005c  f04f31ff          MOV      r1,#0xffffffff
000060  6842              LDR      r2,[r0,#4]
000062  4628              MOV      r0,r5
000064  4790              BLX      r2
;;;117        /* Insert a fake EOI marker */
;;;118        nbytes = 2;
000066  f04f0602          MOV      r6,#2
;;;119        pSrc->pub.next_input_byte = _abEnd;
00006a  48ae              LDR      r0,|L1.804|
00006c  6020              STR      r0,[r4,#0]
                  |L1.110|
;;;120      }
;;;121    
;;;122      pSrc->pub.bytes_in_buffer = nbytes;
00006e  6066              STR      r6,[r4,#4]
;;;123      pSrc->start_of_file = FALSE;
000070  f04f0000          MOV      r0,#0
000074  62a0              STR      r0,[r4,#0x28]
;;;124      return TRUE;
000076  f04f0001          MOV      r0,#1
;;;125    }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;126    
                          ENDP

                  _SkipInputData PROC
;;;138    
;;;139    static void _SkipInputData (j_decompress_ptr cinfo, long num_bytes) {
00007e  b570              PUSH     {r4-r6,lr}
000080  4606              MOV      r6,r0
000082  460c              MOV      r4,r1
;;;140      SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
000084  69b5              LDR      r5,[r6,#0x18]
;;;141      /* Just a dumb implementation for now.  Could use fseek() except
;;;142       * it doesn't work on pipes.  Not clear that being smart is worth
;;;143       * any trouble anyway --- large skips are infrequent.
;;;144       */
;;;145      if (num_bytes > 0) {
000086  2c00              CMP      r4,#0
000088  dd10              BLE      |L1.172|
;;;146        while (num_bytes > (long) pSrc->pub.bytes_in_buffer) {
00008a  e005              B        |L1.152|
                  |L1.140|
;;;147          num_bytes -= (long) pSrc->pub.bytes_in_buffer;
00008c  6868              LDR      r0,[r5,#4]
00008e  eba40400          SUB      r4,r4,r0
;;;148          (void) _FillInputBuffer(cinfo);
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       _FillInputBuffer
                  |L1.152|
000098  6868              LDR      r0,[r5,#4]            ;146
00009a  42a0              CMP      r0,r4                 ;146
00009c  dbf6              BLT      |L1.140|
;;;149          /* note we assume that fill_input_buffer will never return FALSE,
;;;150           * so suspension need not be handled.
;;;151           */
;;;152        }
;;;153        pSrc->pub.next_input_byte += (size_t) num_bytes;
00009e  6828              LDR      r0,[r5,#0]
0000a0  4420              ADD      r0,r0,r4
0000a2  6028              STR      r0,[r5,#0]
;;;154        pSrc->pub.bytes_in_buffer -= (size_t) num_bytes;
0000a4  6868              LDR      r0,[r5,#4]
0000a6  eba00004          SUB      r0,r0,r4
0000aa  6068              STR      r0,[r5,#4]
                  |L1.172|
;;;155      }
;;;156    }
0000ac  bd70              POP      {r4-r6,pc}
;;;157    /*
                          ENDP

                  _TermSource PROC
;;;174    
;;;175    static void _TermSource(j_decompress_ptr cinfo) {
0000ae  bf00              NOP      
;;;176      /* no work necessary here */
;;;177      GUI_USE_PARA(cinfo);
;;;178    }
0000b0  4770              BX       lr
;;;179    
                          ENDP

                  _InitSrc PROC
;;;180    
;;;181    static void _InitSrc(j_decompress_ptr cinfo, const U8* pFileData, I32 FileSize) {
0000b2  e92d41f0          PUSH     {r4-r8,lr}
0000b6  4605              MOV      r5,r0
0000b8  460e              MOV      r6,r1
0000ba  4617              MOV      r7,r2
;;;182      SOURCE_MANAGER* pSrc;
;;;183      /* The source object and input buffer are made permanent so that a series
;;;184       * of JPEG images can be read from the same file by calling jpeg_stdio_src
;;;185       * only before the first one.  (If we discarded the buffer at the end of
;;;186       * one image, we'd likely lose the start of the next one.)
;;;187       * This makes it unsafe to use this manager and a different source
;;;188       * manager serially with the same JPEG object.  Caveat programmer.
;;;189       */
;;;190      if (cinfo->src == NULL) {	/* first time for this JPEG object? */
0000bc  69a8              LDR      r0,[r5,#0x18]
0000be  b930              CBNZ     r0,|L1.206|
;;;191        cinfo->src = (jpeg_source_mgr *) (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT, sizeof(SOURCE_MANAGER));
0000c0  6868              LDR      r0,[r5,#4]
0000c2  222c              MOVS     r2,#0x2c
0000c4  2100              MOVS     r1,#0
0000c6  6803              LDR      r3,[r0,#0]
0000c8  4628              MOV      r0,r5
0000ca  4798              BLX      r3
0000cc  61a8              STR      r0,[r5,#0x18]
                  |L1.206|
;;;192      }
;;;193      pSrc = (SOURCE_MANAGER*) cinfo->src;
0000ce  69ac              LDR      r4,[r5,#0x18]
;;;194      pSrc->pub.init_source       = _InitSource;
0000d0  4895              LDR      r0,|L1.808|
0000d2  60a0              STR      r0,[r4,#8]
;;;195      pSrc->pub.fill_input_buffer = _FillInputBuffer;
0000d4  4895              LDR      r0,|L1.812|
0000d6  60e0              STR      r0,[r4,#0xc]
;;;196      pSrc->pub.skip_input_data   = _SkipInputData;
0000d8  4895              LDR      r0,|L1.816|
0000da  6120              STR      r0,[r4,#0x10]
;;;197      pSrc->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
0000dc  4895              LDR      r0,|L1.820|
0000de  6160              STR      r0,[r4,#0x14]
;;;198      pSrc->pub.term_source       = _TermSource;
0000e0  4895              LDR      r0,|L1.824|
0000e2  61a0              STR      r0,[r4,#0x18]
;;;199      pSrc->pub.bytes_in_buffer   = 0;    /* forces fill_input_buffer on first read */
0000e4  f04f0000          MOV      r0,#0
0000e8  6060              STR      r0,[r4,#4]
;;;200      pSrc->pub.next_input_byte   = NULL; /* until buffer loaded */
0000ea  6020              STR      r0,[r4,#0]
;;;201      /*
;;;202       *  Init private part of Source manager
;;;203       */
;;;204      pSrc->FileSize  = FileSize;
0000ec  6227              STR      r7,[r4,#0x20]
;;;205      pSrc->pFileData = pFileData;
0000ee  61e6              STR      r6,[r4,#0x1c]
;;;206      pSrc->Off       = 0;
0000f0  6260              STR      r0,[r4,#0x24]
;;;207    }
0000f2  e8bd81f0          POP      {r4-r8,pc}
;;;208    
                          ENDP

                  jpeg_get_small PROC
;;;223    
;;;224    GLOBAL(void *) jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject) {
0000f6  b570              PUSH     {r4-r6,lr}
0000f8  4605              MOV      r5,r0
0000fa  460c              MOV      r4,r1
;;;225      GUI_USE_PARA(cinfo);
0000fc  bf00              NOP      
;;;226      AllocCnt++;
0000fe  488f              LDR      r0,|L1.828|
000100  6800              LDR      r0,[r0,#0]  ; AllocCnt
000102  f1000001          ADD      r0,r0,#1
000106  498d              LDR      r1,|L1.828|
000108  6008              STR      r0,[r1,#0]  ; AllocCnt
;;;227      TotalSize += sizeofobject;
00010a  488d              LDR      r0,|L1.832|
00010c  6800              LDR      r0,[r0,#0]  ; TotalSize
00010e  4420              ADD      r0,r0,r4
000110  498b              LDR      r1,|L1.832|
000112  6008              STR      r0,[r1,#0]  ; TotalSize
;;;228      return (void *) malloc(sizeofobject);
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       malloc
;;;229    }
00011a  bd70              POP      {r4-r6,pc}
;;;230    
                          ENDP

                  jpeg_free_small PROC
;;;231    GLOBAL(void) jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject) {
00011c  b570              PUSH     {r4-r6,lr}
00011e  4604              MOV      r4,r0
000120  460d              MOV      r5,r1
000122  4616              MOV      r6,r2
;;;232      GUI_USE_PARA(cinfo);
000124  bf00              NOP      
;;;233      GUI_USE_PARA(sizeofobject);
000126  bf00              NOP      
;;;234      if (--AllocCnt) {
000128  4884              LDR      r0,|L1.828|
00012a  6800              LDR      r0,[r0,#0]  ; AllocCnt
00012c  1e40              SUBS     r0,r0,#1
00012e  4983              LDR      r1,|L1.828|
000130  6008              STR      r0,[r1,#0]  ; AllocCnt
000132  d003              BEQ      |L1.316|
;;;235        TotalSize = 0;
000134  f04f0000          MOV      r0,#0
000138  4981              LDR      r1,|L1.832|
00013a  6008              STR      r0,[r1,#0]  ; TotalSize
                  |L1.316|
;;;236      }
;;;237      free(object);
00013c  4628              MOV      r0,r5
00013e  f7fffffe          BL       free
;;;238    }
000142  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP

                  jpeg_mem_available PROC
;;;244    
;;;245    GLOBAL(long) jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed, long max_bytes_needed, long already_allocated) {
000144  b510              PUSH     {r4,lr}
000146  4604              MOV      r4,r0
;;;246      GUI_USE_PARA(cinfo);
000148  bf00              NOP      
;;;247      GUI_USE_PARA(min_bytes_needed);
00014a  bf00              NOP      
;;;248      GUI_USE_PARA(already_allocated);
00014c  bf00              NOP      
;;;249      return max_bytes_needed;
00014e  4610              MOV      r0,r2
;;;250    }
000150  bd10              POP      {r4,pc}
;;;251    
                          ENDP

                  jpeg_mem_init PROC
;;;258    
;;;259    GLOBAL(long) jpeg_mem_init (j_common_ptr cinfo) { 
000152  4601              MOV      r1,r0
;;;260      GUI_USE_PARA(cinfo);
000154  bf00              NOP      
;;;261      return 0;
000156  f04f0000          MOV      r0,#0
;;;262    }
00015a  4770              BX       lr
;;;263    
                          ENDP

                  jpeg_mem_term PROC
;;;264    GLOBAL(void) jpeg_mem_term (j_common_ptr cinfo) {
00015c  bf00              NOP      
;;;265      GUI_USE_PARA(cinfo);
;;;266    }
00015e  4770              BX       lr
;;;267    
                          ENDP

                  _Init PROC
;;;285    */
;;;286    static void _Init(struct jpeg_error_mgr* pjerr, struct jpeg_decompress_struct *pcinfo, const void * pFileData, int DataSize) {
000160  e92d41f0          PUSH     {r4-r8,lr}
000164  4607              MOV      r7,r0
000166  460c              MOV      r4,r1
000168  4615              MOV      r5,r2
00016a  461e              MOV      r6,r3
;;;287      /* 1. Allocate and initialize a JPEG decompression object. */
;;;288      pcinfo->err = jpeg_std_error(pjerr);
00016c  4638              MOV      r0,r7
00016e  f7fffffe          BL       jpeg_std_error
000172  6020              STR      r0,[r4,#0]
;;;289    	jpeg_create_decompress(pcinfo);
000174  f44f72e8          MOV      r2,#0x1d0
000178  213e              MOVS     r1,#0x3e
00017a  4620              MOV      r0,r4
00017c  f7fffffe          BL       jpeg_CreateDecompress
;;;290      /* 2. Init the source manager so the library can retrieve data via methods */
;;;291      _InitSrc(pcinfo, (const U8*)pFileData, DataSize);
000180  4632              MOV      r2,r6
000182  4629              MOV      r1,r5
000184  4620              MOV      r0,r4
000186  f7fffffe          BL       _InitSrc
;;;292      /* 3. Call jpeg_read_header() to obtain image info. */
;;;293    	jpeg_read_header(pcinfo, TRUE);
00018a  2101              MOVS     r1,#1
00018c  4620              MOV      r0,r4
00018e  f7fffffe          BL       jpeg_read_header
;;;294    }
000192  e8bd81f0          POP      {r4-r8,pc}
;;;295    
                          ENDP

                  _WritePixelsRGB PROC
;;;299    */
;;;300    static void _WritePixelsRGB(const U8*p, int x0, int y0, int xSize) {
000196  e92d47f0          PUSH     {r4-r10,lr}
00019a  4604              MOV      r4,r0
00019c  460e              MOV      r6,r1
00019e  4617              MOV      r7,r2
0001a0  461d              MOV      r5,r3
;;;301      U8 r,g,b;
;;;302      while (xSize) {
0001a2  e012              B        |L1.458|
                  |L1.420|
;;;303        r = *p++;
0001a4  f8148b01          LDRB     r8,[r4],#1
;;;304        g = *p++;
0001a8  f8149b01          LDRB     r9,[r4],#1
;;;305        b = *p++;
0001ac  f814ab01          LDRB     r10,[r4],#1
;;;306        LCD_SetColor(r | (g << 8) | (U32)((U32)b << 16));
0001b0  ea482109          ORR      r1,r8,r9,LSL #8
0001b4  ea41400a          ORR      r0,r1,r10,LSL #16
0001b8  f7fffffe          BL       LCD_SetColor
;;;307        LCD_DrawPixel(x0++, y0);
0001bc  4630              MOV      r0,r6
0001be  1c76              ADDS     r6,r6,#1
0001c0  4639              MOV      r1,r7
0001c2  f7fffffe          BL       LCD_DrawPixel
;;;308        xSize--;
0001c6  f1a50501          SUB      r5,r5,#1
                  |L1.458|
0001ca  2d00              CMP      r5,#0                 ;302
0001cc  d1ea              BNE      |L1.420|
;;;309      }
;;;310    }
0001ce  e8bd87f0          POP      {r4-r10,pc}
;;;311    
                          ENDP

                  _WritePixelsGray PROC
;;;315    */
;;;316    static void _WritePixelsGray(const U8*p, int x0, int y0, int xSize) {
0001d2  e92d41f0          PUSH     {r4-r8,lr}
0001d6  4604              MOV      r4,r0
0001d8  460e              MOV      r6,r1
0001da  4617              MOV      r7,r2
0001dc  461d              MOV      r5,r3
;;;317      U8 u;
;;;318      while (xSize) {
0001de  e00e              B        |L1.510|
                  |L1.480|
;;;319        u = *p++;
0001e0  f8148b01          LDRB     r8,[r4],#1
;;;320        LCD_SetColor(u * (U32)0x10101);
0001e4  eb082108          ADD      r1,r8,r8,LSL #8
0001e8  eb014008          ADD      r0,r1,r8,LSL #16
0001ec  f7fffffe          BL       LCD_SetColor
;;;321        LCD_DrawPixel(x0++, y0);
0001f0  4630              MOV      r0,r6
0001f2  1c76              ADDS     r6,r6,#1
0001f4  4639              MOV      r1,r7
0001f6  f7fffffe          BL       LCD_DrawPixel
;;;322        xSize--;
0001fa  f1a50501          SUB      r5,r5,#1
                  |L1.510|
0001fe  2d00              CMP      r5,#0                 ;318
000200  d1ee              BNE      |L1.480|
;;;323      }
;;;324    }
000202  e8bd81f0          POP      {r4-r8,pc}
;;;325    
                          ENDP

                  GUI_JPEG_GetInfo PROC
;;;335    */
;;;336    int GUI_JPEG_GetInfo(const void * pFileData, int DataSize, GUI_JPEG_INFO* pInfo) {
000206  b570              PUSH     {r4-r6,lr}
000208  f5ad7d16          SUB      sp,sp,#0x258
00020c  4605              MOV      r5,r0
00020e  460e              MOV      r6,r1
000210  4614              MOV      r4,r2
;;;337    	struct jpeg_decompress_struct cinfo;
;;;338    	struct jpeg_error_mgr jerr;
;;;339      _Init(&jerr, &cinfo, pFileData, DataSize);
000212  4633              MOV      r3,r6
000214  462a              MOV      r2,r5
000216  a922              ADD      r1,sp,#0x88
000218  a801              ADD      r0,sp,#4
00021a  f7fffffe          BL       _Init
;;;340      /*
;;;341       * Release the JPEG decompression object.
;;;342       */
;;;343      jpeg_destroy_decompress(&cinfo);
00021e  a822              ADD      r0,sp,#0x88
000220  f7fffffe          BL       jpeg_destroy_decompress
;;;344      if (pInfo) {
000224  b11c              CBZ      r4,|L1.558|
;;;345        pInfo->XSize = cinfo.image_width;
000226  9829              LDR      r0,[sp,#0xa4]
000228  6020              STR      r0,[r4,#0]
;;;346        pInfo->YSize = cinfo.image_height;
00022a  982a              LDR      r0,[sp,#0xa8]
00022c  6060              STR      r0,[r4,#4]
                  |L1.558|
;;;347      }
;;;348      return 0;
00022e  2000              MOVS     r0,#0
;;;349    }
000230  f50d7d16          ADD      sp,sp,#0x258
000234  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP

                  GUI_JPEG_Draw PROC
;;;355    */
;;;356    int GUI_JPEG_Draw(const void * pFileData, int DataSize, int x0, int y0) {
000236  e92d43f0          PUSH     {r4-r9,lr}
00023a  f5ad7d19          SUB      sp,sp,#0x264
00023e  4607              MOV      r7,r0
000240  4688              MOV      r8,r1
000242  4615              MOV      r5,r2
000244  461c              MOV      r4,r3
;;;357      #if (GUI_WINSUPPORT)
;;;358        GUI_RECT r;
;;;359      #endif
;;;360      int Ret = 0;
000246  f04f0900          MOV      r9,#0
;;;361      GUI_HMEM hBuffer = 0;
00024a  464e              MOV      r6,r9
;;;362    	struct jpeg_decompress_struct cinfo;
;;;363    	struct jpeg_error_mgr jerr;
;;;364      GUI_LOCK();
;;;365      _Init(&jerr, &cinfo, pFileData, DataSize);
00024c  4643              MOV      r3,r8
00024e  463a              MOV      r2,r7
000250  a922              ADD      r1,sp,#0x88
000252  a801              ADD      r0,sp,#4
000254  f7fffffe          BL       _Init
;;;366      #if (GUI_WINSUPPORT)
;;;367        WM_ADDORG(x0,y0);
000258  483a              LDR      r0,|L1.836|
00025a  6c00              LDR      r0,[r0,#0x40]  ; GUI_Context
00025c  4405              ADD      r5,r5,r0
00025e  4839              LDR      r0,|L1.836|
000260  6c40              LDR      r0,[r0,#0x44]  ; GUI_Context
000262  4404              ADD      r4,r4,r0
;;;368        r.x1 = (r.x0 = x0) + cinfo.image_width - 1;
000264  b228              SXTH     r0,r5
000266  f8ad0258          STRH     r0,[sp,#0x258]
00026a  9929              LDR      r1,[sp,#0xa4]
00026c  4408              ADD      r0,r0,r1
00026e  f1a00001          SUB      r0,r0,#1
000272  b200              SXTH     r0,r0
000274  f8ad025c          STRH     r0,[sp,#0x25c]
;;;369        r.y1 = (r.y0 = y0) + cinfo.image_height - 1;
000278  b220              SXTH     r0,r4
00027a  f8ad025a          STRH     r0,[sp,#0x25a]
00027e  992a              LDR      r1,[sp,#0xa8]
000280  4408              ADD      r0,r0,r1
000282  f1a00001          SUB      r0,r0,#1
000286  b200              SXTH     r0,r0
000288  f8ad025e          STRH     r0,[sp,#0x25e]
;;;370        WM_ITERATE_START(&r) {
00028c  a896              ADD      r0,sp,#0x258
00028e  f7fffffe          BL       WM__InitIVRSearch
000292  2800              CMP      r0,#0
000294  d03e              BEQ      |L1.788|
000296  bf00              NOP      
                  |L1.664|
;;;371      #endif
;;;372        if (hBuffer) {
000298  b12e              CBZ      r6,|L1.678|
;;;373          _Init(&jerr, &cinfo, pFileData, DataSize);
00029a  4643              MOV      r3,r8
00029c  463a              MOV      r2,r7
00029e  a922              ADD      r1,sp,#0x88
0002a0  a801              ADD      r0,sp,#4
0002a2  f7fffffe          BL       _Init
                  |L1.678|
;;;374        }
;;;375        /* 4. Set up parameters for decompression (optional ...) */
;;;376        /* 5. jpeg_start_decompress(...); Should normally return quickly */
;;;377    	  jpeg_start_decompress(&cinfo);
0002a6  a822              ADD      r0,sp,#0x88
0002a8  f7fffffe          BL       jpeg_start_decompress
;;;378        /* 6. while (scan lines remain to be read) */
;;;379    	  /*     jpeg_read_scanlines(...); */
;;;380        if (!hBuffer) {
0002ac  b936              CBNZ     r6,|L1.700|
;;;381          hBuffer = GUI_ALLOC_AllocNoInit(cinfo.image_width * 3);
0002ae  9929              LDR      r1,[sp,#0xa4]
0002b0  eb010141          ADD      r1,r1,r1,LSL #1
0002b4  b208              SXTH     r0,r1
0002b6  f7fffffe          BL       GUI_ALLOC_AllocNoInit
0002ba  4606              MOV      r6,r0
                  |L1.700|
;;;382        }
;;;383        while (cinfo.output_scanline < cinfo.output_height) {
0002bc  e01c              B        |L1.760|
                  |L1.702|
;;;384          U8* p;
;;;385          p = (U8*)GUI_ALLOC_h2p(hBuffer);
0002be  4630              MOV      r0,r6
0002c0  f7fffffe          BL       GUI_ALLOC_h2p
0002c4  9000              STR      r0,[sp,#0]
;;;386          jpeg_read_scanlines(&cinfo, &p, 1);
0002c6  2201              MOVS     r2,#1
0002c8  4669              MOV      r1,sp
0002ca  a822              ADD      r0,sp,#0x88
0002cc  f7fffffe          BL       jpeg_read_scanlines
;;;387          if (cinfo.jpeg_color_space == JCS_GRAYSCALE) {
0002d0  f89d00b0          LDRB     r0,[sp,#0xb0]
0002d4  2801              CMP      r0,#1
0002d6  d107              BNE      |L1.744|
;;;388            _WritePixelsGray(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
0002d8  9845              LDR      r0,[sp,#0x114]
0002da  1902              ADDS     r2,r0,r4
0002dc  4629              MOV      r1,r5
0002de  9b29              LDR      r3,[sp,#0xa4]
0002e0  9800              LDR      r0,[sp,#0]
0002e2  f7fffffe          BL       _WritePixelsGray
0002e6  e006              B        |L1.758|
                  |L1.744|
;;;389          } else {
;;;390            _WritePixelsRGB(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
0002e8  9845              LDR      r0,[sp,#0x114]
0002ea  1902              ADDS     r2,r0,r4
0002ec  4629              MOV      r1,r5
0002ee  9b29              LDR      r3,[sp,#0xa4]
0002f0  9800              LDR      r0,[sp,#0]
0002f2  f7fffffe          BL       _WritePixelsRGB
                  |L1.758|
;;;391          }
;;;392        }
0002f6  bf00              NOP      
                  |L1.760|
0002f8  993f              LDR      r1,[sp,#0xfc]         ;383
0002fa  9845              LDR      r0,[sp,#0x114]        ;383
0002fc  4288              CMP      r0,r1                 ;383
0002fe  d3de              BCC      |L1.702|
;;;393        /* 7. jpeg_finish_decompress(...); */
;;;394        /*    Complete the decompression cycle.  This causes working memory associated */
;;;395        /*    with the JPEG object to be released. */
;;;396    	  jpeg_finish_decompress(&cinfo);
000300  a822              ADD      r0,sp,#0x88
000302  f7fffffe          BL       jpeg_finish_decompress
;;;397        /* 8. Release the JPEG decompression object. */
;;;398        jpeg_destroy_decompress(&cinfo);
000306  a822              ADD      r0,sp,#0x88
000308  f7fffffe          BL       jpeg_destroy_decompress
;;;399      #if (GUI_WINSUPPORT)
;;;400        } WM_ITERATE_END();
00030c  f7fffffe          BL       WM__GetNextIVR
000310  2800              CMP      r0,#0
000312  d1c1              BNE      |L1.664|
                  |L1.788|
;;;401      #endif
;;;402      GUI_ALLOC_Free(hBuffer);
000314  4630              MOV      r0,r6
000316  f7fffffe          BL       GUI_ALLOC_Free
;;;403      GUI_UNLOCK();
;;;404      return Ret;
00031a  4648              MOV      r0,r9
;;;405    }
00031c  f50d7d19          ADD      sp,sp,#0x264
000320  e8bd83f0          POP      {r4-r9,pc}
;;;406    
                          ENDP

                  |L1.804|
                          DCD      _abEnd
                  |L1.808|
                          DCD      _InitSource
                  |L1.812|
                          DCD      _FillInputBuffer
                  |L1.816|
                          DCD      _SkipInputData
                  |L1.820|
                          DCD      jpeg_resync_to_restart
                  |L1.824|
                          DCD      _TermSource
                  |L1.828|
                          DCD      AllocCnt
                  |L1.832|
                          DCD      TotalSize
                  |L1.836|
                          DCD      GUI_Context

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _abEnd
000000  ffd9              DCB      0xff,0xd9

                          AREA ||.data||, DATA, ALIGN=2

                  AllocCnt
                          DCD      0x00000000
                  TotalSize
                          DCD      0x00000000
