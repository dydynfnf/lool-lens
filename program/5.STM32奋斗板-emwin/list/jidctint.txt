; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jidctint.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jidctint.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jidctint.crf GUI\JPEG\jidctint.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  jpeg_idct_islow PROC
;;;147    GLOBAL(void)
;;;148    jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;149    		 JCOEFPTR coef_block,
;;;150    		 JSAMPARRAY output_buf, JDIMENSION output_col)
;;;151    {
000004  b0c8              SUB      sp,sp,#0x120
;;;152      INT32 tmp0, tmp1, tmp2, tmp3;
;;;153      INT32 tmp10, tmp11, tmp12, tmp13;
;;;154      INT32 z1, z2, z3, z4, z5;
;;;155      JCOEFPTR inptr;
;;;156      ISLOW_MULT_TYPE * quantptr;
;;;157      int * wsptr;
;;;158      JSAMPROW outptr;
;;;159      JSAMPLE *range_limit = IDCT_range_limit(cinfo);
000006  f8ddb120          LDR      r11,[sp,#0x120]
00000a  f8dbb144          LDR      r11,[r11,#0x144]
00000e  f10b0b80          ADD      r11,r11,#0x80
000012  f8cdb108          STR      r11,[sp,#0x108]
;;;160      int ctr;
;;;161      int workspace[DCTSIZE2];	/* buffers data between passes */
;;;162      SHIFT_TEMPS
;;;163    
;;;164      /* Pass 1: process columns from input, store into work array. */
;;;165      /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
;;;166      /* furthermore, we scale the results by 2**PASS1_BITS. */
;;;167    
;;;168      inptr = coef_block;
000016  994a              LDR      r1,[sp,#0x128]
;;;169      quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
000018  f8ddb124          LDR      r11,[sp,#0x124]
00001c  f8db8050          LDR      r8,[r11,#0x50]
;;;170      wsptr = workspace;
000020  a801              ADD      r0,sp,#4
;;;171      for (ctr = DCTSIZE; ctr > 0; ctr--) {
000022  f04f0b08          MOV      r11,#8
000026  f8cdb104          STR      r11,[sp,#0x104]
00002a  e148              B        |L1.702|
                  |L1.44|
;;;172        /* Due to quantization, we will usually find that many of the input
;;;173         * coefficients are zero, especially the AC terms.  We can exploit this
;;;174         * by short-circuiting the IDCT calculation for any column in which all
;;;175         * the AC terms are zero.  In that case each output is equal to the
;;;176         * DC coefficient (with scale factor as needed).
;;;177         * With typical images and quantization tables, half or more of the
;;;178         * column DCT calculations can be simplified this way.
;;;179         */
;;;180        
;;;181        if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
00002c  f8b1b010          LDRH     r11,[r1,#0x10]
000030  f1bb0f00          CMP      r11,#0
000034  d14e              BNE      |L1.212|
000036  f8b1b020          LDRH     r11,[r1,#0x20]
00003a  f1bb0f00          CMP      r11,#0
00003e  d149              BNE      |L1.212|
;;;182    	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
000040  f8b1b030          LDRH     r11,[r1,#0x30]
000044  f1bb0f00          CMP      r11,#0
000048  d144              BNE      |L1.212|
00004a  f8b1b040          LDRH     r11,[r1,#0x40]
00004e  f1bb0f00          CMP      r11,#0
000052  d13f              BNE      |L1.212|
;;;183    	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
000054  f8b1b050          LDRH     r11,[r1,#0x50]
000058  f1bb0f00          CMP      r11,#0
00005c  d13a              BNE      |L1.212|
00005e  f8b1b060          LDRH     r11,[r1,#0x60]
000062  f1bb0f00          CMP      r11,#0
000066  d135              BNE      |L1.212|
;;;184    	inptr[DCTSIZE*7] == 0) {
000068  f8b1b070          LDRH     r11,[r1,#0x70]
00006c  f1bb0f00          CMP      r11,#0
000070  d130              BNE      |L1.212|
;;;185          /* AC terms all zero */
;;;186          int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
000072  f9b1b000          LDRSH    r11,[r1,#0]
000076  f8d8e000          LDR      lr,[r8,#0]
00007a  fb0bfb0e          MUL      r11,r11,lr
00007e  ea4f0b8b          LSL      r11,r11,#2
000082  f8cdb000          STR      r11,[sp,#0]
;;;187          
;;;188          wsptr[DCTSIZE*0] = dcval;
000086  f8ddb000          LDR      r11,[sp,#0]
00008a  f8c0b000          STR      r11,[r0,#0]
;;;189          wsptr[DCTSIZE*1] = dcval;
00008e  f8ddb000          LDR      r11,[sp,#0]
000092  f8c0b020          STR      r11,[r0,#0x20]
;;;190          wsptr[DCTSIZE*2] = dcval;
000096  f8ddb000          LDR      r11,[sp,#0]
00009a  f8c0b040          STR      r11,[r0,#0x40]
;;;191          wsptr[DCTSIZE*3] = dcval;
00009e  f8ddb000          LDR      r11,[sp,#0]
0000a2  f8c0b060          STR      r11,[r0,#0x60]
;;;192          wsptr[DCTSIZE*4] = dcval;
0000a6  f8ddb000          LDR      r11,[sp,#0]
0000aa  f8c0b080          STR      r11,[r0,#0x80]
;;;193          wsptr[DCTSIZE*5] = dcval;
0000ae  f8ddb000          LDR      r11,[sp,#0]
0000b2  f8c0b0a0          STR      r11,[r0,#0xa0]
;;;194          wsptr[DCTSIZE*6] = dcval;
0000b6  f8ddb000          LDR      r11,[sp,#0]
0000ba  f8c0b0c0          STR      r11,[r0,#0xc0]
;;;195          wsptr[DCTSIZE*7] = dcval;
0000be  f8ddb000          LDR      r11,[sp,#0]
0000c2  f8c0b0e0          STR      r11,[r0,#0xe0]
;;;196          
;;;197          inptr++;			/* advance pointers to next column */
0000c6  f1010102          ADD      r1,r1,#2
;;;198          quantptr++;
0000ca  f1080804          ADD      r8,r8,#4
;;;199          wsptr++;
0000ce  f1000004          ADD      r0,r0,#4
;;;200          continue;
0000d2  e0ee              B        |L1.690|
                  |L1.212|
;;;201        }
;;;202        
;;;203        /* Even part: reverse the even part of the forward DCT. */
;;;204        /* The rotator is sqrt(2)*c(-6). */
;;;205        
;;;206        z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
0000d4  f9b1b020          LDRSH    r11,[r1,#0x20]
0000d8  f8d8e040          LDR      lr,[r8,#0x40]
0000dc  fb0bfc0e          MUL      r12,r11,lr
;;;207        z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
0000e0  f9b1b060          LDRSH    r11,[r1,#0x60]
0000e4  f8d8e0c0          LDR      lr,[r8,#0xc0]
0000e8  fb0bf70e          MUL      r7,r11,lr
;;;208        
;;;209        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
0000ec  eb0c0b07          ADD      r11,r12,r7
0000f0  f2411e51          MOV      lr,#0x1151
0000f4  fb0bf90e          MUL      r9,r11,lr
;;;210        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
0000f8  f8dfb484          LDR      r11,|L1.1408|
0000fc  fb0b9507          MLA      r5,r11,r7,r9
;;;211        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
000100  f6404b3f          MOV      r11,#0xc3f
000104  fb0cfb0b          MUL      r11,r12,r11
000108  eb09064b          ADD      r6,r9,r11,LSL #1
;;;212        
;;;213        z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
00010c  f9b1b000          LDRSH    r11,[r1,#0]
000110  f8d8e000          LDR      lr,[r8,#0]
000114  fb0bfc0e          MUL      r12,r11,lr
;;;214        z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
000118  f9b1b040          LDRSH    r11,[r1,#0x40]
00011c  f8d8e080          LDR      lr,[r8,#0x80]
000120  fb0bf70e          MUL      r7,r11,lr
;;;215    
;;;216        tmp0 = (z2 + z3) << CONST_BITS;
000124  eb0c0b07          ADD      r11,r12,r7
000128  ea4f334b          LSL      r3,r11,#13
;;;217        tmp1 = (z2 - z3) << CONST_BITS;
00012c  ebac0b07          SUB      r11,r12,r7
000130  ea4f344b          LSL      r4,r11,#13
;;;218        
;;;219        tmp10 = tmp0 + tmp3;
000134  eb030b06          ADD      r11,r3,r6
000138  f8cdb11c          STR      r11,[sp,#0x11c]
;;;220        tmp13 = tmp0 - tmp3;
00013c  eba30b06          SUB      r11,r3,r6
000140  f8cdb110          STR      r11,[sp,#0x110]
;;;221        tmp11 = tmp1 + tmp2;
000144  eb040b05          ADD      r11,r4,r5
000148  f8cdb118          STR      r11,[sp,#0x118]
;;;222        tmp12 = tmp1 - tmp2;
00014c  eba40b05          SUB      r11,r4,r5
000150  f8cdb114          STR      r11,[sp,#0x114]
;;;223        
;;;224        /* Odd part per figure 8; the matrix is unitary and hence its
;;;225         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
;;;226         */
;;;227        
;;;228        tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
000154  f9b1b070          LDRSH    r11,[r1,#0x70]
000158  f8d8e0e0          LDR      lr,[r8,#0xe0]
00015c  fb0bf30e          MUL      r3,r11,lr
;;;229        tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
000160  f9b1b050          LDRSH    r11,[r1,#0x50]
000164  f8d8e0a0          LDR      lr,[r8,#0xa0]
000168  fb0bf40e          MUL      r4,r11,lr
;;;230        tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
00016c  f9b1b030          LDRSH    r11,[r1,#0x30]
000170  f8d8e060          LDR      lr,[r8,#0x60]
000174  fb0bf50e          MUL      r5,r11,lr
;;;231        tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
000178  f9b1b010          LDRSH    r11,[r1,#0x10]
00017c  f8d8e020          LDR      lr,[r8,#0x20]
000180  fb0bf60e          MUL      r6,r11,lr
;;;232        
;;;233        z1 = tmp0 + tmp3;
000184  eb030906          ADD      r9,r3,r6
;;;234        z2 = tmp1 + tmp2;
000188  eb040c05          ADD      r12,r4,r5
;;;235        z3 = tmp0 + tmp2;
00018c  eb030705          ADD      r7,r3,r5
;;;236        z4 = tmp1 + tmp3;
000190  eb040a06          ADD      r10,r4,r6
;;;237        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
000194  eb070b0a          ADD      r11,r7,r10
000198  f2425ea1          MOV      lr,#0x25a1
00019c  fb0bfb0e          MUL      r11,r11,lr
0001a0  f8cdb10c          STR      r11,[sp,#0x10c]
;;;238        
;;;239        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
0001a4  f6401b8e          MOV      r11,#0x98e
0001a8  fb03f30b          MUL      r3,r3,r11
;;;240        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
0001ac  f2441bb3          MOV      r11,#0x41b3
0001b0  fb04f40b          MUL      r4,r4,r11
;;;241        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
0001b4  f2462b54          MOV      r11,#0x6254
0001b8  fb05f50b          MUL      r5,r5,r11
;;;242        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
0001bc  f2430b0b          MOV      r11,#0x300b
0001c0  fb06f60b          MUL      r6,r6,r11
;;;243        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
0001c4  f8dfb3bc          LDR      r11,|L1.1412|
0001c8  fb09f90b          MUL      r9,r9,r11
;;;244        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
0001cc  f8dfb3b8          LDR      r11,|L1.1416|
0001d0  fb0cfc0b          MUL      r12,r12,r11
;;;245        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
0001d4  eba72b07          SUB      r11,r7,r7,LSL #8
0001d8  ebcb1b8b          RSB      r11,r11,r11,LSL #6
0001dc  ebab0787          SUB      r7,r11,r7,LSL #2
;;;246        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
0001e0  f8dfb3a8          LDR      r11,|L1.1420|
0001e4  fb0afa0b          MUL      r10,r10,r11
;;;247        
;;;248        z3 += z5;
0001e8  f8ddb10c          LDR      r11,[sp,#0x10c]
0001ec  445f              ADD      r7,r7,r11
;;;249        z4 += z5;
0001ee  f8ddb10c          LDR      r11,[sp,#0x10c]
0001f2  44da              ADD      r10,r10,r11
;;;250        
;;;251        tmp0 += z1 + z3;
0001f4  eb090b07          ADD      r11,r9,r7
0001f8  445b              ADD      r3,r3,r11
;;;252        tmp1 += z2 + z4;
0001fa  eb0c0b0a          ADD      r11,r12,r10
0001fe  445c              ADD      r4,r4,r11
;;;253        tmp2 += z2 + z3;
000200  eb0c0b07          ADD      r11,r12,r7
000204  445d              ADD      r5,r5,r11
;;;254        tmp3 += z1 + z4;
000206  eb090b0a          ADD      r11,r9,r10
00020a  445e              ADD      r6,r6,r11
;;;255        
;;;256        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
;;;257        
;;;258        wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
00020c  f8ddb11c          LDR      r11,[sp,#0x11c]
000210  44b3              ADD      r11,r11,r6
000212  f50b6b80          ADD      r11,r11,#0x400
000216  ea4f2beb          ASR      r11,r11,#11
00021a  f8c0b000          STR      r11,[r0,#0]
;;;259        wsptr[DCTSIZE*7] = (int) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
00021e  f8ddb11c          LDR      r11,[sp,#0x11c]
000222  ebab0b06          SUB      r11,r11,r6
000226  f50b6b80          ADD      r11,r11,#0x400
00022a  ea4f2beb          ASR      r11,r11,#11
00022e  f8c0b0e0          STR      r11,[r0,#0xe0]
;;;260        wsptr[DCTSIZE*1] = (int) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
000232  f8ddb118          LDR      r11,[sp,#0x118]
000236  44ab              ADD      r11,r11,r5
000238  f50b6b80          ADD      r11,r11,#0x400
00023c  ea4f2beb          ASR      r11,r11,#11
000240  f8c0b020          STR      r11,[r0,#0x20]
;;;261        wsptr[DCTSIZE*6] = (int) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
000244  f8ddb118          LDR      r11,[sp,#0x118]
000248  ebab0b05          SUB      r11,r11,r5
00024c  f50b6b80          ADD      r11,r11,#0x400
000250  ea4f2beb          ASR      r11,r11,#11
000254  f8c0b0c0          STR      r11,[r0,#0xc0]
;;;262        wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
000258  f8ddb114          LDR      r11,[sp,#0x114]
00025c  44a3              ADD      r11,r11,r4
00025e  f50b6b80          ADD      r11,r11,#0x400
000262  ea4f2beb          ASR      r11,r11,#11
000266  f8c0b040          STR      r11,[r0,#0x40]
;;;263        wsptr[DCTSIZE*5] = (int) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
00026a  f8ddb114          LDR      r11,[sp,#0x114]
00026e  ebab0b04          SUB      r11,r11,r4
000272  f50b6b80          ADD      r11,r11,#0x400
000276  ea4f2beb          ASR      r11,r11,#11
00027a  f8c0b0a0          STR      r11,[r0,#0xa0]
;;;264        wsptr[DCTSIZE*3] = (int) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
00027e  f8ddb110          LDR      r11,[sp,#0x110]
000282  449b              ADD      r11,r11,r3
000284  f50b6b80          ADD      r11,r11,#0x400
000288  ea4f2beb          ASR      r11,r11,#11
00028c  f8c0b060          STR      r11,[r0,#0x60]
;;;265        wsptr[DCTSIZE*4] = (int) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
000290  f8ddb110          LDR      r11,[sp,#0x110]
000294  ebab0b03          SUB      r11,r11,r3
000298  f50b6b80          ADD      r11,r11,#0x400
00029c  ea4f2beb          ASR      r11,r11,#11
0002a0  f8c0b080          STR      r11,[r0,#0x80]
;;;266        
;;;267        inptr++;			/* advance pointers to next column */
0002a4  f1010102          ADD      r1,r1,#2
;;;268        quantptr++;
0002a8  f1080804          ADD      r8,r8,#4
;;;269        wsptr++;
0002ac  f1000004          ADD      r0,r0,#4
0002b0  bf00              NOP                            ;200
                  |L1.690|
0002b2  f8ddb104          LDR      r11,[sp,#0x104]       ;171
0002b6  f1ab0b01          SUB      r11,r11,#1            ;171
0002ba  f8cdb104          STR      r11,[sp,#0x104]       ;171
                  |L1.702|
0002be  f8ddb104          LDR      r11,[sp,#0x104]       ;171
0002c2  f1bb0f00          CMP      r11,#0                ;171
0002c6  f73faeb1          BGT      |L1.44|
;;;270      }
;;;271      
;;;272      /* Pass 2: process rows from work array, store into output array. */
;;;273      /* Note that we must descale the results by a factor of 8 == 2**3, */
;;;274      /* and also undo the PASS1_BITS scaling. */
;;;275    
;;;276      wsptr = workspace;
0002ca  a801              ADD      r0,sp,#4
;;;277      for (ctr = 0; ctr < DCTSIZE; ctr++) {
0002cc  f04f0b00          MOV      r11,#0
0002d0  f8cdb104          STR      r11,[sp,#0x104]
0002d4  e14a              B        |L1.1388|
                  |L1.726|
;;;278        outptr = output_buf[ctr] + output_col;
0002d6  f8dde104          LDR      lr,[sp,#0x104]
0002da  f8ddb12c          LDR      r11,[sp,#0x12c]
0002de  f85be02e          LDR      lr,[r11,lr,LSL #2]
0002e2  f8ddb154          LDR      r11,[sp,#0x154]
0002e6  eb0e020b          ADD      r2,lr,r11
;;;279        /* Rows of zeroes can be exploited in the same way as we did with columns.
;;;280         * However, the column calculation has created many nonzero AC terms, so
;;;281         * the simplification applies less often (typically 5% to 10% of the time).
;;;282         * On machines with very fast multiplication, it's possible that the
;;;283         * test takes more time than it's worth.  In that case this section
;;;284         * may be commented out.
;;;285         */
;;;286        
;;;287    #ifndef NO_ZERO_ROW_TEST
;;;288        if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
0002ea  f8d0b004          LDR      r11,[r0,#4]
0002ee  f1bb0f00          CMP      r11,#0
0002f2  d14c              BNE      |L1.910|
0002f4  f8d0b008          LDR      r11,[r0,#8]
0002f8  f1bb0f00          CMP      r11,#0
0002fc  d147              BNE      |L1.910|
0002fe  f8d0b00c          LDR      r11,[r0,#0xc]
000302  f1bb0f00          CMP      r11,#0
000306  d142              BNE      |L1.910|
000308  f8d0b010          LDR      r11,[r0,#0x10]
00030c  f1bb0f00          CMP      r11,#0
000310  d13d              BNE      |L1.910|
;;;289    	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
000312  f8d0b014          LDR      r11,[r0,#0x14]
000316  f1bb0f00          CMP      r11,#0
00031a  d138              BNE      |L1.910|
00031c  f8d0b018          LDR      r11,[r0,#0x18]
000320  f1bb0f00          CMP      r11,#0
000324  d133              BNE      |L1.910|
000326  f8d0b01c          LDR      r11,[r0,#0x1c]
00032a  f1bb0f00          CMP      r11,#0
00032e  d12e              BNE      |L1.910|
;;;290          /* AC terms all zero */
;;;291          JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
000330  f8d0b000          LDR      r11,[r0,#0]
000334  f10b0b10          ADD      r11,r11,#0x10
000338  f3cb1e49          UBFX     lr,r11,#5,#10
00033c  f8ddb108          LDR      r11,[sp,#0x108]
000340  f81bb00e          LDRB     r11,[r11,lr]
000344  f8cdb000          STR      r11,[sp,#0]
;;;292    				  & RANGE_MASK];
;;;293          
;;;294          outptr[0] = dcval;
000348  f8ddb000          LDR      r11,[sp,#0]
00034c  f882b000          STRB     r11,[r2,#0]
;;;295          outptr[1] = dcval;
000350  f8ddb000          LDR      r11,[sp,#0]
000354  f882b001          STRB     r11,[r2,#1]
;;;296          outptr[2] = dcval;
000358  f8ddb000          LDR      r11,[sp,#0]
00035c  f882b002          STRB     r11,[r2,#2]
;;;297          outptr[3] = dcval;
000360  f8ddb000          LDR      r11,[sp,#0]
000364  f882b003          STRB     r11,[r2,#3]
;;;298          outptr[4] = dcval;
000368  f8ddb000          LDR      r11,[sp,#0]
00036c  f882b004          STRB     r11,[r2,#4]
;;;299          outptr[5] = dcval;
000370  f8ddb000          LDR      r11,[sp,#0]
000374  f882b005          STRB     r11,[r2,#5]
;;;300          outptr[6] = dcval;
000378  f8ddb000          LDR      r11,[sp,#0]
00037c  f882b006          STRB     r11,[r2,#6]
;;;301          outptr[7] = dcval;
000380  f8ddb000          LDR      r11,[sp,#0]
000384  f882b007          STRB     r11,[r2,#7]
;;;302    
;;;303          wsptr += DCTSIZE;		/* advance pointer to next row */
000388  f1000020          ADD      r0,r0,#0x20
;;;304          continue;
00038c  e0e8              B        |L1.1376|
                  |L1.910|
;;;305        }
;;;306    #endif
;;;307        
;;;308        /* Even part: reverse the even part of the forward DCT. */
;;;309        /* The rotator is sqrt(2)*c(-6). */
;;;310        
;;;311        z2 = (INT32) wsptr[2];
00038e  f8d0c008          LDR      r12,[r0,#8]
;;;312        z3 = (INT32) wsptr[6];
000392  6987              LDR      r7,[r0,#0x18]
;;;313        
;;;314        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
000394  eb0c0b07          ADD      r11,r12,r7
000398  f2411e51          MOV      lr,#0x1151
00039c  fb0bf90e          MUL      r9,r11,lr
;;;315        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
0003a0  f8dfb1dc          LDR      r11,|L1.1408|
0003a4  fb0b9507          MLA      r5,r11,r7,r9
;;;316        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
0003a8  f6404b3f          MOV      r11,#0xc3f
0003ac  fb0cfb0b          MUL      r11,r12,r11
0003b0  eb09064b          ADD      r6,r9,r11,LSL #1
;;;317        
;;;318        tmp0 = ((INT32) wsptr[0] + (INT32) wsptr[4]) << CONST_BITS;
0003b4  f8d0e010          LDR      lr,[r0,#0x10]
0003b8  f8d0b000          LDR      r11,[r0,#0]
0003bc  44f3              ADD      r11,r11,lr
0003be  ea4f334b          LSL      r3,r11,#13
;;;319        tmp1 = ((INT32) wsptr[0] - (INT32) wsptr[4]) << CONST_BITS;
0003c2  f8d0e010          LDR      lr,[r0,#0x10]
0003c6  f8d0b000          LDR      r11,[r0,#0]
0003ca  ebab0b0e          SUB      r11,r11,lr
0003ce  ea4f344b          LSL      r4,r11,#13
;;;320        
;;;321        tmp10 = tmp0 + tmp3;
0003d2  eb030b06          ADD      r11,r3,r6
0003d6  f8cdb11c          STR      r11,[sp,#0x11c]
;;;322        tmp13 = tmp0 - tmp3;
0003da  eba30b06          SUB      r11,r3,r6
0003de  f8cdb110          STR      r11,[sp,#0x110]
;;;323        tmp11 = tmp1 + tmp2;
0003e2  eb040b05          ADD      r11,r4,r5
0003e6  f8cdb118          STR      r11,[sp,#0x118]
;;;324        tmp12 = tmp1 - tmp2;
0003ea  eba40b05          SUB      r11,r4,r5
0003ee  f8cdb114          STR      r11,[sp,#0x114]
;;;325        
;;;326        /* Odd part per figure 8; the matrix is unitary and hence its
;;;327         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
;;;328         */
;;;329        
;;;330        tmp0 = (INT32) wsptr[7];
0003f2  69c3              LDR      r3,[r0,#0x1c]
;;;331        tmp1 = (INT32) wsptr[5];
0003f4  6944              LDR      r4,[r0,#0x14]
;;;332        tmp2 = (INT32) wsptr[3];
0003f6  68c5              LDR      r5,[r0,#0xc]
;;;333        tmp3 = (INT32) wsptr[1];
0003f8  6846              LDR      r6,[r0,#4]
;;;334        
;;;335        z1 = tmp0 + tmp3;
0003fa  eb030906          ADD      r9,r3,r6
;;;336        z2 = tmp1 + tmp2;
0003fe  eb040c05          ADD      r12,r4,r5
;;;337        z3 = tmp0 + tmp2;
000402  eb030705          ADD      r7,r3,r5
;;;338        z4 = tmp1 + tmp3;
000406  eb040a06          ADD      r10,r4,r6
;;;339        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
00040a  eb070b0a          ADD      r11,r7,r10
00040e  f2425ea1          MOV      lr,#0x25a1
000412  fb0bfb0e          MUL      r11,r11,lr
000416  f8cdb10c          STR      r11,[sp,#0x10c]
;;;340        
;;;341        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
00041a  f6401b8e          MOV      r11,#0x98e
00041e  fb03f30b          MUL      r3,r3,r11
;;;342        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
000422  f2441bb3          MOV      r11,#0x41b3
000426  fb04f40b          MUL      r4,r4,r11
;;;343        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
00042a  f2462b54          MOV      r11,#0x6254
00042e  fb05f50b          MUL      r5,r5,r11
;;;344        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
000432  f2430b0b          MOV      r11,#0x300b
000436  fb06f60b          MUL      r6,r6,r11
;;;345        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
00043a  f8dfb148          LDR      r11,|L1.1412|
00043e  fb09f90b          MUL      r9,r9,r11
;;;346        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
000442  f8dfb144          LDR      r11,|L1.1416|
000446  fb0cfc0b          MUL      r12,r12,r11
;;;347        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
00044a  eba72b07          SUB      r11,r7,r7,LSL #8
00044e  ebcb1b8b          RSB      r11,r11,r11,LSL #6
000452  ebab0787          SUB      r7,r11,r7,LSL #2
;;;348        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
000456  f8dfb134          LDR      r11,|L1.1420|
00045a  fb0afa0b          MUL      r10,r10,r11
;;;349        
;;;350        z3 += z5;
00045e  f8ddb10c          LDR      r11,[sp,#0x10c]
000462  445f              ADD      r7,r7,r11
;;;351        z4 += z5;
000464  f8ddb10c          LDR      r11,[sp,#0x10c]
000468  44da              ADD      r10,r10,r11
;;;352        
;;;353        tmp0 += z1 + z3;
00046a  eb090b07          ADD      r11,r9,r7
00046e  445b              ADD      r3,r3,r11
;;;354        tmp1 += z2 + z4;
000470  eb0c0b0a          ADD      r11,r12,r10
000474  445c              ADD      r4,r4,r11
;;;355        tmp2 += z2 + z3;
000476  eb0c0b07          ADD      r11,r12,r7
00047a  445d              ADD      r5,r5,r11
;;;356        tmp3 += z1 + z4;
00047c  eb090b0a          ADD      r11,r9,r10
000480  445e              ADD      r6,r6,r11
;;;357        
;;;358        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
;;;359        
;;;360        outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp3,
000482  f8ddb11c          LDR      r11,[sp,#0x11c]
000486  44b3              ADD      r11,r11,r6
000488  f50b3b00          ADD      r11,r11,#0x20000
00048c  f3cb4e89          UBFX     lr,r11,#18,#10
000490  f8ddb108          LDR      r11,[sp,#0x108]
000494  f81bb00e          LDRB     r11,[r11,lr]
000498  f882b000          STRB     r11,[r2,#0]
;;;361    					  CONST_BITS+PASS1_BITS+3)
;;;362    			    & RANGE_MASK];
;;;363        outptr[7] = range_limit[(int) DESCALE(tmp10 - tmp3,
00049c  f8ddb11c          LDR      r11,[sp,#0x11c]
0004a0  ebab0b06          SUB      r11,r11,r6
0004a4  f50b3b00          ADD      r11,r11,#0x20000
0004a8  f3cb4e89          UBFX     lr,r11,#18,#10
0004ac  f8ddb108          LDR      r11,[sp,#0x108]
0004b0  f81bb00e          LDRB     r11,[r11,lr]
0004b4  f882b007          STRB     r11,[r2,#7]
;;;364    					  CONST_BITS+PASS1_BITS+3)
;;;365    			    & RANGE_MASK];
;;;366        outptr[1] = range_limit[(int) DESCALE(tmp11 + tmp2,
0004b8  f8ddb118          LDR      r11,[sp,#0x118]
0004bc  44ab              ADD      r11,r11,r5
0004be  f50b3b00          ADD      r11,r11,#0x20000
0004c2  f3cb4e89          UBFX     lr,r11,#18,#10
0004c6  f8ddb108          LDR      r11,[sp,#0x108]
0004ca  f81bb00e          LDRB     r11,[r11,lr]
0004ce  f882b001          STRB     r11,[r2,#1]
;;;367    					  CONST_BITS+PASS1_BITS+3)
;;;368    			    & RANGE_MASK];
;;;369        outptr[6] = range_limit[(int) DESCALE(tmp11 - tmp2,
0004d2  f8ddb118          LDR      r11,[sp,#0x118]
0004d6  ebab0b05          SUB      r11,r11,r5
0004da  f50b3b00          ADD      r11,r11,#0x20000
0004de  f3cb4e89          UBFX     lr,r11,#18,#10
0004e2  f8ddb108          LDR      r11,[sp,#0x108]
0004e6  f81bb00e          LDRB     r11,[r11,lr]
0004ea  f882b006          STRB     r11,[r2,#6]
;;;370    					  CONST_BITS+PASS1_BITS+3)
;;;371    			    & RANGE_MASK];
;;;372        outptr[2] = range_limit[(int) DESCALE(tmp12 + tmp1,
0004ee  f8ddb114          LDR      r11,[sp,#0x114]
0004f2  44a3              ADD      r11,r11,r4
0004f4  f50b3b00          ADD      r11,r11,#0x20000
0004f8  f3cb4e89          UBFX     lr,r11,#18,#10
0004fc  f8ddb108          LDR      r11,[sp,#0x108]
000500  f81bb00e          LDRB     r11,[r11,lr]
000504  f882b002          STRB     r11,[r2,#2]
;;;373    					  CONST_BITS+PASS1_BITS+3)
;;;374    			    & RANGE_MASK];
;;;375        outptr[5] = range_limit[(int) DESCALE(tmp12 - tmp1,
000508  f8ddb114          LDR      r11,[sp,#0x114]
00050c  ebab0b04          SUB      r11,r11,r4
000510  f50b3b00          ADD      r11,r11,#0x20000
000514  f3cb4e89          UBFX     lr,r11,#18,#10
000518  f8ddb108          LDR      r11,[sp,#0x108]
00051c  f81bb00e          LDRB     r11,[r11,lr]
000520  f882b005          STRB     r11,[r2,#5]
;;;376    					  CONST_BITS+PASS1_BITS+3)
;;;377    			    & RANGE_MASK];
;;;378        outptr[3] = range_limit[(int) DESCALE(tmp13 + tmp0,
000524  f8ddb110          LDR      r11,[sp,#0x110]
000528  449b              ADD      r11,r11,r3
00052a  f50b3b00          ADD      r11,r11,#0x20000
00052e  f3cb4e89          UBFX     lr,r11,#18,#10
000532  f8ddb108          LDR      r11,[sp,#0x108]
000536  f81bb00e          LDRB     r11,[r11,lr]
00053a  f882b003          STRB     r11,[r2,#3]
;;;379    					  CONST_BITS+PASS1_BITS+3)
;;;380    			    & RANGE_MASK];
;;;381        outptr[4] = range_limit[(int) DESCALE(tmp13 - tmp0,
00053e  f8ddb110          LDR      r11,[sp,#0x110]
000542  ebab0b03          SUB      r11,r11,r3
000546  f50b3b00          ADD      r11,r11,#0x20000
00054a  f3cb4e89          UBFX     lr,r11,#18,#10
00054e  f8ddb108          LDR      r11,[sp,#0x108]
000552  f81bb00e          LDRB     r11,[r11,lr]
000556  f882b004          STRB     r11,[r2,#4]
;;;382    					  CONST_BITS+PASS1_BITS+3)
;;;383    			    & RANGE_MASK];
;;;384        
;;;385        wsptr += DCTSIZE;		/* advance pointer to next row */
00055a  f1000020          ADD      r0,r0,#0x20
00055e  bf00              NOP                            ;304
                  |L1.1376|
000560  f8ddb104          LDR      r11,[sp,#0x104]       ;277
000564  f10b0b01          ADD      r11,r11,#1            ;277
000568  f8cdb104          STR      r11,[sp,#0x104]       ;277
                  |L1.1388|
00056c  f8ddb104          LDR      r11,[sp,#0x104]       ;277
000570  f1bb0f08          CMP      r11,#8                ;277
000574  f6ffaeaf          BLT      |L1.726|
;;;386      }
;;;387    }
000578  b04c              ADD      sp,sp,#0x130
00057a  e8bd8ff0          POP      {r4-r11,pc}
;;;388    
                          ENDP

00057e  0000              DCW      0x0000
                  |L1.1408|
                          DCD      0xffffc4df
                  |L1.1412|
                          DCD      0xffffe333
                  |L1.1416|
                          DCD      0xffffadfd
                  |L1.1420|
                          DCD      0xfffff384
