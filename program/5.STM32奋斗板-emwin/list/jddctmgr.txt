; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jddctmgr.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jddctmgr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jddctmgr.crf GUI\JPEG\jddctmgr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  start_pass PROC
;;;87     
;;;88     METHODDEF(void) start_pass (j_decompress_ptr cinfo) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4604              MOV      r4,r0
;;;89       my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
000006  f8d491c0          LDR      r9,[r4,#0x1c0]
;;;90       int ci, i;
;;;91       jpeg_component_info *compptr;
;;;92       int method = 0;
00000a  f04f0a00          MOV      r10,#0
;;;93       inverse_DCT_method_ptr method_ptr = NULL;
00000e  46d3              MOV      r11,r10
;;;94       JQUANT_TBL * qtbl;
;;;95     
;;;96       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++, compptr++) {
000010  4657              MOV      r7,r10
000012  f8d460d8          LDR      r6,[r4,#0xd8]
000016  e079              B        |L1.268|
                  |L1.24|
;;;97         /* Select the proper IDCT routine for this component's scaling */
;;;98         switch (compptr->DCT_scaled_size) {
000018  6a70              LDR      r0,[r6,#0x24]
00001a  2808              CMP      r0,#8
00001c  d11a              BNE      |L1.84|
;;;99     #ifdef IDCT_SCALING_SUPPORTED
;;;100        case 1:
;;;101          method_ptr = jpeg_idct_1x1;
;;;102          method = JDCT_ISLOW;	/* jidctred uses islow-style table */
;;;103          break;
;;;104        case 2:
;;;105          method_ptr = jpeg_idct_2x2;
;;;106          method = JDCT_ISLOW;	/* jidctred uses islow-style table */
;;;107          break;
;;;108        case 4:
;;;109          method_ptr = jpeg_idct_4x4;
;;;110          method = JDCT_ISLOW;	/* jidctred uses islow-style table */
;;;111          break;
;;;112    #endif
;;;113        case DCTSIZE:
;;;114          switch (cinfo->dct_method) {
00001e  f8940048          LDRB     r0,[r4,#0x48]
000022  b110              CBZ      r0,|L1.42|
000024  2801              CMP      r0,#1
000026  d10a              BNE      |L1.62|
000028  e004              B        |L1.52|
                  |L1.42|
;;;115    #ifdef DCT_ISLOW_SUPPORTED
;;;116          case JDCT_ISLOW:
;;;117    	method_ptr = jpeg_idct_islow;
00002a  f8dfb14c          LDR      r11,|L1.376|
;;;118    	method = JDCT_ISLOW;
00002e  f04f0a00          MOV      r10,#0
;;;119    	break;
000032  e00d              B        |L1.80|
                  |L1.52|
;;;120    #endif
;;;121    #ifdef DCT_IFAST_SUPPORTED
;;;122          case JDCT_IFAST:
;;;123    	method_ptr = jpeg_idct_ifast;
000034  f8dfb144          LDR      r11,|L1.380|
;;;124    	method = JDCT_IFAST;
000038  f04f0a01          MOV      r10,#1
;;;125    	break;
00003c  e008              B        |L1.80|
                  |L1.62|
;;;126    #endif
;;;127    #ifdef DCT_FLOAT_SUPPORTED
;;;128          case JDCT_FLOAT:
;;;129    	method_ptr = jpeg_idct_float;
;;;130    	method = JDCT_FLOAT;
;;;131    	break;
;;;132    #endif
;;;133          default:
;;;134    	ERREXIT(cinfo, JERR_NOT_COMPILED);
00003e  f04f0030          MOV      r0,#0x30
000042  6821              LDR      r1,[r4,#0]
000044  6148              STR      r0,[r1,#0x14]
000046  6820              LDR      r0,[r4,#0]
000048  6801              LDR      r1,[r0,#0]
00004a  4620              MOV      r0,r4
00004c  4788              BLX      r1
;;;135    	break;
00004e  bf00              NOP      
                  |L1.80|
000050  bf00              NOP                            ;119
;;;136          }
;;;137          break;
000052  e00b              B        |L1.108|
                  |L1.84|
;;;138        default:
;;;139          ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);
000054  f04f0007          MOV      r0,#7
000058  6821              LDR      r1,[r4,#0]
00005a  6148              STR      r0,[r1,#0x14]
00005c  6a70              LDR      r0,[r6,#0x24]
00005e  6821              LDR      r1,[r4,#0]
000060  6188              STR      r0,[r1,#0x18]
000062  6820              LDR      r0,[r4,#0]
000064  6801              LDR      r1,[r0,#0]
000066  4620              MOV      r0,r4
000068  4788              BLX      r1
;;;140          break;
00006a  bf00              NOP      
                  |L1.108|
00006c  bf00              NOP                            ;137
;;;141        }
;;;142        idct->pub.inverse_DCT[ci] = method_ptr;
00006e  f1090004          ADD      r0,r9,#4
000072  f840b027          STR      r11,[r0,r7,LSL #2]
;;;143        /* Create multiplier table from quant table.
;;;144         * However, we can skip this if the component is uninteresting
;;;145         * or if we already built the table.  Also, if no quant table
;;;146         * has yet been saved for the component, we leave the
;;;147         * multiplier table all-zero; we'll be reading zeroes from the
;;;148         * coefficient controller's buffer anyway.
;;;149         */
;;;150        if (! compptr->component_needed || idct->cur_method[ci] == method)
000076  6b30              LDR      r0,[r6,#0x30]
000078  b128              CBZ      r0,|L1.134|
00007a  f1090014          ADD      r0,r9,#0x14
00007e  f8500027          LDR      r0,[r0,r7,LSL #2]
000082  4550              CMP      r0,r10
000084  d100              BNE      |L1.136|
                  |L1.134|
;;;151          continue;
000086  e03d              B        |L1.260|
                  |L1.136|
;;;152        qtbl = compptr->quant_table;
000088  f8d6804c          LDR      r8,[r6,#0x4c]
;;;153        if (qtbl == NULL)		/* happens if no data yet for component */
00008c  f1b80f00          CMP      r8,#0
000090  d100              BNE      |L1.148|
;;;154          continue;
000092  e037              B        |L1.260|
                  |L1.148|
;;;155        idct->cur_method[ci] = method;
000094  f1090014          ADD      r0,r9,#0x14
000098  f840a027          STR      r10,[r0,r7,LSL #2]
;;;156        switch (method) {
00009c  f1ba0f00          CMP      r10,#0
0000a0  d003              BEQ      |L1.170|
0000a2  f1ba0f01          CMP      r10,#1
0000a6  d122              BNE      |L1.238|
0000a8  e00c              B        |L1.196|
                  |L1.170|
;;;157    #ifdef PROVIDE_ISLOW_TABLES
;;;158        case JDCT_ISLOW:
;;;159          {
;;;160    	/* For LL&M IDCT method, multipliers are equal to raw quantization
;;;161    	 * coefficients, but are stored as ints to ensure access efficiency.
;;;162    	 */
;;;163    	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
0000aa  6d30              LDR      r0,[r6,#0x50]
;;;164    	for (i = 0; i < DCTSIZE2; i++) {
0000ac  f04f0500          MOV      r5,#0
0000b0  e005              B        |L1.190|
                  |L1.178|
;;;165    	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
0000b2  f8381015          LDRH     r1,[r8,r5,LSL #1]
0000b6  f8401025          STR      r1,[r0,r5,LSL #2]
0000ba  f1050501          ADD      r5,r5,#1              ;164
                  |L1.190|
0000be  2d40              CMP      r5,#0x40              ;164
0000c0  dbf7              BLT      |L1.178|
;;;166    	}
;;;167          }
;;;168          break;
0000c2  e01d              B        |L1.256|
                  |L1.196|
;;;169    #endif
;;;170    #ifdef DCT_IFAST_SUPPORTED
;;;171        case JDCT_IFAST:
;;;172          {
;;;173    	/* For AA&N IDCT method, multipliers are equal to quantization
;;;174    	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
;;;175    	 *   scalefactor[0] = 1
;;;176    	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
;;;177    	 * For integer operation, the multiplier table is to be scaled by
;;;178    	 * IFAST_SCALE_BITS.
;;;179    	 */
;;;180    	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
0000c4  6d30              LDR      r0,[r6,#0x50]
;;;181    #define CONST_BITS 14
;;;182    	static const INT16 aanscales[DCTSIZE2] = {
;;;183    	  /* precomputed values scaled up by 14 bits */
;;;184    	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
;;;185    	  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
;;;186    	  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
;;;187    	  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
;;;188    	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
;;;189    	  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
;;;190    	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
;;;191    	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
;;;192    	};
;;;193    	SHIFT_TEMPS
;;;194    
;;;195    	for (i = 0; i < DCTSIZE2; i++) {
0000c6  f04f0500          MOV      r5,#0
0000ca  e00d              B        |L1.232|
                  |L1.204|
;;;196    	  ifmtbl[i] = (IFAST_MULT_TYPE)
0000cc  f8381015          LDRH     r1,[r8,r5,LSL #1]
0000d0  4a2b              LDR      r2,|L1.384|
0000d2  f9322015          LDRSH    r2,[r2,r5,LSL #1]
0000d6  4351              MULS     r1,r2,r1
0000d8  f5016100          ADD      r1,r1,#0x800
0000dc  ea4f3121          ASR      r1,r1,#12
0000e0  f8401025          STR      r1,[r0,r5,LSL #2]
0000e4  f1050501          ADD      r5,r5,#1              ;195
                  |L1.232|
0000e8  2d40              CMP      r5,#0x40              ;195
0000ea  dbef              BLT      |L1.204|
;;;197    	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
;;;198    				  (INT32) aanscales[i]),
;;;199    		    CONST_BITS-IFAST_SCALE_BITS);
;;;200    	}
;;;201          }
;;;202          break;
0000ec  e008              B        |L1.256|
                  |L1.238|
;;;203    #endif
;;;204    #ifdef DCT_FLOAT_SUPPORTED
;;;205        case JDCT_FLOAT:
;;;206          {
;;;207    	/* For float AA&N IDCT method, multipliers are equal to quantization
;;;208    	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
;;;209    	 *   scalefactor[0] = 1
;;;210    	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
;;;211    	 */
;;;212    	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
;;;213    	int row, col;
;;;214    	static const double aanscalefactor[DCTSIZE] = {
;;;215    	  1.0, 1.387039845, 1.306562965, 1.175875602,
;;;216    	  1.0, 0.785694958, 0.541196100, 0.275899379
;;;217    	};
;;;218    
;;;219    	i = 0;
;;;220    	for (row = 0; row < DCTSIZE; row++) {
;;;221    	  for (col = 0; col < DCTSIZE; col++) {
;;;222    	    fmtbl[i] = (FLOAT_MULT_TYPE)
;;;223    	      ((double) qtbl->quantval[i] *
;;;224    	       aanscalefactor[row] * aanscalefactor[col]);
;;;225    	    i++;
;;;226    	  }
;;;227    	}
;;;228          }
;;;229          break;
;;;230    #endif
;;;231        default:
;;;232          ERREXIT(cinfo, JERR_NOT_COMPILED);
0000ee  f04f0030          MOV      r0,#0x30
0000f2  6821              LDR      r1,[r4,#0]
0000f4  6148              STR      r0,[r1,#0x14]
0000f6  6820              LDR      r0,[r4,#0]
0000f8  6801              LDR      r1,[r0,#0]
0000fa  4620              MOV      r0,r4
0000fc  4788              BLX      r1
;;;233          break;
0000fe  bf00              NOP      
                  |L1.256|
000100  bf00              NOP                            ;168
000102  bf00              NOP                            ;151
                  |L1.260|
000104  f1070701          ADD      r7,r7,#1              ;96
000108  f1060654          ADD      r6,r6,#0x54           ;96
                  |L1.268|
00010c  6a60              LDR      r0,[r4,#0x24]         ;96
00010e  42b8              CMP      r0,r7                 ;96
000110  dc82              BGT      |L1.24|
;;;234        }
;;;235      }
;;;236    }
000112  e8bd9ff0          POP      {r4-r12,pc}
;;;237    
                          ENDP

                  jinit_inverse_dct PROC
;;;243    GLOBAL(void)
;;;244    jinit_inverse_dct (j_decompress_ptr cinfo)
000116  e92d41f0          PUSH     {r4-r8,lr}
;;;245    {
00011a  4604              MOV      r4,r0
;;;246      my_idct_ptr idct;
;;;247      int ci;
;;;248      jpeg_component_info *compptr;
;;;249    
;;;250      idct = (my_idct_ptr)
00011c  6860              LDR      r0,[r4,#4]
00011e  f04f0224          MOV      r2,#0x24
000122  f04f0101          MOV      r1,#1
000126  6803              LDR      r3,[r0,#0]
000128  4620              MOV      r0,r4
00012a  4798              BLX      r3
00012c  4605              MOV      r5,r0
;;;251        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;252    				SIZEOF(my_idct_controller));
;;;253      cinfo->idct = (struct jpeg_inverse_dct *) idct;
00012e  f8c451c0          STR      r5,[r4,#0x1c0]
;;;254      idct->pub.start_pass = start_pass;
000132  4814              LDR      r0,|L1.388|
000134  6028              STR      r0,[r5,#0]
;;;255    
;;;256      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000136  f04f0600          MOV      r6,#0
00013a  f8d470d8          LDR      r7,[r4,#0xd8]
00013e  e016              B        |L1.366|
                  |L1.320|
;;;257           ci++, compptr++) {
;;;258        /* Allocate and pre-zero a multiplier table for each component */
;;;259        compptr->dct_table =
000140  6860              LDR      r0,[r4,#4]
000142  f44f7280          MOV      r2,#0x100
000146  2101              MOVS     r1,#1
000148  6803              LDR      r3,[r0,#0]
00014a  4620              MOV      r0,r4
00014c  4798              BLX      r3
00014e  6538              STR      r0,[r7,#0x50]
;;;260          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;261    				  SIZEOF(multiplier_table));
;;;262        MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
000150  f44f7180          MOV      r1,#0x100
000154  6d38              LDR      r0,[r7,#0x50]
000156  f7fffffe          BL       __aeabi_memclr
;;;263        /* Mark multiplier table not yet set up for any method */
;;;264        idct->cur_method[ci] = -1;
00015a  f04f31ff          MOV      r1,#0xffffffff
00015e  f1050014          ADD      r0,r5,#0x14
000162  f8401026          STR      r1,[r0,r6,LSL #2]
000166  f1060601          ADD      r6,r6,#1              ;257
00016a  f1070754          ADD      r7,r7,#0x54           ;257
                  |L1.366|
00016e  6a60              LDR      r0,[r4,#0x24]         ;256
000170  42b0              CMP      r0,r6                 ;256
000172  dce5              BGT      |L1.320|
;;;265      }
;;;266    }
000174  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L1.376|
                          DCD      jpeg_idct_islow
                  |L1.380|
                          DCD      jpeg_idct_ifast
                  |L1.384|
                          DCD      aanscales
                  |L1.388|
                          DCD      start_pass

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  aanscales
000000  400058c5          DCW      0x4000,0x58c5
000004  539f4b42          DCW      0x539f,0x4b42
000008  40003249          DCW      0x4000,0x3249
00000c  22a311a8          DCW      0x22a3,0x11a8
000010  58c57b21          DCW      0x58c5,0x7b21
000014  73fc6862          DCW      0x73fc,0x6862
000018  58c545bf          DCW      0x58c5,0x45bf
00001c  300b187e          DCW      0x300b,0x187e
000020  539f73fc          DCW      0x539f,0x73fc
000024  6d416254          DCW      0x6d41,0x6254
000028  539f41b3          DCW      0x539f,0x41b3
00002c  2d411712          DCW      0x2d41,0x1712
000030  4b426862          DCW      0x4b42,0x6862
000034  6254587e          DCW      0x6254,0x587e
000038  4b423b21          DCW      0x4b42,0x3b21
00003c  28ba14c3          DCW      0x28ba,0x14c3
000040  400058c5          DCW      0x4000,0x58c5
000044  539f4b42          DCW      0x539f,0x4b42
000048  40003249          DCW      0x4000,0x3249
00004c  22a311a8          DCW      0x22a3,0x11a8
000050  324945bf          DCW      0x3249,0x45bf
000054  41b33b21          DCW      0x41b3,0x3b21
000058  32492782          DCW      0x3249,0x2782
00005c  1b370de0          DCW      0x1b37,0x0de0
000060  22a3300b          DCW      0x22a3,0x300b
000064  2d4128ba          DCW      0x2d41,0x28ba
000068  22a31b37          DCW      0x22a3,0x1b37
00006c  12bf098e          DCW      0x12bf,0x098e
000070  11a8187e          DCW      0x11a8,0x187e
000074  171214c3          DCW      0x1712,0x14c3
000078  11a80de0          DCW      0x11a8,0x0de0
00007c  098e04df          DCW      0x098e,0x04df
