; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdmerge.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdmerge.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdmerge.crf GUI\JPEG\jdmerge.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  build_ycc_rgb_table PROC
;;;82     LOCAL(void)
;;;83     build_ycc_rgb_table (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {
000004  4605              MOV      r5,r0
;;;85       my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
000006  f8d541c4          LDR      r4,[r5,#0x1c4]
;;;86       int i;
;;;87       INT32 x;
;;;88       SHIFT_TEMPS
;;;89     
;;;90       upsample->Cr_r_tab = (int *)
00000a  6868              LDR      r0,[r5,#4]
00000c  f44f6280          MOV      r2,#0x400
000010  f04f0101          MOV      r1,#1
000014  6803              LDR      r3,[r0,#0]
000016  4628              MOV      r0,r5
000018  4798              BLX      r3
00001a  6120              STR      r0,[r4,#0x10]
;;;91         (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;92     				(MAXJSAMPLE+1) * SIZEOF(int));
;;;93       upsample->Cb_b_tab = (int *)
00001c  6868              LDR      r0,[r5,#4]
00001e  f44f6280          MOV      r2,#0x400
000022  2101              MOVS     r1,#1
000024  6803              LDR      r3,[r0,#0]
000026  4628              MOV      r0,r5
000028  4798              BLX      r3
00002a  6160              STR      r0,[r4,#0x14]
;;;94         (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;95     				(MAXJSAMPLE+1) * SIZEOF(int));
;;;96       upsample->Cr_g_tab = (INT32 *)
00002c  6868              LDR      r0,[r5,#4]
00002e  f44f6280          MOV      r2,#0x400
000032  2101              MOVS     r1,#1
000034  6803              LDR      r3,[r0,#0]
000036  4628              MOV      r0,r5
000038  4798              BLX      r3
00003a  61a0              STR      r0,[r4,#0x18]
;;;97         (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;98     				(MAXJSAMPLE+1) * SIZEOF(INT32));
;;;99       upsample->Cb_g_tab = (INT32 *)
00003c  6868              LDR      r0,[r5,#4]
00003e  f44f6280          MOV      r2,#0x400
000042  2101              MOVS     r1,#1
000044  6803              LDR      r3,[r0,#0]
000046  4628              MOV      r0,r5
000048  4798              BLX      r3
00004a  61e0              STR      r0,[r4,#0x1c]
;;;100        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;101    				(MAXJSAMPLE+1) * SIZEOF(INT32));
;;;102    
;;;103      for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
00004c  f04f0600          MOV      r6,#0
000050  f06f077f          MVN      r7,#0x7f
000054  e025              B        |L1.162|
                  |L1.86|
;;;104        /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
;;;105        /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
;;;106        /* Cr=>R value is nearest int to 1.40200 * x */
;;;107        upsample->Cr_r_tab[i] = (int)
000056  49fe              LDR      r1,|L1.1104|
000058  fb07f001          MUL      r0,r7,r1
00005c  f5004000          ADD      r0,r0,#0x8000
000060  ea4f4020          ASR      r0,r0,#16
000064  6921              LDR      r1,[r4,#0x10]
000066  f8410026          STR      r0,[r1,r6,LSL #2]
;;;108    		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
;;;109        /* Cb=>B value is nearest int to 1.77200 * x */
;;;110        upsample->Cb_b_tab[i] = (int)
00006a  49fa              LDR      r1,|L1.1108|
00006c  fb07f001          MUL      r0,r7,r1
000070  f5004000          ADD      r0,r0,#0x8000
000074  ea4f4020          ASR      r0,r0,#16
000078  6961              LDR      r1,[r4,#0x14]
00007a  f8410026          STR      r0,[r1,r6,LSL #2]
;;;111    		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
;;;112        /* Cr=>G value is scaled-up -0.71414 * x */
;;;113        upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
00007e  48f6              LDR      r0,|L1.1112|
000080  fb07f000          MUL      r0,r7,r0
000084  69a1              LDR      r1,[r4,#0x18]
000086  f8410026          STR      r0,[r1,r6,LSL #2]
;;;114        /* Cb=>G value is scaled-up -0.34414 * x */
;;;115        /* We also add in ONE_HALF so that need not do it in inner loop */
;;;116        upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
00008a  49f4              LDR      r1,|L1.1116|
00008c  fb07f001          MUL      r0,r7,r1
000090  f5004000          ADD      r0,r0,#0x8000
000094  69e1              LDR      r1,[r4,#0x1c]
000096  f8410026          STR      r0,[r1,r6,LSL #2]
00009a  f1060601          ADD      r6,r6,#1              ;103
00009e  f1070701          ADD      r7,r7,#1              ;103
                  |L1.162|
0000a2  2eff              CMP      r6,#0xff              ;103
0000a4  ddd7              BLE      |L1.86|
;;;117      }
;;;118    }
0000a6  e8bd81f0          POP      {r4-r8,pc}
;;;119    
                          ENDP

                  start_pass_merged_upsample PROC
;;;125    METHODDEF(void)
;;;126    start_pass_merged_upsample (j_decompress_ptr cinfo)
0000aa  f8d011c4          LDR      r1,[r0,#0x1c4]
;;;127    {
;;;128      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
;;;129    
;;;130      /* Mark the spare buffer empty */
;;;131      upsample->spare_full = FALSE;
0000ae  f04f0200          MOV      r2,#0
0000b2  624a              STR      r2,[r1,#0x24]
;;;132      /* Initialize total-height counter for detecting bottom of image */
;;;133      upsample->rows_to_go = cinfo->output_height;
0000b4  6f42              LDR      r2,[r0,#0x74]
0000b6  62ca              STR      r2,[r1,#0x2c]
;;;134    }
0000b8  4770              BX       lr
;;;135    
                          ENDP

                  merged_2v_upsample PROC
;;;143    METHODDEF(void)
;;;144    merged_2v_upsample (j_decompress_ptr cinfo,
0000ba  e92d4fff          PUSH     {r0-r11,lr}
;;;145    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;146    		    JDIMENSION in_row_groups_avail,
;;;147    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;148    		    JDIMENSION out_rows_avail)
;;;149    /* 2:1 vertical sampling case: may need a spare row. */
;;;150    {
0000be  b085              SUB      sp,sp,#0x14
0000c0  4682              MOV      r10,r0
0000c2  4617              MOV      r7,r2
0000c4  469b              MOV      r11,r3
0000c6  e9dd6913          LDRD     r6,r9,[sp,#0x4c]
0000ca  f8dd8048          LDR      r8,[sp,#0x48]
;;;151      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
0000ce  f8da41c4          LDR      r4,[r10,#0x1c4]
;;;152      JSAMPROW work_ptrs[2];
;;;153      JDIMENSION num_rows;		/* number of rows returned to caller */
;;;154    
;;;155      GUI_USE_PARA(in_row_groups_avail);
0000d2  bf00              NOP      
;;;156      if (upsample->spare_full) {
0000d4  6a60              LDR      r0,[r4,#0x24]
0000d6  b190              CBZ      r0,|L1.254|
;;;157        /* If we have a spare row saved from a previous cycle, just return it. */
;;;158        jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
0000d8  2101              MOVS     r1,#1
0000da  6aa0              LDR      r0,[r4,#0x28]
0000dc  e9cd1000          STRD     r1,r0,[sp,#0]
0000e0  6830              LDR      r0,[r6,#0]
0000e2  eb080280          ADD      r2,r8,r0,LSL #2
0000e6  2300              MOVS     r3,#0
0000e8  4619              MOV      r1,r3
0000ea  f1040020          ADD      r0,r4,#0x20
0000ee  f7fffffe          BL       jcopy_sample_rows
;;;159    		      1, upsample->out_row_width);
;;;160        num_rows = 1;
0000f2  f04f0501          MOV      r5,#1
;;;161        upsample->spare_full = FALSE;
0000f6  f04f0000          MOV      r0,#0
0000fa  6260              STR      r0,[r4,#0x24]
0000fc  e024              B        |L1.328|
                  |L1.254|
;;;162      } else {
;;;163        /* Figure number of rows to return to caller. */
;;;164        num_rows = 2;
0000fe  f04f0502          MOV      r5,#2
;;;165        /* Not more than the distance to the end of the image. */
;;;166        if (num_rows > upsample->rows_to_go)
000102  6ae0              LDR      r0,[r4,#0x2c]
000104  42a8              CMP      r0,r5
000106  d200              BCS      |L1.266|
;;;167          num_rows = upsample->rows_to_go;
000108  6ae5              LDR      r5,[r4,#0x2c]
                  |L1.266|
;;;168        /* And not more than what the client can accept: */
;;;169        out_rows_avail -= *out_row_ctr;
00010a  6830              LDR      r0,[r6,#0]
00010c  eba90900          SUB      r9,r9,r0
;;;170        if (num_rows > out_rows_avail)
000110  454d              CMP      r5,r9
000112  d900              BLS      |L1.278|
;;;171          num_rows = out_rows_avail;
000114  464d              MOV      r5,r9
                  |L1.278|
;;;172        /* Create output pointer array for upsampler. */
;;;173        work_ptrs[0] = output_buf[*out_row_ctr];
000116  6830              LDR      r0,[r6,#0]
000118  f8580020          LDR      r0,[r8,r0,LSL #2]
00011c  9003              STR      r0,[sp,#0xc]
;;;174        if (num_rows > 1) {
00011e  2d01              CMP      r5,#1
000120  d906              BLS      |L1.304|
;;;175          work_ptrs[1] = output_buf[*out_row_ctr + 1];
000122  6830              LDR      r0,[r6,#0]
000124  f1000001          ADD      r0,r0,#1
000128  f8580020          LDR      r0,[r8,r0,LSL #2]
00012c  9004              STR      r0,[sp,#0x10]
00012e  e004              B        |L1.314|
                  |L1.304|
;;;176        } else {
;;;177          work_ptrs[1] = upsample->spare_row;
000130  6a20              LDR      r0,[r4,#0x20]
000132  9004              STR      r0,[sp,#0x10]
;;;178          upsample->spare_full = TRUE;
000134  f04f0001          MOV      r0,#1
000138  6260              STR      r0,[r4,#0x24]
                  |L1.314|
;;;179        }
;;;180        /* Now do the upsampling. */
;;;181        (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
00013a  683a              LDR      r2,[r7,#0]
00013c  ab03              ADD      r3,sp,#0xc
00013e  f8d4c00c          LDR      r12,[r4,#0xc]
000142  4650              MOV      r0,r10
000144  9906              LDR      r1,[sp,#0x18]
000146  47e0              BLX      r12
                  |L1.328|
;;;182      }
;;;183    
;;;184      /* Adjust counts */
;;;185      *out_row_ctr += num_rows;
000148  6830              LDR      r0,[r6,#0]
00014a  4428              ADD      r0,r0,r5
00014c  6030              STR      r0,[r6,#0]
;;;186      upsample->rows_to_go -= num_rows;
00014e  6ae0              LDR      r0,[r4,#0x2c]
000150  eba00005          SUB      r0,r0,r5
000154  62e0              STR      r0,[r4,#0x2c]
;;;187      /* When the buffer is emptied, declare this input row group consumed */
;;;188      if (! upsample->spare_full)
000156  6a60              LDR      r0,[r4,#0x24]
000158  b918              CBNZ     r0,|L1.354|
;;;189        (*in_row_group_ctr)++;
00015a  6838              LDR      r0,[r7,#0]
00015c  f1000001          ADD      r0,r0,#1
000160  6038              STR      r0,[r7,#0]
                  |L1.354|
;;;190    }
000162  b009              ADD      sp,sp,#0x24
000164  e8bd8ff0          POP      {r4-r11,pc}
;;;191    
                          ENDP

                  merged_1v_upsample PROC
;;;193    METHODDEF(void)
;;;194    merged_1v_upsample (j_decompress_ptr cinfo,
000168  e92d5ff0          PUSH     {r4-r12,lr}
;;;195    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;196    		    JDIMENSION in_row_groups_avail,
;;;197    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;198    		    JDIMENSION out_rows_avail)
;;;199    /* 1:1 vertical sampling case: much easier, never need a spare row. */
;;;200    {
00016c  4606              MOV      r6,r0
00016e  468b              MOV      r11,r1
000170  4614              MOV      r4,r2
000172  461f              MOV      r7,r3
000174  e9dd590b          LDRD     r5,r9,[sp,#0x2c]
000178  f8dd8028          LDR      r8,[sp,#0x28]
;;;201      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
00017c  f8d6a1c4          LDR      r10,[r6,#0x1c4]
;;;202    
;;;203      GUI_USE_PARA(out_rows_avail);
000180  bf00              NOP      
;;;204      GUI_USE_PARA(in_row_groups_avail);
000182  bf00              NOP      
;;;205      /* Just do the upsampling. */
;;;206      (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
000184  6828              LDR      r0,[r5,#0]
000186  eb080380          ADD      r3,r8,r0,LSL #2
00018a  6822              LDR      r2,[r4,#0]
00018c  4659              MOV      r1,r11
00018e  4630              MOV      r0,r6
000190  f8dac00c          LDR      r12,[r10,#0xc]
000194  47e0              BLX      r12
;;;207    			 output_buf + *out_row_ctr);
;;;208      /* Adjust counts */
;;;209      (*out_row_ctr)++;
000196  6828              LDR      r0,[r5,#0]
000198  f1000001          ADD      r0,r0,#1
00019c  6028              STR      r0,[r5,#0]
;;;210      (*in_row_group_ctr)++;
00019e  6820              LDR      r0,[r4,#0]
0001a0  f1000001          ADD      r0,r0,#1
0001a4  6020              STR      r0,[r4,#0]
;;;211    }
0001a6  e8bd9ff0          POP      {r4-r12,pc}
;;;212    
                          ENDP

                  h2v1_merged_upsample PROC
;;;228    METHODDEF(void)
;;;229    h2v1_merged_upsample (j_decompress_ptr cinfo,
0001aa  e92d4fff          PUSH     {r0-r11,lr}
;;;230    		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
;;;231    		      JSAMPARRAY output_buf)
;;;232    {
0001ae  b087              SUB      sp,sp,#0x1c
0001b0  4604              MOV      r4,r0
0001b2  4617              MOV      r7,r2
;;;233      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
0001b4  f8d4c1c4          LDR      r12,[r4,#0x1c4]
;;;234      register int y, cred, cgreen, cblue;
;;;235      int cb, cr;
;;;236      register JSAMPROW outptr;
;;;237      JSAMPROW inptr0, inptr1, inptr2;
;;;238      JDIMENSION col;
;;;239      /* copy these pointers into registers if possible */
;;;240      register JSAMPLE * range_limit = cinfo->sample_range_limit;
0001b8  f8d42144          LDR      r2,[r4,#0x144]
;;;241      int * Crrtab = upsample->Cr_r_tab;
0001bc  f8dcb010          LDR      r11,[r12,#0x10]
0001c0  f8cdb00c          STR      r11,[sp,#0xc]
;;;242      int * Cbbtab = upsample->Cb_b_tab;
0001c4  f8dcb014          LDR      r11,[r12,#0x14]
0001c8  f8cdb008          STR      r11,[sp,#8]
;;;243      INT32 * Crgtab = upsample->Cr_g_tab;
0001cc  f8dcb018          LDR      r11,[r12,#0x18]
0001d0  f8cdb004          STR      r11,[sp,#4]
;;;244      INT32 * Cbgtab = upsample->Cb_g_tab;
0001d4  f8dcb01c          LDR      r11,[r12,#0x1c]
0001d8  f8cdb000          STR      r11,[sp,#0]
;;;245      SHIFT_TEMPS
;;;246    
;;;247      inptr0 = input_buf[0][in_row_group_ctr];
0001dc  f8ddb020          LDR      r11,[sp,#0x20]
0001e0  f8dbb000          LDR      r11,[r11,#0]
0001e4  f85b6027          LDR      r6,[r11,r7,LSL #2]
;;;248      inptr1 = input_buf[1][in_row_group_ctr];
0001e8  f8ddb020          LDR      r11,[sp,#0x20]
0001ec  f8dbb004          LDR      r11,[r11,#4]
0001f0  f85bb027          LDR      r11,[r11,r7,LSL #2]
0001f4  f8cdb018          STR      r11,[sp,#0x18]
;;;249      inptr2 = input_buf[2][in_row_group_ctr];
0001f8  f8ddb020          LDR      r11,[sp,#0x20]
0001fc  f8dbb008          LDR      r11,[r11,#8]
000200  f85bb027          LDR      r11,[r11,r7,LSL #2]
000204  f8cdb014          STR      r11,[sp,#0x14]
;;;250      outptr = output_buf[0];
000208  f8ddb028          LDR      r11,[sp,#0x28]
00020c  f8db0000          LDR      r0,[r11,#0]
;;;251      /* Loop for each pair of output pixels */
;;;252      for (col = cinfo->output_width >> 1; col > 0; col--) {
000210  f8d4b070          LDR      r11,[r4,#0x70]
000214  ea4f0b5b          LSR      r11,r11,#1
000218  f8cdb010          STR      r11,[sp,#0x10]
00021c  e050              B        |L1.704|
                  |L1.542|
;;;253        /* Do the chroma part of the calculation */
;;;254        cb = GETJSAMPLE(*inptr1++);
00021e  f8ddb018          LDR      r11,[sp,#0x18]
000222  f81b3b01          LDRB     r3,[r11],#1
000226  f8cdb018          STR      r11,[sp,#0x18]
;;;255        cr = GETJSAMPLE(*inptr2++);
00022a  f8ddb014          LDR      r11,[sp,#0x14]
00022e  f81b5b01          LDRB     r5,[r11],#1
000232  f8cdb014          STR      r11,[sp,#0x14]
;;;256        cred = Crrtab[cr];
000236  f8ddb00c          LDR      r11,[sp,#0xc]
00023a  f85b8025          LDR      r8,[r11,r5,LSL #2]
;;;257        cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
00023e  f8ddb000          LDR      r11,[sp,#0]
000242  f85be023          LDR      lr,[r11,r3,LSL #2]
000246  f8ddb004          LDR      r11,[sp,#4]
00024a  f85bb025          LDR      r11,[r11,r5,LSL #2]
00024e  44f3              ADD      r11,r11,lr
000250  ea4f492b          ASR      r9,r11,#16
;;;258        cblue = Cbbtab[cb];
000254  f8ddb008          LDR      r11,[sp,#8]
000258  f85ba023          LDR      r10,[r11,r3,LSL #2]
;;;259        /* Fetch 2 Y values and emit 2 pixels */
;;;260        y  = GETJSAMPLE(*inptr0++);
00025c  f8161b01          LDRB     r1,[r6],#1
;;;261        outptr[RGB_RED] =   range_limit[y + cred];
000260  eb010b08          ADD      r11,r1,r8
000264  f812b00b          LDRB     r11,[r2,r11]
000268  f880b000          STRB     r11,[r0,#0]
;;;262        outptr[RGB_GREEN] = range_limit[y + cgreen];
00026c  eb010b09          ADD      r11,r1,r9
000270  f812b00b          LDRB     r11,[r2,r11]
000274  f880b001          STRB     r11,[r0,#1]
;;;263        outptr[RGB_BLUE] =  range_limit[y + cblue];
000278  eb010b0a          ADD      r11,r1,r10
00027c  f812b00b          LDRB     r11,[r2,r11]
000280  f880b002          STRB     r11,[r0,#2]
;;;264        outptr += RGB_PIXELSIZE;
000284  f1000003          ADD      r0,r0,#3
;;;265        y  = GETJSAMPLE(*inptr0++);
000288  f8161b01          LDRB     r1,[r6],#1
;;;266        outptr[RGB_RED] =   range_limit[y + cred];
00028c  eb010b08          ADD      r11,r1,r8
000290  f812b00b          LDRB     r11,[r2,r11]
000294  f880b000          STRB     r11,[r0,#0]
;;;267        outptr[RGB_GREEN] = range_limit[y + cgreen];
000298  eb010b09          ADD      r11,r1,r9
00029c  f812b00b          LDRB     r11,[r2,r11]
0002a0  f880b001          STRB     r11,[r0,#1]
;;;268        outptr[RGB_BLUE] =  range_limit[y + cblue];
0002a4  eb010b0a          ADD      r11,r1,r10
0002a8  f812b00b          LDRB     r11,[r2,r11]
0002ac  f880b002          STRB     r11,[r0,#2]
;;;269        outptr += RGB_PIXELSIZE;
0002b0  f1000003          ADD      r0,r0,#3
0002b4  f8ddb010          LDR      r11,[sp,#0x10]        ;252
0002b8  f1ab0b01          SUB      r11,r11,#1            ;252
0002bc  f8cdb010          STR      r11,[sp,#0x10]        ;252
                  |L1.704|
0002c0  f8ddb010          LDR      r11,[sp,#0x10]        ;252
0002c4  f1bb0f00          CMP      r11,#0                ;252
0002c8  d1a9              BNE      |L1.542|
;;;270      }
;;;271      /* If image width is odd, do the last output column separately */
;;;272      if (cinfo->output_width & 1) {
0002ca  f8d4b070          LDR      r11,[r4,#0x70]
0002ce  f01b0f01          TST      r11,#1
0002d2  d02d              BEQ      |L1.816|
;;;273        cb = GETJSAMPLE(*inptr1);
0002d4  f8ddb018          LDR      r11,[sp,#0x18]
0002d8  f89b3000          LDRB     r3,[r11,#0]
;;;274        cr = GETJSAMPLE(*inptr2);
0002dc  f8ddb014          LDR      r11,[sp,#0x14]
0002e0  f89b5000          LDRB     r5,[r11,#0]
;;;275        cred = Crrtab[cr];
0002e4  f8ddb00c          LDR      r11,[sp,#0xc]
0002e8  f85b8025          LDR      r8,[r11,r5,LSL #2]
;;;276        cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
0002ec  f8ddb000          LDR      r11,[sp,#0]
0002f0  f85be023          LDR      lr,[r11,r3,LSL #2]
0002f4  f8ddb004          LDR      r11,[sp,#4]
0002f8  f85bb025          LDR      r11,[r11,r5,LSL #2]
0002fc  44f3              ADD      r11,r11,lr
0002fe  ea4f492b          ASR      r9,r11,#16
;;;277        cblue = Cbbtab[cb];
000302  f8ddb008          LDR      r11,[sp,#8]
000306  f85ba023          LDR      r10,[r11,r3,LSL #2]
;;;278        y  = GETJSAMPLE(*inptr0);
00030a  7831              LDRB     r1,[r6,#0]
;;;279        outptr[RGB_RED] =   range_limit[y + cred];
00030c  eb010b08          ADD      r11,r1,r8
000310  f812b00b          LDRB     r11,[r2,r11]
000314  f880b000          STRB     r11,[r0,#0]
;;;280        outptr[RGB_GREEN] = range_limit[y + cgreen];
000318  eb010b09          ADD      r11,r1,r9
00031c  f812b00b          LDRB     r11,[r2,r11]
000320  f880b001          STRB     r11,[r0,#1]
;;;281        outptr[RGB_BLUE] =  range_limit[y + cblue];
000324  eb010b0a          ADD      r11,r1,r10
000328  f812b00b          LDRB     r11,[r2,r11]
00032c  f880b002          STRB     r11,[r0,#2]
                  |L1.816|
;;;282      }
;;;283    }
000330  b00b              ADD      sp,sp,#0x2c
000332  e8bd8ff0          POP      {r4-r11,pc}
;;;284    
                          ENDP

                  h2v2_merged_upsample PROC
;;;290    METHODDEF(void)
;;;291    h2v2_merged_upsample (j_decompress_ptr cinfo,
000336  e92d4fff          PUSH     {r0-r11,lr}
;;;292    		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
;;;293    		      JSAMPARRAY output_buf)
;;;294    {
00033a  b088              SUB      sp,sp,#0x20
00033c  4617              MOV      r7,r2
;;;295      my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
00033e  f8ddb020          LDR      r11,[sp,#0x20]
000342  f8dbb1c4          LDR      r11,[r11,#0x1c4]
000346  f8cdb01c          STR      r11,[sp,#0x1c]
;;;296      register int y, cred, cgreen, cblue;
;;;297      int cb, cr;
;;;298      register JSAMPROW outptr0, outptr1;
;;;299      JSAMPROW inptr00, inptr01, inptr1, inptr2;
;;;300      JDIMENSION col;
;;;301      /* copy these pointers into registers if possible */
;;;302      register JSAMPLE * range_limit = cinfo->sample_range_limit;
00034a  f8ddb020          LDR      r11,[sp,#0x20]
00034e  f8db1144          LDR      r1,[r11,#0x144]
;;;303      int * Crrtab = upsample->Cr_r_tab;
000352  f8ddb01c          LDR      r11,[sp,#0x1c]
000356  f8dbb010          LDR      r11,[r11,#0x10]
00035a  f8cdb00c          STR      r11,[sp,#0xc]
;;;304      int * Cbbtab = upsample->Cb_b_tab;
00035e  f8ddb01c          LDR      r11,[sp,#0x1c]
000362  f8dbb014          LDR      r11,[r11,#0x14]
000366  f8cdb008          STR      r11,[sp,#8]
;;;305      INT32 * Crgtab = upsample->Cr_g_tab;
00036a  f8ddb01c          LDR      r11,[sp,#0x1c]
00036e  f8dbb018          LDR      r11,[r11,#0x18]
000372  f8cdb004          STR      r11,[sp,#4]
;;;306      INT32 * Cbgtab = upsample->Cb_g_tab;
000376  f8ddb01c          LDR      r11,[sp,#0x1c]
00037a  f8dbb01c          LDR      r11,[r11,#0x1c]
00037e  f8cdb000          STR      r11,[sp,#0]
;;;307      SHIFT_TEMPS
;;;308    
;;;309      inptr00 = input_buf[0][in_row_group_ctr*2];
000382  f8ddb024          LDR      r11,[sp,#0x24]
000386  f8dbb000          LDR      r11,[r11,#0]
00038a  ea4f0e47          LSL      lr,r7,#1
00038e  f85b902e          LDR      r9,[r11,lr,LSL #2]
;;;310      inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
000392  f8ddb024          LDR      r11,[sp,#0x24]
000396  f8dbb000          LDR      r11,[r11,#0]
00039a  f04f0e01          MOV      lr,#1
00039e  eb0e0e47          ADD      lr,lr,r7,LSL #1
0003a2  f85ba02e          LDR      r10,[r11,lr,LSL #2]
;;;311      inptr1 = input_buf[1][in_row_group_ctr];
0003a6  f8ddb024          LDR      r11,[sp,#0x24]
0003aa  f8dbb004          LDR      r11,[r11,#4]
0003ae  f85bb027          LDR      r11,[r11,r7,LSL #2]
0003b2  f8cdb018          STR      r11,[sp,#0x18]
;;;312      inptr2 = input_buf[2][in_row_group_ctr];
0003b6  f8ddb024          LDR      r11,[sp,#0x24]
0003ba  f8dbb008          LDR      r11,[r11,#8]
0003be  f85bb027          LDR      r11,[r11,r7,LSL #2]
0003c2  f8cdb014          STR      r11,[sp,#0x14]
;;;313      outptr0 = output_buf[0];
0003c6  f8ddb02c          LDR      r11,[sp,#0x2c]
0003ca  f8db2000          LDR      r2,[r11,#0]
;;;314      outptr1 = output_buf[1];
0003ce  f8ddb02c          LDR      r11,[sp,#0x2c]
0003d2  f8db3004          LDR      r3,[r11,#4]
;;;315      /* Loop for each group of output pixels */
;;;316      for (col = cinfo->output_width >> 1; col > 0; col--) {
0003d6  f8ddb020          LDR      r11,[sp,#0x20]
0003da  f8dbb070          LDR      r11,[r11,#0x70]
0003de  ea4f0b5b          LSR      r11,r11,#1
0003e2  f8cdb010          STR      r11,[sp,#0x10]
0003e6  e085              B        |L1.1268|
                  |L1.1000|
;;;317        /* Do the chroma part of the calculation */
;;;318        cb = GETJSAMPLE(*inptr1++);
0003e8  f8ddb018          LDR      r11,[sp,#0x18]
0003ec  f81bcb01          LDRB     r12,[r11],#1
0003f0  f8cdb018          STR      r11,[sp,#0x18]
;;;319        cr = GETJSAMPLE(*inptr2++);
0003f4  f8ddb014          LDR      r11,[sp,#0x14]
0003f8  f81b8b01          LDRB     r8,[r11],#1
0003fc  f8cdb014          STR      r11,[sp,#0x14]
;;;320        cred = Crrtab[cr];
000400  f8ddb00c          LDR      r11,[sp,#0xc]
000404  f85b4028          LDR      r4,[r11,r8,LSL #2]
;;;321        cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
000408  f8ddb000          LDR      r11,[sp,#0]
00040c  f85be02c          LDR      lr,[r11,r12,LSL #2]
000410  f8ddb004          LDR      r11,[sp,#4]
000414  f85bb028          LDR      r11,[r11,r8,LSL #2]
000418  44f3              ADD      r11,r11,lr
00041a  ea4f452b          ASR      r5,r11,#16
;;;322        cblue = Cbbtab[cb];
00041e  f8ddb008          LDR      r11,[sp,#8]
000422  f85b602c          LDR      r6,[r11,r12,LSL #2]
;;;323        /* Fetch 4 Y values and emit 4 pixels */
;;;324        y  = GETJSAMPLE(*inptr00++);
000426  f8190b01          LDRB     r0,[r9],#1
;;;325        outptr0[RGB_RED] =   range_limit[y + cred];
00042a  eb000b04          ADD      r11,r0,r4
00042e  f811b00b          LDRB     r11,[r1,r11]
000432  f882b000          STRB     r11,[r2,#0]
;;;326        outptr0[RGB_GREEN] = range_limit[y + cgreen];
000436  eb000b05          ADD      r11,r0,r5
00043a  f811b00b          LDRB     r11,[r1,r11]
00043e  f882b001          STRB     r11,[r2,#1]
;;;327        outptr0[RGB_BLUE] =  range_limit[y + cblue];
000442  eb000b06          ADD      r11,r0,r6
000446  f811b00b          LDRB     r11,[r1,r11]
00044a  f882b002          STRB     r11,[r2,#2]
;;;328        outptr0 += RGB_PIXELSIZE;
00044e  e007              B        |L1.1120|
                  |L1.1104|
                          DCD      0x000166e9
                  |L1.1108|
                          DCD      0x0001c5a2
                  |L1.1112|
                          DCD      0xffff492e
                  |L1.1116|
                          DCD      0xffffa7e6
                  |L1.1120|
000460  f1020203          ADD      r2,r2,#3
;;;329        y  = GETJSAMPLE(*inptr00++);
000464  f8190b01          LDRB     r0,[r9],#1
;;;330        outptr0[RGB_RED] =   range_limit[y + cred];
000468  eb000b04          ADD      r11,r0,r4
00046c  f811b00b          LDRB     r11,[r1,r11]
000470  f882b000          STRB     r11,[r2,#0]
;;;331        outptr0[RGB_GREEN] = range_limit[y + cgreen];
000474  eb000b05          ADD      r11,r0,r5
000478  f811b00b          LDRB     r11,[r1,r11]
00047c  f882b001          STRB     r11,[r2,#1]
;;;332        outptr0[RGB_BLUE] =  range_limit[y + cblue];
000480  eb000b06          ADD      r11,r0,r6
000484  f811b00b          LDRB     r11,[r1,r11]
000488  f882b002          STRB     r11,[r2,#2]
;;;333        outptr0 += RGB_PIXELSIZE;
00048c  f1020203          ADD      r2,r2,#3
;;;334        y  = GETJSAMPLE(*inptr01++);
000490  f81a0b01          LDRB     r0,[r10],#1
;;;335        outptr1[RGB_RED] =   range_limit[y + cred];
000494  eb000b04          ADD      r11,r0,r4
000498  f811b00b          LDRB     r11,[r1,r11]
00049c  f883b000          STRB     r11,[r3,#0]
;;;336        outptr1[RGB_GREEN] = range_limit[y + cgreen];
0004a0  eb000b05          ADD      r11,r0,r5
0004a4  f811b00b          LDRB     r11,[r1,r11]
0004a8  f883b001          STRB     r11,[r3,#1]
;;;337        outptr1[RGB_BLUE] =  range_limit[y + cblue];
0004ac  eb000b06          ADD      r11,r0,r6
0004b0  f811b00b          LDRB     r11,[r1,r11]
0004b4  f883b002          STRB     r11,[r3,#2]
;;;338        outptr1 += RGB_PIXELSIZE;
0004b8  f1030303          ADD      r3,r3,#3
;;;339        y  = GETJSAMPLE(*inptr01++);
0004bc  f81a0b01          LDRB     r0,[r10],#1
;;;340        outptr1[RGB_RED] =   range_limit[y + cred];
0004c0  eb000b04          ADD      r11,r0,r4
0004c4  f811b00b          LDRB     r11,[r1,r11]
0004c8  f883b000          STRB     r11,[r3,#0]
;;;341        outptr1[RGB_GREEN] = range_limit[y + cgreen];
0004cc  eb000b05          ADD      r11,r0,r5
0004d0  f811b00b          LDRB     r11,[r1,r11]
0004d4  f883b001          STRB     r11,[r3,#1]
;;;342        outptr1[RGB_BLUE] =  range_limit[y + cblue];
0004d8  eb000b06          ADD      r11,r0,r6
0004dc  f811b00b          LDRB     r11,[r1,r11]
0004e0  f883b002          STRB     r11,[r3,#2]
;;;343        outptr1 += RGB_PIXELSIZE;
0004e4  f1030303          ADD      r3,r3,#3
0004e8  f8ddb010          LDR      r11,[sp,#0x10]        ;316
0004ec  f1ab0b01          SUB      r11,r11,#1            ;316
0004f0  f8cdb010          STR      r11,[sp,#0x10]        ;316
                  |L1.1268|
0004f4  f8ddb010          LDR      r11,[sp,#0x10]        ;316
0004f8  f1bb0f00          CMP      r11,#0                ;316
0004fc  f47faf74          BNE      |L1.1000|
;;;344      }
;;;345      /* If image width is odd, do the last output column separately */
;;;346      if (cinfo->output_width & 1) {
000500  f8ddb020          LDR      r11,[sp,#0x20]
000504  f8dbb070          LDR      r11,[r11,#0x70]
000508  f01b0f01          TST      r11,#1
00050c  d042              BEQ      |L1.1428|
;;;347        cb = GETJSAMPLE(*inptr1);
00050e  f8ddb018          LDR      r11,[sp,#0x18]
000512  f89bc000          LDRB     r12,[r11,#0]
;;;348        cr = GETJSAMPLE(*inptr2);
000516  f8ddb014          LDR      r11,[sp,#0x14]
00051a  f89b8000          LDRB     r8,[r11,#0]
;;;349        cred = Crrtab[cr];
00051e  f8ddb00c          LDR      r11,[sp,#0xc]
000522  f85b4028          LDR      r4,[r11,r8,LSL #2]
;;;350        cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
000526  f8ddb000          LDR      r11,[sp,#0]
00052a  f85be02c          LDR      lr,[r11,r12,LSL #2]
00052e  f8ddb004          LDR      r11,[sp,#4]
000532  f85bb028          LDR      r11,[r11,r8,LSL #2]
000536  44f3              ADD      r11,r11,lr
000538  ea4f452b          ASR      r5,r11,#16
;;;351        cblue = Cbbtab[cb];
00053c  f8ddb008          LDR      r11,[sp,#8]
000540  f85b602c          LDR      r6,[r11,r12,LSL #2]
;;;352        y  = GETJSAMPLE(*inptr00);
000544  f8990000          LDRB     r0,[r9,#0]
;;;353        outptr0[RGB_RED] =   range_limit[y + cred];
000548  eb000b04          ADD      r11,r0,r4
00054c  f811b00b          LDRB     r11,[r1,r11]
000550  f882b000          STRB     r11,[r2,#0]
;;;354        outptr0[RGB_GREEN] = range_limit[y + cgreen];
000554  eb000b05          ADD      r11,r0,r5
000558  f811b00b          LDRB     r11,[r1,r11]
00055c  f882b001          STRB     r11,[r2,#1]
;;;355        outptr0[RGB_BLUE] =  range_limit[y + cblue];
000560  eb000b06          ADD      r11,r0,r6
000564  f811b00b          LDRB     r11,[r1,r11]
000568  f882b002          STRB     r11,[r2,#2]
;;;356        y  = GETJSAMPLE(*inptr01);
00056c  f89a0000          LDRB     r0,[r10,#0]
;;;357        outptr1[RGB_RED] =   range_limit[y + cred];
000570  eb000b04          ADD      r11,r0,r4
000574  f811b00b          LDRB     r11,[r1,r11]
000578  f883b000          STRB     r11,[r3,#0]
;;;358        outptr1[RGB_GREEN] = range_limit[y + cgreen];
00057c  eb000b05          ADD      r11,r0,r5
000580  f811b00b          LDRB     r11,[r1,r11]
000584  f883b001          STRB     r11,[r3,#1]
;;;359        outptr1[RGB_BLUE] =  range_limit[y + cblue];
000588  eb000b06          ADD      r11,r0,r6
00058c  f811b00b          LDRB     r11,[r1,r11]
000590  f883b002          STRB     r11,[r3,#2]
                  |L1.1428|
;;;360      }
;;;361    }
000594  b00c              ADD      sp,sp,#0x30
000596  e8bd8ff0          POP      {r4-r11,pc}
;;;362    
                          ENDP

                  jinit_merged_upsampler PROC
;;;372    GLOBAL(void)
;;;373    jinit_merged_upsampler (j_decompress_ptr cinfo)
00059a  b570              PUSH     {r4-r6,lr}
;;;374    {
00059c  4605              MOV      r5,r0
;;;375      my_upsample_ptr upsample;
;;;376    
;;;377      upsample = (my_upsample_ptr)
00059e  6868              LDR      r0,[r5,#4]
0005a0  f04f0230          MOV      r2,#0x30
0005a4  f04f0101          MOV      r1,#1
0005a8  6803              LDR      r3,[r0,#0]
0005aa  4628              MOV      r0,r5
0005ac  4798              BLX      r3
0005ae  4604              MOV      r4,r0
;;;378        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;379    				SIZEOF(my_upsampler));
;;;380      cinfo->upsample = (struct jpeg_upsampler *) upsample;
0005b0  f8c541c4          STR      r4,[r5,#0x1c4]
;;;381      upsample->pub.start_pass = start_pass_merged_upsample;
0005b4  4812              LDR      r0,|L1.1536|
0005b6  6020              STR      r0,[r4,#0]
;;;382      upsample->pub.need_context_rows = FALSE;
0005b8  f04f0000          MOV      r0,#0
0005bc  60a0              STR      r0,[r4,#8]
;;;383    
;;;384      upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
0005be  6fa9              LDR      r1,[r5,#0x78]
0005c0  6f28              LDR      r0,[r5,#0x70]
0005c2  fb00f001          MUL      r0,r0,r1
0005c6  62a0              STR      r0,[r4,#0x28]
;;;385    
;;;386      if (cinfo->max_v_samp_factor == 2) {
0005c8  f8d50138          LDR      r0,[r5,#0x138]
0005cc  2802              CMP      r0,#2
0005ce  d10b              BNE      |L1.1512|
;;;387        upsample->pub.upsample = merged_2v_upsample;
0005d0  480c              LDR      r0,|L1.1540|
0005d2  6060              STR      r0,[r4,#4]
;;;388        upsample->upmethod = h2v2_merged_upsample;
0005d4  480c              LDR      r0,|L1.1544|
0005d6  60e0              STR      r0,[r4,#0xc]
;;;389        /* Allocate a spare row buffer */
;;;390        upsample->spare_row = (JSAMPROW)
0005d8  6aa2              LDR      r2,[r4,#0x28]
0005da  6868              LDR      r0,[r5,#4]
0005dc  2101              MOVS     r1,#1
0005de  6843              LDR      r3,[r0,#4]
0005e0  4628              MOV      r0,r5
0005e2  4798              BLX      r3
0005e4  6220              STR      r0,[r4,#0x20]
0005e6  e006              B        |L1.1526|
                  |L1.1512|
;;;391          (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;392    		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
;;;393      } else {
;;;394        upsample->pub.upsample = merged_1v_upsample;
0005e8  4808              LDR      r0,|L1.1548|
0005ea  6060              STR      r0,[r4,#4]
;;;395        upsample->upmethod = h2v1_merged_upsample;
0005ec  4808              LDR      r0,|L1.1552|
0005ee  60e0              STR      r0,[r4,#0xc]
;;;396        /* No spare row needed */
;;;397        upsample->spare_row = NULL;
0005f0  f04f0000          MOV      r0,#0
0005f4  6220              STR      r0,[r4,#0x20]
                  |L1.1526|
;;;398      }
;;;399    
;;;400      build_ycc_rgb_table(cinfo);
0005f6  4628              MOV      r0,r5
0005f8  f7fffffe          BL       build_ycc_rgb_table
;;;401    }
0005fc  bd70              POP      {r4-r6,pc}
;;;402    
                          ENDP

0005fe  0000              DCW      0x0000
                  |L1.1536|
                          DCD      start_pass_merged_upsample
                  |L1.1540|
                          DCD      merged_2v_upsample
                  |L1.1544|
                          DCD      h2v2_merged_upsample
                  |L1.1548|
                          DCD      merged_1v_upsample
                  |L1.1552|
                          DCD      h2v1_merged_upsample
