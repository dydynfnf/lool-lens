; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdhuff.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdhuff.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdhuff.crf GUI\JPEG\jdhuff.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  jpeg_make_d_derived_tbl PROC
;;;148    GLOBAL(void)
;;;149    jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;150    			 d_derived_tbl ** pdtbl)
;;;151    {
000004  f2ad5d1c          SUB      sp,sp,#0x51c
000008  4605              MOV      r5,r0
00000a  4692              MOV      r10,r2
;;;152      JHUFF_TBL *htbl;
;;;153      d_derived_tbl *dtbl;
;;;154      int p, i, l, si, numsymbols;
;;;155      int lookbits, ctr;
;;;156      char huffsize[257];
;;;157      unsigned int huffcode[257];
;;;158      unsigned int code;
;;;159    
;;;160      /* Note that huffsize[] and huffcode[] are filled in code-length order,
;;;161       * paralleling the order of the symbols themselves in htbl->huffval[].
;;;162       */
;;;163    
;;;164      /* Find the input Huffman table */
;;;165      if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
00000c  f1ba0f00          CMP      r10,#0
000010  db02              BLT      |L1.24|
000012  f1ba0f04          CMP      r10,#4
000016  db0a              BLT      |L1.46|
                  |L1.24|
;;;166        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
000018  f04f0032          MOV      r0,#0x32
00001c  6829              LDR      r1,[r5,#0]
00001e  6148              STR      r0,[r1,#0x14]
000020  6828              LDR      r0,[r5,#0]
000022  f8c0a018          STR      r10,[r0,#0x18]
000026  6828              LDR      r0,[r5,#0]
000028  6801              LDR      r1,[r0,#0]
00002a  4628              MOV      r0,r5
00002c  4788              BLX      r1
                  |L1.46|
;;;167      htbl =
00002e  f8dd0520          LDR      r0,[sp,#0x520]
000032  b120              CBZ      r0,|L1.62|
;;;168        isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
000034  f10500b4          ADD      r0,r5,#0xb4
000038  f850002a          LDR      r0,[r0,r10,LSL #2]
00003c  e003              B        |L1.70|
                  |L1.62|
00003e  f10500c4          ADD      r0,r5,#0xc4
000042  f850002a          LDR      r0,[r0,r10,LSL #2]
                  |L1.70|
000046  4680              MOV      r8,r0
;;;169      if (htbl == NULL)
000048  f1b80f00          CMP      r8,#0
00004c  d10a              BNE      |L1.100|
;;;170        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
00004e  f04f0032          MOV      r0,#0x32
000052  6829              LDR      r1,[r5,#0]
000054  6148              STR      r0,[r1,#0x14]
000056  6828              LDR      r0,[r5,#0]
000058  f8c0a018          STR      r10,[r0,#0x18]
00005c  6828              LDR      r0,[r5,#0]
00005e  6801              LDR      r1,[r0,#0]
000060  4628              MOV      r0,r5
000062  4788              BLX      r1
                  |L1.100|
;;;171    
;;;172      /* Allocate a workspace if we haven't already done so. */
;;;173      if (*pdtbl == NULL)
000064  f8dd0528          LDR      r0,[sp,#0x528]
000068  6800              LDR      r0,[r0,#0]
00006a  b948              CBNZ     r0,|L1.128|
;;;174        *pdtbl = (d_derived_tbl *)
00006c  6868              LDR      r0,[r5,#4]
00006e  f44f62b2          MOV      r2,#0x590
000072  2101              MOVS     r1,#1
000074  6803              LDR      r3,[r0,#0]
000076  4628              MOV      r0,r5
000078  4798              BLX      r3
00007a  f8dd1528          LDR      r1,[sp,#0x528]
00007e  6008              STR      r0,[r1,#0]
                  |L1.128|
;;;175          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;176    				  SIZEOF(d_derived_tbl));
;;;177      dtbl = *pdtbl;
000080  f8dd0528          LDR      r0,[sp,#0x528]
000084  6807              LDR      r7,[r0,#0]
;;;178      dtbl->pub = htbl;		/* fill in back link */
000086  f8c7808c          STR      r8,[r7,#0x8c]
;;;179      
;;;180      /* Figure C.1: make table of Huffman code length for each symbol */
;;;181    
;;;182      p = 0;
00008a  f04f0600          MOV      r6,#0
;;;183      for (l = 1; l <= 16; l++) {
00008e  f04f0401          MOV      r4,#1
000092  e01f              B        |L1.212|
                  |L1.148|
;;;184        i = (int) htbl->bits[l];
000094  f8189004          LDRB     r9,[r8,r4]
;;;185        if (i < 0 || p + i > 256)	/* protect against table overrun */
000098  f1b90f00          CMP      r9,#0
00009c  db04              BLT      |L1.168|
00009e  eb060009          ADD      r0,r6,r9
0000a2  f5b07f80          CMP      r0,#0x100
0000a6  dd07              BLE      |L1.184|
                  |L1.168|
;;;186          ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
0000a8  f04f0008          MOV      r0,#8
0000ac  6829              LDR      r1,[r5,#0]
0000ae  6148              STR      r0,[r1,#0x14]
0000b0  6828              LDR      r0,[r5,#0]
0000b2  6801              LDR      r1,[r0,#0]
0000b4  4628              MOV      r0,r5
0000b6  4788              BLX      r1
                  |L1.184|
;;;187        while (i--)
0000b8  e005              B        |L1.198|
                  |L1.186|
;;;188          huffsize[p++] = (char) l;
0000ba  4630              MOV      r0,r6
0000bc  f1060601          ADD      r6,r6,#1
0000c0  f50d6181          ADD      r1,sp,#0x408
0000c4  540c              STRB     r4,[r1,r0]
                  |L1.198|
0000c6  ea5f0009          MOVS     r0,r9                 ;187
0000ca  f1a90901          SUB      r9,r9,#1              ;187
0000ce  d1f4              BNE      |L1.186|
0000d0  f1040401          ADD      r4,r4,#1              ;183
                  |L1.212|
0000d4  2c10              CMP      r4,#0x10              ;183
0000d6  dddd              BLE      |L1.148|
;;;189      }
;;;190      huffsize[p] = 0;
0000d8  f04f0000          MOV      r0,#0
0000dc  f50d6181          ADD      r1,sp,#0x408
0000e0  5588              STRB     r0,[r1,r6]
;;;191      numsymbols = p;
0000e2  f8cd6514          STR      r6,[sp,#0x514]
;;;192      
;;;193      /* Figure C.2: generate the codes themselves */
;;;194      /* We also validate that the counts represent a legal Huffman code tree. */
;;;195      
;;;196      code = 0;
0000e6  4683              MOV      r11,r0
;;;197      si = huffsize[0];
0000e8  f89d0408          LDRB     r0,[sp,#0x408]
0000ec  f8cd0518          STR      r0,[sp,#0x518]
;;;198      p = 0;
0000f0  465e              MOV      r6,r11
;;;199      while (huffsize[p]) {
0000f2  e025              B        |L1.320|
                  |L1.244|
;;;200        while (((int) huffsize[p]) == si) {
0000f4  e007              B        |L1.262|
                  |L1.246|
;;;201          huffcode[p++] = code;
0000f6  4630              MOV      r0,r6
0000f8  f1060601          ADD      r6,r6,#1
0000fc  a901              ADD      r1,sp,#4
0000fe  f841b020          STR      r11,[r1,r0,LSL #2]
;;;202          code++;
000102  f10b0b01          ADD      r11,r11,#1
                  |L1.262|
000106  f50d6081          ADD      r0,sp,#0x408          ;200
00010a  5d81              LDRB     r1,[r0,r6]            ;200
00010c  f8dd0518          LDR      r0,[sp,#0x518]        ;200
000110  4281              CMP      r1,r0                 ;200
000112  d0f0              BEQ      |L1.246|
;;;203        }
;;;204        /* code is now 1 more than the last code used for codelength si; but
;;;205         * it must still fit in si bits, since no code is allowed to be all ones.
;;;206         */
;;;207        if (((INT32) code) >= (((INT32) 1) << si))
000114  2101              MOVS     r1,#1
000116  f8dd0518          LDR      r0,[sp,#0x518]
00011a  4081              LSLS     r1,r1,r0
00011c  4559              CMP      r1,r11
00011e  dc07              BGT      |L1.304|
;;;208          ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
000120  f04f0008          MOV      r0,#8
000124  6829              LDR      r1,[r5,#0]
000126  6148              STR      r0,[r1,#0x14]
000128  6828              LDR      r0,[r5,#0]
00012a  6801              LDR      r1,[r0,#0]
00012c  4628              MOV      r0,r5
00012e  4788              BLX      r1
                  |L1.304|
;;;209        code <<= 1;
000130  ea4f0b4b          LSL      r11,r11,#1
;;;210        si++;
000134  f8dd0518          LDR      r0,[sp,#0x518]
000138  f1000001          ADD      r0,r0,#1
00013c  f8cd0518          STR      r0,[sp,#0x518]
                  |L1.320|
000140  f50d6081          ADD      r0,sp,#0x408          ;199
000144  5d80              LDRB     r0,[r0,r6]            ;199
000146  2800              CMP      r0,#0                 ;199
000148  d1d4              BNE      |L1.244|
;;;211      }
;;;212    
;;;213      /* Figure F.15: generate decoding tables for bit-sequential decoding */
;;;214    
;;;215      p = 0;
00014a  4606              MOV      r6,r0
;;;216      for (l = 1; l <= 16; l++) {
00014c  f04f0401          MOV      r4,#1
000150  e01c              B        |L1.396|
                  |L1.338|
;;;217        if (htbl->bits[l]) {
000152  f8180004          LDRB     r0,[r8,r4]
000156  b198              CBZ      r0,|L1.384|
;;;218          /* valoffset[l] = huffval[] index of 1st symbol of code length l,
;;;219           * minus the minimum code of length l
;;;220           */
;;;221          dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
000158  a801              ADD      r0,sp,#4
00015a  f8500026          LDR      r0,[r0,r6,LSL #2]
00015e  eba60100          SUB      r1,r6,r0
000162  f1070048          ADD      r0,r7,#0x48
000166  f8401024          STR      r1,[r0,r4,LSL #2]
;;;222          p += htbl->bits[l];
00016a  f8180004          LDRB     r0,[r8,r4]
00016e  4406              ADD      r6,r6,r0
;;;223          dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
000170  f1a60001          SUB      r0,r6,#1
000174  a901              ADD      r1,sp,#4
000176  f8510020          LDR      r0,[r1,r0,LSL #2]
00017a  f8470024          STR      r0,[r7,r4,LSL #2]
00017e  e003              B        |L1.392|
                  |L1.384|
;;;224        } else {
;;;225          dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
000180  f04f30ff          MOV      r0,#0xffffffff
000184  f8470024          STR      r0,[r7,r4,LSL #2]
                  |L1.392|
000188  f1040401          ADD      r4,r4,#1              ;216
                  |L1.396|
00018c  2c10              CMP      r4,#0x10              ;216
00018e  dde0              BLE      |L1.338|
;;;226        }
;;;227      }
;;;228      dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
000190  48f8              LDR      r0,|L1.1396|
000192  6478              STR      r0,[r7,#0x44]
;;;229    
;;;230      /* Compute lookahead tables to speed up decoding.
;;;231       * First we set all the table entries to 0, indicating "too long";
;;;232       * then we iterate through the Huffman codes that are short enough and
;;;233       * fill in all the entries that correspond to bit sequences starting
;;;234       * with that code.
;;;235       */
;;;236    
;;;237      MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
000194  f44f6180          MOV      r1,#0x400
000198  f1070090          ADD      r0,r7,#0x90
00019c  f7fffffe          BL       __aeabi_memclr4
;;;238    
;;;239      p = 0;
0001a0  f04f0600          MOV      r6,#0
;;;240      for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
0001a4  f04f0401          MOV      r4,#1
0001a8  e03c              B        |L1.548|
                  |L1.426|
;;;241        for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
0001aa  f04f0901          MOV      r9,#1
0001ae  e033              B        |L1.536|
                  |L1.432|
;;;242          /* l = current code's length, p = its index in huffcode[] & huffval[]. */
;;;243          /* Generate left-justified code followed by all possible bit sequences */
;;;244          lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
0001b0  a801              ADD      r0,sp,#4
0001b2  f8500026          LDR      r0,[r0,r6,LSL #2]
0001b6  f1c40108          RSB      r1,r4,#8
0001ba  fa00f001          LSL      r0,r0,r1
0001be  f8cd0510          STR      r0,[sp,#0x510]
;;;245          for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
0001c2  f1c40108          RSB      r1,r4,#8
0001c6  f04f0001          MOV      r0,#1
0001ca  fa00f001          LSL      r0,r0,r1
0001ce  f8cd050c          STR      r0,[sp,#0x50c]
0001d2  e019              B        |L1.520|
                  |L1.468|
;;;246    	dtbl->look_nbits[lookbits] = l;
0001d4  f1070090          ADD      r0,r7,#0x90
0001d8  f8dd1510          LDR      r1,[sp,#0x510]
0001dc  f8404021          STR      r4,[r0,r1,LSL #2]
;;;247    	dtbl->look_sym[lookbits] = htbl->huffval[p];
0001e0  f1080011          ADD      r0,r8,#0x11
0001e4  5d82              LDRB     r2,[r0,r6]
0001e6  f5076092          ADD      r0,r7,#0x490
0001ea  f8dd1510          LDR      r1,[sp,#0x510]
0001ee  5442              STRB     r2,[r0,r1]
;;;248    	lookbits++;
0001f0  f8dd0510          LDR      r0,[sp,#0x510]
0001f4  f1000001          ADD      r0,r0,#1
0001f8  f8cd0510          STR      r0,[sp,#0x510]
0001fc  f8dd050c          LDR      r0,[sp,#0x50c]        ;245
000200  f1a00001          SUB      r0,r0,#1              ;245
000204  f8cd050c          STR      r0,[sp,#0x50c]        ;245
                  |L1.520|
000208  f8dd050c          LDR      r0,[sp,#0x50c]        ;245
00020c  2800              CMP      r0,#0                 ;245
00020e  dce1              BGT      |L1.468|
000210  f1090901          ADD      r9,r9,#1              ;241
000214  f1060601          ADD      r6,r6,#1              ;241
                  |L1.536|
000218  f8180004          LDRB     r0,[r8,r4]            ;241
00021c  4548              CMP      r0,r9                 ;241
00021e  dac7              BGE      |L1.432|
000220  f1040401          ADD      r4,r4,#1              ;240
                  |L1.548|
000224  2c08              CMP      r4,#8                 ;240
000226  ddc0              BLE      |L1.426|
;;;249          }
;;;250        }
;;;251      }
;;;252    
;;;253      /* Validate symbols as being reasonable.
;;;254       * For AC tables, we make no check, but accept all byte values 0..255.
;;;255       * For DC tables, we require the symbols to be in range 0..15.
;;;256       * (Tighter bounds could be applied depending on the data depth and mode,
;;;257       * but this is sufficient to ensure safe decoding.)
;;;258       */
;;;259      if (isDC) {
000228  f8dd0520          LDR      r0,[sp,#0x520]
00022c  b1d8              CBZ      r0,|L1.614|
;;;260        for (i = 0; i < numsymbols; i++) {
00022e  f04f0900          MOV      r9,#0
000232  e014              B        |L1.606|
                  |L1.564|
;;;261          int sym = htbl->huffval[i];
000234  f1080011          ADD      r0,r8,#0x11
000238  f8100009          LDRB     r0,[r0,r9]
00023c  9000              STR      r0,[sp,#0]
;;;262          if (sym < 0 || sym > 15)
00023e  9800              LDR      r0,[sp,#0]
000240  2800              CMP      r0,#0
000242  db02              BLT      |L1.586|
000244  9800              LDR      r0,[sp,#0]
000246  280f              CMP      r0,#0xf
000248  dd07              BLE      |L1.602|
                  |L1.586|
;;;263    	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
00024a  f04f0008          MOV      r0,#8
00024e  6829              LDR      r1,[r5,#0]
000250  6148              STR      r0,[r1,#0x14]
000252  6828              LDR      r0,[r5,#0]
000254  6801              LDR      r1,[r0,#0]
000256  4628              MOV      r0,r5
000258  4788              BLX      r1
                  |L1.602|
00025a  f1090901          ADD      r9,r9,#1              ;260
                  |L1.606|
00025e  f8dd0514          LDR      r0,[sp,#0x514]        ;260
000262  4581              CMP      r9,r0                 ;260
000264  dbe6              BLT      |L1.564|
                  |L1.614|
;;;264        }
;;;265      }
;;;266    }
000266  f20d5d2c          ADD      sp,sp,#0x52c
00026a  e8bd8ff0          POP      {r4-r11,pc}
;;;267    
                          ENDP

                  start_pass_huff_decoder PROC
;;;85     METHODDEF(void)
;;;86     start_pass_huff_decoder (j_decompress_ptr cinfo)
00026e  e92d47f0          PUSH     {r4-r10,lr}
;;;87     {
000272  4605              MOV      r5,r0
;;;88       huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
000274  f8d541bc          LDR      r4,[r5,#0x1bc]
;;;89       int ci, blkn, dctbl, actbl;
;;;90       jpeg_component_info * compptr;
;;;91     
;;;92       /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
;;;93        * This ought to be an error condition, but we make it a warning because
;;;94        * there are some baseline files out there with all zeroes in these bytes.
;;;95        */
;;;96       if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
000278  f8d50190          LDR      r0,[r5,#0x190]
00027c  b948              CBNZ     r0,|L1.658|
00027e  f8d50194          LDR      r0,[r5,#0x194]
000282  283f              CMP      r0,#0x3f
000284  d105              BNE      |L1.658|
;;;97           cinfo->Ah != 0 || cinfo->Al != 0)
000286  f8d50198          LDR      r0,[r5,#0x198]
00028a  b910              CBNZ     r0,|L1.658|
00028c  f8d5019c          LDR      r0,[r5,#0x19c]
000290  b148              CBZ      r0,|L1.678|
                  |L1.658|
;;;98         WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
000292  f04f007a          MOV      r0,#0x7a
000296  6829              LDR      r1,[r5,#0]
000298  6148              STR      r0,[r1,#0x14]
00029a  6828              LDR      r0,[r5,#0]
00029c  f04f31ff          MOV      r1,#0xffffffff
0002a0  6842              LDR      r2,[r0,#4]
0002a2  4628              MOV      r0,r5
0002a4  4790              BLX      r2
                  |L1.678|
;;;99     
;;;100      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
0002a6  f04f0800          MOV      r8,#0
0002aa  e022              B        |L1.754|
                  |L1.684|
;;;101        compptr = cinfo->cur_comp_info[ci];
0002ac  f50570a6          ADD      r0,r5,#0x14c
0002b0  f8507028          LDR      r7,[r0,r8,LSL #2]
;;;102        dctbl = compptr->dc_tbl_no;
0002b4  f8d79014          LDR      r9,[r7,#0x14]
;;;103        actbl = compptr->ac_tbl_no;
0002b8  f8d7a018          LDR      r10,[r7,#0x18]
;;;104        /* Compute derived values for Huffman tables */
;;;105        /* We may do this more than once for a table, but it's not expensive */
;;;106        jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
0002bc  f1040028          ADD      r0,r4,#0x28
0002c0  eb000389          ADD      r3,r0,r9,LSL #2
0002c4  464a              MOV      r2,r9
0002c6  f04f0101          MOV      r1,#1
0002ca  4628              MOV      r0,r5
0002cc  f7fffffe          BL       jpeg_make_d_derived_tbl
;;;107    			    & entropy->dc_derived_tbls[dctbl]);
;;;108        jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
0002d0  f1040038          ADD      r0,r4,#0x38
0002d4  eb00038a          ADD      r3,r0,r10,LSL #2
0002d8  4652              MOV      r2,r10
0002da  2100              MOVS     r1,#0
0002dc  4628              MOV      r0,r5
0002de  f7fffffe          BL       jpeg_make_d_derived_tbl
;;;109    			    & entropy->ac_derived_tbls[actbl]);
;;;110        /* Initialize DC predictions to 0 */
;;;111        entropy->saved.last_dc_val[ci] = 0;
0002e2  f04f0100          MOV      r1,#0
0002e6  f1040014          ADD      r0,r4,#0x14
0002ea  f8401028          STR      r1,[r0,r8,LSL #2]
0002ee  f1080801          ADD      r8,r8,#1              ;100
                  |L1.754|
0002f2  f8d50148          LDR      r0,[r5,#0x148]        ;100
0002f6  4540              CMP      r0,r8                 ;100
0002f8  dcd8              BGT      |L1.684|
;;;112      }
;;;113    
;;;114      /* Precalculate decoding info for each block in an MCU of this scan */
;;;115      for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
0002fa  f04f0600          MOV      r6,#0
0002fe  e038              B        |L1.882|
                  |L1.768|
;;;116        ci = cinfo->MCU_membership[blkn];
000300  f50570b4          ADD      r0,r5,#0x168
000304  f8508026          LDR      r8,[r0,r6,LSL #2]
;;;117        compptr = cinfo->cur_comp_info[ci];
000308  f50570a6          ADD      r0,r5,#0x14c
00030c  f8507028          LDR      r7,[r0,r8,LSL #2]
;;;118        /* Precalculate which table to use for each block */
;;;119        entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
000310  f1040028          ADD      r0,r4,#0x28
000314  6979              LDR      r1,[r7,#0x14]
000316  f8501021          LDR      r1,[r0,r1,LSL #2]
00031a  f1040048          ADD      r0,r4,#0x48
00031e  f8401026          STR      r1,[r0,r6,LSL #2]
;;;120        entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
000322  f1040038          ADD      r0,r4,#0x38
000326  69b9              LDR      r1,[r7,#0x18]
000328  f8501021          LDR      r1,[r0,r1,LSL #2]
00032c  f1040070          ADD      r0,r4,#0x70
000330  f8401026          STR      r1,[r0,r6,LSL #2]
;;;121        /* Decide whether we really care about the coefficient values */
;;;122        if (compptr->component_needed) {
000334  6b38              LDR      r0,[r7,#0x30]
000336  b180              CBZ      r0,|L1.858|
;;;123          entropy->dc_needed[blkn] = TRUE;
000338  f04f0101          MOV      r1,#1
00033c  f1040098          ADD      r0,r4,#0x98
000340  f8401026          STR      r1,[r0,r6,LSL #2]
;;;124          /* we don't need the ACs if producing a 1/8th-size image */
;;;125          entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
000344  6a78              LDR      r0,[r7,#0x24]
000346  2801              CMP      r0,#1
000348  dd00              BLE      |L1.844|
00034a  e001              B        |L1.848|
                  |L1.844|
00034c  f04f0100          MOV      r1,#0
                  |L1.848|
000350  f10400c0          ADD      r0,r4,#0xc0
000354  f8401026          STR      r1,[r0,r6,LSL #2]
000358  e009              B        |L1.878|
                  |L1.858|
;;;126        } else {
;;;127          entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
00035a  f04f0100          MOV      r1,#0
00035e  f10400c0          ADD      r0,r4,#0xc0
000362  f8401026          STR      r1,[r0,r6,LSL #2]
000366  f1040098          ADD      r0,r4,#0x98
00036a  f8401026          STR      r1,[r0,r6,LSL #2]
                  |L1.878|
00036e  f1060601          ADD      r6,r6,#1              ;115
                  |L1.882|
000372  f8d50164          LDR      r0,[r5,#0x164]        ;115
000376  42b0              CMP      r0,r6                 ;115
000378  dcc2              BGT      |L1.768|
;;;128        }
;;;129      }
;;;130    
;;;131      /* Initialize bitread state variables */
;;;132      entropy->bitstate.bits_left = 0;
00037a  f04f0100          MOV      r1,#0
00037e  6121              STR      r1,[r4,#0x10]
;;;133      entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
000380  4608              MOV      r0,r1
000382  60e0              STR      r0,[r4,#0xc]
;;;134      entropy->pub.insufficient_data = FALSE;
000384  60a0              STR      r0,[r4,#8]
;;;135    
;;;136      /* Initialize restart counter */
;;;137      entropy->restarts_to_go = cinfo->restart_interval;
000386  f8d50114          LDR      r0,[r5,#0x114]
00038a  6260              STR      r0,[r4,#0x24]
;;;138    }
00038c  e8bd87f0          POP      {r4-r10,pc}
;;;139    
                          ENDP

                  jpeg_fill_bit_buffer PROC
;;;291    GLOBAL(boolean)
;;;292    jpeg_fill_bit_buffer (bitread_working_state * state,
000390  e92d5ff0          PUSH     {r4-r12,lr}
;;;293    		      register bit_buf_type get_buffer, register int bits_left,
;;;294    		      int nbits)
;;;295    /* Load up the bit buffer to a depth of at least nbits */
;;;296    {
000394  4605              MOV      r5,r0
000396  468a              MOV      r10,r1
000398  4616              MOV      r6,r2
00039a  469b              MOV      r11,r3
;;;297      /* Copy heavily used state fields into locals (hopefully registers) */
;;;298      register const JOCTET * next_input_byte = state->next_input_byte;
00039c  f8d58000          LDR      r8,[r5,#0]
;;;299      register size_t bytes_in_buffer = state->bytes_in_buffer;
0003a0  f8d59004          LDR      r9,[r5,#4]
;;;300      j_decompress_ptr cinfo = state->cinfo;
0003a4  692c              LDR      r4,[r5,#0x10]
;;;301    
;;;302      /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
;;;303      /* (It is assumed that no request will be for more than that many bits.) */
;;;304      /* We fail to do so only if we hit a marker or are forced to suspend. */
;;;305    
;;;306      if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
0003a6  f8d401a0          LDR      r0,[r4,#0x1a0]
0003aa  2800              CMP      r0,#0
0003ac  d13d              BNE      |L1.1066|
;;;307        while (bits_left < MIN_GET_BITS) {
0003ae  e039              B        |L1.1060|
                  |L1.944|
;;;308          register int c;
;;;309    
;;;310          /* Attempt to read a byte */
;;;311          if (bytes_in_buffer == 0) {
0003b0  f1b90f00          CMP      r9,#0
0003b4  d10d              BNE      |L1.978|
;;;312    	if (! (*cinfo->src->fill_input_buffer) (cinfo))
0003b6  69a0              LDR      r0,[r4,#0x18]
0003b8  68c1              LDR      r1,[r0,#0xc]
0003ba  4620              MOV      r0,r4
0003bc  4788              BLX      r1
0003be  b910              CBNZ     r0,|L1.966|
;;;313    	  return FALSE;
0003c0  2000              MOVS     r0,#0
                  |L1.962|
;;;314    	next_input_byte = cinfo->src->next_input_byte;
;;;315    	bytes_in_buffer = cinfo->src->bytes_in_buffer;
;;;316          }
;;;317          bytes_in_buffer--;
;;;318          c = GETJOCTET(*next_input_byte++);
;;;319    
;;;320          /* If it's 0xFF, check and discard stuffed zero byte */
;;;321          if (c == 0xFF) {
;;;322    	/* Loop here to discard any padding FF's on terminating marker,
;;;323    	 * so that we can save a valid unread_marker value.  NOTE: we will
;;;324    	 * accept multiple FF's followed by a 0 as meaning a single FF data
;;;325    	 * byte.  This data pattern is not valid according to the standard.
;;;326    	 */
;;;327    	do {
;;;328    	  if (bytes_in_buffer == 0) {
;;;329    	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
;;;330    	      return FALSE;
;;;331    	    next_input_byte = cinfo->src->next_input_byte;
;;;332    	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
;;;333    	  }
;;;334    	  bytes_in_buffer--;
;;;335    	  c = GETJOCTET(*next_input_byte++);
;;;336    	} while (c == 0xFF);
;;;337    
;;;338    	if (c == 0) {
;;;339    	  /* Found FF/00, which represents an FF data byte */
;;;340    	  c = 0xFF;
;;;341    	} else {
;;;342    	  /* Oops, it's actually a marker indicating end of compressed data.
;;;343    	   * Save the marker code for later use.
;;;344    	   * Fine point: it might appear that we should save the marker into
;;;345    	   * bitread working state, not straight into permanent state.  But
;;;346    	   * once we have hit a marker, we cannot need to suspend within the
;;;347    	   * current MCU, because we will read no more bytes from the data
;;;348    	   * source.  So it is OK to update permanent state right away.
;;;349    	   */
;;;350    	  cinfo->unread_marker = c;
;;;351    	  /* See if we need to insert some fake zero bits. */
;;;352    	  goto no_more_bytes;
;;;353    	}
;;;354          }
;;;355    
;;;356          /* OK, load c into get_buffer */
;;;357          get_buffer = (get_buffer << 8) | c;
;;;358          bits_left += 8;
;;;359        } /* end while */
;;;360      } else {
;;;361      no_more_bytes:
;;;362        /* We get here if we've read the marker that terminates the compressed
;;;363         * data segment.  There should be enough bits in the buffer register
;;;364         * to satisfy the request; if so, no problem.
;;;365         */
;;;366        if (nbits > bits_left) {
;;;367          /* Uh-oh.  Report corrupted data to user and stuff zeroes into
;;;368           * the data stream, so that we can produce some kind of image.
;;;369           * We use a nonvolatile flag to ensure that only one warning message
;;;370           * appears per data segment.
;;;371           */
;;;372          if (! cinfo->entropy->insufficient_data) {
;;;373    	WARNMS(cinfo, JWRN_HIT_MARKER);
;;;374    	cinfo->entropy->insufficient_data = TRUE;
;;;375          }
;;;376          /* Fill the buffer with zero bits */
;;;377          get_buffer <<= MIN_GET_BITS - bits_left;
;;;378          bits_left = MIN_GET_BITS;
;;;379        }
;;;380      }
;;;381    
;;;382      /* Unload the local registers */
;;;383      state->next_input_byte = next_input_byte;
;;;384      state->bytes_in_buffer = bytes_in_buffer;
;;;385      state->get_buffer = get_buffer;
;;;386      state->bits_left = bits_left;
;;;387    
;;;388      return TRUE;
;;;389    }
0003c2  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.966|
0003c6  69a0              LDR      r0,[r4,#0x18]         ;314
0003c8  f8d08000          LDR      r8,[r0,#0]            ;314
0003cc  69a0              LDR      r0,[r4,#0x18]         ;315
0003ce  f8d09004          LDR      r9,[r0,#4]            ;315
                  |L1.978|
0003d2  f1a90901          SUB      r9,r9,#1              ;317
0003d6  f8187b01          LDRB     r7,[r8],#1            ;318
0003da  2fff              CMP      r7,#0xff              ;321
0003dc  d11d              BNE      |L1.1050|
0003de  bf00              NOP                            ;327
                  |L1.992|
0003e0  f1b90f00          CMP      r9,#0                 ;328
0003e4  d10c              BNE      |L1.1024|
0003e6  69a0              LDR      r0,[r4,#0x18]         ;329
0003e8  68c1              LDR      r1,[r0,#0xc]          ;329
0003ea  4620              MOV      r0,r4                 ;329
0003ec  4788              BLX      r1                    ;329
0003ee  b908              CBNZ     r0,|L1.1012|
0003f0  2000              MOVS     r0,#0                 ;330
0003f2  e7e6              B        |L1.962|
                  |L1.1012|
0003f4  69a0              LDR      r0,[r4,#0x18]         ;331
0003f6  f8d08000          LDR      r8,[r0,#0]            ;331
0003fa  69a0              LDR      r0,[r4,#0x18]         ;332
0003fc  f8d09004          LDR      r9,[r0,#4]            ;332
                  |L1.1024|
000400  f1a90901          SUB      r9,r9,#1              ;334
000404  f8187b01          LDRB     r7,[r8],#1            ;335
000408  2fff              CMP      r7,#0xff              ;336
00040a  d0e9              BEQ      |L1.992|
00040c  b917              CBNZ     r7,|L1.1044|
00040e  f04f07ff          MOV      r7,#0xff              ;340
000412  e002              B        |L1.1050|
                  |L1.1044|
000414  f8c471a0          STR      r7,[r4,#0x1a0]        ;350
000418  e008              B        |L1.1068|
                  |L1.1050|
00041a  ea472a0a          ORR      r10,r7,r10,LSL #8     ;357
00041e  f1060608          ADD      r6,r6,#8              ;358
000422  bf00              NOP                            ;359
                  |L1.1060|
000424  2e19              CMP      r6,#0x19              ;307
000426  dbc3              BLT      |L1.944|
000428  e01b              B        |L1.1122|
                  |L1.1066|
00042a  bf00              NOP                            ;361
                  |L1.1068|
00042c  45b3              CMP      r11,r6                ;366
00042e  dd18              BLE      |L1.1122|
000430  f8d401bc          LDR      r0,[r4,#0x1bc]        ;372
000434  6880              LDR      r0,[r0,#8]            ;372
000436  b970              CBNZ     r0,|L1.1110|
000438  f04f0075          MOV      r0,#0x75              ;373
00043c  6821              LDR      r1,[r4,#0]            ;373
00043e  6148              STR      r0,[r1,#0x14]         ;373
000440  6820              LDR      r0,[r4,#0]            ;373
000442  f04f31ff          MOV      r1,#0xffffffff        ;373
000446  6842              LDR      r2,[r0,#4]            ;373
000448  4620              MOV      r0,r4                 ;373
00044a  4790              BLX      r2                    ;373
00044c  f04f0001          MOV      r0,#1                 ;374
000450  f8d411bc          LDR      r1,[r4,#0x1bc]        ;374
000454  6088              STR      r0,[r1,#8]            ;374
                  |L1.1110|
000456  f1c60019          RSB      r0,r6,#0x19           ;377
00045a  fa0afa00          LSL      r10,r10,r0            ;377
00045e  f04f0619          MOV      r6,#0x19              ;378
                  |L1.1122|
000462  f8c58000          STR      r8,[r5,#0]            ;383
000466  f8c59004          STR      r9,[r5,#4]            ;384
00046a  f8c5a008          STR      r10,[r5,#8]           ;385
00046e  60ee              STR      r6,[r5,#0xc]          ;386
000470  2001              MOVS     r0,#1                 ;388
000472  e7a6              B        |L1.962|
;;;390    
                          ENDP

                  jpeg_huff_decode PROC
;;;397    GLOBAL(int)
;;;398    jpeg_huff_decode (bitread_working_state * state,
000474  e92d47f0          PUSH     {r4-r10,lr}
;;;399    		  register bit_buf_type get_buffer, register int bits_left,
;;;400    		  d_derived_tbl * htbl, int min_bits)
;;;401    {
000478  4604              MOV      r4,r0
00047a  4688              MOV      r8,r1
00047c  4616              MOV      r6,r2
00047e  4699              MOV      r9,r3
000480  f8dda020          LDR      r10,[sp,#0x20]
;;;402      register int l = min_bits;
000484  4655              MOV      r5,r10
;;;403      register INT32 code;
;;;404    
;;;405      /* HUFF_DECODE has determined that the code is at least min_bits */
;;;406      /* bits long, so fetch that many bits in one swoop. */
;;;407    
;;;408      CHECK_BIT_BUFFER(*state, l, return -1);
000486  42ae              CMP      r6,r5
000488  da0d              BGE      |L1.1190|
00048a  462b              MOV      r3,r5
00048c  4632              MOV      r2,r6
00048e  4641              MOV      r1,r8
000490  4620              MOV      r0,r4
000492  f7fffffe          BL       jpeg_fill_bit_buffer
000496  b918              CBNZ     r0,|L1.1184|
000498  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1180|
;;;409      code = GET_BITS(l);
;;;410    
;;;411      /* Collect the rest of the Huffman code one bit at a time. */
;;;412      /* This is per Figure F.16 in the JPEG spec. */
;;;413    
;;;414      while (code > htbl->maxcode[l]) {
;;;415        code <<= 1;
;;;416        CHECK_BIT_BUFFER(*state, 1, return -1);
;;;417        code |= GET_BITS(1);
;;;418        l++;
;;;419      }
;;;420    
;;;421      /* Unload the local registers */
;;;422      state->get_buffer = get_buffer;
;;;423      state->bits_left = bits_left;
;;;424    
;;;425      /* With garbage input we may reach the sentinel value l = 17. */
;;;426    
;;;427      if (l > 16) {
;;;428        WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
;;;429        return 0;			/* fake a zero as the safest result */
;;;430      }
;;;431    
;;;432      return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
;;;433    }
00049c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1184|
0004a0  f8d48008          LDR      r8,[r4,#8]            ;408
0004a4  68e6              LDR      r6,[r4,#0xc]          ;408
                  |L1.1190|
0004a6  eba60105          SUB      r1,r6,r5              ;409
0004aa  460e              MOV      r6,r1                 ;409
0004ac  fa48f001          ASR      r0,r8,r1              ;409
0004b0  f04f0101          MOV      r1,#1                 ;409
0004b4  fa01f105          LSL      r1,r1,r5              ;409
0004b8  f1a10101          SUB      r1,r1,#1              ;409
0004bc  ea000701          AND      r7,r0,r1              ;409
0004c0  e01b              B        |L1.1274|
                  |L1.1218|
0004c2  ea4f0747          LSL      r7,r7,#1              ;415
0004c6  2e01              CMP      r6,#1                 ;416
0004c8  da0c              BGE      |L1.1252|
0004ca  2301              MOVS     r3,#1                 ;416
0004cc  4632              MOV      r2,r6                 ;416
0004ce  4641              MOV      r1,r8                 ;416
0004d0  4620              MOV      r0,r4                 ;416
0004d2  f7fffffe          BL       jpeg_fill_bit_buffer
0004d6  b910              CBNZ     r0,|L1.1246|
0004d8  f04f30ff          MOV      r0,#0xffffffff        ;416
0004dc  e7de              B        |L1.1180|
                  |L1.1246|
0004de  f8d48008          LDR      r8,[r4,#8]            ;416
0004e2  68e6              LDR      r6,[r4,#0xc]          ;416
                  |L1.1252|
0004e4  f1a60001          SUB      r0,r6,#1              ;417
0004e8  4606              MOV      r6,r0                 ;417
0004ea  fa48f000          ASR      r0,r8,r0              ;417
0004ee  f0000001          AND      r0,r0,#1              ;417
0004f2  ea400707          ORR      r7,r0,r7              ;417
0004f6  f1050501          ADD      r5,r5,#1              ;418
                  |L1.1274|
0004fa  f8590025          LDR      r0,[r9,r5,LSL #2]     ;414
0004fe  42b8              CMP      r0,r7                 ;414
000500  dbdf              BLT      |L1.1218|
000502  f8c48008          STR      r8,[r4,#8]            ;422
000506  60e6              STR      r6,[r4,#0xc]          ;423
000508  2d10              CMP      r5,#0x10              ;427
00050a  dd0c              BLE      |L1.1318|
00050c  f04f0076          MOV      r0,#0x76              ;428
000510  6921              LDR      r1,[r4,#0x10]         ;428
000512  6809              LDR      r1,[r1,#0]            ;428
000514  6148              STR      r0,[r1,#0x14]         ;428
000516  6920              LDR      r0,[r4,#0x10]         ;428
000518  6801              LDR      r1,[r0,#0]            ;428
00051a  684a              LDR      r2,[r1,#4]            ;428
00051c  f04f31ff          MOV      r1,#0xffffffff        ;428
000520  4790              BLX      r2                    ;428
000522  2000              MOVS     r0,#0                 ;429
000524  e7ba              B        |L1.1180|
                  |L1.1318|
000526  f8d9008c          LDR      r0,[r9,#0x8c]         ;432
00052a  3011              ADDS     r0,r0,#0x11           ;432
00052c  f1090148          ADD      r1,r9,#0x48           ;432
000530  f8511025          LDR      r1,[r1,r5,LSL #2]     ;432
000534  4439              ADD      r1,r1,r7              ;432
000536  5c40              LDRB     r0,[r0,r1]            ;432
000538  e7b0              B        |L1.1180|
;;;434    
                          ENDP

                  process_restart PROC
;;;467    LOCAL(boolean)
;;;468    process_restart (j_decompress_ptr cinfo)
00053a  b570              PUSH     {r4-r6,lr}
;;;469    {
00053c  4604              MOV      r4,r0
;;;470      huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
00053e  f8d451bc          LDR      r5,[r4,#0x1bc]
;;;471      int ci;
;;;472    
;;;473      /* Throw away any unused bits remaining in bit buffer; */
;;;474      /* include any full bytes in next_marker's count of discarded bytes */
;;;475      cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
000542  6928              LDR      r0,[r5,#0x10]
000544  ea4f71e0          ASR      r1,r0,#31
000548  eb007151          ADD      r1,r0,r1,LSR #29
00054c  f8d421b8          LDR      r2,[r4,#0x1b8]
000550  6992              LDR      r2,[r2,#0x18]
000552  eb0201e1          ADD      r1,r2,r1,ASR #3
000556  f8d421b8          LDR      r2,[r4,#0x1b8]
00055a  6191              STR      r1,[r2,#0x18]
;;;476      entropy->bitstate.bits_left = 0;
00055c  f04f0100          MOV      r1,#0
000560  6129              STR      r1,[r5,#0x10]
;;;477    
;;;478      /* Advance past the RSTn marker */
;;;479      if (! (*cinfo->marker->read_restart_marker) (cinfo))
000562  f8d401b8          LDR      r0,[r4,#0x1b8]
000566  6881              LDR      r1,[r0,#8]
000568  4620              MOV      r0,r4
00056a  4788              BLX      r1
00056c  b920              CBNZ     r0,|L1.1400|
;;;480        return FALSE;
00056e  2000              MOVS     r0,#0
                  |L1.1392|
;;;481    
;;;482      /* Re-initialize DC predictions to 0 */
;;;483      for (ci = 0; ci < cinfo->comps_in_scan; ci++)
;;;484        entropy->saved.last_dc_val[ci] = 0;
;;;485    
;;;486      /* Reset restart counter */
;;;487      entropy->restarts_to_go = cinfo->restart_interval;
;;;488    
;;;489      /* Reset out-of-data flag, unless read_restart_marker left us smack up
;;;490       * against a marker.  In that case we will end up treating the next data
;;;491       * segment as empty, and we can avoid producing bogus output pixels by
;;;492       * leaving the flag set.
;;;493       */
;;;494      if (cinfo->unread_marker == 0)
;;;495        entropy->pub.insufficient_data = FALSE;
;;;496    
;;;497      return TRUE;
;;;498    }
000570  bd70              POP      {r4-r6,pc}
000572  0000              DCW      0x0000
                  |L1.1396|
                          DCD      0x000fffff
                  |L1.1400|
000578  f04f0600          MOV      r6,#0                 ;483
00057c  e007              B        |L1.1422|
                  |L1.1406|
00057e  f04f0100          MOV      r1,#0                 ;484
000582  f1050014          ADD      r0,r5,#0x14           ;484
000586  f8401026          STR      r1,[r0,r6,LSL #2]     ;484
00058a  f1060601          ADD      r6,r6,#1              ;483
                  |L1.1422|
00058e  f8d40148          LDR      r0,[r4,#0x148]        ;483
000592  42b0              CMP      r0,r6                 ;483
000594  dcf3              BGT      |L1.1406|
000596  f8d40114          LDR      r0,[r4,#0x114]        ;487
00059a  6268              STR      r0,[r5,#0x24]         ;487
00059c  f8d401a0          LDR      r0,[r4,#0x1a0]        ;494
0005a0  b910              CBNZ     r0,|L1.1448|
0005a2  f04f0000          MOV      r0,#0                 ;495
0005a6  60a8              STR      r0,[r5,#8]            ;495
                  |L1.1448|
0005a8  2001              MOVS     r0,#1                 ;497
0005aa  e7e1              B        |L1.1392|
;;;499    
                          ENDP

                  decode_mcu PROC
;;;516    METHODDEF(boolean)
;;;517    decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
0005ac  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;518    {
0005b0  b08f              SUB      sp,sp,#0x3c
0005b2  4680              MOV      r8,r0
;;;519      huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
0005b4  f8d861bc          LDR      r6,[r8,#0x1bc]
;;;520      int blkn;
;;;521      BITREAD_STATE_VARS;
;;;522      savable_state state;
;;;523    
;;;524      /* Process restart marker if needed; may have to suspend */
;;;525      if (cinfo->restart_interval) {
0005b8  f8d80114          LDR      r0,[r8,#0x114]
0005bc  b148              CBZ      r0,|L1.1490|
;;;526        if (entropy->restarts_to_go == 0)
0005be  6a70              LDR      r0,[r6,#0x24]
0005c0  b938              CBNZ     r0,|L1.1490|
;;;527          if (! process_restart(cinfo))
0005c2  4640              MOV      r0,r8
0005c4  f7fffffe          BL       process_restart
0005c8  b918              CBNZ     r0,|L1.1490|
;;;528    	return FALSE;
0005ca  2000              MOVS     r0,#0
                  |L1.1484|
;;;529      }
;;;530    
;;;531      /* If we've run out of data, just leave the MCU set to zeroes.
;;;532       * This way, we return uniform gray for the remainder of the segment.
;;;533       */
;;;534      if (! entropy->pub.insufficient_data) {
;;;535    
;;;536        /* Load up working state */
;;;537        BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
;;;538        ASSIGN_STATE(state, entropy->saved);
;;;539    
;;;540        /* Outer loop handles each block in the MCU */
;;;541    
;;;542        for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
;;;543          JBLOCKROW block = MCU_data[blkn];
;;;544          d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
;;;545          d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
;;;546          register int s, k, r;
;;;547    
;;;548          /* Decode a single block's worth of coefficients */
;;;549    
;;;550          /* Section F.2.2.1: decode the DC coefficient difference */
;;;551          HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
;;;552          if (s) {
;;;553    	CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;554    	r = GET_BITS(s);
;;;555    	s = HUFF_EXTEND(r, s);
;;;556          }
;;;557    
;;;558          if (entropy->dc_needed[blkn]) {
;;;559    	/* Convert DC difference to actual value, update last_dc_val */
;;;560    	int ci = cinfo->MCU_membership[blkn];
;;;561    	s += state.last_dc_val[ci];
;;;562    	state.last_dc_val[ci] = s;
;;;563    	/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
;;;564    	(*block)[0] = (JCOEF) s;
;;;565          }
;;;566    
;;;567          if (entropy->ac_needed[blkn]) {
;;;568    
;;;569    	/* Section F.2.2.2: decode the AC coefficients */
;;;570    	/* Since zeroes are skipped, output area must be cleared beforehand */
;;;571    	for (k = 1; k < DCTSIZE2; k++) {
;;;572    	  HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
;;;573          
;;;574    	  r = s >> 4;
;;;575    	  s &= 15;
;;;576          
;;;577    	  if (s) {
;;;578    	    k += r;
;;;579    	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;580    	    r = GET_BITS(s);
;;;581    	    s = HUFF_EXTEND(r, s);
;;;582    	    /* Output coefficient in natural (dezigzagged) order.
;;;583    	     * Note: the extra entries in jpeg_natural_order[] will save us
;;;584    	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
;;;585    	     */
;;;586    	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
;;;587    	  } else {
;;;588    	    if (r != 15)
;;;589    	      break;
;;;590    	    k += 15;
;;;591    	  }
;;;592    	}
;;;593    
;;;594          } else {
;;;595    
;;;596    	/* Section F.2.2.2: decode the AC coefficients */
;;;597    	/* In this path we just discard the values */
;;;598    	for (k = 1; k < DCTSIZE2; k++) {
;;;599    	  HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
;;;600          
;;;601    	  r = s >> 4;
;;;602    	  s &= 15;
;;;603          
;;;604    	  if (s) {
;;;605    	    k += r;
;;;606    	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;607    	    DROP_BITS(s);
;;;608    	  } else {
;;;609    	    if (r != 15)
;;;610    	      break;
;;;611    	    k += 15;
;;;612    	  }
;;;613    	}
;;;614    
;;;615          }
;;;616        }
;;;617    
;;;618        /* Completed MCU, so update state */
;;;619        BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
;;;620        ASSIGN_STATE(entropy->saved, state);
;;;621      }
;;;622    
;;;623      /* Account for restart interval (no-op if not using restarts) */
;;;624      entropy->restarts_to_go--;
;;;625    
;;;626      return TRUE;
;;;627    }
0005cc  b011              ADD      sp,sp,#0x44
0005ce  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1490|
0005d2  68b0              LDR      r0,[r6,#8]            ;534
0005d4  2800              CMP      r0,#0                 ;534
0005d6  d16e              BNE      |L1.1718|
0005d8  f8cd8038          STR      r8,[sp,#0x38]         ;537
0005dc  f8d80018          LDR      r0,[r8,#0x18]         ;537
0005e0  6800              LDR      r0,[r0,#0]            ;537
0005e2  900a              STR      r0,[sp,#0x28]         ;537
0005e4  f8d80018          LDR      r0,[r8,#0x18]         ;537
0005e8  6840              LDR      r0,[r0,#4]            ;537
0005ea  900b              STR      r0,[sp,#0x2c]         ;537
0005ec  f8d6b00c          LDR      r11,[r6,#0xc]         ;537
0005f0  6935              LDR      r5,[r6,#0x10]         ;537
0005f2  e9d62307          LDRD     r2,r3,[r6,#0x1c]      ;538
0005f6  e9d61005          LDRD     r1,r0,[r6,#0x14]      ;538
0005fa  ac07              ADD      r4,sp,#0x1c           ;538
0005fc  c40d              STM      r4!,{r0,r2,r3}        ;538
0005fe  9106              STR      r1,[sp,#0x18]         ;538
000600  f04f0900          MOV      r9,#0                 ;542
000604  e176              B        |L1.2292|
                  |L1.1542|
000606  9810              LDR      r0,[sp,#0x40]         ;543
000608  f8500029          LDR      r0,[r0,r9,LSL #2]     ;543
00060c  9005              STR      r0,[sp,#0x14]         ;543
00060e  f1060048          ADD      r0,r6,#0x48           ;544
000612  f8500029          LDR      r0,[r0,r9,LSL #2]     ;544
000616  9004              STR      r0,[sp,#0x10]         ;544
000618  f1060070          ADD      r0,r6,#0x70           ;545
00061c  f8500029          LDR      r0,[r0,r9,LSL #2]     ;545
000620  9003              STR      r0,[sp,#0xc]          ;545
000622  2d08              CMP      r5,#8                 ;551
000624  da11              BGE      |L1.1610|
000626  2300              MOVS     r3,#0                 ;551
000628  462a              MOV      r2,r5                 ;551
00062a  4659              MOV      r1,r11                ;551
00062c  a80a              ADD      r0,sp,#0x28           ;551
00062e  f7fffffe          BL       jpeg_fill_bit_buffer
000632  b908              CBNZ     r0,|L1.1592|
000634  2000              MOVS     r0,#0                 ;551
000636  e7c9              B        |L1.1484|
                  |L1.1592|
000638  f8ddb030          LDR      r11,[sp,#0x30]        ;551
00063c  9d0d              LDR      r5,[sp,#0x34]         ;551
00063e  2d08              CMP      r5,#8                 ;551
000640  da03              BGE      |L1.1610|
000642  f04f0001          MOV      r0,#1                 ;551
000646  9002              STR      r0,[sp,#8]            ;551
000648  e01a              B        |L1.1664|
                  |L1.1610|
00064a  f1a50008          SUB      r0,r5,#8              ;551
00064e  fa4bf000          ASR      r0,r11,r0             ;551
000652  b2c0              UXTB     r0,r0                 ;551
000654  9001              STR      r0,[sp,#4]            ;551
000656  9804              LDR      r0,[sp,#0x10]         ;551
000658  f1000190          ADD      r1,r0,#0x90           ;551
00065c  9801              LDR      r0,[sp,#4]            ;551
00065e  f8510020          LDR      r0,[r1,r0,LSL #2]     ;551
000662  9002              STR      r0,[sp,#8]            ;551
000664  b140              CBZ      r0,|L1.1656|
000666  9802              LDR      r0,[sp,#8]            ;551
000668  eba50500          SUB      r5,r5,r0              ;551
00066c  9804              LDR      r0,[sp,#0x10]         ;551
00066e  f5006092          ADD      r0,r0,#0x490          ;551
000672  9901              LDR      r1,[sp,#4]            ;551
000674  5c44              LDRB     r4,[r0,r1]            ;551
000676  e012              B        |L1.1694|
                  |L1.1656|
000678  f04f0009          MOV      r0,#9                 ;551
00067c  9002              STR      r0,[sp,#8]            ;551
00067e  bf00              NOP                            ;551
                  |L1.1664|
000680  9802              LDR      r0,[sp,#8]            ;551
000682  9000              STR      r0,[sp,#0]            ;551
000684  462a              MOV      r2,r5                 ;551
000686  4659              MOV      r1,r11                ;551
000688  a80a              ADD      r0,sp,#0x28           ;551
00068a  9b04              LDR      r3,[sp,#0x10]         ;551
00068c  f7fffffe          BL       jpeg_huff_decode
000690  1e04              SUBS     r4,r0,#0              ;551
000692  da01              BGE      |L1.1688|
000694  2000              MOVS     r0,#0                 ;551
000696  e799              B        |L1.1484|
                  |L1.1688|
000698  f8ddb030          LDR      r11,[sp,#0x30]        ;551
00069c  9d0d              LDR      r5,[sp,#0x34]         ;551
                  |L1.1694|
00069e  b33c              CBZ      r4,|L1.1776|
0006a0  42a5              CMP      r5,r4                 ;553
0006a2  da0c              BGE      |L1.1726|
0006a4  4623              MOV      r3,r4                 ;553
0006a6  462a              MOV      r2,r5                 ;553
0006a8  4659              MOV      r1,r11                ;553
0006aa  a80a              ADD      r0,sp,#0x28           ;553
0006ac  f7fffffe          BL       jpeg_fill_bit_buffer
0006b0  b910              CBNZ     r0,|L1.1720|
0006b2  2000              MOVS     r0,#0                 ;553
0006b4  e78a              B        |L1.1484|
                  |L1.1718|
0006b6  e132              B        |L1.2334|
                  |L1.1720|
0006b8  f8ddb030          LDR      r11,[sp,#0x30]        ;553
0006bc  9d0d              LDR      r5,[sp,#0x34]         ;553
                  |L1.1726|
0006be  eba50104          SUB      r1,r5,r4              ;554
0006c2  460d              MOV      r5,r1                 ;554
0006c4  fa4bf001          ASR      r0,r11,r1             ;554
0006c8  f04f0101          MOV      r1,#1                 ;554
0006cc  fa01f104          LSL      r1,r1,r4              ;554
0006d0  f1a10101          SUB      r1,r1,#1              ;554
0006d4  ea000a01          AND      r10,r0,r1             ;554
0006d8  48a6              LDR      r0,|L1.2420|
0006da  f8500024          LDR      r0,[r0,r4,LSL #2]     ;555
0006de  4550              CMP      r0,r10                ;555
0006e0  dd04              BLE      |L1.1772|
0006e2  48a5              LDR      r0,|L1.2424|
0006e4  f8500024          LDR      r0,[r0,r4,LSL #2]     ;555
0006e8  4450              ADD      r0,r0,r10             ;555
0006ea  e000              B        |L1.1774|
                  |L1.1772|
0006ec  4650              MOV      r0,r10                ;555
                  |L1.1774|
0006ee  4604              MOV      r4,r0                 ;555
                  |L1.1776|
0006f0  f1060098          ADD      r0,r6,#0x98           ;558
0006f4  f8500029          LDR      r0,[r0,r9,LSL #2]     ;558
0006f8  b170              CBZ      r0,|L1.1816|
0006fa  f50871b4          ADD      r1,r8,#0x168          ;560
0006fe  f8510029          LDR      r0,[r1,r9,LSL #2]     ;560
000702  a906              ADD      r1,sp,#0x18           ;561
000704  f8511020          LDR      r1,[r1,r0,LSL #2]     ;561
000708  440c              ADD      r4,r4,r1              ;561
00070a  a906              ADD      r1,sp,#0x18           ;562
00070c  f8414020          STR      r4,[r1,r0,LSL #2]     ;562
000710  b222              SXTH     r2,r4                 ;564
000712  9905              LDR      r1,[sp,#0x14]         ;564
000714  800a              STRH     r2,[r1,#0]            ;564
000716  bf00              NOP                            ;565
                  |L1.1816|
000718  f10600c0          ADD      r0,r6,#0xc0           ;567
00071c  f8500029          LDR      r0,[r0,r9,LSL #2]     ;567
000720  2800              CMP      r0,#0                 ;567
000722  d075              BEQ      |L1.2064|
000724  f04f0701          MOV      r7,#1                 ;571
000728  e07c              B        |L1.2084|
                  |L1.1834|
00072a  2d08              CMP      r5,#8                 ;572
00072c  da11              BGE      |L1.1874|
00072e  2300              MOVS     r3,#0                 ;572
000730  462a              MOV      r2,r5                 ;572
000732  4659              MOV      r1,r11                ;572
000734  a80a              ADD      r0,sp,#0x28           ;572
000736  f7fffffe          BL       jpeg_fill_bit_buffer
00073a  b908              CBNZ     r0,|L1.1856|
00073c  2000              MOVS     r0,#0                 ;572
00073e  e745              B        |L1.1484|
                  |L1.1856|
000740  f8ddb030          LDR      r11,[sp,#0x30]        ;572
000744  9d0d              LDR      r5,[sp,#0x34]         ;572
000746  2d08              CMP      r5,#8                 ;572
000748  da03              BGE      |L1.1874|
00074a  f04f0001          MOV      r0,#1                 ;572
00074e  9002              STR      r0,[sp,#8]            ;572
000750  e01a              B        |L1.1928|
                  |L1.1874|
000752  f1a50008          SUB      r0,r5,#8              ;572
000756  fa4bf000          ASR      r0,r11,r0             ;572
00075a  b2c0              UXTB     r0,r0                 ;572
00075c  9001              STR      r0,[sp,#4]            ;572
00075e  9803              LDR      r0,[sp,#0xc]          ;572
000760  f1000190          ADD      r1,r0,#0x90           ;572
000764  9801              LDR      r0,[sp,#4]            ;572
000766  f8510020          LDR      r0,[r1,r0,LSL #2]     ;572
00076a  9002              STR      r0,[sp,#8]            ;572
00076c  b140              CBZ      r0,|L1.1920|
00076e  9802              LDR      r0,[sp,#8]            ;572
000770  eba50500          SUB      r5,r5,r0              ;572
000774  9803              LDR      r0,[sp,#0xc]          ;572
000776  f5006092          ADD      r0,r0,#0x490          ;572
00077a  9901              LDR      r1,[sp,#4]            ;572
00077c  5c44              LDRB     r4,[r0,r1]            ;572
00077e  e012              B        |L1.1958|
                  |L1.1920|
000780  f04f0009          MOV      r0,#9                 ;572
000784  9002              STR      r0,[sp,#8]            ;572
000786  bf00              NOP                            ;572
                  |L1.1928|
000788  9802              LDR      r0,[sp,#8]            ;572
00078a  9000              STR      r0,[sp,#0]            ;572
00078c  462a              MOV      r2,r5                 ;572
00078e  4659              MOV      r1,r11                ;572
000790  a80a              ADD      r0,sp,#0x28           ;572
000792  9b03              LDR      r3,[sp,#0xc]          ;572
000794  f7fffffe          BL       jpeg_huff_decode
000798  1e04              SUBS     r4,r0,#0              ;572
00079a  da01              BGE      |L1.1952|
00079c  2000              MOVS     r0,#0                 ;572
00079e  e715              B        |L1.1484|
                  |L1.1952|
0007a0  f8ddb030          LDR      r11,[sp,#0x30]        ;572
0007a4  9d0d              LDR      r5,[sp,#0x34]         ;572
                  |L1.1958|
0007a6  ea4f1a24          ASR      r10,r4,#4             ;574
0007aa  f004040f          AND      r4,r4,#0xf            ;575
0007ae  b384              CBZ      r4,|L1.2066|
0007b0  4457              ADD      r7,r7,r10             ;578
0007b2  42a5              CMP      r5,r4                 ;579
0007b4  da0b              BGE      |L1.1998|
0007b6  4623              MOV      r3,r4                 ;579
0007b8  462a              MOV      r2,r5                 ;579
0007ba  4659              MOV      r1,r11                ;579
0007bc  a80a              ADD      r0,sp,#0x28           ;579
0007be  f7fffffe          BL       jpeg_fill_bit_buffer
0007c2  b908              CBNZ     r0,|L1.1992|
0007c4  2000              MOVS     r0,#0                 ;579
0007c6  e701              B        |L1.1484|
                  |L1.1992|
0007c8  f8ddb030          LDR      r11,[sp,#0x30]        ;579
0007cc  9d0d              LDR      r5,[sp,#0x34]         ;579
                  |L1.1998|
0007ce  eba50104          SUB      r1,r5,r4              ;580
0007d2  460d              MOV      r5,r1                 ;580
0007d4  fa4bf001          ASR      r0,r11,r1             ;580
0007d8  f04f0101          MOV      r1,#1                 ;580
0007dc  fa01f104          LSL      r1,r1,r4              ;580
0007e0  f1a10101          SUB      r1,r1,#1              ;580
0007e4  ea000a01          AND      r10,r0,r1             ;580
0007e8  4862              LDR      r0,|L1.2420|
0007ea  f8500024          LDR      r0,[r0,r4,LSL #2]     ;581
0007ee  4550              CMP      r0,r10                ;581
0007f0  dd04              BLE      |L1.2044|
0007f2  4861              LDR      r0,|L1.2424|
0007f4  f8500024          LDR      r0,[r0,r4,LSL #2]     ;581
0007f8  4450              ADD      r0,r0,r10             ;581
0007fa  e000              B        |L1.2046|
                  |L1.2044|
0007fc  4650              MOV      r0,r10                ;581
                  |L1.2046|
0007fe  4604              MOV      r4,r0                 ;581
000800  b221              SXTH     r1,r4                 ;586
000802  485e              LDR      r0,|L1.2428|
000804  f8502027          LDR      r2,[r0,r7,LSL #2]     ;586
000808  9805              LDR      r0,[sp,#0x14]         ;586
00080a  f8201012          STRH     r1,[r0,r2,LSL #1]     ;586
00080e  e007              B        |L1.2080|
                  |L1.2064|
000810  e00b              B        |L1.2090|
                  |L1.2066|
000812  e7ff              B        |L1.2068|
                  |L1.2068|
000814  f1ba0f0f          CMP      r10,#0xf              ;588
000818  d000              BEQ      |L1.2076|
00081a  e005              B        |L1.2088|
                  |L1.2076|
00081c  f107070f          ADD      r7,r7,#0xf            ;590
                  |L1.2080|
000820  f1070701          ADD      r7,r7,#1              ;571
                  |L1.2084|
000824  2f40              CMP      r7,#0x40              ;571
000826  db80              BLT      |L1.1834|
                  |L1.2088|
000828  e062              B        |L1.2288|
                  |L1.2090|
00082a  f04f0701          MOV      r7,#1                 ;598
00082e  e05c              B        |L1.2282|
                  |L1.2096|
000830  2d08              CMP      r5,#8                 ;599
000832  da11              BGE      |L1.2136|
000834  2300              MOVS     r3,#0                 ;599
000836  462a              MOV      r2,r5                 ;599
000838  4659              MOV      r1,r11                ;599
00083a  a80a              ADD      r0,sp,#0x28           ;599
00083c  f7fffffe          BL       jpeg_fill_bit_buffer
000840  b908              CBNZ     r0,|L1.2118|
000842  2000              MOVS     r0,#0                 ;599
000844  e6c2              B        |L1.1484|
                  |L1.2118|
000846  f8ddb030          LDR      r11,[sp,#0x30]        ;599
00084a  9d0d              LDR      r5,[sp,#0x34]         ;599
00084c  2d08              CMP      r5,#8                 ;599
00084e  da03              BGE      |L1.2136|
000850  f04f0001          MOV      r0,#1                 ;599
000854  9002              STR      r0,[sp,#8]            ;599
000856  e01a              B        |L1.2190|
                  |L1.2136|
000858  f1a50008          SUB      r0,r5,#8              ;599
00085c  fa4bf000          ASR      r0,r11,r0             ;599
000860  b2c0              UXTB     r0,r0                 ;599
000862  9001              STR      r0,[sp,#4]            ;599
000864  9803              LDR      r0,[sp,#0xc]          ;599
000866  f1000190          ADD      r1,r0,#0x90           ;599
00086a  9801              LDR      r0,[sp,#4]            ;599
00086c  f8510020          LDR      r0,[r1,r0,LSL #2]     ;599
000870  9002              STR      r0,[sp,#8]            ;599
000872  b140              CBZ      r0,|L1.2182|
000874  9802              LDR      r0,[sp,#8]            ;599
000876  eba50500          SUB      r5,r5,r0              ;599
00087a  9803              LDR      r0,[sp,#0xc]          ;599
00087c  f5006092          ADD      r0,r0,#0x490          ;599
000880  9901              LDR      r1,[sp,#4]            ;599
000882  5c44              LDRB     r4,[r0,r1]            ;599
000884  e012              B        |L1.2220|
                  |L1.2182|
000886  f04f0009          MOV      r0,#9                 ;599
00088a  9002              STR      r0,[sp,#8]            ;599
00088c  bf00              NOP                            ;599
                  |L1.2190|
00088e  9802              LDR      r0,[sp,#8]            ;599
000890  9000              STR      r0,[sp,#0]            ;599
000892  462a              MOV      r2,r5                 ;599
000894  4659              MOV      r1,r11                ;599
000896  a80a              ADD      r0,sp,#0x28           ;599
000898  9b03              LDR      r3,[sp,#0xc]          ;599
00089a  f7fffffe          BL       jpeg_huff_decode
00089e  1e04              SUBS     r4,r0,#0              ;599
0008a0  da01              BGE      |L1.2214|
0008a2  2000              MOVS     r0,#0                 ;599
0008a4  e692              B        |L1.1484|
                  |L1.2214|
0008a6  f8ddb030          LDR      r11,[sp,#0x30]        ;599
0008aa  9d0d              LDR      r5,[sp,#0x34]         ;599
                  |L1.2220|
0008ac  ea4f1a24          ASR      r10,r4,#4             ;601
0008b0  f004040f          AND      r4,r4,#0xf            ;602
0008b4  b18c              CBZ      r4,|L1.2266|
0008b6  4457              ADD      r7,r7,r10             ;605
0008b8  42a5              CMP      r5,r4                 ;606
0008ba  da0b              BGE      |L1.2260|
0008bc  4623              MOV      r3,r4                 ;606
0008be  462a              MOV      r2,r5                 ;606
0008c0  4659              MOV      r1,r11                ;606
0008c2  a80a              ADD      r0,sp,#0x28           ;606
0008c4  f7fffffe          BL       jpeg_fill_bit_buffer
0008c8  b908              CBNZ     r0,|L1.2254|
0008ca  2000              MOVS     r0,#0                 ;606
0008cc  e67e              B        |L1.1484|
                  |L1.2254|
0008ce  f8ddb030          LDR      r11,[sp,#0x30]        ;606
0008d2  9d0d              LDR      r5,[sp,#0x34]         ;606
                  |L1.2260|
0008d4  eba50504          SUB      r5,r5,r4              ;607
0008d8  e005              B        |L1.2278|
                  |L1.2266|
0008da  f1ba0f0f          CMP      r10,#0xf              ;609
0008de  d000              BEQ      |L1.2274|
0008e0  e005              B        |L1.2286|
                  |L1.2274|
0008e2  f107070f          ADD      r7,r7,#0xf            ;611
                  |L1.2278|
0008e6  f1070701          ADD      r7,r7,#1              ;598
                  |L1.2282|
0008ea  2f40              CMP      r7,#0x40              ;598
0008ec  dba0              BLT      |L1.2096|
                  |L1.2286|
0008ee  bf00              NOP                            ;610
                  |L1.2288|
0008f0  f1090901          ADD      r9,r9,#1              ;542
                  |L1.2292|
0008f4  f8d80164          LDR      r0,[r8,#0x164]        ;542
0008f8  4548              CMP      r0,r9                 ;542
0008fa  f73fae84          BGT      |L1.1542|
0008fe  980a              LDR      r0,[sp,#0x28]         ;619
000900  f8d81018          LDR      r1,[r8,#0x18]         ;619
000904  6008              STR      r0,[r1,#0]            ;619
000906  980b              LDR      r0,[sp,#0x2c]         ;619
000908  f8d81018          LDR      r1,[r8,#0x18]         ;619
00090c  6048              STR      r0,[r1,#4]            ;619
00090e  f8c6b00c          STR      r11,[r6,#0xc]         ;619
000912  6135              STR      r5,[r6,#0x10]         ;619
000914  a806              ADD      r0,sp,#0x18           ;620
000916  c80f              LDM      r0,{r0-r3}            ;620
000918  f1060414          ADD      r4,r6,#0x14           ;620
00091c  c40f              STM      r4!,{r0-r3}           ;620
                  |L1.2334|
00091e  6a70              LDR      r0,[r6,#0x24]         ;624
000920  f1a00001          SUB      r0,r0,#1              ;624
000924  6270              STR      r0,[r6,#0x24]         ;624
000926  f04f0001          MOV      r0,#1                 ;626
00092a  e64f              B        |L1.1484|
;;;628    
                          ENDP

                  jinit_huff_decoder PROC
;;;634    GLOBAL(void)
;;;635    jinit_huff_decoder (j_decompress_ptr cinfo)
00092c  b570              PUSH     {r4-r6,lr}
;;;636    {
00092e  4606              MOV      r6,r0
;;;637      huff_entropy_ptr entropy;
;;;638      int i;
;;;639    
;;;640      entropy = (huff_entropy_ptr)
000930  6870              LDR      r0,[r6,#4]
000932  f04f02e8          MOV      r2,#0xe8
000936  f04f0101          MOV      r1,#1
00093a  6803              LDR      r3,[r0,#0]
00093c  4630              MOV      r0,r6
00093e  4798              BLX      r3
000940  4604              MOV      r4,r0
;;;641        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;642    				SIZEOF(huff_entropy_decoder));
;;;643      cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
000942  f8c641bc          STR      r4,[r6,#0x1bc]
;;;644      entropy->pub.start_pass = start_pass_huff_decoder;
000946  480e              LDR      r0,|L1.2432|
000948  6020              STR      r0,[r4,#0]
;;;645      entropy->pub.decode_mcu = decode_mcu;
00094a  480e              LDR      r0,|L1.2436|
00094c  6060              STR      r0,[r4,#4]
;;;646    
;;;647      /* Mark tables unallocated */
;;;648      for (i = 0; i < NUM_HUFF_TBLS; i++) {
00094e  f04f0500          MOV      r5,#0
000952  e00b              B        |L1.2412|
                  |L1.2388|
;;;649        entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
000954  f04f0100          MOV      r1,#0
000958  f1040038          ADD      r0,r4,#0x38
00095c  f8401025          STR      r1,[r0,r5,LSL #2]
000960  f1040028          ADD      r0,r4,#0x28
000964  f8401025          STR      r1,[r0,r5,LSL #2]
000968  f1050501          ADD      r5,r5,#1              ;648
                  |L1.2412|
00096c  2d04              CMP      r5,#4                 ;648
00096e  dbf1              BLT      |L1.2388|
;;;650      }
;;;651    }
000970  bd70              POP      {r4-r6,pc}
                          ENDP

000972  0000              DCW      0x0000
                  |L1.2420|
                          DCD      extend_test
                  |L1.2424|
                          DCD      extend_offset
                  |L1.2428|
                          DCD      jpeg_natural_order
                  |L1.2432|
                          DCD      start_pass_huff_decoder
                  |L1.2436|
                          DCD      decode_mcu

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  extend_test
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000020
                          DCD      0x00000040
                          DCD      0x00000080
                          DCD      0x00000100
                          DCD      0x00000200
                          DCD      0x00000400
                          DCD      0x00000800
                          DCD      0x00001000
                          DCD      0x00002000
                          DCD      0x00004000
                  extend_offset
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0xfffffffd
                          DCD      0xfffffff9
                          DCD      0xfffffff1
                          DCD      0xffffffe1
                          DCD      0xffffffc1
                          DCD      0xffffff81
                          DCD      0xffffff01
                          DCD      0xfffffe01
                          DCD      0xfffffc01
                          DCD      0xfffff801
                          DCD      0xfffff001
                          DCD      0xffffe001
                          DCD      0xffffc001
                          DCD      0xffff8001
