; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jutils.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jutils.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jutils.crf GUI\JPEG\jutils.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  jdiv_round_up PROC
;;;71     GLOBAL(long)
;;;72     jdiv_round_up (long a, long b)
000000  4602              MOV      r2,r0
;;;73     /* Compute a/b rounded up to next integer, ie, ceil(a/b) */
;;;74     /* Assumes a >= 0, b > 0 */
;;;75     {
;;;76       return (a + b - 1L) / b;
000002  eb020001          ADD      r0,r2,r1
000006  f1a00001          SUB      r0,r0,#1
00000a  fb90f0f1          SDIV     r0,r0,r1
;;;77     }
00000e  4770              BX       lr
;;;78     
                          ENDP

                  jround_up PROC
;;;80     GLOBAL(long)
;;;81     jround_up (long a, long b)
000010  4602              MOV      r2,r0
;;;82     /* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
;;;83     /* Assumes a >= 0, b > 0 */
;;;84     {
;;;85       a += b - 1L;
000012  f1a10001          SUB      r0,r1,#1
000016  4402              ADD      r2,r2,r0
;;;86       return a - (a % b);
000018  fb92f0f1          SDIV     r0,r2,r1
00001c  fb012010          MLS      r0,r1,r0,r2
000020  eba20000          SUB      r0,r2,r0
;;;87     }
000024  4770              BX       lr
;;;88     
                          ENDP

                  jcopy_sample_rows PROC
;;;110    GLOBAL(void)
;;;111    jcopy_sample_rows (JSAMPARRAY input_array, int source_row,
000026  e92d4ff8          PUSH     {r3-r11,lr}
;;;112    		   JSAMPARRAY output_array, int dest_row,
;;;113    		   int num_rows, JDIMENSION num_cols)
;;;114    /* Copy some rows of samples from one place to another.
;;;115     * num_rows rows are copied from input_array[source_row++]
;;;116     * to output_array[dest_row++]; these areas may overlap for duplication.
;;;117     * The source and destination arrays must be at least as wide as num_cols.
;;;118     */
;;;119    {
00002a  4604              MOV      r4,r0
00002c  460e              MOV      r6,r1
00002e  4615              MOV      r5,r2
000030  461f              MOV      r7,r3
000032  f8dd802c          LDR      r8,[sp,#0x2c]
;;;120      register JSAMPROW inptr, outptr;
;;;121    #ifdef FMEMCOPY
;;;122      register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
000036  f8cd8000          STR      r8,[sp,#0]
;;;123    #else
;;;124      register JDIMENSION count;
;;;125    #endif
;;;126      register int row;
;;;127    
;;;128      input_array += source_row;
00003a  eb040486          ADD      r4,r4,r6,LSL #2
;;;129      output_array += dest_row;
00003e  eb050587          ADD      r5,r5,r7,LSL #2
;;;130    
;;;131      for (row = num_rows; row > 0; row--) {
000042  f8ddb028          LDR      r11,[sp,#0x28]
000046  e00a              B        |L1.94|
                  |L1.72|
;;;132        inptr = *input_array++;
000048  f8549b04          LDR      r9,[r4],#4
;;;133        outptr = *output_array++;
00004c  f855ab04          LDR      r10,[r5],#4
;;;134    #ifdef FMEMCOPY
;;;135        FMEMCOPY(outptr, inptr, count);
000050  4649              MOV      r1,r9
000052  4650              MOV      r0,r10
000054  9a00              LDR      r2,[sp,#0]
000056  f7fffffe          BL       __aeabi_memcpy
00005a  f1ab0b01          SUB      r11,r11,#1            ;131
                  |L1.94|
00005e  f1bb0f00          CMP      r11,#0                ;131
000062  dcf1              BGT      |L1.72|
;;;136    #else
;;;137        for (count = num_cols; count > 0; count--)
;;;138          *outptr++ = *inptr++;	/* needn't bother with GETJSAMPLE() here */
;;;139    #endif
;;;140      }
;;;141    }
000064  e8bd8ff8          POP      {r3-r11,pc}
;;;142    
                          ENDP

                  jcopy_block_row PROC
;;;144    GLOBAL(void)
;;;145    jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
000068  b570              PUSH     {r4-r6,lr}
;;;146    		 JDIMENSION num_blocks)
;;;147    /* Copy a row of coefficient blocks from one place to another. */
;;;148    {
00006a  4604              MOV      r4,r0
00006c  460d              MOV      r5,r1
00006e  4616              MOV      r6,r2
;;;149    #ifdef FMEMCOPY
;;;150      FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
000070  ea4f12c6          LSL      r2,r6,#7
000074  4621              MOV      r1,r4
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       __aeabi_memcpy
;;;151    #else
;;;152      register JCOEFPTR inptr, outptr;
;;;153      register long count;
;;;154    
;;;155      inptr = (JCOEFPTR) input_row;
;;;156      outptr = (JCOEFPTR) output_row;
;;;157      for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
;;;158        *outptr++ = *inptr++;
;;;159      }
;;;160    #endif
;;;161    }
00007c  bd70              POP      {r4-r6,pc}
;;;162    
                          ENDP

                  jzero_far PROC
;;;164    GLOBAL(void)
;;;165    jzero_far (void FAR * target, size_t bytestozero)
00007e  b570              PUSH     {r4-r6,lr}
;;;166    /* Zero out a chunk of FAR memory. */
;;;167    /* This might be sample-array data, block-array data, or alloc_large data. */
;;;168    {
000080  4604              MOV      r4,r0
000082  460d              MOV      r5,r1
;;;169    #ifdef FMEMZERO
;;;170      FMEMZERO(target, bytestozero);
000084  4629              MOV      r1,r5
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       __aeabi_memclr
;;;171    #else
;;;172      register char FAR * ptr = (char FAR *) target;
;;;173      register size_t count;
;;;174    
;;;175      for (count = bytestozero; count > 0; count--) {
;;;176        *ptr++ = 0;
;;;177      }
;;;178    #endif
;;;179    }
00008c  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  jpeg_natural_order
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000009
                          DCD      0x00000002
                          DCD      0x00000003
                          DCD      0x0000000a
                          DCD      0x00000011
                          DCD      0x00000018
                          DCD      0x00000020
                          DCD      0x00000019
                          DCD      0x00000012
                          DCD      0x0000000b
                          DCD      0x00000004
                          DCD      0x00000005
                          DCD      0x0000000c
                          DCD      0x00000013
                          DCD      0x0000001a
                          DCD      0x00000021
                          DCD      0x00000028
                          DCD      0x00000030
                          DCD      0x00000029
                          DCD      0x00000022
                          DCD      0x0000001b
                          DCD      0x00000014
                          DCD      0x0000000d
                          DCD      0x00000006
                          DCD      0x00000007
                          DCD      0x0000000e
                          DCD      0x00000015
                          DCD      0x0000001c
                          DCD      0x00000023
                          DCD      0x0000002a
                          DCD      0x00000031
                          DCD      0x00000038
                          DCD      0x00000039
                          DCD      0x00000032
                          DCD      0x0000002b
                          DCD      0x00000024
                          DCD      0x0000001d
                          DCD      0x00000016
                          DCD      0x0000000f
                          DCD      0x00000017
                          DCD      0x0000001e
                          DCD      0x00000025
                          DCD      0x0000002c
                          DCD      0x00000033
                          DCD      0x0000003a
                          DCD      0x0000003b
                          DCD      0x00000034
                          DCD      0x0000002d
                          DCD      0x00000026
                          DCD      0x0000001f
                          DCD      0x00000027
                          DCD      0x0000002e
                          DCD      0x00000035
                          DCD      0x0000003c
                          DCD      0x0000003d
                          DCD      0x00000036
                          DCD      0x0000002f
                          DCD      0x00000037
                          DCD      0x0000003e
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
                          DCD      0x0000003f
