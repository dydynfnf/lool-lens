; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\header.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\header.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\header.crf GUI\Widget\HEADER.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _DrawTriangle PROC
;;;100    */
;;;101    static void _DrawTriangle(int x, int y, int Size, int Inc) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;102      for (; Size >= 0; Size--, y += Inc) {
00000c  e007              B        |L1.30|
                  |L1.14|
;;;103        GUI_DrawHLine(y, x - Size, x + Size);
00000e  192a              ADDS     r2,r5,r4
000010  1b29              SUBS     r1,r5,r4
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       GUI_DrawHLine
000018  f1a40401          SUB      r4,r4,#1              ;102
00001c  443e              ADD      r6,r6,r7              ;102
                  |L1.30|
00001e  2c00              CMP      r4,#0                 ;102
000020  daf5              BGE      |L1.14|
;;;104      }
;;;105    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;106    
                          ENDP

                  _Paint PROC
;;;110    */
;;;111    static void _Paint(HEADER_Obj* pObj) {
000026  e92d4ff0          PUSH     {r4-r11,lr}
00002a  b089              SUB      sp,sp,#0x24
00002c  4605              MOV      r5,r0
;;;112      GUI_RECT Rect, RectItem;
;;;113      int i, xPos = -pObj->ScrollPos;
00002e  6be8              LDR      r0,[r5,#0x3c]
000030  f1c00900          RSB      r9,r0,#0
;;;114      int NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
000034  f1050030          ADD      r0,r5,#0x30
000038  f7fffffe          BL       GUI_ARRAY_GetNumItems
00003c  9004              STR      r0,[sp,#0x10]
;;;115      int EffectSize = pObj->Widget.pEffect->EffectSize;
00003e  6a28              LDR      r0,[r5,#0x20]
000040  6946              LDR      r6,[r0,#0x14]
;;;116      int ArrowSize, ArrowPos;
;;;117      LCD_SetBkColor(pObj->BkColor);
000042  6aa8              LDR      r0,[r5,#0x28]
000044  f7fffffe          BL       LCD_SetBkColor
;;;118      GUI_SetFont(pObj->pFont);
000048  6ce8              LDR      r0,[r5,#0x4c]
00004a  f7fffffe          BL       GUI_SetFont
;;;119      GUI_Clear();
00004e  f7fffffe          BL       GUI_Clear
;;;120      for (i = 0; i < NumItems; i++) {
000052  f04f0700          MOV      r7,#0
000056  e10c              B        |L1.626|
                  |L1.88|
;;;121        int Subtract = 0;
000058  f04f0b00          MOV      r11,#0
;;;122        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
00005c  4639              MOV      r1,r7
00005e  f1050030          ADD      r0,r5,#0x30
000062  f7fffffe          BL       GUI_ARRAY_GetpItem
000066  4604              MOV      r4,r0
;;;123        GUI_GetClientRect(&Rect);
000068  a807              ADD      r0,sp,#0x1c
00006a  f7fffffe          BL       GUI_GetClientRect
;;;124        Rect.x0 = xPos;
00006e  fa0ff089          SXTH     r0,r9
000072  f8ad001c          STRH     r0,[sp,#0x1c]
;;;125        Rect.x1 = Rect.x0 + pColumn->Width;
000076  f8bd001c          LDRH     r0,[sp,#0x1c]
00007a  6821              LDR      r1,[r4,#0]
00007c  4408              ADD      r0,r0,r1
00007e  b200              SXTH     r0,r0
000080  f8ad0020          STRH     r0,[sp,#0x20]
;;;126        RectItem = Rect;
000084  e9dd0107          LDRD     r0,r1,[sp,#0x1c]
000088  e9cd0105          STRD     r0,r1,[sp,#0x14]
;;;127        ArrowSize = ((RectItem.y1 - RectItem.y0 - EffectSize * 2) / 3) - 1;
00008c  f9bd001a          LDRSH    r0,[sp,#0x1a]
000090  f9bd1016          LDRSH    r1,[sp,#0x16]
000094  eba00001          SUB      r0,r0,r1
000098  eba00046          SUB      r0,r0,r6,LSL #1
00009c  f04f0103          MOV      r1,#3
0000a0  fb90f0f1          SDIV     r0,r0,r1
0000a4  f1a00801          SUB      r8,r0,#1
;;;128        ArrowPos = RectItem.x1 - 4 - ArrowSize;
0000a8  f9bd0018          LDRSH    r0,[sp,#0x18]
0000ac  f1a00004          SUB      r0,r0,#4
0000b0  eba00a08          SUB      r10,r0,r8
;;;129        if (pColumn->hDrawObj) {
0000b4  88e0              LDRH     r0,[r4,#6]
0000b6  2800              CMP      r0,#0
0000b8  d060              BEQ      |L1.380|
;;;130          int xOff = 0, yOff = 0;
0000ba  f04f0000          MOV      r0,#0
0000be  9003              STR      r0,[sp,#0xc]
0000c0  9002              STR      r0,[sp,#8]
;;;131          switch (pColumn->Align & GUI_TA_HORIZONTAL) {
0000c2  88a0              LDRH     r0,[r4,#4]
0000c4  f0000003          AND      r0,r0,#3
0000c8  2801              CMP      r0,#1
0000ca  d002              BEQ      |L1.210|
0000cc  2802              CMP      r0,#2
0000ce  d117              BNE      |L1.256|
0000d0  e008              B        |L1.228|
                  |L1.210|
;;;132            case GUI_TA_RIGHT:
;;;133              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj));
0000d2  f9b40006          LDRSH    r0,[r4,#6]
0000d6  f7fffffe          BL       GUI_DRAW__GetXSize
0000da  6821              LDR      r1,[r4,#0]
0000dc  eba10000          SUB      r0,r1,r0
0000e0  9003              STR      r0,[sp,#0xc]
;;;134              break;
0000e2  e00d              B        |L1.256|
                  |L1.228|
;;;135            case GUI_TA_HCENTER:
;;;136              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj)) / 2;
0000e4  f9b40006          LDRSH    r0,[r4,#6]
0000e8  f7fffffe          BL       GUI_DRAW__GetXSize
0000ec  6821              LDR      r1,[r4,#0]
0000ee  eba10000          SUB      r0,r1,r0
0000f2  9001              STR      r0,[sp,#4]
0000f4  eb0070d0          ADD      r0,r0,r0,LSR #31
0000f8  ea4f0060          ASR      r0,r0,#1
0000fc  9003              STR      r0,[sp,#0xc]
;;;137              break;
0000fe  bf00              NOP      
                  |L1.256|
000100  bf00              NOP                            ;134
;;;138          }
;;;139          switch (pColumn->Align & GUI_TA_VERTICAL) {
000102  88a0              LDRH     r0,[r4,#4]
000104  f000000c          AND      r0,r0,#0xc
000108  2804              CMP      r0,#4
00010a  d002              BEQ      |L1.274|
00010c  280c              CMP      r0,#0xc
00010e  d125              BNE      |L1.348|
000110  e00f              B        |L1.306|
                  |L1.274|
;;;140    	      case GUI_TA_BOTTOM:
;;;141              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj));
000112  f9b40006          LDRSH    r0,[r4,#6]
000116  f7fffffe          BL       GUI_DRAW__GetYSize
00011a  f9bd1022          LDRSH    r1,[sp,#0x22]
00011e  f9bd201e          LDRSH    r2,[sp,#0x1e]
000122  eba10102          SUB      r1,r1,r2
000126  f1010101          ADD      r1,r1,#1
00012a  eba10000          SUB      r0,r1,r0
00012e  9002              STR      r0,[sp,#8]
;;;142              break;
000130  e014              B        |L1.348|
                  |L1.306|
;;;143    	      case GUI_TA_VCENTER:
;;;144              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj)) / 2;
000132  f9b40006          LDRSH    r0,[r4,#6]
000136  f7fffffe          BL       GUI_DRAW__GetYSize
00013a  f9bd1022          LDRSH    r1,[sp,#0x22]
00013e  f9bd201e          LDRSH    r2,[sp,#0x1e]
000142  eba10102          SUB      r1,r1,r2
000146  f1010101          ADD      r1,r1,#1
00014a  eba10000          SUB      r0,r1,r0
00014e  9001              STR      r0,[sp,#4]
000150  eb0070d0          ADD      r0,r0,r0,LSR #31
000154  ea4f0060          ASR      r0,r0,#1
000158  9002              STR      r0,[sp,#8]
;;;145              break;
00015a  bf00              NOP      
                  |L1.348|
00015c  bf00              NOP                            ;142
;;;146          }
;;;147          WM_SetUserClipRect(&Rect);
00015e  a807              ADD      r0,sp,#0x1c
000160  f7fffffe          BL       WM_SetUserClipRect
;;;148          GUI_DRAW__Draw(pColumn->hDrawObj, xPos + xOff, yOff);
000164  9a03              LDR      r2,[sp,#0xc]
000166  eb090102          ADD      r1,r9,r2
00016a  f9b40006          LDRSH    r0,[r4,#6]
00016e  9a02              LDR      r2,[sp,#8]
000170  f7fffffe          BL       GUI_DRAW__Draw
;;;149          WM_SetUserClipRect(NULL);
000174  2000              MOVS     r0,#0
000176  f7fffffe          BL       WM_SetUserClipRect
;;;150        }
00017a  bf00              NOP      
                  |L1.380|
;;;151        WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
00017c  a907              ADD      r1,sp,#0x1c
00017e  4628              MOV      r0,r5
000180  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;152        xPos += Rect.x1 - Rect.x0;
000184  f9bd0020          LDRSH    r0,[sp,#0x20]
000188  f9bd101c          LDRSH    r1,[sp,#0x1c]
00018c  eba00001          SUB      r0,r0,r1
000190  4481              ADD      r9,r9,r0
;;;153        Rect.x0 += EffectSize + _DefaultBorderH;
000192  f8bd001c          LDRH     r0,[sp,#0x1c]
000196  49fe              LDR      r1,|L1.1424|
000198  6809              LDR      r1,[r1,#0]  ; _DefaultBorderH
00019a  4431              ADD      r1,r1,r6
00019c  4408              ADD      r0,r0,r1
00019e  b200              SXTH     r0,r0
0001a0  f8ad001c          STRH     r0,[sp,#0x1c]
;;;154        Rect.x1 -= EffectSize + _DefaultBorderH;
0001a4  f8bd0020          LDRH     r0,[sp,#0x20]
0001a8  49f9              LDR      r1,|L1.1424|
0001aa  6809              LDR      r1,[r1,#0]  ; _DefaultBorderH
0001ac  4431              ADD      r1,r1,r6
0001ae  eba00001          SUB      r0,r0,r1
0001b2  b200              SXTH     r0,r0
0001b4  f8ad0020          STRH     r0,[sp,#0x20]
;;;155        Rect.y0 += EffectSize + _DefaultBorderV;
0001b8  f8bd001e          LDRH     r0,[sp,#0x1e]
0001bc  49f5              LDR      r1,|L1.1428|
0001be  6809              LDR      r1,[r1,#0]  ; _DefaultBorderV
0001c0  4431              ADD      r1,r1,r6
0001c2  4408              ADD      r0,r0,r1
0001c4  b200              SXTH     r0,r0
0001c6  f8ad001e          STRH     r0,[sp,#0x1e]
;;;156        Rect.y1 -= EffectSize + _DefaultBorderV;
0001ca  f8bd0022          LDRH     r0,[sp,#0x22]
0001ce  49f1              LDR      r1,|L1.1428|
0001d0  6809              LDR      r1,[r1,#0]  ; _DefaultBorderV
0001d2  4431              ADD      r1,r1,r6
0001d4  eba00001          SUB      r0,r0,r1
0001d8  b200              SXTH     r0,r0
0001da  f8ad0022          STRH     r0,[sp,#0x22]
;;;157        LCD_SetColor(pObj->TextColor);
0001de  6ae8              LDR      r0,[r5,#0x2c]
0001e0  f7fffffe          BL       LCD_SetColor
;;;158        if ((pObj->DirIndicatorColumn == i) && ((pColumn->Align & GUI_TA_HORIZONTAL) == GUI_TA_RIGHT)) {
0001e4  6c68              LDR      r0,[r5,#0x44]
0001e6  42b8              CMP      r0,r7
0001e8  d106              BNE      |L1.504|
0001ea  88a0              LDRH     r0,[r4,#4]
0001ec  f0000003          AND      r0,r0,#3
0001f0  2801              CMP      r0,#1
0001f2  d101              BNE      |L1.504|
;;;159          Subtract = (ArrowSize << 1) + 1;
0001f4  eb000b48          ADD      r11,r0,r8,LSL #1
                  |L1.504|
;;;160        }
;;;161        Rect.x1 -= Subtract;
0001f8  f8bd0020          LDRH     r0,[sp,#0x20]
0001fc  eba0000b          SUB      r0,r0,r11
000200  b200              SXTH     r0,r0
000202  f8ad0020          STRH     r0,[sp,#0x20]
;;;162        GUI_DispStringInRect(pColumn->acText, &Rect, pColumn->Align);
000206  f9b42004          LDRSH    r2,[r4,#4]
00020a  a907              ADD      r1,sp,#0x1c
00020c  f1040008          ADD      r0,r4,#8
000210  f7fffffe          BL       GUI_DispStringInRect
;;;163        Rect.x1 += Subtract;
000214  f8bd0020          LDRH     r0,[sp,#0x20]
000218  4458              ADD      r0,r0,r11
00021a  b200              SXTH     r0,r0
00021c  f8ad0020          STRH     r0,[sp,#0x20]
;;;164        if (pObj->DirIndicatorColumn == i) {
000220  6c68              LDR      r0,[r5,#0x44]
000222  42b8              CMP      r0,r7
000224  d123              BNE      |L1.622|
;;;165          LCD_SetColor(GUI_BLACK);
000226  2000              MOVS     r0,#0
000228  f7fffffe          BL       LCD_SetColor
;;;166          WM_SetUserClipRect(&RectItem);
00022c  a805              ADD      r0,sp,#0x14
00022e  f7fffffe          BL       WM_SetUserClipRect
;;;167          if (pObj->DirIndicatorReverse == 0) {
000232  6ca8              LDR      r0,[r5,#0x48]
000234  b958              CBNZ     r0,|L1.590|
;;;168            _DrawTriangle(ArrowPos, ((Rect.y1 - Rect.y0) >> 1), ArrowSize, 1);
000236  f9bd0022          LDRSH    r0,[sp,#0x22]
00023a  f9bd201e          LDRSH    r2,[sp,#0x1e]
00023e  1a80              SUBS     r0,r0,r2
000240  1041              ASRS     r1,r0,#1
000242  2301              MOVS     r3,#1
000244  4642              MOV      r2,r8
000246  4650              MOV      r0,r10
000248  f7fffffe          BL       _DrawTriangle
00024c  e00c              B        |L1.616|
                  |L1.590|
;;;169          } else {
;;;170            _DrawTriangle(ArrowPos, ((Rect.y1 - Rect.y0) >> 1) + ArrowSize, ArrowSize, -1);
00024e  f9bd0022          LDRSH    r0,[sp,#0x22]
000252  f9bd201e          LDRSH    r2,[sp,#0x1e]
000256  1a80              SUBS     r0,r0,r2
000258  eb080160          ADD      r1,r8,r0,ASR #1
00025c  f04f33ff          MOV      r3,#0xffffffff
000260  4642              MOV      r2,r8
000262  4650              MOV      r0,r10
000264  f7fffffe          BL       _DrawTriangle
                  |L1.616|
;;;171          }
;;;172          WM_SetUserClipRect(NULL);
000268  2000              MOVS     r0,#0
00026a  f7fffffe          BL       WM_SetUserClipRect
                  |L1.622|
00026e  f1070701          ADD      r7,r7,#1              ;120
                  |L1.626|
000272  9804              LDR      r0,[sp,#0x10]         ;120
000274  4287              CMP      r7,r0                 ;120
000276  f6ffaeef          BLT      |L1.88|
;;;173        }
;;;174      }
;;;175      GUI_GetClientRect(&Rect);
00027a  a807              ADD      r0,sp,#0x1c
00027c  f7fffffe          BL       GUI_GetClientRect
;;;176      Rect.x0 = xPos;
000280  fa0ff089          SXTH     r0,r9
000284  f8ad001c          STRH     r0,[sp,#0x1c]
;;;177      Rect.x1 = 0xfff;
000288  f64070ff          MOV      r0,#0xfff
00028c  f8ad0020          STRH     r0,[sp,#0x20]
;;;178      WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
000290  a907              ADD      r1,sp,#0x1c
000292  4628              MOV      r0,r5
000294  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;179    }
000298  b009              ADD      sp,sp,#0x24
00029a  e8bd8ff0          POP      {r4-r11,pc}
;;;180    
                          ENDP

                  _RestoreOldCursor PROC
;;;184    */
;;;185    static void _RestoreOldCursor(void) {
00029e  48be              LDR      r0,|L1.1432|
;;;186      if (_pOldCursor) {
0002a0  6800              LDR      r0,[r0,#0]  ; _pOldCursor
0002a2  b118              CBZ      r0,|L1.684|
;;;187        #if GUI_SUPPORT_CURSOR
;;;188          GUI_CURSOR_Select(_pOldCursor);
;;;189        #endif
;;;190        _pOldCursor = 0;
0002a4  f04f0000          MOV      r0,#0
0002a8  49bb              LDR      r1,|L1.1432|
0002aa  6008              STR      r0,[r1,#0]  ; _pOldCursor
                  |L1.684|
;;;191      }
;;;192    }
0002ac  4770              BX       lr
;;;193    
                          ENDP

                  _FreeAttached PROC
;;;199    */
;;;200    static void _FreeAttached(HEADER_Obj * pObj) {
0002ae  e92d41f0          PUSH     {r4-r8,lr}
0002b2  4604              MOV      r4,r0
;;;201      int i, NumItems;
;;;202      NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
0002b4  f1040030          ADD      r0,r4,#0x30
0002b8  f7fffffe          BL       GUI_ARRAY_GetNumItems
0002bc  4607              MOV      r7,r0
;;;203      for (i = 0; i < NumItems; i++) {
0002be  f04f0500          MOV      r5,#0
0002c2  e00d              B        |L1.736|
                  |L1.708|
;;;204        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
0002c4  4629              MOV      r1,r5
0002c6  f1040030          ADD      r0,r4,#0x30
0002ca  f7fffffe          BL       GUI_ARRAY_GetpItem
0002ce  4606              MOV      r6,r0
;;;205        if (pColumn->hDrawObj) {
0002d0  88f0              LDRH     r0,[r6,#6]
0002d2  b118              CBZ      r0,|L1.732|
;;;206          GUI_ALLOC_Free(pColumn->hDrawObj);
0002d4  f9b60006          LDRSH    r0,[r6,#6]
0002d8  f7fffffe          BL       GUI_ALLOC_Free
                  |L1.732|
0002dc  f1050501          ADD      r5,r5,#1              ;203
                  |L1.736|
0002e0  42bd              CMP      r5,r7                 ;203
0002e2  dbef              BLT      |L1.708|
;;;207        }
;;;208      }
;;;209      /* Delete attached objects (if any) */
;;;210      GUI_ARRAY_Delete(&pObj->Columns);
0002e4  f1040030          ADD      r0,r4,#0x30
0002e8  f7fffffe          BL       GUI_ARRAY_Delete
;;;211      _RestoreOldCursor();
0002ec  f7fffffe          BL       _RestoreOldCursor
;;;212    }
0002f0  e8bd81f0          POP      {r4-r8,pc}
;;;213    
                          ENDP

                  _GetDividerIndex PROC
;;;218    #if (HEADER_SUPPORT_DRAG)
;;;219    static int _GetDividerIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
0002f4  e92d4ff8          PUSH     {r3-r11,lr}
0002f8  4681              MOV      r9,r0
0002fa  460d              MOV      r5,r1
0002fc  4616              MOV      r6,r2
0002fe  4698              MOV      r8,r3
;;;220      int Item = -1;
000300  f04f30ff          MOV      r0,#0xffffffff
000304  9000              STR      r0,[sp,#0]
;;;221      if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
000306  f1b80f00          CMP      r8,#0
00030a  db37              BLT      |L1.892|
00030c  4648              MOV      r0,r9
00030e  f7fffffe          BL       WM_GetWindowSizeY
000312  4540              CMP      r0,r8
000314  dd32              BLE      |L1.892|
;;;222        if (hObj) {
000316  f1b90f00          CMP      r9,#0
00031a  d02f              BEQ      |L1.892|
;;;223          int Index, xPos = 0, NumColumns;
00031c  f04f0700          MOV      r7,#0
;;;224          NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
000320  f1050030          ADD      r0,r5,#0x30
000324  f7fffffe          BL       GUI_ARRAY_GetNumItems
000328  4682              MOV      r10,r0
;;;225          for (Index = 0; Index < NumColumns; Index++) {
00032a  463c              MOV      r4,r7
00032c  e022              B        |L1.884|
                  |L1.814|
;;;226            HEADER_COLUMN * pColumn;
;;;227            pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
00032e  4621              MOV      r1,r4
000330  f1050030          ADD      r0,r5,#0x30
000334  f7fffffe          BL       GUI_ARRAY_GetpItem
000338  4683              MOV      r11,r0
;;;228            xPos += pColumn->Width;
00033a  f8db0000          LDR      r0,[r11,#0]
00033e  4407              ADD      r7,r7,r0
;;;229            if ((xPos >= (x - 4)) && (xPos <= (x + 4))) {
000340  f1a60004          SUB      r0,r6,#4
000344  42b8              CMP      r0,r7
000346  dc13              BGT      |L1.880|
000348  1d30              ADDS     r0,r6,#4
00034a  4287              CMP      r7,r0
00034c  dc10              BGT      |L1.880|
;;;230              Item = Index;
00034e  9400              STR      r4,[sp,#0]
;;;231              if ((Index < (NumColumns - 1)) && (x < xPos)) {
000350  f1aa0001          SUB      r0,r10,#1
000354  42a0              CMP      r0,r4
000356  dd0b              BLE      |L1.880|
000358  42be              CMP      r6,r7
00035a  da09              BGE      |L1.880|
;;;232                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index + 1);
00035c  1c61              ADDS     r1,r4,#1
00035e  f1050030          ADD      r0,r5,#0x30
000362  f7fffffe          BL       GUI_ARRAY_GetpItem
000366  4683              MOV      r11,r0
;;;233                if (pColumn->Width == 0) {
000368  f8db0000          LDR      r0,[r11,#0]
00036c  b900              CBNZ     r0,|L1.880|
;;;234                  break;
00036e  e003              B        |L1.888|
                  |L1.880|
000370  f1040401          ADD      r4,r4,#1              ;225
                  |L1.884|
000374  4554              CMP      r4,r10                ;225
000376  dbda              BLT      |L1.814|
                  |L1.888|
000378  bf00              NOP      
;;;235                }
;;;236              }
;;;237            }
;;;238          }
;;;239        }
00037a  bf00              NOP      
                  |L1.892|
;;;240      }
;;;241      return Item;
00037c  9800              LDR      r0,[sp,#0]
;;;242    }
00037e  e8bd8ff8          POP      {r3-r11,pc}
;;;243    #endif
                          ENDP

                  HEADER_SetItemWidth PROC
;;;792    */
;;;793    void HEADER_SetItemWidth(HEADER_Handle hObj, unsigned int Index, int Width) {
000382  e92d43fe          PUSH     {r1-r9,lr}
000386  4604              MOV      r4,r0
000388  460e              MOV      r6,r1
00038a  4615              MOV      r5,r2
;;;794      if (hObj && (Width >= 0)) {
00038c  b38c              CBZ      r4,|L1.1010|
00038e  2d00              CMP      r5,#0
000390  db2f              BLT      |L1.1010|
;;;795        HEADER_Obj * pObj;
;;;796        WM_LOCK();
;;;797        pObj = HEADER_H2P(hObj);
000392  4620              MOV      r0,r4
000394  f7fffffe          BL       GUI_ALLOC_h2p
000398  4607              MOV      r7,r0
;;;798        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
00039a  f1070030          ADD      r0,r7,#0x30
00039e  f7fffffe          BL       GUI_ARRAY_GetNumItems
0003a2  42b0              CMP      r0,r6
0003a4  d324              BCC      |L1.1008|
;;;799          HEADER_COLUMN * pColumn;
;;;800          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
0003a6  4631              MOV      r1,r6
0003a8  f1070030          ADD      r0,r7,#0x30
0003ac  f7fffffe          BL       GUI_ARRAY_GetpItem
0003b0  4680              MOV      r8,r0
;;;801          if (pColumn) {
0003b2  f1b80f00          CMP      r8,#0
0003b6  d01a              BEQ      |L1.1006|
;;;802            WM_MESSAGE Msg;
;;;803            pColumn->Width = Width;
0003b8  f8c85000          STR      r5,[r8,#0]
;;;804            Msg.hWin  = WM_GetParent(hObj);
0003bc  4620              MOV      r0,r4
0003be  f7fffffe          BL       WM_GetParent
0003c2  f8ad0004          STRH     r0,[sp,#4]
;;;805            Msg.MsgId = WM_NOTIFY_CLIENTCHANGE;
0003c6  f04f0025          MOV      r0,#0x25
0003ca  9000              STR      r0,[sp,#0]
;;;806            Msg.hWinSrc = hObj;
0003cc  f8ad4006          STRH     r4,[sp,#6]
;;;807            WM_InvalidateWindow(hObj);
0003d0  4620              MOV      r0,r4
0003d2  f7fffffe          BL       WM_InvalidateWindow
;;;808            WM__SendMessage(Msg.hWin, &Msg);
0003d6  f9bd0004          LDRSH    r0,[sp,#4]
0003da  4669              MOV      r1,sp
0003dc  f7fffffe          BL       WM__SendMessage
;;;809            //WM__SendMsgNoData(WM_GetParent(hObj), WM_NOTIFY_CLIENTCHANGE);
;;;810            WM_InvalidateWindow(WM_GetParent(hObj));
0003e0  4620              MOV      r0,r4
0003e2  f7fffffe          BL       WM_GetParent
0003e6  4681              MOV      r9,r0
0003e8  f7fffffe          BL       WM_InvalidateWindow
;;;811          }
0003ec  bf00              NOP      
                  |L1.1006|
;;;812        }
0003ee  bf00              NOP      
                  |L1.1008|
;;;813        WM_UNLOCK();
;;;814      }
0003f0  bf00              NOP      
                  |L1.1010|
;;;815    }
0003f2  e8bd83fe          POP      {r1-r9,pc}
;;;816    
                          ENDP

                  HEADER_GetItemWidth PROC
;;;835    */
;;;836    int HEADER_GetItemWidth(HEADER_Handle hObj, unsigned int Index) {
0003f6  e92d41f0          PUSH     {r4-r8,lr}
0003fa  4604              MOV      r4,r0
0003fc  460d              MOV      r5,r1
;;;837      int Width = 0;
0003fe  f04f0700          MOV      r7,#0
;;;838      if (hObj) {
000402  b19c              CBZ      r4,|L1.1068|
;;;839        HEADER_Obj * pObj;
;;;840        WM_LOCK();
;;;841        pObj = HEADER_H2P(hObj);
000404  4620              MOV      r0,r4
000406  f7fffffe          BL       GUI_ALLOC_h2p
00040a  4606              MOV      r6,r0
;;;842        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
00040c  f1060030          ADD      r0,r6,#0x30
000410  f7fffffe          BL       GUI_ARRAY_GetNumItems
000414  42a8              CMP      r0,r5
000416  d308              BCC      |L1.1066|
;;;843          HEADER_COLUMN * pColumn;
;;;844          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000418  4629              MOV      r1,r5
00041a  f1060030          ADD      r0,r6,#0x30
00041e  f7fffffe          BL       GUI_ARRAY_GetpItem
000422  4680              MOV      r8,r0
;;;845          Width = pColumn->Width;
000424  f8d87000          LDR      r7,[r8,#0]
;;;846        }
000428  bf00              NOP      
                  |L1.1066|
;;;847        WM_UNLOCK();
;;;848      }
00042a  bf00              NOP      
                  |L1.1068|
;;;849      return Width;
00042c  4638              MOV      r0,r7
;;;850    }
00042e  e8bd81f0          POP      {r4-r8,pc}
;;;851    
                          ENDP

                  _LimitDragWitdh PROC
;;;255    */
;;;256    static int _LimitDragWitdh(HEADER_Handle hObj, HEADER_Obj * pObj) {
000432  e92d5ffc          PUSH     {r2-r12,lr}
000436  4681              MOV      r9,r0
000438  460d              MOV      r5,r1
;;;257      if (pObj->DragLimit) {
00043a  f8950050          LDRB     r0,[r5,#0x50]
00043e  2800              CMP      r0,#0
000440  d043              BEQ      |L1.1226|
;;;258        int DragLimit, i, SumX;
;;;259        GUI_RECT Rect;
;;;260        WM_HWIN hVScroll, hParent;
;;;261        /* Take the x-size of the widgets client rectangle as limit */
;;;262        WM_GetClientRectEx(hObj, &Rect);
000442  4669              MOV      r1,sp
000444  4648              MOV      r0,r9
000446  f7fffffe          BL       WM_GetClientRectEx
;;;263        DragLimit = Rect.x1;
00044a  f9bd7004          LDRSH    r7,[sp,#4]
;;;264        /* If the parent window has a vertical scrollbar, reduce the drag limit by the xsize of the scrollbar */
;;;265        hParent = WM_GetParent(hObj);
00044e  4648              MOV      r0,r9
000450  f7fffffe          BL       WM_GetParent
000454  4682              MOV      r10,r0
;;;266        if (hParent) {
000456  f1ba0f00          CMP      r10,#0
00045a  d00e              BEQ      |L1.1146|
;;;267          hVScroll = WM_GetScrollbarV(WM_GetParent(hObj));
00045c  4648              MOV      r0,r9
00045e  f7fffffe          BL       WM_GetParent
000462  4683              MOV      r11,r0
000464  f7fffffe          BL       WM_GetScrollbarV
000468  4680              MOV      r8,r0
;;;268          if (hVScroll) {
00046a  f1b80f00          CMP      r8,#0
00046e  d004              BEQ      |L1.1146|
;;;269            DragLimit -= WM_GetWindowSizeX(hVScroll);
000470  4640              MOV      r0,r8
000472  f7fffffe          BL       WM_GetWindowSizeX
000476  eba70700          SUB      r7,r7,r0
                  |L1.1146|
;;;270          }
;;;271        }
;;;272        /* Calculate the sum of the width of all header items */
;;;273        for (SumX = i = 0; i <= pObj->CaptureItem; i++) {
00047a  f04f0400          MOV      r4,#0
00047e  4626              MOV      r6,r4
000480  e006              B        |L1.1168|
                  |L1.1154|
;;;274          SumX += HEADER_GetItemWidth(hObj, i);
000482  4621              MOV      r1,r4
000484  4648              MOV      r0,r9
000486  f7fffffe          BL       HEADER_GetItemWidth
00048a  4406              ADD      r6,r6,r0
00048c  f1040401          ADD      r4,r4,#1              ;273
                  |L1.1168|
000490  6ba8              LDR      r0,[r5,#0x38]         ;273
000492  42a0              CMP      r0,r4                 ;273
000494  daf5              BGE      |L1.1154|
;;;275        }
;;;276        /* If the sum of the width of all header items exeeds the limit, limit the captured item */
;;;277        if (SumX > DragLimit) {
000496  42be              CMP      r6,r7
000498  dd16              BLE      |L1.1224|
;;;278          for (SumX = i = 0; i < pObj->CaptureItem; i++) {
00049a  f04f0000          MOV      r0,#0
00049e  4604              MOV      r4,r0
0004a0  4606              MOV      r6,r0
0004a2  e006              B        |L1.1202|
                  |L1.1188|
;;;279            SumX += HEADER_GetItemWidth(hObj, i);
0004a4  4621              MOV      r1,r4
0004a6  4648              MOV      r0,r9
0004a8  f7fffffe          BL       HEADER_GetItemWidth
0004ac  4406              ADD      r6,r6,r0
0004ae  f1040401          ADD      r4,r4,#1              ;278
                  |L1.1202|
0004b2  6ba8              LDR      r0,[r5,#0x38]         ;278
0004b4  42a0              CMP      r0,r4                 ;278
0004b6  dcf5              BGT      |L1.1188|
;;;280          }
;;;281          HEADER_SetItemWidth(hObj, pObj->CaptureItem, DragLimit - SumX);
0004b8  1bba              SUBS     r2,r7,r6
0004ba  4648              MOV      r0,r9
0004bc  6ba9              LDR      r1,[r5,#0x38]
0004be  f7fffffe          BL       HEADER_SetItemWidth
;;;282          return 1;
0004c2  2001              MOVS     r0,#1
                  |L1.1220|
;;;283        }
;;;284      }
;;;285      return 0;
;;;286    }
0004c4  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.1224|
0004c8  bf00              NOP                            ;284
                  |L1.1226|
0004ca  2000              MOVS     r0,#0                 ;285
0004cc  e7fa              B        |L1.1220|
;;;287    
                          ENDP

                  _HandlePID PROC
;;;292    #if (HEADER_SUPPORT_DRAG)
;;;293    static void _HandlePID(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y, int Pressed) {
0004ce  e92d47f0          PUSH     {r4-r10,lr}
0004d2  4681              MOV      r9,r0
0004d4  460c              MOV      r4,r1
0004d6  4615              MOV      r5,r2
0004d8  469a              MOV      r10,r3
0004da  9e08              LDR      r6,[sp,#0x20]
;;;294      int Hit = _GetDividerIndex(hObj, pObj, x, y);
0004dc  4653              MOV      r3,r10
0004de  462a              MOV      r2,r5
0004e0  4621              MOV      r1,r4
0004e2  4648              MOV      r0,r9
0004e4  f7fffffe          BL       _GetDividerIndex
0004e8  4607              MOV      r7,r0
;;;295      /* set capture position */
;;;296      if ((Pressed == 1) && (Hit >= 0) && (pObj->CapturePosX == -1)) {
0004ea  2e01              CMP      r6,#1
0004ec  d106              BNE      |L1.1276|
0004ee  2f00              CMP      r7,#0
0004f0  db04              BLT      |L1.1276|
0004f2  6b60              LDR      r0,[r4,#0x34]
0004f4  1c40              ADDS     r0,r0,#1
0004f6  d101              BNE      |L1.1276|
;;;297        pObj->CapturePosX = x;
0004f8  6365              STR      r5,[r4,#0x34]
;;;298        pObj->CaptureItem = Hit;
0004fa  63a7              STR      r7,[r4,#0x38]
                  |L1.1276|
;;;299      }
;;;300      if (Pressed <= 0) {
0004fc  2e00              CMP      r6,#0
0004fe  dc02              BGT      |L1.1286|
;;;301        pObj->CapturePosX = -1;
000500  f04f30ff          MOV      r0,#0xffffffff
000504  6360              STR      r0,[r4,#0x34]
                  |L1.1286|
;;;302      }
;;;303      /* set mouse cursor and capture */
;;;304      if (Hit >= 0) {
000506  2f00              CMP      r7,#0
000508  db03              BLT      |L1.1298|
;;;305        WM_SetCapture(hObj, 1);
00050a  2101              MOVS     r1,#1
00050c  4648              MOV      r0,r9
00050e  f7fffffe          BL       WM_SetCapture
                  |L1.1298|
;;;306        #if GUI_SUPPORT_CURSOR
;;;307          if (!_pOldCursor) {
;;;308            _pOldCursor = GUI_CURSOR_Select(_pDefaultCursor);
;;;309          }
;;;310        #endif
;;;311      }
;;;312      /* modify header */
;;;313      if ((pObj->CapturePosX >= 0) && (x != pObj->CapturePosX) && (Pressed == 1)) {
000512  6b60              LDR      r0,[r4,#0x34]
000514  2800              CMP      r0,#0
000516  db1b              BLT      |L1.1360|
000518  6b60              LDR      r0,[r4,#0x34]
00051a  42a8              CMP      r0,r5
00051c  d018              BEQ      |L1.1360|
00051e  2e01              CMP      r6,#1
000520  d116              BNE      |L1.1360|
;;;314        int NewSize = HEADER_GetItemWidth(hObj, pObj->CaptureItem) + x - pObj->CapturePosX;
000522  4648              MOV      r0,r9
000524  6ba1              LDR      r1,[r4,#0x38]
000526  f7fffffe          BL       HEADER_GetItemWidth
00052a  4428              ADD      r0,r0,r5
00052c  6b61              LDR      r1,[r4,#0x34]
00052e  eba00801          SUB      r8,r0,r1
;;;315        if (NewSize >= 0) {
000532  f1b80f00          CMP      r8,#0
000536  db0a              BLT      |L1.1358|
;;;316          HEADER_SetItemWidth(hObj, pObj->CaptureItem, NewSize);
000538  4642              MOV      r2,r8
00053a  4648              MOV      r0,r9
00053c  6ba1              LDR      r1,[r4,#0x38]
00053e  f7fffffe          BL       HEADER_SetItemWidth
;;;317          if (!_LimitDragWitdh(hObj, pObj)) {
000542  4621              MOV      r1,r4
000544  4648              MOV      r0,r9
000546  f7fffffe          BL       _LimitDragWitdh
00054a  b900              CBNZ     r0,|L1.1358|
;;;318            pObj->CapturePosX = x;
00054c  6365              STR      r5,[r4,#0x34]
                  |L1.1358|
;;;319          }
;;;320        }
;;;321      }
00054e  bf00              NOP      
                  |L1.1360|
;;;322      /* release capture & restore cursor */
;;;323      if (Pressed <= 0) {
000550  2e00              CMP      r6,#0
000552  dc06              BGT      |L1.1378|
;;;324        #if (GUI_SUPPORT_MOUSE)
;;;325        if (Hit == -1)
;;;326        #endif
;;;327        {
;;;328          _RestoreOldCursor();
000554  f7fffffe          BL       _RestoreOldCursor
;;;329          pObj->CapturePosX = -1;
000558  f04f30ff          MOV      r0,#0xffffffff
00055c  6360              STR      r0,[r4,#0x34]
;;;330          WM_ReleaseCapture();
00055e  f7fffffe          BL       WM_ReleaseCapture
                  |L1.1378|
;;;331        }
;;;332      }
;;;333    }
000562  e8bd87f0          POP      {r4-r10,pc}
;;;334    #endif
                          ENDP

                  _GetItemIndex PROC
;;;352    */
;;;353    static int _GetItemIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
000566  e92d4ff8          PUSH     {r3-r11,lr}
00056a  4681              MOV      r9,r0
00056c  460d              MOV      r5,r1
00056e  4616              MOV      r6,r2
000570  461f              MOV      r7,r3
;;;354      int Item = -1;
000572  f04f30ff          MOV      r0,#0xffffffff
000576  9000              STR      r0,[sp,#0]
;;;355      if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
000578  2f00              CMP      r7,#0
00057a  db33              BLT      |L1.1508|
00057c  4648              MOV      r0,r9
00057e  f7fffffe          BL       WM_GetWindowSizeY
000582  42b8              CMP      r0,r7
000584  dd2e              BLE      |L1.1508|
;;;356        if (hObj) {
000586  f1b90f00          CMP      r9,#0
00058a  d02b              BEQ      |L1.1508|
;;;357          int Index, xPos = 0, NumColumns;
00058c  e006              B        |L1.1436|
00058e  0000              DCW      0x0000
                  |L1.1424|
                          DCD      _DefaultBorderH
                  |L1.1428|
                          DCD      _DefaultBorderV
                  |L1.1432|
                          DCD      _pOldCursor
                  |L1.1436|
00059c  f04f0800          MOV      r8,#0
;;;358          NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
0005a0  f1050030          ADD      r0,r5,#0x30
0005a4  f7fffffe          BL       GUI_ARRAY_GetNumItems
0005a8  4683              MOV      r11,r0
;;;359          for (Index = 0; Index < NumColumns; Index++) {
0005aa  4644              MOV      r4,r8
0005ac  e016              B        |L1.1500|
                  |L1.1454|
;;;360            HEADER_COLUMN * pColumn;
;;;361            pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
0005ae  4621              MOV      r1,r4
0005b0  f1050030          ADD      r0,r5,#0x30
0005b4  f7fffffe          BL       GUI_ARRAY_GetpItem
0005b8  4682              MOV      r10,r0
;;;362            if ((x > (xPos + 4)) && (x < (xPos + pColumn->Width - 4))) {
0005ba  f1080004          ADD      r0,r8,#4
0005be  4286              CMP      r6,r0
0005c0  dd07              BLE      |L1.1490|
0005c2  f8da0000          LDR      r0,[r10,#0]
0005c6  4440              ADD      r0,r0,r8
0005c8  1f00              SUBS     r0,r0,#4
0005ca  42b0              CMP      r0,r6
0005cc  dd01              BLE      |L1.1490|
;;;363              Item = Index;
0005ce  9400              STR      r4,[sp,#0]
;;;364              break;
0005d0  e006              B        |L1.1504|
                  |L1.1490|
;;;365            }
;;;366            xPos += pColumn->Width;
0005d2  f8da0000          LDR      r0,[r10,#0]
0005d6  4480              ADD      r8,r8,r0
0005d8  f1040401          ADD      r4,r4,#1              ;359
                  |L1.1500|
0005dc  455c              CMP      r4,r11                ;359
0005de  dbe6              BLT      |L1.1454|
                  |L1.1504|
0005e0  bf00              NOP                            ;364
;;;367          }
;;;368        }
0005e2  bf00              NOP      
                  |L1.1508|
;;;369      }
;;;370      return Item;
0005e4  9800              LDR      r0,[sp,#0]
;;;371    }
0005e6  e8bd8ff8          POP      {r3-r11,pc}
;;;372    
                          ENDP

                  _OnTouch PROC
;;;377    #if (HEADER_SUPPORT_DRAG)
;;;378    static void _OnTouch(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
0005ea  e92d43f8          PUSH     {r3-r9,lr}
0005ee  4680              MOV      r8,r0
0005f0  460f              MOV      r7,r1
0005f2  4616              MOV      r6,r2
;;;379      int Notification;
;;;380      const GUI_PID_STATE * pState = (const GUI_PID_STATE *)pMsg->Data.p;
0005f4  68b4              LDR      r4,[r6,#8]
;;;381      if (pState) {
0005f6  b14c              CBZ      r4,|L1.1548|
;;;382        _HandlePID(hObj, pObj, pState->x + pObj->ScrollPos, pState->y, pState->Pressed);
0005f8  7a20              LDRB     r0,[r4,#8]
0005fa  9000              STR      r0,[sp,#0]
0005fc  6820              LDR      r0,[r4,#0]
0005fe  6bf9              LDR      r1,[r7,#0x3c]
000600  1842              ADDS     r2,r0,r1
000602  4639              MOV      r1,r7
000604  4640              MOV      r0,r8
000606  6863              LDR      r3,[r4,#4]
000608  f7fffffe          BL       _HandlePID
                  |L1.1548|
;;;383      }
;;;384      if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
00060c  68b0              LDR      r0,[r6,#8]
00060e  b138              CBZ      r0,|L1.1568|
;;;385        if (pState->Pressed) {
000610  7a20              LDRB     r0,[r4,#8]
000612  b110              CBZ      r0,|L1.1562|
;;;386          Notification = WM_NOTIFICATION_CLICKED;
000614  f04f0501          MOV      r5,#1
000618  e004              B        |L1.1572|
                  |L1.1562|
;;;387        } else {
;;;388          Notification = WM_NOTIFICATION_RELEASED;
00061a  f04f0502          MOV      r5,#2
00061e  e001              B        |L1.1572|
                  |L1.1568|
;;;389        }
;;;390      } else {
;;;391        Notification = WM_NOTIFICATION_MOVED_OUT;
000620  f04f0503          MOV      r5,#3
                  |L1.1572|
;;;392      }
;;;393      WM_NotifyParent(hObj, Notification);
000624  4629              MOV      r1,r5
000626  4640              MOV      r0,r8
000628  f7fffffe          BL       WM_NotifyParent
;;;394    }
00062c  e8bd83f8          POP      {r3-r9,pc}
;;;395    #endif
                          ENDP

                  _OnPidStateChange PROC
;;;400    */
;;;401    static void _OnPidStateChange(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
000630  e92d41f0          PUSH     {r4-r8,lr}
000634  4607              MOV      r7,r0
000636  460d              MOV      r5,r1
000638  4616              MOV      r6,r2
;;;402      const WM_PID_STATE_CHANGED_INFO * pState = (const WM_PID_STATE_CHANGED_INFO *)pMsg->Data.p;
00063a  68b4              LDR      r4,[r6,#8]
;;;403      if ((pState->StatePrev == 1) && (pState->State == 0)) {
00063c  7a60              LDRB     r0,[r4,#9]
00063e  2801              CMP      r0,#1
000640  d10a              BNE      |L1.1624|
000642  7a20              LDRB     r0,[r4,#8]
000644  b940              CBNZ     r0,|L1.1624|
;;;404        pObj->Sel = _GetItemIndex(hObj, pObj, pState->x + pObj->ScrollPos, pState->y);
000646  6820              LDR      r0,[r4,#0]
000648  6be9              LDR      r1,[r5,#0x3c]
00064a  1842              ADDS     r2,r0,r1
00064c  4629              MOV      r1,r5
00064e  4638              MOV      r0,r7
000650  6863              LDR      r3,[r4,#4]
000652  f7fffffe          BL       _GetItemIndex
000656  6428              STR      r0,[r5,#0x40]
                  |L1.1624|
;;;405      }
;;;406    }
000658  e8bd81f0          POP      {r4-r8,pc}
;;;407    
                          ENDP

                  HEADER_Callback PROC
;;;440    */
;;;441    void HEADER_Callback (WM_MESSAGE *pMsg) {
00065c  b570              PUSH     {r4-r6,lr}
00065e  4604              MOV      r4,r0
;;;442      HEADER_Handle hObj;
;;;443      HEADER_Obj * pObj;
;;;444      hObj = pMsg->hWin;
000660  f9b45004          LDRSH    r5,[r4,#4]
;;;445      /* Let widget handle the standard messages */
;;;446      if (WIDGET_HandleActive(hObj, pMsg) == 0) {
000664  4621              MOV      r1,r4
000666  4628              MOV      r0,r5
000668  f7fffffe          BL       WIDGET_HandleActive
00066c  b900              CBNZ     r0,|L1.1648|
                  |L1.1646|
;;;447        return;
;;;448      }
;;;449      WM_LOCK();
;;;450      pObj = (HEADER_Obj *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
;;;451      switch (pMsg->MsgId) {
;;;452      case WM_PAINT:
;;;453        _Paint(pObj);
;;;454        break;
;;;455      case WM_PID_STATE_CHANGED:
;;;456        _OnPidStateChange(hObj, pObj, pMsg);
;;;457        break;
;;;458    #if (HEADER_SUPPORT_DRAG)
;;;459      case WM_TOUCH:
;;;460        _OnTouch(hObj, pObj, pMsg);
;;;461        break;
;;;462    #endif
;;;463    #if (HEADER_SUPPORT_DRAG & GUI_SUPPORT_MOUSE)
;;;464      case WM_MOUSEOVER:
;;;465        _OnMouseOver(hObj, pObj, pMsg);
;;;466        break;
;;;467    #endif
;;;468      case WM_DELETE:
;;;469        _FreeAttached(pObj); /* No return here ... WM_DefaultProc needs to be called */
;;;470      default:
;;;471        WM_DefaultProc(pMsg);
;;;472      }
;;;473      WM_UNLOCK();
;;;474    }
00066e  bd70              POP      {r4-r6,pc}
                  |L1.1648|
000670  4628              MOV      r0,r5                 ;450
000672  f7fffffe          BL       GUI_ALLOC_h2p
000676  4606              MOV      r6,r0                 ;450
000678  6820              LDR      r0,[r4,#0]            ;451
00067a  280b              CMP      r0,#0xb               ;451
00067c  d016              BEQ      |L1.1708|
00067e  280c              CMP      r0,#0xc               ;451
000680  d00e              BEQ      |L1.1696|
000682  280f              CMP      r0,#0xf               ;451
000684  d002              BEQ      |L1.1676|
000686  2811              CMP      r0,#0x11              ;451
000688  d114              BNE      |L1.1716|
00068a  e003              B        |L1.1684|
                  |L1.1676|
00068c  4630              MOV      r0,r6                 ;453
00068e  f7fffffe          BL       _Paint
000692  e013              B        |L1.1724|
                  |L1.1684|
000694  4622              MOV      r2,r4                 ;456
000696  4631              MOV      r1,r6                 ;456
000698  4628              MOV      r0,r5                 ;456
00069a  f7fffffe          BL       _OnPidStateChange
00069e  e00d              B        |L1.1724|
                  |L1.1696|
0006a0  4622              MOV      r2,r4                 ;460
0006a2  4631              MOV      r1,r6                 ;460
0006a4  4628              MOV      r0,r5                 ;460
0006a6  f7fffffe          BL       _OnTouch
0006aa  e007              B        |L1.1724|
                  |L1.1708|
0006ac  4630              MOV      r0,r6                 ;469
0006ae  f7fffffe          BL       _FreeAttached
0006b2  bf00              NOP                            ;470
                  |L1.1716|
0006b4  4620              MOV      r0,r4                 ;471
0006b6  f7fffffe          BL       WM_DefaultProc
0006ba  bf00              NOP                            ;451
                  |L1.1724|
0006bc  bf00              NOP                            ;454
0006be  bf00              NOP      
0006c0  e7d5              B        |L1.1646|
;;;475    
                          ENDP

                  HEADER_CreateEx PROC
;;;493    */
;;;494    HEADER_Handle HEADER_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
0006c2  e92d5fff          PUSH     {r0-r12,lr}
;;;495                                  int WinFlags, int ExFlags, int Id)
;;;496    {
0006c6  4607              MOV      r7,r0
0006c8  4688              MOV      r8,r1
0006ca  4691              MOV      r9,r2
0006cc  461d              MOV      r5,r3
0006ce  e9ddab0e          LDRD     r10,r11,[sp,#0x38]
;;;497      HEADER_Handle hObj;
;;;498      GUI_USE_PARA(ExFlags);
0006d2  9810              LDR      r0,[sp,#0x40]
0006d4  9010              STR      r0,[sp,#0x40]
;;;499      /* Create the window */
;;;500      WM_LOCK();
;;;501      if ((xsize == 0) && (x0 == 0) && (y0 == 0)) {
0006d6  f1b90f00          CMP      r9,#0
0006da  d114              BNE      |L1.1798|
0006dc  b99f              CBNZ     r7,|L1.1798|
0006de  f1b80f00          CMP      r8,#0
0006e2  d110              BNE      |L1.1798|
;;;502        GUI_RECT Rect;
;;;503        WM_GetInsideRectEx(hParent, &Rect);
0006e4  a902              ADD      r1,sp,#8
0006e6  4650              MOV      r0,r10
0006e8  f7fffffe          BL       WM_GetInsideRectEx
;;;504        xsize = Rect.x1 - Rect.x0 + 1;
0006ec  f9bd000c          LDRSH    r0,[sp,#0xc]
0006f0  f9bd1008          LDRSH    r1,[sp,#8]
0006f4  eba00001          SUB      r0,r0,r1
0006f8  f1000901          ADD      r9,r0,#1
;;;505        x0    = Rect.x0;
0006fc  f9bd7008          LDRSH    r7,[sp,#8]
;;;506        y0    = Rect.y0;
000700  f9bd800a          LDRSH    r8,[sp,#0xa]
;;;507      }
000704  bf00              NOP      
                  |L1.1798|
;;;508      if (ysize == 0) {
000706  b98d              CBNZ     r5,|L1.1836|
;;;509        const WIDGET_EFFECT* pEffect = WIDGET_GetDefaultEffect();
000708  f7fffffe          BL       WIDGET_GetDefaultEffect
00070c  4604              MOV      r4,r0
;;;510        ysize  = GUI_GetYDistOfFont(_pDefaultFont);
00070e  48fe              LDR      r0,|L1.2824|
000710  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
000712  f7fffffe          BL       GUI_GetYDistOfFont
000716  4605              MOV      r5,r0
;;;511        ysize += 2 * _DefaultBorderV;
000718  48fc              LDR      r0,|L1.2828|
00071a  6800              LDR      r0,[r0,#0]  ; _DefaultBorderV
00071c  f04f0102          MOV      r1,#2
000720  fb015500          MLA      r5,r1,r0,r5
;;;512        ysize += 2 * (unsigned)pEffect->EffectSize;
000724  6960              LDR      r0,[r4,#0x14]
000726  fb015500          MLA      r5,r1,r0,r5
;;;513      }
00072a  bf00              NOP      
                  |L1.1836|
;;;514      WinFlags |= WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_RIGHT;
00072c  f44b7b20          ORR      r11,r11,#0x280
;;;515      hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &HEADER_Callback,
000730  f04f0134          MOV      r1,#0x34
000734  f2af02db          ADR      r2,HEADER_Callback + 1
000738  fa1ff08b          UXTH     r0,r11
00073c  462b              MOV      r3,r5
00073e  e9cda000          STRD     r10,r0,[sp,#0]
000742  e9cd2102          STRD     r2,r1,[sp,#8]
000746  464a              MOV      r2,r9
000748  4641              MOV      r1,r8
00074a  4638              MOV      r0,r7
00074c  f7fffffe          BL       WM_CreateWindowAsChild
000750  4606              MOV      r6,r0
;;;516                                    sizeof(HEADER_Obj) - sizeof(WM_Obj));
;;;517      if (hObj) {
000752  b1ee              CBZ      r6,|L1.1936|
;;;518        HEADER_Obj * pObj;
;;;519        pObj = (HEADER_Obj *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
000754  4630              MOV      r0,r6
000756  f7fffffe          BL       GUI_ALLOC_h2p
00075a  4604              MOV      r4,r0
;;;520        /* Init sub-classes */
;;;521        GUI_ARRAY_CREATE(&pObj->Columns);
;;;522        /* init widget specific variables */
;;;523        WIDGET__Init(&pObj->Widget, Id, 0);
00075c  f04f0200          MOV      r2,#0
000760  4620              MOV      r0,r4
000762  9911              LDR      r1,[sp,#0x44]
000764  f7fffffe          BL       WIDGET__Init
;;;524        /* init member variables */
;;;525        HEADER_INIT_ID(pObj);
;;;526        pObj->BkColor     = _DefaultBkColor;
000768  48e9              LDR      r0,|L1.2832|
00076a  6800              LDR      r0,[r0,#0]  ; _DefaultBkColor
00076c  62a0              STR      r0,[r4,#0x28]
;;;527        pObj->TextColor   = _DefaultTextColor;
00076e  48e9              LDR      r0,|L1.2836|
000770  6800              LDR      r0,[r0,#0]  ; _DefaultTextColor
000772  62e0              STR      r0,[r4,#0x2c]
;;;528        pObj->pFont       = _pDefaultFont;
000774  48e4              LDR      r0,|L1.2824|
000776  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
000778  64e0              STR      r0,[r4,#0x4c]
;;;529        pObj->CapturePosX = -1;
00077a  f04f30ff          MOV      r0,#0xffffffff
00077e  6360              STR      r0,[r4,#0x34]
;;;530        pObj->CaptureItem = -1;
000780  63a0              STR      r0,[r4,#0x38]
;;;531        pObj->ScrollPos   = 0;
000782  f04f0000          MOV      r0,#0
000786  63e0              STR      r0,[r4,#0x3c]
;;;532        pObj->DirIndicatorColumn = -1;
000788  f04f30ff          MOV      r0,#0xffffffff
00078c  6460              STR      r0,[r4,#0x44]
;;;533      } else {
00078e  bf00              NOP      
                  |L1.1936|
;;;534        GUI_DEBUG_ERROROUT_IF(hObj==0, "HEADER_Create failed")
;;;535      }
;;;536      WM_UNLOCK();
;;;537      return hObj;
000790  4630              MOV      r0,r6
;;;538    }
000792  b004              ADD      sp,sp,#0x10
000794  e8bd9ff0          POP      {r4-r12,pc}
;;;539    
                          ENDP

                  HEADER_Create PROC
;;;485    */
;;;486    HEADER_Handle HEADER_Create(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int Id, int Flags, int ExFlags) {
000798  e92d5fff          PUSH     {r0-r12,lr}
00079c  4604              MOV      r4,r0
00079e  460d              MOV      r5,r1
0007a0  4616              MOV      r6,r2
0007a2  461f              MOV      r7,r3
0007a4  e9ddab10          LDRD     r10,r11,[sp,#0x40]
0007a8  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;487      return HEADER_CreateEx(x0, y0, xsize, ysize, hParent, Flags, ExFlags, Id);
0007ac  463b              MOV      r3,r7
0007ae  4632              MOV      r2,r6
0007b0  4629              MOV      r1,r5
0007b2  4620              MOV      r0,r4
0007b4  e88d0d00          STM      sp,{r8,r10,r11}
0007b8  f8cd900c          STR      r9,[sp,#0xc]
0007bc  f7fffffe          BL       HEADER_CreateEx
;;;488    }
0007c0  b004              ADD      sp,sp,#0x10
0007c2  e8bd9ff0          POP      {r4-r12,pc}
;;;489    
                          ENDP

                  HEADER_SetDefaultCursor PROC
;;;549    */
;;;550    const GUI_CURSOR GUI_UNI_PTR * HEADER_SetDefaultCursor(const GUI_CURSOR * pCursor) {
0007c6  4601              MOV      r1,r0
;;;551      const GUI_CURSOR GUI_UNI_PTR * pOldCursor = _pDefaultCursor;
0007c8  4ad3              LDR      r2,|L1.2840|
0007ca  6810              LDR      r0,[r2,#0]  ; _pDefaultCursor
;;;552      _pDefaultCursor = pCursor;
0007cc  6011              STR      r1,[r2,#0]  ; _pDefaultCursor
;;;553      return pOldCursor;
;;;554    }
0007ce  4770              BX       lr
;;;555    
                          ENDP

                  HEADER_SetDefaultBkColor PROC
;;;559    */
;;;560    GUI_COLOR HEADER_SetDefaultBkColor(GUI_COLOR Color) {
0007d0  4601              MOV      r1,r0
;;;561      GUI_COLOR OldColor = _DefaultBkColor;
0007d2  4acf              LDR      r2,|L1.2832|
0007d4  6810              LDR      r0,[r2,#0]  ; _DefaultBkColor
;;;562      _DefaultBkColor = Color;
0007d6  6011              STR      r1,[r2,#0]  ; _DefaultBkColor
;;;563      return OldColor;
;;;564    }
0007d8  4770              BX       lr
;;;565    
                          ENDP

                  HEADER_SetDefaultTextColor PROC
;;;569    */
;;;570    GUI_COLOR HEADER_SetDefaultTextColor(GUI_COLOR Color) {
0007da  4601              MOV      r1,r0
;;;571      GUI_COLOR OldColor = _DefaultTextColor;
0007dc  4acd              LDR      r2,|L1.2836|
0007de  6810              LDR      r0,[r2,#0]  ; _DefaultTextColor
;;;572      _DefaultTextColor = Color;
0007e0  6011              STR      r1,[r2,#0]  ; _DefaultTextColor
;;;573      return OldColor;
;;;574    }
0007e2  4770              BX       lr
;;;575    
                          ENDP

                  HEADER_SetDefaultBorderH PROC
;;;579    */
;;;580    int HEADER_SetDefaultBorderH(int Spacing) {
0007e4  4601              MOV      r1,r0
;;;581      int OldSpacing = _DefaultBorderH;
0007e6  4acd              LDR      r2,|L1.2844|
0007e8  6810              LDR      r0,[r2,#0]  ; _DefaultBorderH
;;;582      _DefaultBorderH = Spacing;
0007ea  6011              STR      r1,[r2,#0]  ; _DefaultBorderH
;;;583      return OldSpacing;
;;;584    }
0007ec  4770              BX       lr
;;;585    
                          ENDP

                  HEADER_SetDefaultBorderV PROC
;;;589    */
;;;590    int HEADER_SetDefaultBorderV(int Spacing) {
0007ee  4601              MOV      r1,r0
;;;591      int OldSpacing = _DefaultBorderV;
0007f0  4ac6              LDR      r2,|L1.2828|
0007f2  6810              LDR      r0,[r2,#0]  ; _DefaultBorderV
;;;592      _DefaultBorderV = Spacing;
0007f4  6011              STR      r1,[r2,#0]  ; _DefaultBorderV
;;;593      return OldSpacing;
;;;594    }
0007f6  4770              BX       lr
;;;595    
                          ENDP

                  HEADER_SetDefaultFont PROC
;;;599    */
;;;600    const GUI_FONT GUI_UNI_PTR * HEADER_SetDefaultFont(const GUI_FONT GUI_UNI_PTR * pFont) {
0007f8  4601              MOV      r1,r0
;;;601      const GUI_FONT GUI_UNI_PTR * pOldFont = _pDefaultFont;
0007fa  4ac3              LDR      r2,|L1.2824|
0007fc  6810              LDR      r0,[r2,#0]  ; _pDefaultFont
;;;602      _pDefaultFont = pFont;
0007fe  6011              STR      r1,[r2,#0]  ; _pDefaultFont
;;;603      return pOldFont;
;;;604    }
000800  4770              BX       lr
;;;605    
                          ENDP

                  HEADER_GetDefaultCursor PROC
;;;609    */
;;;610    const GUI_CURSOR GUI_UNI_PTR *  HEADER_GetDefaultCursor(void)    { return _pDefaultCursor; }
000802  48c5              LDR      r0,|L1.2840|
000804  6800              LDR      r0,[r0,#0]  ; _pDefaultCursor
000806  4770              BX       lr
;;;611    GUI_COLOR          HEADER_GetDefaultBkColor(void)   { return _DefaultBkColor; }
                          ENDP

                  HEADER_GetDefaultBkColor PROC
000808  48c1              LDR      r0,|L1.2832|
00080a  6800              LDR      r0,[r0,#0]  ; _DefaultBkColor
00080c  4770              BX       lr
;;;612    GUI_COLOR          HEADER_GetDefaultTextColor(void) { return _DefaultTextColor; }
                          ENDP

                  HEADER_GetDefaultTextColor PROC
00080e  48c1              LDR      r0,|L1.2836|
000810  6800              LDR      r0,[r0,#0]  ; _DefaultTextColor
000812  4770              BX       lr
;;;613    int                HEADER_GetDefaultBorderH(void)   { return _DefaultBorderH; }
                          ENDP

                  HEADER_GetDefaultBorderH PROC
000814  48c1              LDR      r0,|L1.2844|
000816  6800              LDR      r0,[r0,#0]  ; _DefaultBorderH
000818  4770              BX       lr
;;;614    int                HEADER_GetDefaultBorderV(void)   { return _DefaultBorderV; }
                          ENDP

                  HEADER_GetDefaultBorderV PROC
00081a  48bc              LDR      r0,|L1.2828|
00081c  6800              LDR      r0,[r0,#0]  ; _DefaultBorderV
00081e  4770              BX       lr
;;;615    const GUI_FONT GUI_UNI_PTR *    HEADER_GetDefaultFont(void)      { return _pDefaultFont; }
                          ENDP

                  HEADER_GetDefaultFont PROC
000820  48b9              LDR      r0,|L1.2824|
000822  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
000824  4770              BX       lr
;;;616    
                          ENDP

                  HEADER_SetHeight PROC
;;;642    */
;;;643    void HEADER_SetHeight(HEADER_Handle hObj, int Height) {
000826  b57c              PUSH     {r2-r6,lr}
000828  4604              MOV      r4,r0
00082a  460d              MOV      r5,r1
;;;644      if (hObj) {
00082c  b1a4              CBZ      r4,|L1.2136|
;;;645        GUI_RECT Rect;
;;;646        WM_GetClientRectEx(hObj, &Rect);
00082e  4669              MOV      r1,sp
000830  4620              MOV      r0,r4
000832  f7fffffe          BL       WM_GetClientRectEx
;;;647        WM_SetSize(hObj, Rect.x1 - Rect.x0 + 1, Height);
000836  f9bd0004          LDRSH    r0,[sp,#4]
00083a  f9bd2000          LDRSH    r2,[sp,#0]
00083e  1a80              SUBS     r0,r0,r2
000840  1c41              ADDS     r1,r0,#1
000842  462a              MOV      r2,r5
000844  4620              MOV      r0,r4
000846  f7fffffe          BL       WM_SetSize
;;;648        WM_InvalidateWindow(WM_GetParent(hObj));
00084a  4620              MOV      r0,r4
00084c  f7fffffe          BL       WM_GetParent
000850  4606              MOV      r6,r0
000852  f7fffffe          BL       WM_InvalidateWindow
;;;649      }
000856  bf00              NOP      
                  |L1.2136|
;;;650    }
000858  bd7c              POP      {r2-r6,pc}
;;;651    
                          ENDP

                  HEADER_SetFont PROC
;;;626    */
;;;627    void HEADER_SetFont(HEADER_Handle hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
00085a  e92d41f0          PUSH     {r4-r8,lr}
00085e  4605              MOV      r5,r0
000860  460c              MOV      r4,r1
;;;628      if (hObj) {
000862  b1a5              CBZ      r5,|L1.2190|
;;;629        HEADER_Obj * pObj;
;;;630        WM_LOCK();
;;;631        pObj = HEADER_H2P(hObj);
000864  4628              MOV      r0,r5
000866  f7fffffe          BL       GUI_ALLOC_h2p
00086a  4606              MOV      r6,r0
;;;632        pObj->pFont = pFont;
00086c  64f4              STR      r4,[r6,#0x4c]
;;;633        HEADER_SetHeight(hObj, GUI_GetYDistOfFont(pFont) + 2 * HEADER_BORDER_V_DEFAULT + 2 * pObj->Widget.pEffect->EffectSize);
00086e  4620              MOV      r0,r4
000870  f7fffffe          BL       GUI_GetYDistOfFont
000874  6a31              LDR      r1,[r6,#0x20]
000876  6949              LDR      r1,[r1,#0x14]
000878  2202              MOVS     r2,#2
00087a  fb020701          MLA      r7,r2,r1,r0
00087e  4639              MOV      r1,r7
000880  4628              MOV      r0,r5
000882  f7fffffe          BL       HEADER_SetHeight
;;;634        WM_InvalidateWindow(hObj);
000886  4628              MOV      r0,r5
000888  f7fffffe          BL       WM_InvalidateWindow
;;;635        WM_UNLOCK();
;;;636      }
00088c  bf00              NOP      
                  |L1.2190|
;;;637    }
00088e  e8bd81f0          POP      {r4-r8,pc}
;;;638    
                          ENDP

                  HEADER_SetTextColor PROC
;;;655    */
;;;656    void HEADER_SetTextColor(HEADER_Handle hObj, GUI_COLOR Color) {
000892  b570              PUSH     {r4-r6,lr}
000894  4604              MOV      r4,r0
000896  460d              MOV      r5,r1
;;;657      if (hObj) {
000898  b144              CBZ      r4,|L1.2220|
;;;658        HEADER_Obj * pObj;
;;;659        WM_LOCK();
;;;660        pObj = HEADER_H2P(hObj);
00089a  4620              MOV      r0,r4
00089c  f7fffffe          BL       GUI_ALLOC_h2p
0008a0  4606              MOV      r6,r0
;;;661        pObj->TextColor = Color;
0008a2  62f5              STR      r5,[r6,#0x2c]
;;;662        WM_InvalidateWindow(hObj);
0008a4  4620              MOV      r0,r4
0008a6  f7fffffe          BL       WM_InvalidateWindow
;;;663        WM_UNLOCK();
;;;664      }
0008aa  bf00              NOP      
                  |L1.2220|
;;;665    }
0008ac  bd70              POP      {r4-r6,pc}
;;;666    
                          ENDP

                  HEADER_SetBkColor PROC
;;;670    */
;;;671    void HEADER_SetBkColor(HEADER_Handle hObj, GUI_COLOR Color) {
0008ae  b570              PUSH     {r4-r6,lr}
0008b0  4604              MOV      r4,r0
0008b2  460d              MOV      r5,r1
;;;672      if (hObj) {
0008b4  b144              CBZ      r4,|L1.2248|
;;;673        HEADER_Obj * pObj;
;;;674        WM_LOCK();
;;;675        pObj = HEADER_H2P(hObj);
0008b6  4620              MOV      r0,r4
0008b8  f7fffffe          BL       GUI_ALLOC_h2p
0008bc  4606              MOV      r6,r0
;;;676        pObj->BkColor = Color;
0008be  62b5              STR      r5,[r6,#0x28]
;;;677        WM_InvalidateWindow(hObj);
0008c0  4620              MOV      r0,r4
0008c2  f7fffffe          BL       WM_InvalidateWindow
;;;678        WM_UNLOCK();
;;;679      }
0008c6  bf00              NOP      
                  |L1.2248|
;;;680    }
0008c8  bd70              POP      {r4-r6,pc}
;;;681    
                          ENDP

                  HEADER_SetTextAlign PROC
;;;685    */
;;;686    void HEADER_SetTextAlign(HEADER_Handle hObj, unsigned int Index, int Align) {
0008ca  e92d41f0          PUSH     {r4-r8,lr}
0008ce  4604              MOV      r4,r0
0008d0  460d              MOV      r5,r1
0008d2  4616              MOV      r6,r2
;;;687      if (hObj) {
0008d4  b1bc              CBZ      r4,|L1.2310|
;;;688        HEADER_Obj * pObj;
;;;689        WM_LOCK();
;;;690        pObj = HEADER_H2P(hObj);
0008d6  4620              MOV      r0,r4
0008d8  f7fffffe          BL       GUI_ALLOC_h2p
0008dc  4607              MOV      r7,r0
;;;691        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
0008de  f1070030          ADD      r0,r7,#0x30
0008e2  f7fffffe          BL       GUI_ARRAY_GetNumItems
0008e6  42a8              CMP      r0,r5
0008e8  d30c              BCC      |L1.2308|
;;;692          HEADER_COLUMN * pColumn;
;;;693          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
0008ea  4629              MOV      r1,r5
0008ec  f1070030          ADD      r0,r7,#0x30
0008f0  f7fffffe          BL       GUI_ARRAY_GetpItem
0008f4  4680              MOV      r8,r0
;;;694          pColumn->Align = Align;
0008f6  b230              SXTH     r0,r6
0008f8  f8a80004          STRH     r0,[r8,#4]
;;;695          WM_InvalidateWindow(hObj);
0008fc  4620              MOV      r0,r4
0008fe  f7fffffe          BL       WM_InvalidateWindow
;;;696        }
000902  bf00              NOP      
                  |L1.2308|
;;;697        WM_UNLOCK();
;;;698      }
000904  bf00              NOP      
                  |L1.2310|
;;;699    }
000906  e8bd81f0          POP      {r4-r8,pc}
;;;700    
                          ENDP

                  HEADER_SetScrollPos PROC
;;;704    */
;;;705    void HEADER_SetScrollPos(HEADER_Handle hObj, int ScrollPos) {
00090a  e92d41f0          PUSH     {r4-r8,lr}
00090e  4605              MOV      r5,r0
000910  460c              MOV      r4,r1
;;;706      if (hObj && (ScrollPos >= 0)) {
000912  b19d              CBZ      r5,|L1.2364|
000914  2c00              CMP      r4,#0
000916  db11              BLT      |L1.2364|
;;;707        HEADER_Obj* pObj;
;;;708        WM_LOCK();
;;;709        pObj = HEADER_H2P(hObj);
000918  4628              MOV      r0,r5
00091a  f7fffffe          BL       GUI_ALLOC_h2p
00091e  4606              MOV      r6,r0
;;;710        if (ScrollPos != pObj->ScrollPos) {
000920  6bf0              LDR      r0,[r6,#0x3c]
000922  42a0              CMP      r0,r4
000924  d009              BEQ      |L1.2362|
;;;711          pObj->ScrollPos = ScrollPos;
000926  63f4              STR      r4,[r6,#0x3c]
;;;712          WM_Invalidate(hObj);
000928  4628              MOV      r0,r5
00092a  f7fffffe          BL       WM_InvalidateWindow
;;;713          WM_InvalidateWindow(WM_GetParent(hObj));
00092e  4628              MOV      r0,r5
000930  f7fffffe          BL       WM_GetParent
000934  4607              MOV      r7,r0
000936  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2362|
;;;714        }
;;;715        WM_UNLOCK();
;;;716      }
00093a  bf00              NOP      
                  |L1.2364|
;;;717    }
00093c  e8bd81f0          POP      {r4-r8,pc}
;;;718    
                          ENDP

                  HEADER_AddItem PROC
;;;722    */
;;;723    void HEADER_AddItem(HEADER_Handle hObj, int Width, const char * s, int Align) {
000940  e92d4ffe          PUSH     {r1-r11,lr}
000944  4607              MOV      r7,r0
000946  460d              MOV      r5,r1
000948  4616              MOV      r6,r2
00094a  4698              MOV      r8,r3
;;;724      if (hObj) {
00094c  2f00              CMP      r7,#0
00094e  d04c              BEQ      |L1.2538|
;;;725        HEADER_Obj * pObj;
;;;726        HEADER_COLUMN Column;
;;;727        int Index;
;;;728        WM_LOCK();
;;;729        pObj = HEADER_H2P(hObj);
000950  4638              MOV      r0,r7
000952  f7fffffe          BL       GUI_ALLOC_h2p
000956  4604              MOV      r4,r0
;;;730        if (!Width) {
000958  b99d              CBNZ     r5,|L1.2434|
;;;731          const GUI_FONT GUI_UNI_PTR * pFont = GUI_SetFont(pObj->pFont);
00095a  6ce0              LDR      r0,[r4,#0x4c]
00095c  f7fffffe          BL       GUI_SetFont
000960  4681              MOV      r9,r0
;;;732          Width = GUI_GetStringDistX(s) + 2 * (pObj->Widget.pEffect->EffectSize + _DefaultBorderH);
000962  4630              MOV      r0,r6
000964  f7fffffe          BL       GUI_GetStringDistX
000968  6a21              LDR      r1,[r4,#0x20]
00096a  6949              LDR      r1,[r1,#0x14]
00096c  4a6b              LDR      r2,|L1.2844|
00096e  6812              LDR      r2,[r2,#0]  ; _DefaultBorderH
000970  4411              ADD      r1,r1,r2
000972  f04f0202          MOV      r2,#2
000976  fb020501          MLA      r5,r2,r1,r0
;;;733          GUI_SetFont(pFont);
00097a  4648              MOV      r0,r9
00097c  f7fffffe          BL       GUI_SetFont
;;;734        }
000980  bf00              NOP      
                  |L1.2434|
;;;735        Column.Width    = Width;
000982  9500              STR      r5,[sp,#0]
;;;736        Column.Align    = Align;
000984  fa0ff088          SXTH     r0,r8
000988  f8ad0004          STRH     r0,[sp,#4]
;;;737        Column.hDrawObj = 0;
00098c  f04f0000          MOV      r0,#0
000990  f8ad0006          STRH     r0,[sp,#6]
;;;738        Index = GUI_ARRAY_GetNumItems(&pObj->Columns);
000994  f1040030          ADD      r0,r4,#0x30
000998  f7fffffe          BL       GUI_ARRAY_GetNumItems
00099c  4682              MOV      r10,r0
;;;739        if (GUI_ARRAY_AddItem(&pObj->Columns, &Column, sizeof(HEADER_COLUMN) + strlen(s) + 1) == 0) {
00099e  4630              MOV      r0,r6
0009a0  f7fffffe          BL       strlen
0009a4  f100090d          ADD      r9,r0,#0xd
0009a8  464a              MOV      r2,r9
0009aa  4669              MOV      r1,sp
0009ac  f1040030          ADD      r0,r4,#0x30
0009b0  f7fffffe          BL       GUI_ARRAY_AddItem
0009b4  b9c0              CBNZ     r0,|L1.2536|
;;;740          HEADER_COLUMN * pColumn;
;;;741          pObj = HEADER_H2P(hObj);
0009b6  4638              MOV      r0,r7
0009b8  f7fffffe          BL       GUI_ALLOC_h2p
0009bc  4604              MOV      r4,r0
;;;742          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
0009be  4651              MOV      r1,r10
0009c0  f1040030          ADD      r0,r4,#0x30
0009c4  f7fffffe          BL       GUI_ARRAY_GetpItem
0009c8  4681              MOV      r9,r0
;;;743          strcpy(pColumn->acText, s);
0009ca  4631              MOV      r1,r6
0009cc  f1090008          ADD      r0,r9,#8
0009d0  f7fffffe          BL       strcpy
;;;744          WM_InvalidateWindow(hObj);
0009d4  4638              MOV      r0,r7
0009d6  f7fffffe          BL       WM_InvalidateWindow
;;;745          WM_InvalidateWindow(WM_GetParent(hObj));
0009da  4638              MOV      r0,r7
0009dc  f7fffffe          BL       WM_GetParent
0009e0  4683              MOV      r11,r0
0009e2  f7fffffe          BL       WM_InvalidateWindow
;;;746        }
0009e6  bf00              NOP      
                  |L1.2536|
;;;747        WM_UNLOCK();
;;;748      }
0009e8  bf00              NOP      
                  |L1.2538|
;;;749    }
0009ea  e8bd8ffe          POP      {r1-r11,pc}
;;;750    
                          ENDP

                  HEADER_DeleteItem PROC
;;;754    */
;;;755    void HEADER_DeleteItem(HEADER_Handle hObj, unsigned Index) {
0009ee  e92d41f0          PUSH     {r4-r8,lr}
0009f2  4604              MOV      r4,r0
0009f4  460d              MOV      r5,r1
;;;756      if (hObj) {
0009f6  b1c4              CBZ      r4,|L1.2602|
;;;757        HEADER_Obj* pObj;
;;;758        WM_LOCK();
;;;759        pObj = HEADER_H2P(hObj);
0009f8  4620              MOV      r0,r4
0009fa  f7fffffe          BL       GUI_ALLOC_h2p
0009fe  4606              MOV      r6,r0
;;;760        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000a00  f1060030          ADD      r0,r6,#0x30
000a04  f7fffffe          BL       GUI_ARRAY_GetNumItems
000a08  42a8              CMP      r0,r5
000a0a  d90d              BLS      |L1.2600|
;;;761          GUI_ARRAY_DeleteItem(&pObj->Columns, Index);
000a0c  4629              MOV      r1,r5
000a0e  f1060030          ADD      r0,r6,#0x30
000a12  f7fffffe          BL       GUI_ARRAY_DeleteItem
;;;762          WM_InvalidateWindow(hObj);
000a16  4620              MOV      r0,r4
000a18  f7fffffe          BL       WM_InvalidateWindow
;;;763          WM_InvalidateWindow(WM_GetParent(hObj));
000a1c  4620              MOV      r0,r4
000a1e  f7fffffe          BL       WM_GetParent
000a22  4607              MOV      r7,r0
000a24  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2600|
;;;764        }
;;;765        WM_UNLOCK();
;;;766      }
000a28  bf00              NOP      
                  |L1.2602|
;;;767    }
000a2a  e8bd81f0          POP      {r4-r8,pc}
;;;768    
                          ENDP

                  HEADER_SetItemText PROC
;;;772    */
;;;773    void HEADER_SetItemText(HEADER_Handle hObj, unsigned int Index, const char* s) {
000a2e  e92d47f0          PUSH     {r4-r10,lr}
000a32  4605              MOV      r5,r0
000a34  460e              MOV      r6,r1
000a36  4614              MOV      r4,r2
;;;774      if (hObj) {
000a38  b1fd              CBZ      r5,|L1.2682|
;;;775        HEADER_Obj* pObj;
;;;776        WM_LOCK();
;;;777        pObj = HEADER_H2P(hObj);
000a3a  4628              MOV      r0,r5
000a3c  f7fffffe          BL       GUI_ALLOC_h2p
000a40  4607              MOV      r7,r0
;;;778        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000a42  f1070030          ADD      r0,r7,#0x30
000a46  f7fffffe          BL       GUI_ARRAY_GetNumItems
000a4a  42b0              CMP      r0,r6
000a4c  d914              BLS      |L1.2680|
;;;779          HEADER_COLUMN* pColumn;
;;;780          pColumn = (HEADER_COLUMN*)GUI_ARRAY_ResizeItem(&pObj->Columns, Index, sizeof(HEADER_COLUMN) + strlen(s));
000a4e  4620              MOV      r0,r4
000a50  f7fffffe          BL       strlen
000a54  f100090c          ADD      r9,r0,#0xc
000a58  464a              MOV      r2,r9
000a5a  4631              MOV      r1,r6
000a5c  f1070030          ADD      r0,r7,#0x30
000a60  f7fffffe          BL       GUI_ARRAY_ResizeItem
000a64  4680              MOV      r8,r0
;;;781          if (pColumn) {
000a66  f1b80f00          CMP      r8,#0
000a6a  d004              BEQ      |L1.2678|
;;;782            strcpy(pColumn->acText, s);
000a6c  4621              MOV      r1,r4
000a6e  f1080008          ADD      r0,r8,#8
000a72  f7fffffe          BL       strcpy
                  |L1.2678|
;;;783          }
;;;784        }
000a76  bf00              NOP      
                  |L1.2680|
;;;785        WM_UNLOCK();
;;;786      }
000a78  bf00              NOP      
                  |L1.2682|
;;;787    }
000a7a  e8bd87f0          POP      {r4-r10,pc}
;;;788    
                          ENDP

                  HEADER_GetHeight PROC
;;;820    */
;;;821    int HEADER_GetHeight(HEADER_Handle hObj) {
000a7e  b57c              PUSH     {r2-r6,lr}
000a80  4604              MOV      r4,r0
;;;822      int Height = 0;
000a82  f04f0500          MOV      r5,#0
;;;823      if (hObj) {
000a86  b1ac              CBZ      r4,|L1.2740|
;;;824        GUI_RECT Rect;
;;;825        WM_GetClientRectEx(hObj, &Rect);
000a88  4669              MOV      r1,sp
000a8a  4620              MOV      r0,r4
000a8c  f7fffffe          BL       WM_GetClientRectEx
;;;826        GUI_MoveRect(&Rect, -Rect.x0, -Rect.y0);
000a90  f9bd0002          LDRSH    r0,[sp,#2]
000a94  4242              RSBS     r2,r0,#0
000a96  f9bd0000          LDRSH    r0,[sp,#0]
000a9a  4241              RSBS     r1,r0,#0
000a9c  4668              MOV      r0,sp
000a9e  f7fffffe          BL       GUI_MoveRect
;;;827        Height = Rect.y1 - Rect.y0 + 1;
000aa2  f9bd0006          LDRSH    r0,[sp,#6]
000aa6  f9bd1002          LDRSH    r1,[sp,#2]
000aaa  eba00001          SUB      r0,r0,r1
000aae  f1000501          ADD      r5,r0,#1
;;;828      }
000ab2  bf00              NOP      
                  |L1.2740|
;;;829      return Height;
000ab4  4628              MOV      r0,r5
;;;830    }
000ab6  bd7c              POP      {r2-r6,pc}
;;;831    
                          ENDP

                  HEADER_GetNumItems PROC
;;;855    */
;;;856    int  HEADER_GetNumItems(HEADER_Handle hObj) {
000ab8  b570              PUSH     {r4-r6,lr}
000aba  4604              MOV      r4,r0
;;;857      int NumCols = 0;
000abc  f04f0500          MOV      r5,#0
;;;858      if (hObj) {
000ac0  b14c              CBZ      r4,|L1.2774|
;;;859        HEADER_Obj * pObj;
;;;860        WM_LOCK();
;;;861        pObj = HEADER_H2P(hObj);
000ac2  4620              MOV      r0,r4
000ac4  f7fffffe          BL       GUI_ALLOC_h2p
000ac8  4606              MOV      r6,r0
;;;862        NumCols = GUI_ARRAY_GetNumItems(&pObj->Columns);
000aca  f1060030          ADD      r0,r6,#0x30
000ace  f7fffffe          BL       GUI_ARRAY_GetNumItems
000ad2  4605              MOV      r5,r0
;;;863        WM_UNLOCK();
;;;864      }
000ad4  bf00              NOP      
                  |L1.2774|
;;;865      return NumCols;
000ad6  4628              MOV      r0,r5
;;;866    }
000ad8  bd70              POP      {r4-r6,pc}
;;;867    
                          ENDP

                  HEADER_SetDirIndicator PROC
;;;871    */
;;;872    void HEADER_SetDirIndicator(HEADER_Handle hObj, int Column, int Reverse) {
000ada  e92d41f0          PUSH     {r4-r8,lr}
000ade  4607              MOV      r7,r0
000ae0  460d              MOV      r5,r1
000ae2  4616              MOV      r6,r2
;;;873      if (hObj) {
000ae4  b17f              CBZ      r7,|L1.2822|
;;;874        HEADER_Obj * pObj;
;;;875        WM_LOCK();
;;;876        pObj = HEADER_H2P(hObj);
000ae6  4638              MOV      r0,r7
000ae8  f7fffffe          BL       GUI_ALLOC_h2p
000aec  4604              MOV      r4,r0
;;;877        if ((pObj->DirIndicatorColumn != Column) || (pObj->DirIndicatorReverse != Reverse)) {
000aee  6c60              LDR      r0,[r4,#0x44]
000af0  42a8              CMP      r0,r5
000af2  d102              BNE      |L1.2810|
000af4  6ca0              LDR      r0,[r4,#0x48]
000af6  42b0              CMP      r0,r6
000af8  d004              BEQ      |L1.2820|
                  |L1.2810|
;;;878          pObj->DirIndicatorColumn = Column;
000afa  6465              STR      r5,[r4,#0x44]
;;;879          pObj->DirIndicatorReverse = Reverse;
000afc  64a6              STR      r6,[r4,#0x48]
;;;880          WM_InvalidateWindow(hObj);
000afe  4638              MOV      r0,r7
000b00  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2820|
;;;881        }
;;;882        WM_UNLOCK();
;;;883      }
000b04  bf00              NOP      
                  |L1.2822|
;;;884    }
000b06  e00b              B        |L1.2848|
                  |L1.2824|
                          DCD      _pDefaultFont
                  |L1.2828|
                          DCD      _DefaultBorderV
                  |L1.2832|
                          DCD      _DefaultBkColor
                  |L1.2836|
                          DCD      _DefaultTextColor
                  |L1.2840|
                          DCD      _pDefaultCursor
                  |L1.2844|
                          DCD      _DefaultBorderH
                  |L1.2848|
000b20  e8bd81f0          POP      {r4-r8,pc}
;;;885    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  _pDefaultCursor
                          DCD      GUI_CursorHeaderM
                  _DefaultBkColor
                          DCD      0x00aaaaaa
                  _DefaultTextColor
                          DCD      0x00000000
                  _DefaultBorderH
                          DCD      0x00000002
                  _DefaultBorderV
                          DCD      0x00000000
                  _pDefaultFont
                          DCD      GUI_Font13_1
                  _pOldCursor
                          DCD      0x00000000
