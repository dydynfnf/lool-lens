; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdcoefct.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdcoefct.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdcoefct.crf GUI\JPEG\jdcoefct.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  start_iMCU_row PROC
;;;78     LOCAL(void)
;;;79     start_iMCU_row (j_decompress_ptr cinfo)
000000  f8d011ac          LDR      r1,[r0,#0x1ac]
;;;80     /* Reset within-iMCU-row counters for a new row (input side) */
;;;81     {
;;;82       my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;83     
;;;84       /* In an interleaved scan, an MCU row is the same as an iMCU row.
;;;85        * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
;;;86        * But at the bottom of the image, process only what's left.
;;;87        */
;;;88       if (cinfo->comps_in_scan > 1) {
000004  f8d02148          LDR      r2,[r0,#0x148]
000008  2a01              CMP      r2,#1
00000a  dd03              BLE      |L1.20|
;;;89         coef->MCU_rows_per_iMCU_row = 1;
00000c  f04f0201          MOV      r2,#1
000010  61ca              STR      r2,[r1,#0x1c]
000012  e00f              B        |L1.52|
                  |L1.20|
;;;90       } else {
;;;91         if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
000014  f8d02140          LDR      r2,[r0,#0x140]
000018  1e52              SUBS     r2,r2,#1
00001a  f8d03094          LDR      r3,[r0,#0x94]
00001e  4293              CMP      r3,r2
000020  d204              BCS      |L1.44|
;;;92           coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
000022  f8d0214c          LDR      r2,[r0,#0x14c]
000026  68d2              LDR      r2,[r2,#0xc]
000028  61ca              STR      r2,[r1,#0x1c]
00002a  e003              B        |L1.52|
                  |L1.44|
;;;93         else
;;;94           coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
00002c  f8d0214c          LDR      r2,[r0,#0x14c]
000030  6c92              LDR      r2,[r2,#0x48]
000032  61ca              STR      r2,[r1,#0x1c]
                  |L1.52|
;;;95       }
;;;96     
;;;97       coef->MCU_ctr = 0;
000034  f04f0200          MOV      r2,#0
000038  614a              STR      r2,[r1,#0x14]
;;;98       coef->MCU_vert_offset = 0;
00003a  618a              STR      r2,[r1,#0x18]
;;;99     }
00003c  4770              BX       lr
;;;100    
                          ENDP

                  start_input_pass PROC
;;;106    METHODDEF(void)
;;;107    start_input_pass (j_decompress_ptr cinfo)
00003e  b510              PUSH     {r4,lr}
;;;108    {
000040  4604              MOV      r4,r0
;;;109      cinfo->input_iMCU_row = 0;
000042  f04f0000          MOV      r0,#0
000046  f8c40094          STR      r0,[r4,#0x94]
;;;110      start_iMCU_row(cinfo);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       start_iMCU_row
;;;111    }
000050  bd10              POP      {r4,pc}
;;;112    
                          ENDP

                  start_output_pass PROC
;;;118    METHODDEF(void)
;;;119    start_output_pass (j_decompress_ptr cinfo)
000052  f04f0100          MOV      r1,#0
;;;120    {
;;;121    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;122      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;123    
;;;124      /* If multipass, check to see whether to use block smoothing on this pass */
;;;125      if (coef->pub.coef_arrays != NULL) {
;;;126        if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
;;;127          coef->pub.decompress_data = decompress_smooth_data;
;;;128        else
;;;129          coef->pub.decompress_data = decompress_data;
;;;130      }
;;;131    #endif
;;;132      cinfo->output_iMCU_row = 0;
000056  f8c0109c          STR      r1,[r0,#0x9c]
;;;133    }
00005a  4770              BX       lr
;;;134    
                          ENDP

                  decompress_onepass PROC
;;;146    METHODDEF(int)
;;;147    decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
00005c  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;148    {
000060  b089              SUB      sp,sp,#0x24
000062  4604              MOV      r4,r0
;;;149      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
000064  f8d461ac          LDR      r6,[r4,#0x1ac]
;;;150      JDIMENSION MCU_col_num;	/* index of current MCU within row */
;;;151      JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
000068  f8d4015c          LDR      r0,[r4,#0x15c]
00006c  f1a00001          SUB      r0,r0,#1
000070  9008              STR      r0,[sp,#0x20]
;;;152      JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
000072  f8d40140          LDR      r0,[r4,#0x140]
000076  f1a00001          SUB      r0,r0,#1
00007a  9007              STR      r0,[sp,#0x1c]
;;;153      int blkn, ci, xindex, yindex, yoffset, useful_width;
;;;154      JSAMPARRAY output_ptr;
;;;155      JDIMENSION start_col, output_col;
;;;156      jpeg_component_info *compptr;
;;;157      inverse_DCT_method_ptr inverse_DCT;
;;;158    
;;;159      /* Loop to process as much as one whole iMCU row */
;;;160      for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
00007c  f8d68018          LDR      r8,[r6,#0x18]
000080  e08b              B        |L1.410|
                  |L1.130|
;;;161           yoffset++) {
;;;162        for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
000082  6977              LDR      r7,[r6,#0x14]
000084  e080              B        |L1.392|
                  |L1.134|
;;;163    	 MCU_col_num++) {
;;;164          /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
;;;165          jzero_far((void FAR *) coef->MCU_buffer[0],
000086  f8d42164          LDR      r2,[r4,#0x164]
00008a  01d1              LSLS     r1,r2,#7
00008c  6a30              LDR      r0,[r6,#0x20]
00008e  f7fffffe          BL       jzero_far
;;;166    		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
;;;167          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
000092  f8d401bc          LDR      r0,[r4,#0x1bc]
000096  f1060120          ADD      r1,r6,#0x20
00009a  6842              LDR      r2,[r0,#4]
00009c  4620              MOV      r0,r4
00009e  4790              BLX      r2
0000a0  b930              CBNZ     r0,|L1.176|
;;;168    	/* Suspension forced; update state counters and exit */
;;;169    	coef->MCU_vert_offset = yoffset;
0000a2  f8c68018          STR      r8,[r6,#0x18]
;;;170    	coef->MCU_ctr = MCU_col_num;
0000a6  6177              STR      r7,[r6,#0x14]
;;;171    	return JPEG_SUSPENDED;
0000a8  2000              MOVS     r0,#0
                  |L1.170|
;;;172          }
;;;173          /* Determine where data should go in output_buf and do the IDCT thing.
;;;174           * We skip dummy blocks at the right and bottom edges (but blkn gets
;;;175           * incremented past them!).  Note the inner loop relies on having
;;;176           * allocated the MCU_buffer[] blocks sequentially.
;;;177           */
;;;178          blkn = 0;			/* index of current DCT block within MCU */
;;;179          for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
;;;180    	compptr = cinfo->cur_comp_info[ci];
;;;181    	/* Don't bother to IDCT an uninteresting component. */
;;;182    	if (! compptr->component_needed) {
;;;183    	  blkn += compptr->MCU_blocks;
;;;184    	  continue;
;;;185    	}
;;;186    	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
;;;187    	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
;;;188    						    : compptr->last_col_width;
;;;189    	output_ptr = output_buf[compptr->component_index] +
;;;190    	  yoffset * compptr->DCT_scaled_size;
;;;191    	start_col = MCU_col_num * compptr->MCU_sample_width;
;;;192    	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
;;;193    	  if (cinfo->input_iMCU_row < last_iMCU_row ||
;;;194    	      yoffset+yindex < compptr->last_row_height) {
;;;195    	    output_col = start_col;
;;;196    	    for (xindex = 0; xindex < useful_width; xindex++) {
;;;197    	      (*inverse_DCT) (cinfo, compptr,
;;;198    			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
;;;199    			      output_ptr, output_col);
;;;200    	      output_col += compptr->DCT_scaled_size;
;;;201    	    }
;;;202    	  }
;;;203    	  blkn += compptr->MCU_width;
;;;204    	  output_ptr += compptr->DCT_scaled_size;
;;;205    	}
;;;206          }
;;;207        }
;;;208        /* Completed an MCU row, but perhaps not an iMCU row */
;;;209        coef->MCU_ctr = 0;
;;;210      }
;;;211      /* Completed the iMCU row, advance counters for next one */
;;;212      cinfo->output_iMCU_row++;
;;;213      if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
;;;214        start_iMCU_row(cinfo);
;;;215        return JPEG_ROW_COMPLETED;
;;;216      }
;;;217      /* Completed the scan */
;;;218      (*cinfo->inputctl->finish_input_pass) (cinfo);
;;;219      return JPEG_SCAN_COMPLETED;
;;;220    }
0000aa  b00b              ADD      sp,sp,#0x2c
0000ac  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.176|
0000b0  f04f0900          MOV      r9,#0                 ;178
0000b4  46ca              MOV      r10,r9                ;179
0000b6  e061              B        |L1.380|
                  |L1.184|
0000b8  f50470a6          ADD      r0,r4,#0x14c          ;180
0000bc  f850502a          LDR      r5,[r0,r10,LSL #2]    ;180
0000c0  6b28              LDR      r0,[r5,#0x30]         ;182
0000c2  b910              CBNZ     r0,|L1.202|
0000c4  6be8              LDR      r0,[r5,#0x3c]         ;183
0000c6  4481              ADD      r9,r9,r0              ;183
0000c8  e056              B        |L1.376|
                  |L1.202|
0000ca  f8d401c0          LDR      r0,[r4,#0x1c0]        ;186
0000ce  f1000004          ADD      r0,r0,#4              ;186
0000d2  6869              LDR      r1,[r5,#4]            ;186
0000d4  f8500021          LDR      r0,[r0,r1,LSL #2]     ;186
0000d8  9001              STR      r0,[sp,#4]            ;186
0000da  9808              LDR      r0,[sp,#0x20]         ;187
0000dc  4287              CMP      r7,r0                 ;187
0000de  d201              BCS      |L1.228|
0000e0  6b68              LDR      r0,[r5,#0x34]         ;187
0000e2  e000              B        |L1.230|
                  |L1.228|
0000e4  6c68              LDR      r0,[r5,#0x44]         ;188
                  |L1.230|
0000e6  9005              STR      r0,[sp,#0x14]         ;188
0000e8  6869              LDR      r1,[r5,#4]            ;189
0000ea  980a              LDR      r0,[sp,#0x28]         ;189
0000ec  f8501021          LDR      r1,[r0,r1,LSL #2]     ;189
0000f0  6a68              LDR      r0,[r5,#0x24]         ;189
0000f2  fb00f008          MUL      r0,r0,r8              ;189
0000f6  eb010080          ADD      r0,r1,r0,LSL #2       ;189
0000fa  9004              STR      r0,[sp,#0x10]         ;189
0000fc  6c28              LDR      r0,[r5,#0x40]         ;191
0000fe  fb00f007          MUL      r0,r0,r7              ;191
000102  9003              STR      r0,[sp,#0xc]          ;191
000104  f04f0000          MOV      r0,#0                 ;192
000108  9006              STR      r0,[sp,#0x18]         ;192
00010a  e030              B        |L1.366|
                  |L1.268|
00010c  f8d41094          LDR      r1,[r4,#0x94]         ;193
000110  9807              LDR      r0,[sp,#0x1c]         ;193
000112  4281              CMP      r1,r0                 ;193
000114  d304              BCC      |L1.288|
000116  9806              LDR      r0,[sp,#0x18]         ;194
000118  4440              ADD      r0,r0,r8              ;194
00011a  6ca9              LDR      r1,[r5,#0x48]         ;194
00011c  4288              CMP      r0,r1                 ;194
00011e  da1b              BGE      |L1.344|
                  |L1.288|
000120  9803              LDR      r0,[sp,#0xc]          ;195
000122  9002              STR      r0,[sp,#8]            ;195
000124  f04f0b00          MOV      r11,#0                ;196
000128  e013              B        |L1.338|
                  |L1.298|
00012a  9802              LDR      r0,[sp,#8]            ;197
00012c  eb09010b          ADD      r1,r9,r11             ;197
000130  9000              STR      r0,[sp,#0]            ;197
000132  f1060020          ADD      r0,r6,#0x20           ;197
000136  f8502021          LDR      r2,[r0,r1,LSL #2]     ;197
00013a  4629              MOV      r1,r5                 ;197
00013c  4620              MOV      r0,r4                 ;197
00013e  f8ddc004          LDR      r12,[sp,#4]           ;197
000142  9b04              LDR      r3,[sp,#0x10]         ;197
000144  47e0              BLX      r12                   ;197
000146  6a69              LDR      r1,[r5,#0x24]         ;200
000148  9802              LDR      r0,[sp,#8]            ;200
00014a  4408              ADD      r0,r0,r1              ;200
00014c  9002              STR      r0,[sp,#8]            ;200
00014e  f10b0b01          ADD      r11,r11,#1            ;196
                  |L1.338|
000152  9805              LDR      r0,[sp,#0x14]         ;196
000154  4583              CMP      r11,r0                ;196
000156  dbe8              BLT      |L1.298|
                  |L1.344|
000158  6b68              LDR      r0,[r5,#0x34]         ;203
00015a  4481              ADD      r9,r9,r0              ;203
00015c  6a69              LDR      r1,[r5,#0x24]         ;204
00015e  9804              LDR      r0,[sp,#0x10]         ;204
000160  eb000081          ADD      r0,r0,r1,LSL #2       ;204
000164  9004              STR      r0,[sp,#0x10]         ;204
000166  9806              LDR      r0,[sp,#0x18]         ;192
000168  f1000001          ADD      r0,r0,#1              ;192
00016c  9006              STR      r0,[sp,#0x18]         ;192
                  |L1.366|
00016e  6ba9              LDR      r1,[r5,#0x38]         ;192
000170  9806              LDR      r0,[sp,#0x18]         ;192
000172  4281              CMP      r1,r0                 ;192
000174  dcca              BGT      |L1.268|
000176  bf00              NOP                            ;184
                  |L1.376|
000178  f10a0a01          ADD      r10,r10,#1            ;179
                  |L1.380|
00017c  f8d40148          LDR      r0,[r4,#0x148]        ;179
000180  4550              CMP      r0,r10                ;179
000182  dc99              BGT      |L1.184|
000184  f1070701          ADD      r7,r7,#1              ;163
                  |L1.392|
000188  9808              LDR      r0,[sp,#0x20]         ;162
00018a  4287              CMP      r7,r0                 ;162
00018c  f67faf7b          BLS      |L1.134|
000190  f04f0000          MOV      r0,#0                 ;209
000194  6170              STR      r0,[r6,#0x14]         ;209
000196  f1080801          ADD      r8,r8,#1              ;161
                  |L1.410|
00019a  69f0              LDR      r0,[r6,#0x1c]         ;160
00019c  4540              CMP      r0,r8                 ;160
00019e  f73faf70          BGT      |L1.130|
0001a2  f1040494          ADD      r4,r4,#0x94           ;212
0001a6  68a0              LDR      r0,[r4,#8]            ;212
0001a8  f1000001          ADD      r0,r0,#1              ;212
0001ac  60a0              STR      r0,[r4,#8]            ;212
0001ae  6820              LDR      r0,[r4,#0]            ;213
0001b0  f1000001          ADD      r0,r0,#1              ;213
0001b4  6020              STR      r0,[r4,#0]            ;213
0001b6  f8d410ac          LDR      r1,[r4,#0xac]         ;213
0001ba  f1a40494          SUB      r4,r4,#0x94           ;213
0001be  4288              CMP      r0,r1                 ;213
0001c0  d204              BCS      |L1.460|
0001c2  4620              MOV      r0,r4                 ;214
0001c4  f7fffffe          BL       start_iMCU_row
0001c8  2003              MOVS     r0,#3                 ;215
0001ca  e76e              B        |L1.170|
                  |L1.460|
0001cc  f8d401b4          LDR      r0,[r4,#0x1b4]        ;218
0001d0  68c1              LDR      r1,[r0,#0xc]          ;218
0001d2  4620              MOV      r0,r4                 ;218
0001d4  4788              BLX      r1                    ;218
0001d6  2004              MOVS     r0,#4                 ;219
0001d8  e767              B        |L1.170|
;;;221    
                          ENDP

                  dummy_consume_data PROC
;;;227    METHODDEF(int)
;;;228    dummy_consume_data (j_decompress_ptr cinfo)
0001da  4601              MOV      r1,r0
;;;229    {
;;;230      GUI_USE_PARA(cinfo);
0001dc  bf00              NOP      
;;;231      return JPEG_SUSPENDED;	/* Always indicate nothing was done */
0001de  f04f0000          MOV      r0,#0
;;;232    }
0001e2  4770              BX       lr
;;;233    
                          ENDP

                  consume_data PROC
;;;244    METHODDEF(int)
;;;245    consume_data (j_decompress_ptr cinfo)
0001e4  e92d4ff0          PUSH     {r4-r11,lr}
;;;246    {
0001e8  b089              SUB      sp,sp,#0x24
0001ea  4604              MOV      r4,r0
;;;247      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
0001ec  f8d451ac          LDR      r5,[r4,#0x1ac]
;;;248      JDIMENSION MCU_col_num;	/* index of current MCU within row */
;;;249      int blkn, ci, xindex, yindex, yoffset;
;;;250      JDIMENSION start_col;
;;;251      JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
;;;252      JBLOCKROW buffer_ptr;
;;;253      jpeg_component_info *compptr;
;;;254    
;;;255      /* Align the virtual buffers for the components used in this scan. */
;;;256      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
0001f0  f04f0600          MOV      r6,#0
0001f4  e01c              B        |L1.560|
                  |L1.502|
;;;257        compptr = cinfo->cur_comp_info[ci];
0001f6  f50470a6          ADD      r0,r4,#0x14c
0001fa  f8507026          LDR      r7,[r0,r6,LSL #2]
;;;258        buffer[ci] = (*cinfo->mem->access_virt_barray)
0001fe  f04f0001          MOV      r0,#1
000202  9000              STR      r0,[sp,#0]
000204  f8d40094          LDR      r0,[r4,#0x94]
000208  f8d7e00c          LDR      lr,[r7,#0xc]
00020c  fb00f20e          MUL      r2,r0,lr
000210  4673              MOV      r3,lr
000212  f1050e48          ADD      lr,r5,#0x48
000216  6878              LDR      r0,[r7,#4]
000218  f85e1020          LDR      r1,[lr,r0,LSL #2]
00021c  6860              LDR      r0,[r4,#4]
00021e  f8d0c020          LDR      r12,[r0,#0x20]
000222  4620              MOV      r0,r4
000224  47e0              BLX      r12
000226  a903              ADD      r1,sp,#0xc
000228  f8410026          STR      r0,[r1,r6,LSL #2]
00022c  f1060601          ADD      r6,r6,#1              ;256
                  |L1.560|
000230  f8d40148          LDR      r0,[r4,#0x148]        ;256
000234  42b0              CMP      r0,r6                 ;256
000236  dcde              BGT      |L1.502|
;;;259          ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
;;;260           cinfo->input_iMCU_row * compptr->v_samp_factor,
;;;261           (JDIMENSION) compptr->v_samp_factor, TRUE);
;;;262        /* Note: entropy decoder expects buffer to be zeroed,
;;;263         * but this is handled automatically by the memory manager
;;;264         * because we requested a pre-zeroed array.
;;;265         */
;;;266      }
;;;267    
;;;268      /* Loop to process one whole iMCU row */
;;;269      for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
000238  f8d58018          LDR      r8,[r5,#0x18]
00023c  e058              B        |L1.752|
                  |L1.574|
;;;270           yoffset++) {
;;;271        for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
00023e  f8d59014          LDR      r9,[r5,#0x14]
000242  e04c              B        |L1.734|
                  |L1.580|
;;;272    	 MCU_col_num++) {
;;;273          /* Construct list of pointers to DCT blocks belonging to this MCU */
;;;274          blkn = 0;			/* index of current DCT block within MCU */
000244  f04f0000          MOV      r0,#0
000248  9008              STR      r0,[sp,#0x20]
;;;275          for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
00024a  4606              MOV      r6,r0
00024c  e031              B        |L1.690|
                  |L1.590|
;;;276    	compptr = cinfo->cur_comp_info[ci];
00024e  f50470a6          ADD      r0,r4,#0x14c
000252  f8507026          LDR      r7,[r0,r6,LSL #2]
;;;277    	start_col = MCU_col_num * compptr->MCU_width;
000256  6b78              LDR      r0,[r7,#0x34]
000258  fb00f009          MUL      r0,r0,r9
00025c  9007              STR      r0,[sp,#0x1c]
;;;278    	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
00025e  f04f0a00          MOV      r10,#0
000262  e021              B        |L1.680|
                  |L1.612|
;;;279    	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
000264  a803              ADD      r0,sp,#0xc
000266  f8500026          LDR      r0,[r0,r6,LSL #2]
00026a  eb0a0108          ADD      r1,r10,r8
00026e  f8501021          LDR      r1,[r0,r1,LSL #2]
000272  9807              LDR      r0,[sp,#0x1c]
000274  eb0110c0          ADD      r0,r1,r0,LSL #7
000278  9002              STR      r0,[sp,#8]
;;;280    	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
00027a  f04f0b00          MOV      r11,#0
00027e  e00e              B        |L1.670|
                  |L1.640|
;;;281    	    coef->MCU_buffer[blkn++] = buffer_ptr++;
000280  9808              LDR      r0,[sp,#0x20]
000282  f1000201          ADD      r2,r0,#1
000286  9902              LDR      r1,[sp,#8]
000288  9208              STR      r2,[sp,#0x20]
00028a  f1050220          ADD      r2,r5,#0x20
00028e  f8421020          STR      r1,[r2,r0,LSL #2]
000292  9802              LDR      r0,[sp,#8]
000294  f1000080          ADD      r0,r0,#0x80
000298  9002              STR      r0,[sp,#8]
00029a  f10b0b01          ADD      r11,r11,#1            ;280
                  |L1.670|
00029e  6b78              LDR      r0,[r7,#0x34]         ;280
0002a0  4558              CMP      r0,r11                ;280
0002a2  dced              BGT      |L1.640|
0002a4  f10a0a01          ADD      r10,r10,#1            ;278
                  |L1.680|
0002a8  6bb8              LDR      r0,[r7,#0x38]         ;278
0002aa  4550              CMP      r0,r10                ;278
0002ac  dcda              BGT      |L1.612|
0002ae  f1060601          ADD      r6,r6,#1              ;275
                  |L1.690|
0002b2  f8d40148          LDR      r0,[r4,#0x148]        ;275
0002b6  42b0              CMP      r0,r6                 ;275
0002b8  dcc9              BGT      |L1.590|
;;;282    	  }
;;;283    	}
;;;284          }
;;;285          /* Try to fetch the MCU. */
;;;286          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
0002ba  f8d401bc          LDR      r0,[r4,#0x1bc]
0002be  f1050120          ADD      r1,r5,#0x20
0002c2  6842              LDR      r2,[r0,#4]
0002c4  4620              MOV      r0,r4
0002c6  4790              BLX      r2
0002c8  b938              CBNZ     r0,|L1.730|
;;;287    	/* Suspension forced; update state counters and exit */
;;;288    	coef->MCU_vert_offset = yoffset;
0002ca  f8c58018          STR      r8,[r5,#0x18]
;;;289    	coef->MCU_ctr = MCU_col_num;
0002ce  f8c59014          STR      r9,[r5,#0x14]
;;;290    	return JPEG_SUSPENDED;
0002d2  2000              MOVS     r0,#0
                  |L1.724|
;;;291          }
;;;292        }
;;;293        /* Completed an MCU row, but perhaps not an iMCU row */
;;;294        coef->MCU_ctr = 0;
;;;295      }
;;;296      /* Completed the iMCU row, advance counters for next one */
;;;297      if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
;;;298        start_iMCU_row(cinfo);
;;;299        return JPEG_ROW_COMPLETED;
;;;300      }
;;;301      /* Completed the scan */
;;;302      (*cinfo->inputctl->finish_input_pass) (cinfo);
;;;303      return JPEG_SCAN_COMPLETED;
;;;304    }
0002d4  b009              ADD      sp,sp,#0x24
0002d6  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.730|
0002da  f1090901          ADD      r9,r9,#1              ;272
                  |L1.734|
0002de  f8d4015c          LDR      r0,[r4,#0x15c]        ;271
0002e2  4548              CMP      r0,r9                 ;271
0002e4  d8ae              BHI      |L1.580|
0002e6  f04f0000          MOV      r0,#0                 ;294
0002ea  6168              STR      r0,[r5,#0x14]         ;294
0002ec  f1080801          ADD      r8,r8,#1              ;270
                  |L1.752|
0002f0  69e8              LDR      r0,[r5,#0x1c]         ;269
0002f2  4540              CMP      r0,r8                 ;269
0002f4  dca3              BGT      |L1.574|
0002f6  f8d40094          LDR      r0,[r4,#0x94]         ;297
0002fa  1c40              ADDS     r0,r0,#1              ;297
0002fc  f8c40094          STR      r0,[r4,#0x94]         ;297
000300  f8d41140          LDR      r1,[r4,#0x140]        ;297
000304  4288              CMP      r0,r1                 ;297
000306  d204              BCS      |L1.786|
000308  4620              MOV      r0,r4                 ;298
00030a  f7fffffe          BL       start_iMCU_row
00030e  2003              MOVS     r0,#3                 ;299
000310  e7e0              B        |L1.724|
                  |L1.786|
000312  f8d401b4          LDR      r0,[r4,#0x1b4]        ;302
000316  68c1              LDR      r1,[r0,#0xc]          ;302
000318  4620              MOV      r0,r4                 ;302
00031a  4788              BLX      r1                    ;302
00031c  2004              MOVS     r0,#4                 ;303
00031e  e7d9              B        |L1.724|
;;;305    
                          ENDP

                  decompress_data PROC
;;;315    METHODDEF(int)
;;;316    decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
000320  e92d4ff0          PUSH     {r4-r11,lr}
;;;317    {
000324  b087              SUB      sp,sp,#0x1c
000326  4604              MOV      r4,r0
000328  4689              MOV      r9,r1
;;;318      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
00032a  f8d401ac          LDR      r0,[r4,#0x1ac]
00032e  9006              STR      r0,[sp,#0x18]
;;;319      JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
000330  f8d40140          LDR      r0,[r4,#0x140]
000334  f1a00001          SUB      r0,r0,#1
000338  9005              STR      r0,[sp,#0x14]
;;;320      JDIMENSION block_num;
;;;321      int ci, block_row, block_rows;
;;;322      JBLOCKARRAY buffer;
;;;323      JBLOCKROW buffer_ptr;
;;;324      JSAMPARRAY output_ptr;
;;;325      JDIMENSION output_col;
;;;326      jpeg_component_info *compptr;
;;;327      inverse_DCT_method_ptr inverse_DCT;
;;;328    
;;;329      /* Force some input to be done if we are getting ahead of the input. */
;;;330      while (cinfo->input_scan_number < cinfo->output_scan_number ||
00033a  e009              B        |L1.848|
                  |L1.828|
;;;331    	 (cinfo->input_scan_number == cinfo->output_scan_number &&
;;;332    	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
;;;333        if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
00033c  f8d401b4          LDR      r0,[r4,#0x1b4]
000340  6801              LDR      r1,[r0,#0]
000342  4620              MOV      r0,r4
000344  4788              BLX      r1
000346  b918              CBNZ     r0,|L1.848|
;;;334          return JPEG_SUSPENDED;
000348  2000              MOVS     r0,#0
                  |L1.842|
;;;335      }
;;;336    
;;;337      /* OK, output from the virtual arrays. */
;;;338      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;339           ci++, compptr++) {
;;;340        /* Don't bother to IDCT an uninteresting component. */
;;;341        if (! compptr->component_needed)
;;;342          continue;
;;;343        /* Align the virtual buffer for this component. */
;;;344        buffer = (*cinfo->mem->access_virt_barray)
;;;345          ((j_common_ptr) cinfo, coef->whole_image[ci],
;;;346           cinfo->output_iMCU_row * compptr->v_samp_factor,
;;;347           (JDIMENSION) compptr->v_samp_factor, FALSE);
;;;348        /* Count non-dummy DCT block rows in this iMCU row. */
;;;349        if (cinfo->output_iMCU_row < last_iMCU_row)
;;;350          block_rows = compptr->v_samp_factor;
;;;351        else {
;;;352          /* NB: can't use last_row_height here; it is input-side-dependent! */
;;;353          block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
;;;354          if (block_rows == 0) block_rows = compptr->v_samp_factor;
;;;355        }
;;;356        inverse_DCT = cinfo->idct->inverse_DCT[ci];
;;;357        output_ptr = output_buf[ci];
;;;358        /* Loop over all DCT blocks to be processed. */
;;;359        for (block_row = 0; block_row < block_rows; block_row++) {
;;;360          buffer_ptr = buffer[block_row];
;;;361          output_col = 0;
;;;362          for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
;;;363    	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
;;;364    			output_ptr, output_col);
;;;365    	buffer_ptr++;
;;;366    	output_col += compptr->DCT_scaled_size;
;;;367          }
;;;368          output_ptr += compptr->DCT_scaled_size;
;;;369        }
;;;370      }
;;;371    
;;;372      if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
;;;373        return JPEG_ROW_COMPLETED;
;;;374      return JPEG_SCAN_COMPLETED;
;;;375    }
00034a  b007              ADD      sp,sp,#0x1c
00034c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.848|
000350  f8d41098          LDR      r1,[r4,#0x98]         ;330
000354  f8d40090          LDR      r0,[r4,#0x90]         ;330
000358  4288              CMP      r0,r1                 ;330
00035a  dbef              BLT      |L1.828|
00035c  f8d41098          LDR      r1,[r4,#0x98]         ;331
000360  f8d40090          LDR      r0,[r4,#0x90]         ;331
000364  4288              CMP      r0,r1                 ;331
000366  d105              BNE      |L1.884|
000368  f8d4109c          LDR      r1,[r4,#0x9c]         ;332
00036c  f8d40094          LDR      r0,[r4,#0x94]         ;332
000370  4288              CMP      r0,r1                 ;332
000372  d9e3              BLS      |L1.828|
                  |L1.884|
000374  f04f0600          MOV      r6,#0                 ;338
000378  f8d450d8          LDR      r5,[r4,#0xd8]         ;338
00037c  e05f              B        |L1.1086|
                  |L1.894|
00037e  6b28              LDR      r0,[r5,#0x30]         ;341
000380  b900              CBNZ     r0,|L1.900|
000382  e058              B        |L1.1078|
                  |L1.900|
000384  2000              MOVS     r0,#0                 ;344
000386  9000              STR      r0,[sp,#0]            ;344
000388  f8d4009c          LDR      r0,[r4,#0x9c]         ;344
00038c  f8d5e00c          LDR      lr,[r5,#0xc]          ;344
000390  fb00f20e          MUL      r2,r0,lr              ;344
000394  4673              MOV      r3,lr                 ;344
000396  9806              LDR      r0,[sp,#0x18]         ;344
000398  3048              ADDS     r0,r0,#0x48           ;344
00039a  f8501026          LDR      r1,[r0,r6,LSL #2]     ;344
00039e  6860              LDR      r0,[r4,#4]            ;344
0003a0  f8d0c020          LDR      r12,[r0,#0x20]        ;344
0003a4  4620              MOV      r0,r4                 ;344
0003a6  47e0              BLX      r12                   ;344
0003a8  4680              MOV      r8,r0                 ;344
0003aa  f8d4109c          LDR      r1,[r4,#0x9c]         ;349
0003ae  9805              LDR      r0,[sp,#0x14]         ;349
0003b0  4281              CMP      r1,r0                 ;349
0003b2  d202              BCS      |L1.954|
0003b4  68e8              LDR      r0,[r5,#0xc]          ;350
0003b6  9004              STR      r0,[sp,#0x10]         ;350
0003b8  e00a              B        |L1.976|
                  |L1.954|
0003ba  68e9              LDR      r1,[r5,#0xc]          ;353
0003bc  6a28              LDR      r0,[r5,#0x20]         ;353
0003be  fbb0f2f1          UDIV     r2,r0,r1              ;353
0003c2  fb010012          MLS      r0,r1,r2,r0           ;353
0003c6  9004              STR      r0,[sp,#0x10]         ;353
0003c8  9804              LDR      r0,[sp,#0x10]         ;354
0003ca  b908              CBNZ     r0,|L1.976|
0003cc  68e8              LDR      r0,[r5,#0xc]          ;354
0003ce  9004              STR      r0,[sp,#0x10]         ;354
                  |L1.976|
0003d0  f8d401c0          LDR      r0,[r4,#0x1c0]        ;356
0003d4  f1000004          ADD      r0,r0,#4              ;356
0003d8  f850b026          LDR      r11,[r0,r6,LSL #2]    ;356
0003dc  f8590026          LDR      r0,[r9,r6,LSL #2]     ;357
0003e0  9002              STR      r0,[sp,#8]            ;357
0003e2  f04f0700          MOV      r7,#0                 ;359
0003e6  e022              B        |L1.1070|
                  |L1.1000|
0003e8  f8580027          LDR      r0,[r8,r7,LSL #2]     ;360
0003ec  9003              STR      r0,[sp,#0xc]          ;360
0003ee  f04f0000          MOV      r0,#0                 ;361
0003f2  9001              STR      r0,[sp,#4]            ;361
0003f4  4682              MOV      r10,r0                ;362
0003f6  e010              B        |L1.1050|
                  |L1.1016|
0003f8  9801              LDR      r0,[sp,#4]            ;363
0003fa  9000              STR      r0,[sp,#0]            ;363
0003fc  4629              MOV      r1,r5                 ;363
0003fe  4620              MOV      r0,r4                 ;363
000400  e9dd3202          LDRD     r3,r2,[sp,#8]         ;363
000404  47d8              BLX      r11                   ;363
000406  9803              LDR      r0,[sp,#0xc]          ;365
000408  f1000080          ADD      r0,r0,#0x80           ;365
00040c  9003              STR      r0,[sp,#0xc]          ;365
00040e  6a69              LDR      r1,[r5,#0x24]         ;366
000410  9801              LDR      r0,[sp,#4]            ;366
000412  4408              ADD      r0,r0,r1              ;366
000414  9001              STR      r0,[sp,#4]            ;366
000416  f10a0a01          ADD      r10,r10,#1            ;362
                  |L1.1050|
00041a  69e8              LDR      r0,[r5,#0x1c]         ;362
00041c  4550              CMP      r0,r10                ;362
00041e  d8eb              BHI      |L1.1016|
000420  6a69              LDR      r1,[r5,#0x24]         ;368
000422  9802              LDR      r0,[sp,#8]            ;368
000424  eb000081          ADD      r0,r0,r1,LSL #2       ;368
000428  9002              STR      r0,[sp,#8]            ;368
00042a  f1070701          ADD      r7,r7,#1              ;359
                  |L1.1070|
00042e  9804              LDR      r0,[sp,#0x10]         ;359
000430  4287              CMP      r7,r0                 ;359
000432  dbd9              BLT      |L1.1000|
000434  bf00              NOP                            ;342
                  |L1.1078|
000436  f1060601          ADD      r6,r6,#1              ;339
00043a  f1050554          ADD      r5,r5,#0x54           ;339
                  |L1.1086|
00043e  6a60              LDR      r0,[r4,#0x24]         ;338
000440  42b0              CMP      r0,r6                 ;338
000442  dc9c              BGT      |L1.894|
000444  f8d4009c          LDR      r0,[r4,#0x9c]         ;372
000448  1c40              ADDS     r0,r0,#1              ;372
00044a  f8c4009c          STR      r0,[r4,#0x9c]         ;372
00044e  f8d41140          LDR      r1,[r4,#0x140]        ;372
000452  4288              CMP      r0,r1                 ;372
000454  d201              BCS      |L1.1114|
000456  2003              MOVS     r0,#3                 ;373
000458  e777              B        |L1.842|
                  |L1.1114|
00045a  2004              MOVS     r0,#4                 ;374
00045c  e775              B        |L1.842|
;;;376    
                          ENDP

                  jinit_d_coef_controller PROC
;;;676    GLOBAL(void)
;;;677    jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
00045e  e92d5ffc          PUSH     {r2-r12,lr}
;;;678    {
000462  4605              MOV      r5,r0
000464  4688              MOV      r8,r1
;;;679      my_coef_ptr coef;
;;;680    
;;;681      coef = (my_coef_ptr)
000466  6868              LDR      r0,[r5,#4]
000468  f04f0258          MOV      r2,#0x58
00046c  f04f0101          MOV      r1,#1
000470  6803              LDR      r3,[r0,#0]
000472  4628              MOV      r0,r5
000474  4798              BLX      r3
000476  4604              MOV      r4,r0
;;;682        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;683    				SIZEOF(my_coef_controller));
;;;684      cinfo->coef = (struct jpeg_d_coef_controller *) coef;
000478  f8c541ac          STR      r4,[r5,#0x1ac]
;;;685      coef->pub.start_input_pass = start_input_pass;
00047c  4829              LDR      r0,|L1.1316|
00047e  6020              STR      r0,[r4,#0]
;;;686      coef->pub.start_output_pass = start_output_pass;
000480  4829              LDR      r0,|L1.1320|
000482  60a0              STR      r0,[r4,#8]
;;;687    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;688      coef->coef_bits_latch = NULL;
;;;689    #endif
;;;690    
;;;691      /* Create the coefficient buffer. */
;;;692      if (need_full_buffer) {
000484  f1b80f00          CMP      r8,#0
000488  d02d              BEQ      |L1.1254|
;;;693    #ifdef D_MULTISCAN_FILES_SUPPORTED
;;;694        /* Allocate a full-image virtual array for each component, */
;;;695        /* padded to a multiple of samp_factor DCT blocks in each direction. */
;;;696        /* Note we ask for a pre-zeroed array. */
;;;697        int ci, access_rows;
;;;698        jpeg_component_info *compptr;
;;;699    
;;;700        for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00048a  f04f0700          MOV      r7,#0
00048e  f8d560d8          LDR      r6,[r5,#0xd8]
000492  e01d              B        |L1.1232|
                  |L1.1172|
;;;701    	 ci++, compptr++) {
;;;702          access_rows = compptr->v_samp_factor;
000494  f8d6900c          LDR      r9,[r6,#0xc]
;;;703    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;704          /* If block smoothing could be used, need a bigger window */
;;;705          if (cinfo->progressive_mode)
;;;706    	access_rows *= 3;
;;;707    #endif
;;;708          coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
000498  68f1              LDR      r1,[r6,#0xc]
00049a  6a30              LDR      r0,[r6,#0x20]
00049c  f7fffffe          BL       jround_up
0004a0  4682              MOV      r10,r0
0004a2  68b1              LDR      r1,[r6,#8]
0004a4  69f0              LDR      r0,[r6,#0x1c]
0004a6  f7fffffe          BL       jround_up
0004aa  4683              MOV      r11,r0
0004ac  e9cda900          STRD     r10,r9,[sp,#0]
0004b0  6868              LDR      r0,[r5,#4]
0004b2  465b              MOV      r3,r11
0004b4  2201              MOVS     r2,#1
0004b6  4611              MOV      r1,r2
0004b8  f8d0c014          LDR      r12,[r0,#0x14]
0004bc  4628              MOV      r0,r5
0004be  47e0              BLX      r12
0004c0  f1040148          ADD      r1,r4,#0x48
0004c4  f8410027          STR      r0,[r1,r7,LSL #2]
0004c8  f1070701          ADD      r7,r7,#1              ;701
0004cc  f1060654          ADD      r6,r6,#0x54           ;701
                  |L1.1232|
0004d0  6a68              LDR      r0,[r5,#0x24]         ;700
0004d2  42b8              CMP      r0,r7                 ;700
0004d4  dcde              BGT      |L1.1172|
;;;709    	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
;;;710    	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
;;;711    				(long) compptr->h_samp_factor),
;;;712    	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
;;;713    				(long) compptr->v_samp_factor),
;;;714    	 (JDIMENSION) access_rows);
;;;715        }
;;;716        coef->pub.consume_data = consume_data;
0004d6  4815              LDR      r0,|L1.1324|
0004d8  6060              STR      r0,[r4,#4]
;;;717        coef->pub.decompress_data = decompress_data;
0004da  4815              LDR      r0,|L1.1328|
0004dc  60e0              STR      r0,[r4,#0xc]
;;;718        coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
0004de  f1040048          ADD      r0,r4,#0x48
0004e2  6120              STR      r0,[r4,#0x10]
;;;719    #else
;;;720        ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;721    #endif
;;;722      } else {
0004e4  e01c              B        |L1.1312|
                  |L1.1254|
;;;723        /* We only need a single-MCU buffer. */
;;;724        JBLOCKROW buffer;
;;;725        int i;
;;;726    
;;;727        buffer = (JBLOCKROW)
0004e6  6868              LDR      r0,[r5,#4]
0004e8  f44f62a0          MOV      r2,#0x500
0004ec  2101              MOVS     r1,#1
0004ee  6843              LDR      r3,[r0,#4]
0004f0  4628              MOV      r0,r5
0004f2  4798              BLX      r3
0004f4  4607              MOV      r7,r0
;;;728          (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;729    				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
;;;730        for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
0004f6  f04f0600          MOV      r6,#0
0004fa  e007              B        |L1.1292|
                  |L1.1276|
;;;731          coef->MCU_buffer[i] = buffer + i;
0004fc  eb0711c6          ADD      r1,r7,r6,LSL #7
000500  f1040020          ADD      r0,r4,#0x20
000504  f8401026          STR      r1,[r0,r6,LSL #2]
000508  f1060601          ADD      r6,r6,#1              ;730
                  |L1.1292|
00050c  2e0a              CMP      r6,#0xa               ;730
00050e  dbf5              BLT      |L1.1276|
;;;732        }
;;;733        coef->pub.consume_data = dummy_consume_data;
000510  4808              LDR      r0,|L1.1332|
000512  6060              STR      r0,[r4,#4]
;;;734        coef->pub.decompress_data = decompress_onepass;
000514  4808              LDR      r0,|L1.1336|
000516  60e0              STR      r0,[r4,#0xc]
;;;735        coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
000518  f04f0000          MOV      r0,#0
00051c  6120              STR      r0,[r4,#0x10]
;;;736      }
00051e  bf00              NOP      
                  |L1.1312|
;;;737    }
000520  e8bd9ffc          POP      {r2-r12,pc}
                          ENDP

                  |L1.1316|
                          DCD      start_input_pass
                  |L1.1320|
                          DCD      start_output_pass
                  |L1.1324|
                          DCD      consume_data
                  |L1.1328|
                          DCD      decompress_data
                  |L1.1332|
                          DCD      dummy_consume_data
                  |L1.1336|
                          DCD      decompress_onepass
