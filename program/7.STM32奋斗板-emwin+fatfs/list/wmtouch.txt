; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\wmtouch.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\wmtouch.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\wmtouch.crf GUI\WM\WMTouch.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  WM__IsInModalArea PROC
;;;48     */
;;;49     int WM__IsInModalArea(WM_HWIN hWin) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;50       if ((WM__CHWinModal.hWin == 0) || WM__IsAncestor(hWin, WM__CHWinModal.hWin) || (hWin == WM__CHWinModal.hWin)) {
000004  48a4              LDR      r0,|L1.664|
000006  8880              LDRH     r0,[r0,#4]  ; WM__CHWinModal
000008  b158              CBZ      r0,|L1.34|
00000a  48a3              LDR      r0,|L1.664|
00000c  f9b01004          LDRSH    r1,[r0,#4]  ; WM__CHWinModal
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       WM__IsAncestor
000016  b920              CBNZ     r0,|L1.34|
000018  489f              LDR      r0,|L1.664|
00001a  f9b00004          LDRSH    r0,[r0,#4]  ; WM__CHWinModal
00001e  42a0              CMP      r0,r4
000020  d101              BNE      |L1.38|
                  |L1.34|
;;;51         return 1;
000022  2001              MOVS     r0,#1
                  |L1.36|
;;;52       }
;;;53       return 0;
;;;54     }
000024  bd10              POP      {r4,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;53
000028  e7fc              B        |L1.36|
;;;55     
                          ENDP

                  WM__SendPIDMessage PROC
;;;65     */
;;;66     void WM__SendPIDMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00002a  b5fe              PUSH     {r1-r7,lr}
00002c  4604              MOV      r4,r0
00002e  460d              MOV      r5,r1
;;;67       #if 1
;;;68       WM_HWIN iWin;
;;;69       WM_MESSAGE Msg;
;;;70       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
000030  e8950007          LDM      r5,{r0-r2}
000034  e88d0007          STM      sp,{r0-r2}
;;;71       /* Send notification to all ancestors.
;;;72          We need to check if the window which has received the last message still exists,
;;;73          since it may have deleted itself and its parent as result of the message.
;;;74       */
;;;75       Msg.hWinSrc = hWin;
000038  f8ad4006          STRH     r4,[sp,#6]
;;;76       Msg.MsgId   = WM_TOUCH_CHILD;
00003c  f04f000d          MOV      r0,#0xd
000040  9000              STR      r0,[sp,#0]
;;;77       iWin = hWin;
000042  4626              MOV      r6,r4
;;;78       while (WM_IsWindow(iWin)) {
000044  e009              B        |L1.90|
                  |L1.70|
;;;79         iWin = WM_GetParent(iWin);
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       WM_GetParent
00004c  4606              MOV      r6,r0
;;;80         if (iWin) {
00004e  b126              CBZ      r6,|L1.90|
;;;81           Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
000050  9502              STR      r5,[sp,#8]
;;;82           WM__SendMessageIfEnabled(iWin, &Msg);    /* Send message to the ancestors */
000052  4669              MOV      r1,sp
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       WM__SendMessageIfEnabled
                  |L1.90|
00005a  4630              MOV      r0,r6                 ;78
00005c  f7fffffe          BL       WM_IsWindow
000060  2800              CMP      r0,#0                 ;78
000062  d1f0              BNE      |L1.70|
;;;83         }
;;;84       }
;;;85       /* Send message to the affected window */
;;;86       WM__SendMessageIfEnabled(hWin, pMsg);
000064  4629              MOV      r1,r5
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       WM__SendMessageIfEnabled
;;;87       #else
;;;88       WM_MESSAGE Msg;
;;;89       /* Send message to the affected window */
;;;90       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
;;;91       WM__SendMessageIfEnabled(hWin, &Msg);
;;;92       /* Send notification to all ancestors.
;;;93          We need to check if the window which has received the last message still exists,
;;;94          since it may have deleted itself and its parent as result of the message.
;;;95       */
;;;96       Msg.hWinSrc = hWin;
;;;97       Msg.MsgId   = WM_TOUCH_CHILD;
;;;98       while (WM_IsWindow(hWin)) {
;;;99         hWin = WM_GetParent(hWin);
;;;100        if (hWin) {
;;;101          Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
;;;102          WM__SendMessageIfEnabled(hWin, &Msg);    /* Send message to the ancestors */
;;;103        }
;;;104      }
;;;105      #endif
;;;106    }
00006c  bdfe              POP      {r1-r7,pc}
;;;107    
                          ENDP

                  WM__SendTouchMessage PROC
;;;111    */
;;;112    void WM__SendTouchMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00006e  e92d41f0          PUSH     {r4-r8,lr}
000072  4607              MOV      r7,r0
000074  460d              MOV      r5,r1
;;;113      GUI_PID_STATE* pState;
;;;114      pState     = (GUI_PID_STATE*)pMsg->Data.p;
000076  68ac              LDR      r4,[r5,#8]
;;;115      if (pState) {
000078  b184              CBZ      r4,|L1.156|
;;;116        WM_Obj* pWin;
;;;117        pWin       = WM_H2P(hWin);
00007a  4638              MOV      r0,r7
00007c  f7fffffe          BL       GUI_ALLOC_h2p
000080  4606              MOV      r6,r0
;;;118        pState->x -= pWin->Rect.x0;
000082  f9b61000          LDRSH    r1,[r6,#0]
000086  6820              LDR      r0,[r4,#0]
000088  eba00001          SUB      r0,r0,r1
00008c  6020              STR      r0,[r4,#0]
;;;119        pState->y -= pWin->Rect.y0;
00008e  f9b61002          LDRSH    r1,[r6,#2]
000092  6860              LDR      r0,[r4,#4]
000094  eba00001          SUB      r0,r0,r1
000098  6060              STR      r0,[r4,#4]
;;;120      }
00009a  bf00              NOP      
                  |L1.156|
;;;121      WM__SendPIDMessage(hWin, pMsg);
00009c  4629              MOV      r1,r5
00009e  4638              MOV      r0,r7
0000a0  f7fffffe          BL       WM__SendPIDMessage
;;;122    }
0000a4  e8bd81f0          POP      {r4-r8,pc}
;;;123    
                          ENDP

                  _Screen2Win PROC
;;;133    */
;;;134    static WM_HWIN _Screen2Win(GUI_PID_STATE* pState) {
0000a8  b510              PUSH     {r4,lr}
0000aa  4604              MOV      r4,r0
;;;135      if (WM__hCapture == 0) {
0000ac  487b              LDR      r0,|L1.668|
0000ae  8800              LDRH     r0,[r0,#0]  ; WM__hCapture
0000b0  b920              CBNZ     r0,|L1.188|
;;;136        return WM_Screen2hWin(pState->x, pState->y);
0000b2  e9d40100          LDRD     r0,r1,[r4,#0]
0000b6  f7fffffe          BL       WM_Screen2hWin
                  |L1.186|
;;;137      } 
;;;138      return WM__hCapture;
;;;139    }
0000ba  bd10              POP      {r4,pc}
                  |L1.188|
0000bc  4877              LDR      r0,|L1.668|
0000be  f9b00000          LDRSH    r0,[r0,#0]            ;138  ; WM__hCapture
0000c2  e7fa              B        |L1.186|
;;;140    
                          ENDP

                  WM_HandlePID PROC
;;;157    */
;;;158    int WM_HandlePID(void) {
0000c4  b570              PUSH     {r4-r6,lr}
0000c6  b092              SUB      sp,sp,#0x48
;;;159      int r = 0;
0000c8  f04f0600          MOV      r6,#0
;;;160      WM_MESSAGE Msg;
;;;161      WM_CRITICAL_HANDLE CHWin;
;;;162      GUI_PID_STATE State = {0}, StateNew;
0000cc  4630              MOV      r0,r6
0000ce  900a              STR      r0,[sp,#0x28]
0000d0  900b              STR      r0,[sp,#0x2c]
0000d2  900c              STR      r0,[sp,#0x30]
;;;163      GUI_PID_GetState(&StateNew);
0000d4  a807              ADD      r0,sp,#0x1c
0000d6  f7fffffe          BL       GUI_PID_GetState
;;;164      WM_LOCK();
;;;165      StateNew.x += GUI_OrgX;
0000da  4971              LDR      r1,|L1.672|
0000dc  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgX
0000e0  9807              LDR      r0,[sp,#0x1c]
0000e2  4408              ADD      r0,r0,r1
0000e4  9007              STR      r0,[sp,#0x1c]
;;;166      StateNew.y += GUI_OrgY;
0000e6  496f              LDR      r1,|L1.676|
0000e8  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgY
0000ec  9808              LDR      r0,[sp,#0x20]
0000ee  4408              ADD      r0,r0,r1
0000f0  9008              STR      r0,[sp,#0x20]
;;;167      WM__AddCriticalHandle(&CHWin);
0000f2  a80d              ADD      r0,sp,#0x34
0000f4  f7fffffe          BL       WM__AddCriticalHandle
;;;168      if ((WM_PID__StateLast.x != StateNew.x) || (WM_PID__StateLast.y != StateNew.y) || (WM_PID__StateLast.Pressed != StateNew.Pressed)) {
0000f8  486b              LDR      r0,|L1.680|
0000fa  6800              LDR      r0,[r0,#0]  ; WM_PID__StateLast
0000fc  9907              LDR      r1,[sp,#0x1c]
0000fe  4288              CMP      r0,r1
000100  d10a              BNE      |L1.280|
000102  4869              LDR      r0,|L1.680|
000104  6840              LDR      r0,[r0,#4]  ; WM_PID__StateLast
000106  9908              LDR      r1,[sp,#0x20]
000108  4288              CMP      r0,r1
00010a  d105              BNE      |L1.280|
00010c  4866              LDR      r0,|L1.680|
00010e  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
000110  f89d1024          LDRB     r1,[sp,#0x24]
000114  4288              CMP      r0,r1
000116  d077              BEQ      |L1.520|
                  |L1.280|
;;;169        #if GUI_SUPPORT_CURSOR
;;;170          GUI_CURSOR_SetPosition(StateNew.x, StateNew.y);
;;;171        #endif
;;;172        CHWin.hWin = _Screen2Win(&StateNew);
000118  a807              ADD      r0,sp,#0x1c
00011a  f7fffffe          BL       _Screen2Win
00011e  f8ad0038          STRH     r0,[sp,#0x38]
;;;173        #if GUI_SUPPORT_MOUSE
;;;174        /* Send WM_MOUSEOVER_END Message */
;;;175        if (WM__CHWinMouseOver.hWin && (WM__CHWinMouseOver.hWin != CHWin.hWin)) {
;;;176          if (WM__IsInModalArea(WM__CHWinMouseOver.hWin)) {
;;;177            /* Do not send messages to disabled windows */
;;;178            if (WM__IsEnabled(WM__CHWinMouseOver.hWin)) {
;;;179              State      = StateNew;
;;;180              Msg.MsgId  = WM_MOUSEOVER_END;
;;;181              Msg.Data.p = (void*)&State;
;;;182              WM__SendTouchMessage(WM__CHWinMouseOver.hWin, &Msg);
;;;183              WM__CHWinMouseOver.hWin = 0;
;;;184            }
;;;185          }
;;;186        }
;;;187        #endif
;;;188        if (WM__IsInModalArea(CHWin.hWin)) {
000122  f9bd0038          LDRSH    r0,[sp,#0x38]
000126  f7fffffe          BL       WM__IsInModalArea
00012a  2800              CMP      r0,#0
00012c  d06d              BEQ      |L1.522|
;;;189          #if GUI_SUPPORT_MOUSE
;;;190            WM__CHWinMouseOver.hWin = CHWin.hWin;
;;;191          #endif
;;;192          /*
;;;193           * Send WM_PID_STATE_CHANGED message if state has changed (just pressed or just released)
;;;194           */
;;;195          if ((WM_PID__StateLast.Pressed != StateNew.Pressed) && CHWin.hWin) {
00012e  485e              LDR      r0,|L1.680|
000130  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
000132  f89d1024          LDRB     r1,[sp,#0x24]
000136  4288              CMP      r0,r1
000138  d04a              BEQ      |L1.464|
00013a  f8bd0038          LDRH     r0,[sp,#0x38]
00013e  2800              CMP      r0,#0
000140  d046              BEQ      |L1.464|
;;;196            GUI_PID_STATE PID_StateOld;
;;;197            WM_HWIN hWinOld;
;;;198            WM_PID_STATE_CHANGED_INFO Info;
;;;199            WM_Obj* pWin;
;;;200            pWin = WM_H2P(CHWin.hWin);
000142  f9bd0038          LDRSH    r0,[sp,#0x38]
000146  f7fffffe          BL       GUI_ALLOC_h2p
00014a  4605              MOV      r5,r0
;;;201            Info.State     = StateNew.Pressed;
00014c  f89d0024          LDRB     r0,[sp,#0x24]
000150  f88d000c          STRB     r0,[sp,#0xc]
;;;202            Info.StatePrev = WM_PID__StateLast.Pressed;
000154  4854              LDR      r0,|L1.680|
000156  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
000158  f88d000d          STRB     r0,[sp,#0xd]
;;;203            Info.x         = StateNew.x - pWin->Rect.x0;
00015c  f9b51000          LDRSH    r1,[r5,#0]
000160  9807              LDR      r0,[sp,#0x1c]
000162  eba00001          SUB      r0,r0,r1
000166  9001              STR      r0,[sp,#4]
;;;204            Info.y         = StateNew.y - pWin->Rect.y0;
000168  f9b51002          LDRSH    r1,[r5,#2]
00016c  9808              LDR      r0,[sp,#0x20]
00016e  eba00001          SUB      r0,r0,r1
000172  9002              STR      r0,[sp,#8]
;;;205            Msg.Data.p = &Info;
000174  a801              ADD      r0,sp,#4
000176  9011              STR      r0,[sp,#0x44]
;;;206            Msg.MsgId  = WM_PID_STATE_CHANGED;
000178  f04f0011          MOV      r0,#0x11
00017c  900f              STR      r0,[sp,#0x3c]
;;;207            /* Make sure that this routine does not react a second time on the same press event.
;;;208             * This could happen if for example a dialog is executed during the WM_PID_STATE_CHANGED message processing
;;;209             */
;;;210            PID_StateOld = WM_PID__StateLast;
00017e  4a4a              LDR      r2,|L1.680|
000180  e9d21000          LDRD     r1,r0,[r2,#0]
000184  6892              LDR      r2,[r2,#8]  ; WM_PID__StateLast
000186  e9cd0205          STRD     r0,r2,[sp,#0x14]
00018a  9104              STR      r1,[sp,#0x10]
;;;211            /* Make sure that in case of creating a new window over the current PID position
;;;212             * during the WM_PID_STATE_CHANGED message processing the old window
;;;213             * will be informed that it is no longer pressed.
;;;214             */
;;;215            WM_PID__StateLast.Pressed = StateNew.Pressed;
00018c  f89d0024          LDRB     r0,[sp,#0x24]
000190  4945              LDR      r1,|L1.680|
000192  7208              STRB     r0,[r1,#8]
;;;216            if (State.Pressed) {
000194  f89d0030          LDRB     r0,[sp,#0x30]
000198  b138              CBZ      r0,|L1.426|
;;;217              hWinOld            = WM__CHWinLast.hWin;
00019a  4844              LDR      r0,|L1.684|
00019c  f9b04004          LDRSH    r4,[r0,#4]  ; WM__CHWinLast
;;;218              WM__CHWinLast.hWin = CHWin.hWin;
0001a0  f8bd0038          LDRH     r0,[sp,#0x38]
0001a4  4941              LDR      r1,|L1.684|
0001a6  8088              STRH     r0,[r1,#4]
0001a8  e001              B        |L1.430|
                  |L1.426|
;;;219            } else {
;;;220              hWinOld            = 0;
0001aa  f04f0400          MOV      r4,#0
                  |L1.430|
;;;221            }
;;;222            WM__SendMessageIfEnabled(CHWin.hWin, &Msg);
0001ae  f9bd0038          LDRSH    r0,[sp,#0x38]
0001b2  a90f              ADD      r1,sp,#0x3c
0001b4  f7fffffe          BL       WM__SendMessageIfEnabled
;;;223            /* Restore state for further processing */
;;;224            WM_PID__StateLast = PID_StateOld;
0001b8  483b              LDR      r0,|L1.680|
0001ba  a904              ADD      r1,sp,#0x10
0001bc  c90e              LDM      r1,{r1-r3}
0001be  c00e              STM      r0!,{r1-r3}
;;;225            if (hWinOld) {
0001c0  b12c              CBZ      r4,|L1.462|
;;;226              /* hWinOld could be deleted during message processing. So check if it is a Window
;;;227               * before using it.
;;;228               */
;;;229              if (WM_IsWindow(hWinOld)) {
0001c2  4620              MOV      r0,r4
0001c4  f7fffffe          BL       WM_IsWindow
0001c8  b108              CBZ      r0,|L1.462|
;;;230                WM__CHWinLast.hWin        = hWinOld;
0001ca  4838              LDR      r0,|L1.684|
0001cc  8084              STRH     r4,[r0,#4]
                  |L1.462|
;;;231              }
;;;232            }
;;;233          }
0001ce  bf00              NOP      
                  |L1.464|
;;;234          /*
;;;235           * Send WM_TOUCH message(s)
;;;236           * Note that we may have to send 2 touch messages.
;;;237           */
;;;238          if (WM_PID__StateLast.Pressed | StateNew.Pressed) {    /* Only if pressed or just released */
0001d0  4835              LDR      r0,|L1.680|
0001d2  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
0001d4  f89d1024          LDRB     r1,[sp,#0x24]
0001d8  4308              ORRS     r0,r0,r1
0001da  d050              BEQ      |L1.638|
;;;239            Msg.MsgId = WM_TOUCH;
0001dc  f04f000c          MOV      r0,#0xc
0001e0  900f              STR      r0,[sp,#0x3c]
;;;240            r = 1;
0001e2  f04f0601          MOV      r6,#1
;;;241            /*
;;;242             * Tell window if it is no longer pressed
;;;243             * This happens for 2 possible reasons:
;;;244             * a) PID is released
;;;245             * b) PID is moved out
;;;246             */
;;;247            if (WM__CHWinLast.hWin != CHWin.hWin) {
0001e6  4831              LDR      r0,|L1.684|
0001e8  f9b00004          LDRSH    r0,[r0,#4]  ; WM__CHWinLast
0001ec  f9bd1038          LDRSH    r1,[sp,#0x38]
0001f0  4288              CMP      r0,r1
0001f2  d021              BEQ      |L1.568|
;;;248              if (WM__CHWinLast.hWin != 0) {
0001f4  482d              LDR      r0,|L1.684|
0001f6  8880              LDRH     r0,[r0,#4]  ; WM__CHWinLast
0001f8  b1f0              CBZ      r0,|L1.568|
;;;249                if (StateNew.Pressed) {
0001fa  f89d0024          LDRB     r0,[sp,#0x24]
0001fe  b128              CBZ      r0,|L1.524|
;;;250                  /* Moved out -> no longer in this window
;;;251                   * Send a NULL pointer as data
;;;252                   */
;;;253                  Msg.Data.p = NULL;
000200  f04f0000          MOV      r0,#0
000204  9011              STR      r0,[sp,#0x44]
000206  e00d              B        |L1.548|
                  |L1.520|
000208  e040              B        |L1.652|
                  |L1.522|
00020a  e038              B        |L1.638|
                  |L1.524|
;;;254                } else {
;;;255                  /* Last window needs to know that it has been "Released"
;;;256                   * Send last coordinates 
;;;257                   */
;;;258                  State.x       = WM_PID__StateLast.x;
00020c  4826              LDR      r0,|L1.680|
00020e  6800              LDR      r0,[r0,#0]  ; WM_PID__StateLast
000210  900a              STR      r0,[sp,#0x28]
;;;259                  State.y       = WM_PID__StateLast.y;
000212  4825              LDR      r0,|L1.680|
000214  6840              LDR      r0,[r0,#4]  ; WM_PID__StateLast
000216  900b              STR      r0,[sp,#0x2c]
;;;260                  State.Pressed = 0;
000218  f04f0000          MOV      r0,#0
00021c  f88d0030          STRB     r0,[sp,#0x30]
;;;261                  Msg.Data.p = (void*)&State;
000220  a80a              ADD      r0,sp,#0x28
000222  9011              STR      r0,[sp,#0x44]
                  |L1.548|
;;;262                }
;;;263                GUI_DEBUG_LOG1 ("\nSending WM_Touch to LastWindow %d (out of area)", WM__CHWinLast.hWin);
;;;264                WM__SendTouchMessage(WM__CHWinLast.hWin, &Msg);
000224  4921              LDR      r1,|L1.684|
000226  f9b10004          LDRSH    r0,[r1,#4]  ; WM__CHWinLast
00022a  a90f              ADD      r1,sp,#0x3c
00022c  f7fffffe          BL       WM__SendTouchMessage
;;;265                WM__CHWinLast.hWin = 0;
000230  f04f0000          MOV      r0,#0
000234  491d              LDR      r1,|L1.684|
000236  8088              STRH     r0,[r1,#4]
                  |L1.568|
;;;266              }
;;;267            }
;;;268            /* Make sure that this routine does not react a second time on the same event.
;;;269             * This could happen if for example a dialog is executed during the WM_TOUCH message processing
;;;270             */
;;;271            WM_PID__StateLast.Pressed = StateNew.Pressed;
000238  f89d0024          LDRB     r0,[sp,#0x24]
00023c  491a              LDR      r1,|L1.680|
00023e  7208              STRB     r0,[r1,#8]
;;;272            /* Sending WM_Touch to current window */
;;;273            if (CHWin.hWin) {
000240  f8bd0038          LDRH     r0,[sp,#0x38]
000244  b1d8              CBZ      r0,|L1.638|
;;;274              /* convert screen into window coordinates */
;;;275              State = StateNew;
000246  a807              ADD      r0,sp,#0x1c
000248  c807              LDM      r0,{r0-r2}
00024a  ab0a              ADD      r3,sp,#0x28
00024c  c307              STM      r3!,{r0-r2}
;;;276              /* Remember window */
;;;277              if (State.Pressed) {
00024e  f89d0030          LDRB     r0,[sp,#0x30]
000252  b120              CBZ      r0,|L1.606|
;;;278                WM__CHWinLast.hWin = CHWin.hWin;
000254  f8bd0038          LDRH     r0,[sp,#0x38]
000258  4914              LDR      r1,|L1.684|
00025a  8088              STRH     r0,[r1,#4]
00025c  e008              B        |L1.624|
                  |L1.606|
;;;279              } else {
;;;280                /* Handle automatic capture release */
;;;281                if (WM__CaptureReleaseAuto) {
00025e  4814              LDR      r0,|L1.688|
000260  7800              LDRB     r0,[r0,#0]  ; WM__CaptureReleaseAuto
000262  b108              CBZ      r0,|L1.616|
;;;282                  WM_ReleaseCapture();
000264  f7fffffe          BL       WM_ReleaseCapture
                  |L1.616|
;;;283                }
;;;284                WM__CHWinLast.hWin = 0;
000268  f04f0000          MOV      r0,#0
00026c  490f              LDR      r1,|L1.684|
00026e  8088              STRH     r0,[r1,#4]
                  |L1.624|
;;;285              }
;;;286              Msg.Data.p = (void*)&State;
000270  a80a              ADD      r0,sp,#0x28
000272  9011              STR      r0,[sp,#0x44]
;;;287              WM__SendTouchMessage(CHWin.hWin, &Msg);
000274  f9bd0038          LDRSH    r0,[sp,#0x38]
000278  a90f              ADD      r1,sp,#0x3c
00027a  f7fffffe          BL       WM__SendTouchMessage
                  |L1.638|
;;;288            }
;;;289          }
;;;290          /*
;;;291           * Send WM_MOUSEOVER message
;;;292           */
;;;293          #if GUI_SUPPORT_MOUSE
;;;294          else {
;;;295            /* Send WM_MOUSEOVER Message */
;;;296            if (CHWin.hWin) {
;;;297              /* Do not send messages to disabled windows */
;;;298              if (WM__IsEnabled(CHWin.hWin)) {
;;;299                State      = StateNew;
;;;300                Msg.MsgId  = WM_MOUSEOVER;
;;;301                Msg.Data.p = (void*)&State;
;;;302                WM__SendTouchMessage(CHWin.hWin, &Msg);
;;;303              }
;;;304            }
;;;305          }
;;;306          #endif
;;;307        }
;;;308        /* Store the new state */
;;;309        WM_PID__StateLast = StateNew;
00027e  480a              LDR      r0,|L1.680|
000280  a907              ADD      r1,sp,#0x1c
000282  c90e              LDM      r1,{r1-r3}
000284  c00e              STM      r0!,{r1-r3}
;;;310        WM_PID__SetPrevState(&StateNew);
000286  a807              ADD      r0,sp,#0x1c
000288  f7fffffe          BL       WM_PID__SetPrevState
                  |L1.652|
;;;311      }
;;;312      WM__RemoveCriticalHandle(&CHWin);
00028c  a80d              ADD      r0,sp,#0x34
00028e  f7fffffe          BL       WM__RemoveCriticalHandle
;;;313      WM_UNLOCK();
;;;314      return r;
000292  4630              MOV      r0,r6
;;;315    }
000294  b012              ADD      sp,sp,#0x48
000296  bd70              POP      {r4-r6,pc}
;;;316    
                          ENDP

                  |L1.664|
                          DCD      WM__CHWinModal
                  |L1.668|
                          DCD      WM__hCapture
                  |L1.672|
                          DCD      GUI_OrgX
                  |L1.676|
                          DCD      GUI_OrgY
                  |L1.680|
                          DCD      WM_PID__StateLast
                  |L1.684|
                          DCD      WM__CHWinLast
                  |L1.688|
                          DCD      WM__CaptureReleaseAuto

                          AREA ||.data||, DATA, ALIGN=2

                  WM__CHWinModal
                          %        8
                  WM__CHWinLast
                          %        8
