; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jmemmgr.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jmemmgr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jmemmgr.crf GUI\JPEG\jmemmgr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  out_of_memory PROC
;;;209    LOCAL(void)
;;;210    out_of_memory (j_common_ptr cinfo, int which)
000000  b570              PUSH     {r4-r6,lr}
;;;211    /* Report an out-of-memory error and stop execution */
;;;212    /* If we compiled MEM_STATS support, report alloc requests before dying */
;;;213    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;214    #ifdef MEM_STATS
;;;215      cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
;;;216    #endif
;;;217      ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
000006  f04f0036          MOV      r0,#0x36
00000a  6821              LDR      r1,[r4,#0]
00000c  6148              STR      r0,[r1,#0x14]
00000e  6820              LDR      r0,[r4,#0]
000010  6185              STR      r5,[r0,#0x18]
000012  6820              LDR      r0,[r4,#0]
000014  6801              LDR      r1,[r0,#0]
000016  4620              MOV      r0,r4
000018  4788              BLX      r1
;;;218    }
00001a  bd70              POP      {r4-r6,pc}
;;;219    
                          ENDP

                  alloc_small PROC
;;;248    
;;;249    METHODDEF(void *) alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
00001c  e92d5ffc          PUSH     {r2-r12,lr}
;;;250    /* Allocate a "small" object */
;;;251    {
000020  4680              MOV      r8,r0
000022  460e              MOV      r6,r1
000024  4615              MOV      r5,r2
;;;252      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000026  f8d8b004          LDR      r11,[r8,#4]
;;;253      small_pool_ptr hdr_ptr, prev_hdr_ptr;
;;;254      char * data_ptr;
;;;255      size_t odd_bytes, min_request, slop;
;;;256    
;;;257      /* Check for unsatisfiable request (do now to ensure no overflow below) */
;;;258      if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
00002a  48f9              LDR      r0,|L1.1040|
00002c  4285              CMP      r5,r0
00002e  d903              BLS      |L1.56|
;;;259        out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
000030  2101              MOVS     r1,#1
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       out_of_memory
                  |L1.56|
;;;260    
;;;261      /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
;;;262      odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
000038  f0050007          AND      r0,r5,#7
00003c  9000              STR      r0,[sp,#0]
;;;263      if (odd_bytes > 0)
00003e  9800              LDR      r0,[sp,#0]
000040  b118              CBZ      r0,|L1.74|
;;;264        sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
000042  9800              LDR      r0,[sp,#0]
000044  f1c00008          RSB      r0,r0,#8
000048  4405              ADD      r5,r5,r0
                  |L1.74|
;;;265    
;;;266      /* See if space is available in any existing pool */
;;;267      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
00004a  2e00              CMP      r6,#0
00004c  db01              BLT      |L1.82|
00004e  2e02              CMP      r6,#2
000050  db0c              BLT      |L1.108|
                  |L1.82|
;;;268        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000052  f04f000e          MOV      r0,#0xe
000056  f8d81000          LDR      r1,[r8,#0]
00005a  6148              STR      r0,[r1,#0x14]
00005c  f8d80000          LDR      r0,[r8,#0]
000060  6186              STR      r6,[r0,#0x18]
000062  f8d80000          LDR      r0,[r8,#0]
000066  6801              LDR      r1,[r0,#0]
000068  4640              MOV      r0,r8
00006a  4788              BLX      r1
                  |L1.108|
;;;269      prev_hdr_ptr = NULL;
00006c  f04f0900          MOV      r9,#0
;;;270      hdr_ptr = mem->small_list[pool_id];
000070  f10b0034          ADD      r0,r11,#0x34
000074  f8504026          LDR      r4,[r0,r6,LSL #2]
;;;271      while (hdr_ptr != NULL) {
000078  e005              B        |L1.134|
                  |L1.122|
;;;272        if (hdr_ptr->hdr.bytes_left >= sizeofobject)
00007a  68a0              LDR      r0,[r4,#8]
00007c  42a8              CMP      r0,r5
00007e  d300              BCC      |L1.130|
;;;273          break;			/* found pool with enough space */
000080  e003              B        |L1.138|
                  |L1.130|
;;;274        prev_hdr_ptr = hdr_ptr;
000082  46a1              MOV      r9,r4
;;;275        hdr_ptr = hdr_ptr->hdr.next;
000084  6824              LDR      r4,[r4,#0]
                  |L1.134|
000086  2c00              CMP      r4,#0                 ;271
000088  d1f7              BNE      |L1.122|
                  |L1.138|
00008a  bf00              NOP                            ;273
;;;276      }
;;;277    
;;;278      /* Time to make a new pool? */
;;;279      if (hdr_ptr == NULL) {
00008c  bbe4              CBNZ     r4,|L1.264|
;;;280        /* min_request is what we need now, slop is what will be leftover */
;;;281        min_request = sizeofobject + SIZEOF(small_pool_hdr);
00008e  f1050a10          ADD      r10,r5,#0x10
;;;282        if (prev_hdr_ptr == NULL)	/* first pool in class? */
000092  f1b90f00          CMP      r9,#0
000096  d103              BNE      |L1.160|
;;;283          slop = first_pool_slop[pool_id];
000098  48de              LDR      r0,|L1.1044|
00009a  f8507026          LDR      r7,[r0,r6,LSL #2]
00009e  e002              B        |L1.166|
                  |L1.160|
;;;284        else
;;;285          slop = extra_pool_slop[pool_id];
0000a0  48dd              LDR      r0,|L1.1048|
0000a2  f8507026          LDR      r7,[r0,r6,LSL #2]
                  |L1.166|
;;;286        /* Don't ask for more than MAX_ALLOC_CHUNK */
;;;287        if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
0000a6  48da              LDR      r0,|L1.1040|
0000a8  3010              ADDS     r0,r0,#0x10
0000aa  eba0000a          SUB      r0,r0,r10
0000ae  42b8              CMP      r0,r7
0000b0  d202              BCS      |L1.184|
;;;288          slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
0000b2  48da              LDR      r0,|L1.1052|
0000b4  eba0070a          SUB      r7,r0,r10
                  |L1.184|
;;;289        /* Try to get space, if fail reduce slop and try again */
;;;290        while(1) {
0000b8  e00f              B        |L1.218|
                  |L1.186|
;;;291          hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
0000ba  eb0a0107          ADD      r1,r10,r7
0000be  4640              MOV      r0,r8
0000c0  f7fffffe          BL       jpeg_get_small
0000c4  4604              MOV      r4,r0
;;;292          if (hdr_ptr != NULL)
0000c6  b104              CBZ      r4,|L1.202|
;;;293    	break;
0000c8  e008              B        |L1.220|
                  |L1.202|
;;;294          slop /= 2;
0000ca  ea4f0757          LSR      r7,r7,#1
;;;295          if (slop < MIN_SLOP)	/* give up when it gets real small */
0000ce  2f32              CMP      r7,#0x32
0000d0  d203              BCS      |L1.218|
;;;296    	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
0000d2  2102              MOVS     r1,#2
0000d4  4640              MOV      r0,r8
0000d6  f7fffffe          BL       out_of_memory
                  |L1.218|
0000da  e7ee              B        |L1.186|
                  |L1.220|
0000dc  bf00              NOP                            ;293
;;;297        }
;;;298        mem->total_space_allocated += min_request + slop;
0000de  eb0a0107          ADD      r1,r10,r7
0000e2  f8db004c          LDR      r0,[r11,#0x4c]
0000e6  4408              ADD      r0,r0,r1
0000e8  f8cb004c          STR      r0,[r11,#0x4c]
;;;299        /* Success, initialize the new pool header and add to end of list */
;;;300        hdr_ptr->hdr.next = NULL;
0000ec  f04f0000          MOV      r0,#0
0000f0  6020              STR      r0,[r4,#0]
;;;301        hdr_ptr->hdr.bytes_used = 0;
0000f2  6060              STR      r0,[r4,#4]
;;;302        hdr_ptr->hdr.bytes_left = sizeofobject + slop;
0000f4  eb050007          ADD      r0,r5,r7
0000f8  60a0              STR      r0,[r4,#8]
;;;303        if (prev_hdr_ptr == NULL)	/* first pool in class? */
0000fa  f1b90f00          CMP      r9,#0
0000fe  d104              BNE      |L1.266|
;;;304          mem->small_list[pool_id] = hdr_ptr;
000100  f10b0034          ADD      r0,r11,#0x34
000104  f8404026          STR      r4,[r0,r6,LSL #2]
                  |L1.264|
000108  e001              B        |L1.270|
                  |L1.266|
;;;305        else
;;;306          prev_hdr_ptr->hdr.next = hdr_ptr;
00010a  f8c94000          STR      r4,[r9,#0]
                  |L1.270|
;;;307      }
;;;308    
;;;309      /* OK, allocate the object from the current pool */
;;;310      data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
00010e  f1040010          ADD      r0,r4,#0x10
000112  9001              STR      r0,[sp,#4]
;;;311      data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
000114  6861              LDR      r1,[r4,#4]
000116  9801              LDR      r0,[sp,#4]
000118  4408              ADD      r0,r0,r1
00011a  9001              STR      r0,[sp,#4]
;;;312      hdr_ptr->hdr.bytes_used += sizeofobject;
00011c  6860              LDR      r0,[r4,#4]
00011e  4428              ADD      r0,r0,r5
000120  6060              STR      r0,[r4,#4]
;;;313      hdr_ptr->hdr.bytes_left -= sizeofobject;
000122  68a0              LDR      r0,[r4,#8]
000124  eba00005          SUB      r0,r0,r5
000128  60a0              STR      r0,[r4,#8]
;;;314    
;;;315      return (void *) data_ptr;
00012a  9801              LDR      r0,[sp,#4]
;;;316    }
00012c  e8bd9ffc          POP      {r2-r12,pc}
;;;317    
                          ENDP

                  alloc_large PROC
;;;332    
;;;333    METHODDEF(void FAR *) alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject) /* Allocate a "large" object */ {
000130  e92d47f0          PUSH     {r4-r10,lr}
000134  4607              MOV      r7,r0
000136  460e              MOV      r6,r1
000138  4615              MOV      r5,r2
;;;334      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
00013a  f8d78004          LDR      r8,[r7,#4]
;;;335      large_pool_ptr hdr_ptr;
;;;336      size_t odd_bytes;
;;;337    
;;;338      /* Check for unsatisfiable request (do now to ensure no overflow below) */
;;;339      if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr))) {
00013e  48b4              LDR      r0,|L1.1040|
000140  4285              CMP      r5,r0
000142  d903              BLS      |L1.332|
;;;340        out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
000144  2103              MOVS     r1,#3
000146  4638              MOV      r0,r7
000148  f7fffffe          BL       out_of_memory
                  |L1.332|
;;;341      }
;;;342      /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
;;;343      odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
00014c  f0050907          AND      r9,r5,#7
;;;344      if (odd_bytes > 0) {
000150  f1b90f00          CMP      r9,#0
000154  d002              BEQ      |L1.348|
;;;345        sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
000156  f1c90008          RSB      r0,r9,#8
00015a  4405              ADD      r5,r5,r0
                  |L1.348|
;;;346      }
;;;347      /* Always make a new pool */
;;;348      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS) {
00015c  2e00              CMP      r6,#0
00015e  db01              BLT      |L1.356|
000160  2e02              CMP      r6,#2
000162  db09              BLT      |L1.376|
                  |L1.356|
;;;349        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000164  f04f000e          MOV      r0,#0xe
000168  6839              LDR      r1,[r7,#0]
00016a  6148              STR      r0,[r1,#0x14]
00016c  6838              LDR      r0,[r7,#0]
00016e  6186              STR      r6,[r0,#0x18]
000170  6838              LDR      r0,[r7,#0]
000172  6801              LDR      r1,[r0,#0]
000174  4638              MOV      r0,r7
000176  4788              BLX      r1
                  |L1.376|
;;;350      }
;;;351    
;;;352      hdr_ptr = (large_pool_ptr) jpeg_get_small/*RS: Changed from jpeg_get_large*/ (cinfo, sizeofobject +  SIZEOF(large_pool_hdr));
000178  f1050110          ADD      r1,r5,#0x10
00017c  4638              MOV      r0,r7
00017e  f7fffffe          BL       jpeg_get_small
000182  4604              MOV      r4,r0
;;;353      if (hdr_ptr == NULL) {
000184  b91c              CBNZ     r4,|L1.398|
;;;354        out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
000186  2104              MOVS     r1,#4
000188  4638              MOV      r0,r7
00018a  f7fffffe          BL       out_of_memory
                  |L1.398|
;;;355      }
;;;356      mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
00018e  f1050010          ADD      r0,r5,#0x10
000192  f8d8104c          LDR      r1,[r8,#0x4c]
000196  4408              ADD      r0,r0,r1
000198  f8c8004c          STR      r0,[r8,#0x4c]
;;;357      /* Success, initialize the new pool header and add to list */
;;;358      hdr_ptr->hdr.next = mem->large_list[pool_id];
00019c  f108003c          ADD      r0,r8,#0x3c
0001a0  f8500026          LDR      r0,[r0,r6,LSL #2]
0001a4  6020              STR      r0,[r4,#0]
;;;359      /* We maintain space counts in each pool header for statistical purposes,
;;;360       * even though they are not needed for allocation.
;;;361       */
;;;362      hdr_ptr->hdr.bytes_used = sizeofobject;
0001a6  6065              STR      r5,[r4,#4]
;;;363      hdr_ptr->hdr.bytes_left = 0;
0001a8  f04f0000          MOV      r0,#0
0001ac  60a0              STR      r0,[r4,#8]
;;;364      mem->large_list[pool_id] = hdr_ptr;
0001ae  f108003c          ADD      r0,r8,#0x3c
0001b2  f8404026          STR      r4,[r0,r6,LSL #2]
;;;365    
;;;366      return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
0001b6  f1040010          ADD      r0,r4,#0x10
;;;367    }
0001ba  e8bd87f0          POP      {r4-r10,pc}
;;;368    
                          ENDP

                  alloc_sarray PROC
;;;382    
;;;383    METHODDEF(JSAMPARRAY) alloc_sarray (j_common_ptr cinfo, int pool_id, JDIMENSION samplesperrow, JDIMENSION numrows) {
0001be  e92d4fff          PUSH     {r0-r11,lr}
0001c2  b083              SUB      sp,sp,#0xc
0001c4  4680              MOV      r8,r0
0001c6  4616              MOV      r6,r2
0001c8  461c              MOV      r4,r3
;;;384    /* Allocate a 2-D sample array */
;;;385      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
0001ca  f8d80004          LDR      r0,[r8,#4]
0001ce  9002              STR      r0,[sp,#8]
;;;386      JSAMPARRAY result;
;;;387      JSAMPROW workspace;
;;;388      JDIMENSION rowsperchunk, currow, i;
;;;389      long ltemp;
;;;390    
;;;391      /* Calculate max # of rows allowed in one allocation chunk */
;;;392      ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
0001d0  488f              LDR      r0,|L1.1040|
0001d2  fbb0faf6          UDIV     r10,r0,r6
;;;393    	  ((long) samplesperrow * SIZEOF(JSAMPLE));
;;;394      if (ltemp <= 0)
0001d6  f1ba0f00          CMP      r10,#0
0001da  dc09              BGT      |L1.496|
;;;395        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
0001dc  f04f0046          MOV      r0,#0x46
0001e0  f8d81000          LDR      r1,[r8,#0]
0001e4  6148              STR      r0,[r1,#0x14]
0001e6  f8d80000          LDR      r0,[r8,#0]
0001ea  6801              LDR      r1,[r0,#0]
0001ec  4640              MOV      r0,r8
0001ee  4788              BLX      r1
                  |L1.496|
;;;396      if (ltemp < (long) numrows)
0001f0  45a2              CMP      r10,r4
0001f2  da01              BGE      |L1.504|
;;;397        rowsperchunk = (JDIMENSION) ltemp;
0001f4  4655              MOV      r5,r10
0001f6  e000              B        |L1.506|
                  |L1.504|
;;;398      else
;;;399        rowsperchunk = numrows;
0001f8  4625              MOV      r5,r4
                  |L1.506|
;;;400      mem->last_rowsperchunk = rowsperchunk;
0001fa  9802              LDR      r0,[sp,#8]
0001fc  6505              STR      r5,[r0,#0x50]
;;;401    
;;;402      /* Get space for row pointers (small object) */
;;;403      result = (JSAMPARRAY) alloc_small(cinfo, pool_id, (size_t) (numrows * SIZEOF(JSAMPROW)));
0001fe  00a2              LSLS     r2,r4,#2
000200  4640              MOV      r0,r8
000202  9904              LDR      r1,[sp,#0x10]
000204  f7fffffe          BL       alloc_small
000208  4681              MOV      r9,r0
;;;404      /* Get the rows themselves (large objects) */
;;;405      currow = 0;
00020a  f04f0700          MOV      r7,#0
;;;406      while (currow < numrows) {
00020e  e01d              B        |L1.588|
                  |L1.528|
;;;407        rowsperchunk = MIN(rowsperchunk, numrows - currow);
000210  1be0              SUBS     r0,r4,r7
000212  42a8              CMP      r0,r5
000214  d901              BLS      |L1.538|
000216  4628              MOV      r0,r5
000218  e001              B        |L1.542|
                  |L1.538|
00021a  eba40007          SUB      r0,r4,r7
                  |L1.542|
00021e  4605              MOV      r5,r0
;;;408        workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
000220  fb05f206          MUL      r2,r5,r6
000224  4640              MOV      r0,r8
000226  9904              LDR      r1,[sp,#0x10]
000228  f7fffffe          BL       alloc_large
00022c  4683              MOV      r11,r0
;;;409    	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
;;;410    		  * SIZEOF(JSAMPLE)));
;;;411        for (i = rowsperchunk; i > 0; i--) {
00022e  9501              STR      r5,[sp,#4]
000230  e009              B        |L1.582|
                  |L1.562|
;;;412          result[currow++] = workspace;
000232  4638              MOV      r0,r7
000234  f1070701          ADD      r7,r7,#1
000238  f849b020          STR      r11,[r9,r0,LSL #2]
;;;413          workspace += samplesperrow;
00023c  44b3              ADD      r11,r11,r6
00023e  9801              LDR      r0,[sp,#4]            ;411
000240  f1a00001          SUB      r0,r0,#1              ;411
000244  9001              STR      r0,[sp,#4]            ;411
                  |L1.582|
000246  9801              LDR      r0,[sp,#4]            ;411
000248  2800              CMP      r0,#0                 ;411
00024a  d1f2              BNE      |L1.562|
                  |L1.588|
00024c  42a7              CMP      r7,r4                 ;406
00024e  d3df              BCC      |L1.528|
;;;414        }
;;;415      }
;;;416    
;;;417      return result;
000250  4648              MOV      r0,r9
;;;418    }
000252  b007              ADD      sp,sp,#0x1c
000254  e8bd8ff0          POP      {r4-r11,pc}
;;;419    
                          ENDP

                  alloc_barray PROC
;;;425    
;;;426    METHODDEF(JBLOCKARRAY) alloc_barray (j_common_ptr cinfo, int pool_id,  JDIMENSION blocksperrow, JDIMENSION numrows) {
000258  e92d4fff          PUSH     {r0-r11,lr}
00025c  b083              SUB      sp,sp,#0xc
00025e  4607              MOV      r7,r0
000260  4690              MOV      r8,r2
000262  461c              MOV      r4,r3
;;;427      /* Allocate a 2-D coefficient-block array */
;;;428      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000264  6878              LDR      r0,[r7,#4]
000266  9002              STR      r0,[sp,#8]
;;;429      JBLOCKARRAY result;
;;;430      JBLOCKROW workspace;
;;;431      JDIMENSION rowsperchunk, currow, i;
;;;432      long ltemp;
;;;433    
;;;434      /* Calculate max # of rows allowed in one allocation chunk */
;;;435      ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
000268  ea4f10c8          LSL      r0,r8,#7
00026c  4968              LDR      r1,|L1.1040|
00026e  fbb1faf0          UDIV     r10,r1,r0
;;;436    	  ((long) blocksperrow * SIZEOF(JBLOCK));
;;;437      if (ltemp <= 0)
000272  f1ba0f00          CMP      r10,#0
000276  dc07              BGT      |L1.648|
;;;438        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
000278  f04f0046          MOV      r0,#0x46
00027c  6839              LDR      r1,[r7,#0]
00027e  6148              STR      r0,[r1,#0x14]
000280  6838              LDR      r0,[r7,#0]
000282  6801              LDR      r1,[r0,#0]
000284  4638              MOV      r0,r7
000286  4788              BLX      r1
                  |L1.648|
;;;439      if (ltemp < (long) numrows)
000288  45a2              CMP      r10,r4
00028a  da01              BGE      |L1.656|
;;;440        rowsperchunk = (JDIMENSION) ltemp;
00028c  4655              MOV      r5,r10
00028e  e000              B        |L1.658|
                  |L1.656|
;;;441      else
;;;442        rowsperchunk = numrows;
000290  4625              MOV      r5,r4
                  |L1.658|
;;;443      mem->last_rowsperchunk = rowsperchunk;
000292  9802              LDR      r0,[sp,#8]
000294  6505              STR      r5,[r0,#0x50]
;;;444    
;;;445      /* Get space for row pointers (small object) */
;;;446      result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
000296  00a2              LSLS     r2,r4,#2
000298  4638              MOV      r0,r7
00029a  9904              LDR      r1,[sp,#0x10]
00029c  f7fffffe          BL       alloc_small
0002a0  4681              MOV      r9,r0
;;;447    				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
;;;448    
;;;449      /* Get the rows themselves (large objects) */
;;;450      currow = 0;
0002a2  f04f0600          MOV      r6,#0
;;;451      while (currow < numrows) {
0002a6  e020              B        |L1.746|
                  |L1.680|
;;;452        rowsperchunk = MIN(rowsperchunk, numrows - currow);
0002a8  1ba0              SUBS     r0,r4,r6
0002aa  42a8              CMP      r0,r5
0002ac  d901              BLS      |L1.690|
0002ae  4628              MOV      r0,r5
0002b0  e001              B        |L1.694|
                  |L1.690|
0002b2  eba40006          SUB      r0,r4,r6
                  |L1.694|
0002b6  4605              MOV      r5,r0
;;;453        workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
0002b8  fb05f008          MUL      r0,r5,r8
0002bc  ea4f12c0          LSL      r2,r0,#7
0002c0  4638              MOV      r0,r7
0002c2  9904              LDR      r1,[sp,#0x10]
0002c4  f7fffffe          BL       alloc_large
0002c8  4683              MOV      r11,r0
;;;454    	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
;;;455    		  * SIZEOF(JBLOCK)));
;;;456        for (i = rowsperchunk; i > 0; i--) {
0002ca  9501              STR      r5,[sp,#4]
0002cc  e00a              B        |L1.740|
                  |L1.718|
;;;457          result[currow++] = workspace;
0002ce  4630              MOV      r0,r6
0002d0  f1060601          ADD      r6,r6,#1
0002d4  f849b020          STR      r11,[r9,r0,LSL #2]
;;;458          workspace += blocksperrow;
0002d8  eb0b1bc8          ADD      r11,r11,r8,LSL #7
0002dc  9801              LDR      r0,[sp,#4]            ;456
0002de  f1a00001          SUB      r0,r0,#1              ;456
0002e2  9001              STR      r0,[sp,#4]            ;456
                  |L1.740|
0002e4  9801              LDR      r0,[sp,#4]            ;456
0002e6  2800              CMP      r0,#0                 ;456
0002e8  d1f1              BNE      |L1.718|
                  |L1.746|
0002ea  42a6              CMP      r6,r4                 ;451
0002ec  d3dc              BCC      |L1.680|
;;;459        }
;;;460      }
;;;461    
;;;462      return result;
0002ee  4648              MOV      r0,r9
;;;463    }
0002f0  b007              ADD      sp,sp,#0x1c
0002f2  e8bd8ff0          POP      {r4-r11,pc}
;;;464    
                          ENDP

                  request_virt_sarray PROC
;;;502    
;;;503    METHODDEF(jvirt_sarray_ptr) request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION samplesperrow, JDIMENSION numrows, JDIMENSION maxaccess) {
0002f6  e92d5ff0          PUSH     {r4-r12,lr}
0002fa  4605              MOV      r5,r0
0002fc  460e              MOV      r6,r1
0002fe  4617              MOV      r7,r2
000300  4698              MOV      r8,r3
000302  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;504      /* Request a virtual 2-D sample array */
;;;505      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000306  f8d59004          LDR      r9,[r5,#4]
;;;506      jvirt_sarray_ptr result;
;;;507    
;;;508      /* Only IMAGE-lifetime virtual arrays are currently supported */
;;;509      if (pool_id != JPOOL_IMAGE) {
00030a  2e01              CMP      r6,#1
00030c  d009              BEQ      |L1.802|
;;;510        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
00030e  f04f000e          MOV      r0,#0xe
000312  6829              LDR      r1,[r5,#0]
000314  6148              STR      r0,[r1,#0x14]
000316  6828              LDR      r0,[r5,#0]
000318  6186              STR      r6,[r0,#0x18]
00031a  6828              LDR      r0,[r5,#0]
00031c  6801              LDR      r1,[r0,#0]
00031e  4628              MOV      r0,r5
000320  4788              BLX      r1
                  |L1.802|
;;;511      }
;;;512      /* get control block */
;;;513      result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id, SIZEOF(struct jvirt_sarray_control));
000322  227c              MOVS     r2,#0x7c
000324  4631              MOV      r1,r6
000326  4628              MOV      r0,r5
000328  f7fffffe          BL       alloc_small
00032c  4604              MOV      r4,r0
;;;514      result->mem_buffer = NULL;	/* marks array not yet realized */
00032e  f04f0100          MOV      r1,#0
000332  6021              STR      r1,[r4,#0]
;;;515      result->rows_in_array = numrows;
000334  f8c4a004          STR      r10,[r4,#4]
;;;516      result->samplesperrow = samplesperrow;
000338  f8c48008          STR      r8,[r4,#8]
;;;517      result->maxaccess = maxaccess;
00033c  f8c4b00c          STR      r11,[r4,#0xc]
;;;518      result->pre_zero = pre_zero;
000340  6227              STR      r7,[r4,#0x20]
;;;519      result->b_s_open = FALSE;	/* no associated backing-store object */
000342  62a1              STR      r1,[r4,#0x28]
;;;520      result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
000344  f8d91044          LDR      r1,[r9,#0x44]
000348  62e1              STR      r1,[r4,#0x2c]
;;;521      mem->virt_sarray_list = result;
00034a  f8c94044          STR      r4,[r9,#0x44]
;;;522    
;;;523      return result;
00034e  4620              MOV      r0,r4
;;;524    }
000350  e8bd9ff0          POP      {r4-r12,pc}
;;;525    
                          ENDP

                  request_virt_barray PROC
;;;526    
;;;527    METHODDEF(jvirt_barray_ptr) request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION blocksperrow, JDIMENSION numrows, JDIMENSION maxaccess) {
000354  e92d5ff0          PUSH     {r4-r12,lr}
000358  4605              MOV      r5,r0
00035a  460e              MOV      r6,r1
00035c  4617              MOV      r7,r2
00035e  4698              MOV      r8,r3
000360  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;528      /* Request a virtual 2-D coefficient-block array */
;;;529      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000364  f8d59004          LDR      r9,[r5,#4]
;;;530      jvirt_barray_ptr result;
;;;531      /* Only IMAGE-lifetime virtual arrays are currently supported */
;;;532      if (pool_id != JPOOL_IMAGE)
000368  2e01              CMP      r6,#1
00036a  d009              BEQ      |L1.896|
;;;533        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
00036c  f04f000e          MOV      r0,#0xe
000370  6829              LDR      r1,[r5,#0]
000372  6148              STR      r0,[r1,#0x14]
000374  6828              LDR      r0,[r5,#0]
000376  6186              STR      r6,[r0,#0x18]
000378  6828              LDR      r0,[r5,#0]
00037a  6801              LDR      r1,[r0,#0]
00037c  4628              MOV      r0,r5
00037e  4788              BLX      r1
                  |L1.896|
;;;534    
;;;535      /* get control block */
;;;536      result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id, SIZEOF(struct jvirt_barray_control));
000380  227c              MOVS     r2,#0x7c
000382  4631              MOV      r1,r6
000384  4628              MOV      r0,r5
000386  f7fffffe          BL       alloc_small
00038a  4604              MOV      r4,r0
;;;537      result->mem_buffer = NULL;	/* marks array not yet realized */
00038c  f04f0100          MOV      r1,#0
000390  6021              STR      r1,[r4,#0]
;;;538      result->rows_in_array = numrows;
000392  f8c4a004          STR      r10,[r4,#4]
;;;539      result->blocksperrow = blocksperrow;
000396  f8c48008          STR      r8,[r4,#8]
;;;540      result->maxaccess = maxaccess;
00039a  f8c4b00c          STR      r11,[r4,#0xc]
;;;541      result->pre_zero = pre_zero;
00039e  6227              STR      r7,[r4,#0x20]
;;;542      result->b_s_open = FALSE;	/* no associated backing-store object */
0003a0  62a1              STR      r1,[r4,#0x28]
;;;543      result->next = mem->virt_barray_list; /* add to list of virtual arrays */
0003a2  f8d91048          LDR      r1,[r9,#0x48]
0003a6  62e1              STR      r1,[r4,#0x2c]
;;;544      mem->virt_barray_list = result;
0003a8  f8c94048          STR      r4,[r9,#0x48]
;;;545    
;;;546      return result;
0003ac  4620              MOV      r0,r4
;;;547    }
0003ae  e8bd9ff0          POP      {r4-r12,pc}
;;;548    
                          ENDP

                  realize_virt_arrays PROC
;;;549    
;;;550    METHODDEF(void) realize_virt_arrays (j_common_ptr cinfo) {
0003b2  e92d47f0          PUSH     {r4-r10,lr}
0003b6  4606              MOV      r6,r0
;;;551    /* Allocate the in-memory buffers for any unrealized virtual arrays */
;;;552      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
0003b8  f8d68004          LDR      r8,[r6,#4]
;;;553      long space_per_minheight, maximum_space/*, avail_mem*/;
;;;554    /*  long minheights, max_minheights;*/
;;;555      jvirt_sarray_ptr sptr;
;;;556      jvirt_barray_ptr bptr;
;;;557    
;;;558      /* Compute the minimum space needed (maxaccess rows in each buffer)
;;;559       * and the maximum space needed (full image height in each buffer).
;;;560       * These may be of use to the system-dependent jpeg_mem_available routine.
;;;561       */
;;;562      space_per_minheight = 0;
0003bc  f04f0700          MOV      r7,#0
;;;563      maximum_space = 0;
0003c0  46b9              MOV      r9,r7
;;;564      for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
0003c2  f8d85044          LDR      r5,[r8,#0x44]
0003c6  e00a              B        |L1.990|
                  |L1.968|
;;;565        if (sptr->mem_buffer == NULL) { /* if not realized yet */
0003c8  6828              LDR      r0,[r5,#0]
0003ca  b938              CBNZ     r0,|L1.988|
;;;566          space_per_minheight += (long) sptr->maxaccess *
0003cc  e9d51002          LDRD     r1,r0,[r5,#8]
0003d0  fb007701          MLA      r7,r0,r1,r7
;;;567    			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
;;;568          maximum_space += (long) sptr->rows_in_array *
0003d4  e9d50101          LDRD     r0,r1,[r5,#4]
0003d8  fb009901          MLA      r9,r0,r1,r9
                  |L1.988|
0003dc  6aed              LDR      r5,[r5,#0x2c]         ;564
                  |L1.990|
0003de  2d00              CMP      r5,#0                 ;564
0003e0  d1f2              BNE      |L1.968|
;;;569    		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
;;;570        }
;;;571      }
;;;572      for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
0003e2  f8d84048          LDR      r4,[r8,#0x48]
0003e6  e00d              B        |L1.1028|
                  |L1.1000|
;;;573        if (bptr->mem_buffer == NULL) { /* if not realized yet */
0003e8  6820              LDR      r0,[r4,#0]
0003ea  b950              CBNZ     r0,|L1.1026|
;;;574          space_per_minheight += (long) bptr->maxaccess *
0003ec  e9d41002          LDRD     r1,r0,[r4,#8]
0003f0  4348              MULS     r0,r1,r0
0003f2  eb0717c0          ADD      r7,r7,r0,LSL #7
;;;575    			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
;;;576          maximum_space += (long) bptr->rows_in_array *
0003f6  e9d40101          LDRD     r0,r1,[r4,#4]
0003fa  fb00f001          MUL      r0,r0,r1
0003fe  eb0919c0          ADD      r9,r9,r0,LSL #7
                  |L1.1026|
000402  6ae4              LDR      r4,[r4,#0x2c]         ;572
                  |L1.1028|
000404  2c00              CMP      r4,#0                 ;572
000406  d1ef              BNE      |L1.1000|
;;;577    		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
;;;578        }
;;;579      }
;;;580    
;;;581      if (space_per_minheight <= 0)
000408  2f00              CMP      r7,#0
00040a  dc09              BGT      |L1.1056|
                  |L1.1036|
;;;582        return;			/* no unrealized arrays, no work */
;;;583    
;;;584    #if 0  /*RS*/
;;;585      /* Determine amount of memory to actually use; this is system-dependent. */
;;;586      avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space, mem->total_space_allocated);
;;;587    
;;;588      /* If the maximum space needed is available, make all the buffers full
;;;589       * height; otherwise parcel it out with the same number of minheights
;;;590       * in each buffer.
;;;591       */
;;;592      if (avail_mem >= maximum_space)
;;;593        max_minheights = 1000000000L;
;;;594      else {
;;;595        max_minheights = avail_mem / space_per_minheight;
;;;596        /* If there doesn't seem to be enough space, try to get the minimum
;;;597         * anyway.  This allows a "stub" implementation of jpeg_mem_available().
;;;598         */
;;;599        if (max_minheights <= 0)
;;;600          max_minheights = 1;
;;;601      }
;;;602    
;;;603      /* Allocate the in-memory buffers and initialize backing store as needed. */
;;;604      for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
;;;605        if (sptr->mem_buffer == NULL) { /* if not realized yet */
;;;606          minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
;;;607          if (minheights <= max_minheights) {
;;;608    	/* This buffer fits in memory */
;;;609    	sptr->rows_in_mem = sptr->rows_in_array;
;;;610          } else {
;;;611    	/* It doesn't fit in memory, create backing store. */
;;;612    	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
;;;613    	jpeg_open_backing_store(cinfo, & sptr->b_s_info, (long) sptr->rows_in_array * (long) sptr->samplesperrow * (long) SIZEOF(JSAMPLE));
;;;614    	sptr->b_s_open = TRUE;
;;;615          }
;;;616          sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
;;;617    				      sptr->samplesperrow, sptr->rows_in_mem);
;;;618          sptr->rowsperchunk = mem->last_rowsperchunk;
;;;619          sptr->cur_start_row = 0;
;;;620          sptr->first_undef_row = 0;
;;;621          sptr->dirty = FALSE;
;;;622        }
;;;623      }
;;;624    
;;;625      for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
;;;626        if (bptr->mem_buffer == NULL) { /* if not realized yet */
;;;627          minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
;;;628          if (minheights <= max_minheights) {
;;;629    	/* This buffer fits in memory */
;;;630    	bptr->rows_in_mem = bptr->rows_in_array;
;;;631          } else {
;;;632    	/* It doesn't fit in memory, create backing store. */
;;;633    	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
;;;634    	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
;;;635    				(long) bptr->rows_in_array *
;;;636    				(long) bptr->blocksperrow *
;;;637    				(long) SIZEOF(JBLOCK));
;;;638    	bptr->b_s_open = TRUE;
;;;639          }
;;;640          bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
;;;641    				      bptr->blocksperrow, bptr->rows_in_mem);
;;;642          bptr->rowsperchunk = mem->last_rowsperchunk;
;;;643          bptr->cur_start_row = 0;
;;;644          bptr->first_undef_row = 0;
;;;645          bptr->dirty = FALSE;
;;;646        }
;;;647      }
;;;648    # else
;;;649      ERREXIT(cinfo, JERR_NO_BACKING_STORE);
;;;650    #endif
;;;651    }
00040c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1040|
                          DCD      0x3b9ac9f0
                  |L1.1044|
                          DCD      first_pool_slop
                  |L1.1048|
                          DCD      extra_pool_slop
                  |L1.1052|
                          DCD      0x3b9aca00
                  |L1.1056|
000420  f04f0031          MOV      r0,#0x31              ;649
000424  6831              LDR      r1,[r6,#0]            ;649
000426  6148              STR      r0,[r1,#0x14]         ;649
000428  6830              LDR      r0,[r6,#0]            ;649
00042a  6801              LDR      r1,[r0,#0]            ;649
00042c  4630              MOV      r0,r6                 ;649
00042e  4788              BLX      r1                    ;649
000430  bf00              NOP      
000432  e7eb              B        |L1.1036|
;;;652    
                          ENDP

                  do_sarray_io PROC
;;;653    
;;;654    LOCAL(void) do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing) {
000434  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000438  b082              SUB      sp,sp,#8
00043a  460c              MOV      r4,r1
00043c  4691              MOV      r9,r2
;;;655    /* Do backing store read or write of a virtual sample array */
;;;656      long bytesperrow, file_offset, byte_count, rows, thisrow, i;
;;;657    
;;;658      bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
00043e  f8d4a008          LDR      r10,[r4,#8]
;;;659      file_offset = ptr->cur_start_row * bytesperrow;
000442  69a0              LDR      r0,[r4,#0x18]
000444  fb00fb0a          MUL      r11,r0,r10
;;;660      /* Loop to read or write each allocation chunk in mem_buffer */
;;;661      for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
000448  f04f0500          MOV      r5,#0
00044c  e046              B        |L1.1244|
                  |L1.1102|
;;;662        /* One chunk, but check for short chunk at end of buffer */
;;;663        rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
00044e  e9d41004          LDRD     r1,r0,[r4,#0x10]
000452  1b49              SUBS     r1,r1,r5
000454  4288              CMP      r0,r1
000456  da01              BGE      |L1.1116|
000458  6960              LDR      r0,[r4,#0x14]
00045a  e002              B        |L1.1122|
                  |L1.1116|
00045c  6920              LDR      r0,[r4,#0x10]
00045e  eba00005          SUB      r0,r0,r5
                  |L1.1122|
000462  4680              MOV      r8,r0
;;;664        /* Transfer no more than is currently defined */
;;;665        thisrow = (long) ptr->cur_start_row + i;
000464  69a0              LDR      r0,[r4,#0x18]
000466  eb000605          ADD      r6,r0,r5
;;;666        rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
00046a  69e0              LDR      r0,[r4,#0x1c]
00046c  eba00006          SUB      r0,r0,r6
000470  4540              CMP      r0,r8
000472  dd01              BLE      |L1.1144|
000474  4640              MOV      r0,r8
000476  e002              B        |L1.1150|
                  |L1.1144|
000478  69e0              LDR      r0,[r4,#0x1c]
00047a  eba00006          SUB      r0,r0,r6
                  |L1.1150|
00047e  4680              MOV      r8,r0
;;;667        /* Transfer no more than fits in file */
;;;668        rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
000480  6860              LDR      r0,[r4,#4]
000482  eba00006          SUB      r0,r0,r6
000486  4540              CMP      r0,r8
000488  dd01              BLE      |L1.1166|
00048a  4640              MOV      r0,r8
00048c  e002              B        |L1.1172|
                  |L1.1166|
00048e  6860              LDR      r0,[r4,#4]
000490  eba00006          SUB      r0,r0,r6
                  |L1.1172|
000494  4680              MOV      r8,r0
;;;669        if (rows <= 0)		/* this chunk might be past end of file! */
000496  f1b80f00          CMP      r8,#0
00049a  dc00              BGT      |L1.1182|
;;;670          break;
00049c  e021              B        |L1.1250|
                  |L1.1182|
;;;671        byte_count = rows * bytesperrow;
00049e  fb08f70a          MUL      r7,r8,r10
;;;672        if (writing)
0004a2  f1b90f00          CMP      r9,#0
0004a6  d00b              BEQ      |L1.1216|
;;;673          (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
0004a8  9700              STR      r7,[sp,#0]
0004aa  6820              LDR      r0,[r4,#0]
0004ac  f8502025          LDR      r2,[r0,r5,LSL #2]
0004b0  465b              MOV      r3,r11
0004b2  f1040130          ADD      r1,r4,#0x30
0004b6  f8d4c034          LDR      r12,[r4,#0x34]
0004ba  9802              LDR      r0,[sp,#8]
0004bc  47e0              BLX      r12
0004be  e00a              B        |L1.1238|
                  |L1.1216|
;;;674    					    (void FAR *) ptr->mem_buffer[i],
;;;675    					    file_offset, byte_count);
;;;676        else
;;;677          (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
0004c0  9700              STR      r7,[sp,#0]
0004c2  6820              LDR      r0,[r4,#0]
0004c4  f8502025          LDR      r2,[r0,r5,LSL #2]
0004c8  465b              MOV      r3,r11
0004ca  f1040130          ADD      r1,r4,#0x30
0004ce  f8d4c030          LDR      r12,[r4,#0x30]
0004d2  9802              LDR      r0,[sp,#8]
0004d4  47e0              BLX      r12
                  |L1.1238|
;;;678    					   (void FAR *) ptr->mem_buffer[i],
;;;679    					   file_offset, byte_count);
;;;680        file_offset += byte_count;
0004d6  44bb              ADD      r11,r11,r7
0004d8  6960              LDR      r0,[r4,#0x14]         ;661
0004da  4405              ADD      r5,r5,r0              ;661
                  |L1.1244|
0004dc  6920              LDR      r0,[r4,#0x10]         ;661
0004de  42a8              CMP      r0,r5                 ;661
0004e0  dcb5              BGT      |L1.1102|
                  |L1.1250|
0004e2  bf00              NOP                            ;670
;;;681      }
;;;682    }
0004e4  b005              ADD      sp,sp,#0x14
0004e6  e8bd8ff0          POP      {r4-r11,pc}
;;;683    
                          ENDP

                  do_barray_io PROC
;;;685    /* Do backing store read or write of a virtual coefficient-block array */
;;;686    LOCAL(void) do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing) {
0004ea  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
0004ee  b082              SUB      sp,sp,#8
0004f0  460c              MOV      r4,r1
0004f2  4691              MOV      r9,r2
;;;687      long bytesperrow, file_offset, byte_count, rows, thisrow, i;
;;;688    
;;;689      bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
0004f4  68a0              LDR      r0,[r4,#8]
0004f6  ea4f1ac0          LSL      r10,r0,#7
;;;690      file_offset = ptr->cur_start_row * bytesperrow;
0004fa  69a0              LDR      r0,[r4,#0x18]
0004fc  fb00fb0a          MUL      r11,r0,r10
;;;691      /* Loop to read or write each allocation chunk in mem_buffer */
;;;692      for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
000500  f04f0500          MOV      r5,#0
000504  e046              B        |L1.1428|
                  |L1.1286|
;;;693        /* One chunk, but check for short chunk at end of buffer */
;;;694        rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
000506  e9d41004          LDRD     r1,r0,[r4,#0x10]
00050a  1b49              SUBS     r1,r1,r5
00050c  4288              CMP      r0,r1
00050e  da01              BGE      |L1.1300|
000510  6960              LDR      r0,[r4,#0x14]
000512  e002              B        |L1.1306|
                  |L1.1300|
000514  6920              LDR      r0,[r4,#0x10]
000516  eba00005          SUB      r0,r0,r5
                  |L1.1306|
00051a  4680              MOV      r8,r0
;;;695        /* Transfer no more than is currently defined */
;;;696        thisrow = (long) ptr->cur_start_row + i;
00051c  69a0              LDR      r0,[r4,#0x18]
00051e  eb000605          ADD      r6,r0,r5
;;;697        rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
000522  69e0              LDR      r0,[r4,#0x1c]
000524  eba00006          SUB      r0,r0,r6
000528  4540              CMP      r0,r8
00052a  dd01              BLE      |L1.1328|
00052c  4640              MOV      r0,r8
00052e  e002              B        |L1.1334|
                  |L1.1328|
000530  69e0              LDR      r0,[r4,#0x1c]
000532  eba00006          SUB      r0,r0,r6
                  |L1.1334|
000536  4680              MOV      r8,r0
;;;698        /* Transfer no more than fits in file */
;;;699        rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
000538  6860              LDR      r0,[r4,#4]
00053a  eba00006          SUB      r0,r0,r6
00053e  4540              CMP      r0,r8
000540  dd01              BLE      |L1.1350|
000542  4640              MOV      r0,r8
000544  e002              B        |L1.1356|
                  |L1.1350|
000546  6860              LDR      r0,[r4,#4]
000548  eba00006          SUB      r0,r0,r6
                  |L1.1356|
00054c  4680              MOV      r8,r0
;;;700        if (rows <= 0)		/* this chunk might be past end of file! */
00054e  f1b80f00          CMP      r8,#0
000552  dc00              BGT      |L1.1366|
;;;701          break;
000554  e021              B        |L1.1434|
                  |L1.1366|
;;;702        byte_count = rows * bytesperrow;
000556  fb08f70a          MUL      r7,r8,r10
;;;703        if (writing)
00055a  f1b90f00          CMP      r9,#0
00055e  d00b              BEQ      |L1.1400|
;;;704          (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
000560  9700              STR      r7,[sp,#0]
000562  6820              LDR      r0,[r4,#0]
000564  f8502025          LDR      r2,[r0,r5,LSL #2]
000568  465b              MOV      r3,r11
00056a  f1040130          ADD      r1,r4,#0x30
00056e  f8d4c034          LDR      r12,[r4,#0x34]
000572  9802              LDR      r0,[sp,#8]
000574  47e0              BLX      r12
000576  e00a              B        |L1.1422|
                  |L1.1400|
;;;705    					    (void FAR *) ptr->mem_buffer[i],
;;;706    					    file_offset, byte_count);
;;;707        else
;;;708          (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
000578  9700              STR      r7,[sp,#0]
00057a  6820              LDR      r0,[r4,#0]
00057c  f8502025          LDR      r2,[r0,r5,LSL #2]
000580  465b              MOV      r3,r11
000582  f1040130          ADD      r1,r4,#0x30
000586  f8d4c030          LDR      r12,[r4,#0x30]
00058a  9802              LDR      r0,[sp,#8]
00058c  47e0              BLX      r12
                  |L1.1422|
;;;709    					   (void FAR *) ptr->mem_buffer[i],
;;;710    					   file_offset, byte_count);
;;;711        file_offset += byte_count;
00058e  44bb              ADD      r11,r11,r7
000590  6960              LDR      r0,[r4,#0x14]         ;692
000592  4405              ADD      r5,r5,r0              ;692
                  |L1.1428|
000594  6920              LDR      r0,[r4,#0x10]         ;692
000596  42a8              CMP      r0,r5                 ;692
000598  dcb5              BGT      |L1.1286|
                  |L1.1434|
00059a  bf00              NOP                            ;701
;;;712      }
;;;713    }
00059c  b005              ADD      sp,sp,#0x14
00059e  e8bd8ff0          POP      {r4-r11,pc}
;;;714    
                          ENDP

                  access_virt_sarray PROC
;;;718    /* caller intends to modify the accessed area. */
;;;719    METHODDEF(JSAMPARRAY) access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable) {
0005a2  e92d5ff0          PUSH     {r4-r12,lr}
0005a6  4605              MOV      r5,r0
0005a8  460c              MOV      r4,r1
0005aa  4616              MOV      r6,r2
0005ac  469a              MOV      r10,r3
0005ae  f8dd9028          LDR      r9,[sp,#0x28]
;;;720      JDIMENSION end_row = start_row + num_rows;
0005b2  eb06070a          ADD      r7,r6,r10
;;;721      JDIMENSION undef_row;
;;;722    
;;;723      /* debugging check */
;;;724      if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
0005b6  6860              LDR      r0,[r4,#4]
0005b8  42b8              CMP      r0,r7
0005ba  d304              BCC      |L1.1478|
0005bc  68e0              LDR      r0,[r4,#0xc]
0005be  4550              CMP      r0,r10
0005c0  d301              BCC      |L1.1478|
;;;725          ptr->mem_buffer == NULL)
0005c2  6820              LDR      r0,[r4,#0]
0005c4  b938              CBNZ     r0,|L1.1494|
                  |L1.1478|
;;;726        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
0005c6  f04f0016          MOV      r0,#0x16
0005ca  6829              LDR      r1,[r5,#0]
0005cc  6148              STR      r0,[r1,#0x14]
0005ce  6828              LDR      r0,[r5,#0]
0005d0  6801              LDR      r1,[r0,#0]
0005d2  4628              MOV      r0,r5
0005d4  4788              BLX      r1
                  |L1.1494|
;;;727    
;;;728      /* Make the desired part of the virtual array accessible */
;;;729      if (start_row < ptr->cur_start_row ||
0005d6  69a0              LDR      r0,[r4,#0x18]
0005d8  42b0              CMP      r0,r6
0005da  d804              BHI      |L1.1510|
;;;730          end_row > ptr->cur_start_row+ptr->rows_in_mem) {
0005dc  6921              LDR      r1,[r4,#0x10]
0005de  69a0              LDR      r0,[r4,#0x18]
0005e0  4408              ADD      r0,r0,r1
0005e2  42b8              CMP      r0,r7
0005e4  d226              BCS      |L1.1588|
                  |L1.1510|
;;;731        if (! ptr->b_s_open)
0005e6  6aa0              LDR      r0,[r4,#0x28]
0005e8  b938              CBNZ     r0,|L1.1530|
;;;732          ERREXIT(cinfo, JERR_VIRTUAL_BUG);
0005ea  f04f0045          MOV      r0,#0x45
0005ee  6829              LDR      r1,[r5,#0]
0005f0  6148              STR      r0,[r1,#0x14]
0005f2  6828              LDR      r0,[r5,#0]
0005f4  6801              LDR      r1,[r0,#0]
0005f6  4628              MOV      r0,r5
0005f8  4788              BLX      r1
                  |L1.1530|
;;;733        /* Flush old buffer contents if necessary */
;;;734        if (ptr->dirty) {
0005fa  6a60              LDR      r0,[r4,#0x24]
0005fc  b138              CBZ      r0,|L1.1550|
;;;735          do_sarray_io(cinfo, ptr, TRUE);
0005fe  2201              MOVS     r2,#1
000600  4621              MOV      r1,r4
000602  4628              MOV      r0,r5
000604  f7fffffe          BL       do_sarray_io
;;;736          ptr->dirty = FALSE;
000608  f04f0000          MOV      r0,#0
00060c  6260              STR      r0,[r4,#0x24]
                  |L1.1550|
;;;737        }
;;;738        /* Decide what part of virtual array to access.
;;;739         * Algorithm: if target address > current window, assume forward scan,
;;;740         * load starting at target address.  If target address < current window,
;;;741         * assume backward scan, load so that target area is top of window.
;;;742         * Note that when switching from forward write to forward read, will have
;;;743         * start_row = 0, so the limiting case applies and we load from 0 anyway.
;;;744         */
;;;745        if (start_row > ptr->cur_start_row) {
00060e  69a0              LDR      r0,[r4,#0x18]
000610  42b0              CMP      r0,r6
000612  d201              BCS      |L1.1560|
;;;746          ptr->cur_start_row = start_row;
000614  61a6              STR      r6,[r4,#0x18]
000616  e008              B        |L1.1578|
                  |L1.1560|
;;;747        } else {
;;;748          /* use long arithmetic here to avoid overflow & unsigned problems */
;;;749          long ltemp;
;;;750    
;;;751          ltemp = (long) end_row - (long) ptr->rows_in_mem;
000618  6921              LDR      r1,[r4,#0x10]
00061a  eba70001          SUB      r0,r7,r1
;;;752          if (ltemp < 0)
00061e  2800              CMP      r0,#0
000620  da01              BGE      |L1.1574|
;;;753    	ltemp = 0;		/* don't fall off front end of file */
000622  f04f0000          MOV      r0,#0
                  |L1.1574|
;;;754          ptr->cur_start_row = (JDIMENSION) ltemp;
000626  61a0              STR      r0,[r4,#0x18]
;;;755        }
000628  bf00              NOP      
                  |L1.1578|
;;;756        /* Read in the selected part of the array.
;;;757         * During the initial write pass, we will do no actual read
;;;758         * because the selected part is all undefined.
;;;759         */
;;;760        do_sarray_io(cinfo, ptr, FALSE);
00062a  2200              MOVS     r2,#0
00062c  4621              MOV      r1,r4
00062e  4628              MOV      r0,r5
000630  f7fffffe          BL       do_sarray_io
                  |L1.1588|
;;;761      }
;;;762      /* Ensure the accessed part of the array is defined; prezero if needed.
;;;763       * To improve locality of access, we only prezero the part of the array
;;;764       * that the caller is about to access, not the entire in-memory array.
;;;765       */
;;;766      if (ptr->first_undef_row < end_row) {
000634  69e0              LDR      r0,[r4,#0x1c]
000636  42b8              CMP      r0,r7
000638  d236              BCS      |L1.1704|
;;;767        if (ptr->first_undef_row < start_row) {
00063a  69e0              LDR      r0,[r4,#0x1c]
00063c  42b0              CMP      r0,r6
00063e  d20c              BCS      |L1.1626|
;;;768          if (writable)		/* writer skipped over a section of array */
000640  f1b90f00          CMP      r9,#0
000644  d007              BEQ      |L1.1622|
;;;769    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000646  f04f0016          MOV      r0,#0x16
00064a  6829              LDR      r1,[r5,#0]
00064c  6148              STR      r0,[r1,#0x14]
00064e  6828              LDR      r0,[r5,#0]
000650  6801              LDR      r1,[r0,#0]
000652  4628              MOV      r0,r5
000654  4788              BLX      r1
                  |L1.1622|
;;;770          undef_row = start_row;	/* but reader is allowed to read ahead */
000656  46b0              MOV      r8,r6
000658  e001              B        |L1.1630|
                  |L1.1626|
;;;771        } else {
;;;772          undef_row = ptr->first_undef_row;
00065a  f8d4801c          LDR      r8,[r4,#0x1c]
                  |L1.1630|
;;;773        }
;;;774        if (writable)
00065e  f1b90f00          CMP      r9,#0
000662  d000              BEQ      |L1.1638|
;;;775          ptr->first_undef_row = end_row;
000664  61e7              STR      r7,[r4,#0x1c]
                  |L1.1638|
;;;776        if (ptr->pre_zero) {
000666  6a20              LDR      r0,[r4,#0x20]
000668  b198              CBZ      r0,|L1.1682|
;;;777          size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
00066a  f8d4b008          LDR      r11,[r4,#8]
;;;778          undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
00066e  69a0              LDR      r0,[r4,#0x18]
000670  eba80800          SUB      r8,r8,r0
;;;779          end_row -= ptr->cur_start_row;
000674  69a0              LDR      r0,[r4,#0x18]
000676  eba70700          SUB      r7,r7,r0
;;;780          while (undef_row < end_row) {
00067a  e007              B        |L1.1676|
                  |L1.1660|
;;;781    	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
00067c  6821              LDR      r1,[r4,#0]
00067e  f8510028          LDR      r0,[r1,r8,LSL #2]
000682  4659              MOV      r1,r11
000684  f7fffffe          BL       jzero_far
;;;782    	undef_row++;
000688  f1080801          ADD      r8,r8,#1
                  |L1.1676|
00068c  45b8              CMP      r8,r7                 ;780
00068e  d3f5              BCC      |L1.1660|
;;;783          }
;;;784        } else {
000690  e00a              B        |L1.1704|
                  |L1.1682|
;;;785          if (! writable)		/* reader looking at undefined data */
000692  f1b90f00          CMP      r9,#0
000696  d107              BNE      |L1.1704|
;;;786    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000698  f04f0016          MOV      r0,#0x16
00069c  6829              LDR      r1,[r5,#0]
00069e  6148              STR      r0,[r1,#0x14]
0006a0  6828              LDR      r0,[r5,#0]
0006a2  6801              LDR      r1,[r0,#0]
0006a4  4628              MOV      r0,r5
0006a6  4788              BLX      r1
                  |L1.1704|
;;;787        }
;;;788      }
;;;789      /* Flag the buffer dirty if caller will write in it */
;;;790      if (writable)
0006a8  f1b90f00          CMP      r9,#0
0006ac  d002              BEQ      |L1.1716|
;;;791        ptr->dirty = TRUE;
0006ae  f04f0001          MOV      r0,#1
0006b2  6260              STR      r0,[r4,#0x24]
                  |L1.1716|
;;;792      /* Return address of proper part of the buffer */
;;;793      return ptr->mem_buffer + (start_row - ptr->cur_start_row);
0006b4  69a1              LDR      r1,[r4,#0x18]
0006b6  1a71              SUBS     r1,r6,r1
0006b8  6820              LDR      r0,[r4,#0]
0006ba  eb000081          ADD      r0,r0,r1,LSL #2
;;;794    }
0006be  e8bd9ff0          POP      {r4-r12,pc}
;;;795    
                          ENDP

                  access_virt_barray PROC
;;;799    /* caller intends to modify the accessed area. */
;;;800    METHODDEF(JBLOCKARRAY) access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows,  boolean writable) {
0006c2  e92d5ff0          PUSH     {r4-r12,lr}
0006c6  4605              MOV      r5,r0
0006c8  460c              MOV      r4,r1
0006ca  4616              MOV      r6,r2
0006cc  469a              MOV      r10,r3
0006ce  f8dd9028          LDR      r9,[sp,#0x28]
;;;801      JDIMENSION end_row = start_row + num_rows;
0006d2  eb06070a          ADD      r7,r6,r10
;;;802      JDIMENSION undef_row;
;;;803    
;;;804      /* debugging check */
;;;805      if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
0006d6  6860              LDR      r0,[r4,#4]
0006d8  42b8              CMP      r0,r7
0006da  d304              BCC      |L1.1766|
0006dc  68e0              LDR      r0,[r4,#0xc]
0006de  4550              CMP      r0,r10
0006e0  d301              BCC      |L1.1766|
;;;806          ptr->mem_buffer == NULL)
0006e2  6820              LDR      r0,[r4,#0]
0006e4  b938              CBNZ     r0,|L1.1782|
                  |L1.1766|
;;;807        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
0006e6  f04f0016          MOV      r0,#0x16
0006ea  6829              LDR      r1,[r5,#0]
0006ec  6148              STR      r0,[r1,#0x14]
0006ee  6828              LDR      r0,[r5,#0]
0006f0  6801              LDR      r1,[r0,#0]
0006f2  4628              MOV      r0,r5
0006f4  4788              BLX      r1
                  |L1.1782|
;;;808    
;;;809      /* Make the desired part of the virtual array accessible */
;;;810      if (start_row < ptr->cur_start_row ||
0006f6  69a0              LDR      r0,[r4,#0x18]
0006f8  42b0              CMP      r0,r6
0006fa  d804              BHI      |L1.1798|
;;;811          end_row > ptr->cur_start_row+ptr->rows_in_mem) {
0006fc  6921              LDR      r1,[r4,#0x10]
0006fe  69a0              LDR      r0,[r4,#0x18]
000700  4408              ADD      r0,r0,r1
000702  42b8              CMP      r0,r7
000704  d226              BCS      |L1.1876|
                  |L1.1798|
;;;812        if (! ptr->b_s_open)
000706  6aa0              LDR      r0,[r4,#0x28]
000708  b938              CBNZ     r0,|L1.1818|
;;;813          ERREXIT(cinfo, JERR_VIRTUAL_BUG);
00070a  f04f0045          MOV      r0,#0x45
00070e  6829              LDR      r1,[r5,#0]
000710  6148              STR      r0,[r1,#0x14]
000712  6828              LDR      r0,[r5,#0]
000714  6801              LDR      r1,[r0,#0]
000716  4628              MOV      r0,r5
000718  4788              BLX      r1
                  |L1.1818|
;;;814        /* Flush old buffer contents if necessary */
;;;815        if (ptr->dirty) {
00071a  6a60              LDR      r0,[r4,#0x24]
00071c  b138              CBZ      r0,|L1.1838|
;;;816          do_barray_io(cinfo, ptr, TRUE);
00071e  2201              MOVS     r2,#1
000720  4621              MOV      r1,r4
000722  4628              MOV      r0,r5
000724  f7fffffe          BL       do_barray_io
;;;817          ptr->dirty = FALSE;
000728  f04f0000          MOV      r0,#0
00072c  6260              STR      r0,[r4,#0x24]
                  |L1.1838|
;;;818        }
;;;819        /* Decide what part of virtual array to access.
;;;820         * Algorithm: if target address > current window, assume forward scan,
;;;821         * load starting at target address.  If target address < current window,
;;;822         * assume backward scan, load so that target area is top of window.
;;;823         * Note that when switching from forward write to forward read, will have
;;;824         * start_row = 0, so the limiting case applies and we load from 0 anyway.
;;;825         */
;;;826        if (start_row > ptr->cur_start_row) {
00072e  69a0              LDR      r0,[r4,#0x18]
000730  42b0              CMP      r0,r6
000732  d201              BCS      |L1.1848|
;;;827          ptr->cur_start_row = start_row;
000734  61a6              STR      r6,[r4,#0x18]
000736  e008              B        |L1.1866|
                  |L1.1848|
;;;828        } else {
;;;829          /* use long arithmetic here to avoid overflow & unsigned problems */
;;;830          long ltemp;
;;;831    
;;;832          ltemp = (long) end_row - (long) ptr->rows_in_mem;
000738  6921              LDR      r1,[r4,#0x10]
00073a  eba70001          SUB      r0,r7,r1
;;;833          if (ltemp < 0)
00073e  2800              CMP      r0,#0
000740  da01              BGE      |L1.1862|
;;;834    	ltemp = 0;		/* don't fall off front end of file */
000742  f04f0000          MOV      r0,#0
                  |L1.1862|
;;;835          ptr->cur_start_row = (JDIMENSION) ltemp;
000746  61a0              STR      r0,[r4,#0x18]
;;;836        }
000748  bf00              NOP      
                  |L1.1866|
;;;837        /* Read in the selected part of the array.
;;;838         * During the initial write pass, we will do no actual read
;;;839         * because the selected part is all undefined.
;;;840         */
;;;841        do_barray_io(cinfo, ptr, FALSE);
00074a  2200              MOVS     r2,#0
00074c  4621              MOV      r1,r4
00074e  4628              MOV      r0,r5
000750  f7fffffe          BL       do_barray_io
                  |L1.1876|
;;;842      }
;;;843      /* Ensure the accessed part of the array is defined; prezero if needed.
;;;844       * To improve locality of access, we only prezero the part of the array
;;;845       * that the caller is about to access, not the entire in-memory array.
;;;846       */
;;;847      if (ptr->first_undef_row < end_row) {
000754  69e0              LDR      r0,[r4,#0x1c]
000756  42b8              CMP      r0,r7
000758  d237              BCS      |L1.1994|
;;;848        if (ptr->first_undef_row < start_row) {
00075a  69e0              LDR      r0,[r4,#0x1c]
00075c  42b0              CMP      r0,r6
00075e  d20c              BCS      |L1.1914|
;;;849          if (writable)		/* writer skipped over a section of array */
000760  f1b90f00          CMP      r9,#0
000764  d007              BEQ      |L1.1910|
;;;850    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000766  f04f0016          MOV      r0,#0x16
00076a  6829              LDR      r1,[r5,#0]
00076c  6148              STR      r0,[r1,#0x14]
00076e  6828              LDR      r0,[r5,#0]
000770  6801              LDR      r1,[r0,#0]
000772  4628              MOV      r0,r5
000774  4788              BLX      r1
                  |L1.1910|
;;;851          undef_row = start_row;	/* but reader is allowed to read ahead */
000776  46b0              MOV      r8,r6
000778  e001              B        |L1.1918|
                  |L1.1914|
;;;852        } else {
;;;853          undef_row = ptr->first_undef_row;
00077a  f8d4801c          LDR      r8,[r4,#0x1c]
                  |L1.1918|
;;;854        }
;;;855        if (writable)
00077e  f1b90f00          CMP      r9,#0
000782  d000              BEQ      |L1.1926|
;;;856          ptr->first_undef_row = end_row;
000784  61e7              STR      r7,[r4,#0x1c]
                  |L1.1926|
;;;857        if (ptr->pre_zero) {
000786  6a20              LDR      r0,[r4,#0x20]
000788  b1a0              CBZ      r0,|L1.1972|
;;;858          size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
00078a  68a0              LDR      r0,[r4,#8]
00078c  ea4f1bc0          LSL      r11,r0,#7
;;;859          undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
000790  69a0              LDR      r0,[r4,#0x18]
000792  eba80800          SUB      r8,r8,r0
;;;860          end_row -= ptr->cur_start_row;
000796  69a0              LDR      r0,[r4,#0x18]
000798  eba70700          SUB      r7,r7,r0
;;;861          while (undef_row < end_row) {
00079c  e007              B        |L1.1966|
                  |L1.1950|
;;;862    	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
00079e  6821              LDR      r1,[r4,#0]
0007a0  f8510028          LDR      r0,[r1,r8,LSL #2]
0007a4  4659              MOV      r1,r11
0007a6  f7fffffe          BL       jzero_far
;;;863    	undef_row++;
0007aa  f1080801          ADD      r8,r8,#1
                  |L1.1966|
0007ae  45b8              CMP      r8,r7                 ;861
0007b0  d3f5              BCC      |L1.1950|
;;;864          }
;;;865        } else {
0007b2  e00a              B        |L1.1994|
                  |L1.1972|
;;;866          if (! writable)		/* reader looking at undefined data */
0007b4  f1b90f00          CMP      r9,#0
0007b8  d107              BNE      |L1.1994|
;;;867    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
0007ba  f04f0016          MOV      r0,#0x16
0007be  6829              LDR      r1,[r5,#0]
0007c0  6148              STR      r0,[r1,#0x14]
0007c2  6828              LDR      r0,[r5,#0]
0007c4  6801              LDR      r1,[r0,#0]
0007c6  4628              MOV      r0,r5
0007c8  4788              BLX      r1
                  |L1.1994|
;;;868        }
;;;869      }
;;;870      /* Flag the buffer dirty if caller will write in it */
;;;871      if (writable)
0007ca  f1b90f00          CMP      r9,#0
0007ce  d002              BEQ      |L1.2006|
;;;872        ptr->dirty = TRUE;
0007d0  f04f0001          MOV      r0,#1
0007d4  6260              STR      r0,[r4,#0x24]
                  |L1.2006|
;;;873      /* Return address of proper part of the buffer */
;;;874      return ptr->mem_buffer + (start_row - ptr->cur_start_row);
0007d6  69a1              LDR      r1,[r4,#0x18]
0007d8  1a71              SUBS     r1,r6,r1
0007da  6820              LDR      r0,[r4,#0]
0007dc  eb000081          ADD      r0,r0,r1,LSL #2
;;;875    }
0007e0  e8bd9ff0          POP      {r4-r12,pc}
;;;876    
                          ENDP

                  free_pool PROC
;;;882    METHODDEF(void)
;;;883    free_pool (j_common_ptr cinfo, int pool_id)
0007e4  e92d5ff0          PUSH     {r4-r12,lr}
;;;884    {
0007e8  4682              MOV      r10,r0
0007ea  460d              MOV      r5,r1
;;;885      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
0007ec  f8da4004          LDR      r4,[r10,#4]
;;;886      small_pool_ptr shdr_ptr;
;;;887      large_pool_ptr lhdr_ptr;
;;;888      size_t space_freed;
;;;889    
;;;890      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
0007f0  2d00              CMP      r5,#0
0007f2  db01              BLT      |L1.2040|
0007f4  2d02              CMP      r5,#2
0007f6  db0c              BLT      |L1.2066|
                  |L1.2040|
;;;891        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
0007f8  f04f000e          MOV      r0,#0xe
0007fc  f8da1000          LDR      r1,[r10,#0]
000800  6148              STR      r0,[r1,#0x14]
000802  f8da0000          LDR      r0,[r10,#0]
000806  6185              STR      r5,[r0,#0x18]
000808  f8da0000          LDR      r0,[r10,#0]
00080c  6801              LDR      r1,[r0,#0]
00080e  4650              MOV      r0,r10
000810  4788              BLX      r1
                  |L1.2066|
;;;892    
;;;893    #ifdef MEM_STATS
;;;894      if (cinfo->err->trace_level > 1)
;;;895        print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
;;;896    #endif
;;;897    
;;;898      /* If freeing IMAGE pool, close any virtual arrays first */
;;;899      if (pool_id == JPOOL_IMAGE) {
000812  2d01              CMP      r5,#1
000814  d129              BNE      |L1.2154|
;;;900        jvirt_sarray_ptr sptr;
;;;901        jvirt_barray_ptr bptr;
;;;902    
;;;903        for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
000816  f8d49044          LDR      r9,[r4,#0x44]
00081a  e00e              B        |L1.2106|
                  |L1.2076|
;;;904          if (sptr->b_s_open) {	/* there may be no backing store */
00081c  f8d90028          LDR      r0,[r9,#0x28]
000820  b148              CBZ      r0,|L1.2102|
;;;905    	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
000822  f04f0000          MOV      r0,#0
000826  f8c90028          STR      r0,[r9,#0x28]
;;;906    	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
00082a  f1090130          ADD      r1,r9,#0x30
00082e  4650              MOV      r0,r10
000830  f8d92038          LDR      r2,[r9,#0x38]
000834  4790              BLX      r2
                  |L1.2102|
000836  f8d9902c          LDR      r9,[r9,#0x2c]         ;903
                  |L1.2106|
00083a  f1b90f00          CMP      r9,#0                 ;903
00083e  d1ed              BNE      |L1.2076|
;;;907          }
;;;908        }
;;;909        mem->virt_sarray_list = NULL;
000840  f04f0000          MOV      r0,#0
000844  6460              STR      r0,[r4,#0x44]
;;;910        for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
000846  6ca6              LDR      r6,[r4,#0x48]
000848  e00a              B        |L1.2144|
                  |L1.2122|
;;;911          if (bptr->b_s_open) {	/* there may be no backing store */
00084a  6ab0              LDR      r0,[r6,#0x28]
00084c  b138              CBZ      r0,|L1.2142|
;;;912    	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
00084e  f04f0000          MOV      r0,#0
000852  62b0              STR      r0,[r6,#0x28]
;;;913    	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
000854  f1060130          ADD      r1,r6,#0x30
000858  4650              MOV      r0,r10
00085a  6bb2              LDR      r2,[r6,#0x38]
00085c  4790              BLX      r2
                  |L1.2142|
00085e  6af6              LDR      r6,[r6,#0x2c]         ;910
                  |L1.2144|
000860  2e00              CMP      r6,#0                 ;910
000862  d1f2              BNE      |L1.2122|
;;;914          }
;;;915        }
;;;916        mem->virt_barray_list = NULL;
000864  4630              MOV      r0,r6
000866  64a0              STR      r0,[r4,#0x48]
;;;917      }
000868  bf00              NOP      
                  |L1.2154|
;;;918    
;;;919      /* Release large objects */
;;;920      lhdr_ptr = mem->large_list[pool_id];
00086a  f104003c          ADD      r0,r4,#0x3c
00086e  f8508025          LDR      r8,[r0,r5,LSL #2]
;;;921      mem->large_list[pool_id] = NULL;
000872  f04f0100          MOV      r1,#0
000876  f8401025          STR      r1,[r0,r5,LSL #2]
;;;922    
;;;923      while (lhdr_ptr != NULL) {
00087a  e011              B        |L1.2208|
                  |L1.2172|
;;;924        large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
00087c  f8d86000          LDR      r6,[r8,#0]
;;;925        space_freed = lhdr_ptr->hdr.bytes_used +
000880  e9d80101          LDRD     r0,r1,[r8,#4]
000884  4408              ADD      r0,r0,r1
000886  f1000b10          ADD      r11,r0,#0x10
;;;926    		  lhdr_ptr->hdr.bytes_left +
;;;927    		  SIZEOF(large_pool_hdr);
;;;928        jpeg_free_small/*RS: Changed from jpeg_free_large*/(cinfo, (void FAR *) lhdr_ptr, space_freed);
00088a  465a              MOV      r2,r11
00088c  4641              MOV      r1,r8
00088e  4650              MOV      r0,r10
000890  f7fffffe          BL       jpeg_free_small
;;;929        mem->total_space_allocated -= space_freed;
000894  6ce0              LDR      r0,[r4,#0x4c]
000896  eba0000b          SUB      r0,r0,r11
00089a  64e0              STR      r0,[r4,#0x4c]
;;;930        lhdr_ptr = next_lhdr_ptr;
00089c  46b0              MOV      r8,r6
;;;931      }
00089e  bf00              NOP      
                  |L1.2208|
0008a0  f1b80f00          CMP      r8,#0                 ;923
0008a4  d1ea              BNE      |L1.2172|
;;;932    
;;;933      /* Release small objects */
;;;934      shdr_ptr = mem->small_list[pool_id];
0008a6  f1040034          ADD      r0,r4,#0x34
0008aa  f8507025          LDR      r7,[r0,r5,LSL #2]
;;;935      mem->small_list[pool_id] = NULL;
0008ae  f04f0100          MOV      r1,#0
0008b2  f8401025          STR      r1,[r0,r5,LSL #2]
;;;936    
;;;937      while (shdr_ptr != NULL) {
0008b6  e010              B        |L1.2266|
                  |L1.2232|
;;;938        small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
0008b8  683e              LDR      r6,[r7,#0]
;;;939        space_freed = shdr_ptr->hdr.bytes_used +
0008ba  e9d70101          LDRD     r0,r1,[r7,#4]
0008be  4408              ADD      r0,r0,r1
0008c0  f1000b10          ADD      r11,r0,#0x10
;;;940    		  shdr_ptr->hdr.bytes_left +
;;;941    		  SIZEOF(small_pool_hdr);
;;;942        jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
0008c4  465a              MOV      r2,r11
0008c6  4639              MOV      r1,r7
0008c8  4650              MOV      r0,r10
0008ca  f7fffffe          BL       jpeg_free_small
;;;943        mem->total_space_allocated -= space_freed;
0008ce  6ce0              LDR      r0,[r4,#0x4c]
0008d0  eba0000b          SUB      r0,r0,r11
0008d4  64e0              STR      r0,[r4,#0x4c]
;;;944        shdr_ptr = next_shdr_ptr;
0008d6  4637              MOV      r7,r6
;;;945      }
0008d8  bf00              NOP      
                  |L1.2266|
0008da  2f00              CMP      r7,#0                 ;937
0008dc  d1ec              BNE      |L1.2232|
;;;946    }
0008de  e8bd9ff0          POP      {r4-r12,pc}
;;;947    
                          ENDP

                  self_destruct PROC
;;;954    METHODDEF(void)
;;;955    self_destruct (j_common_ptr cinfo)
0008e2  b570              PUSH     {r4-r6,lr}
;;;956    {
0008e4  4604              MOV      r4,r0
;;;957      int pool;
;;;958    
;;;959      /* Close all backing store, release all memory.
;;;960       * Releasing pools in reverse order might help avoid fragmentation
;;;961       * with some (brain-damaged) malloc libraries.
;;;962       */
;;;963      for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
0008e6  f04f0501          MOV      r5,#1
0008ea  e005              B        |L1.2296|
                  |L1.2284|
;;;964        free_pool(cinfo, pool);
0008ec  4629              MOV      r1,r5
0008ee  4620              MOV      r0,r4
0008f0  f7fffffe          BL       free_pool
0008f4  f1a50501          SUB      r5,r5,#1              ;963
                  |L1.2296|
0008f8  2d00              CMP      r5,#0                 ;963
0008fa  daf7              BGE      |L1.2284|
;;;965      }
;;;966    
;;;967      /* Release the memory manager control block too. */
;;;968      jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
0008fc  2254              MOVS     r2,#0x54
0008fe  4620              MOV      r0,r4
000900  6861              LDR      r1,[r4,#4]
000902  f7fffffe          BL       jpeg_free_small
;;;969      cinfo->mem = NULL;		/* ensures I will be called only once */
000906  f04f0000          MOV      r0,#0
00090a  6060              STR      r0,[r4,#4]
;;;970    
;;;971      jpeg_mem_term(cinfo);		/* system-dependent cleanup */
00090c  4620              MOV      r0,r4
00090e  f7fffffe          BL       jpeg_mem_term
;;;972    }
000912  bd70              POP      {r4-r6,pc}
;;;973    
                          ENDP

                  jinit_memory_mgr PROC
;;;980    GLOBAL(void)
;;;981    jinit_memory_mgr (j_common_ptr cinfo)
000914  e92d41f0          PUSH     {r4-r8,lr}
;;;982    {
000918  4605              MOV      r5,r0
;;;983      my_mem_ptr mem;
;;;984      long max_to_use;
;;;985      int pool;
;;;986      size_t test_mac;
;;;987    
;;;988      cinfo->mem = NULL;		/* for safety if init fails */
00091a  f04f0000          MOV      r0,#0
00091e  6068              STR      r0,[r5,#4]
;;;989    
;;;990      /* Check for configuration errors.
;;;991       * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
;;;992       * doesn't reflect any real hardware alignment requirement.
;;;993       * The test is a little tricky: for X>0, X and X-1 have no one-bits
;;;994       * in common if and only if X is a power of 2, ie has only one one-bit.
;;;995       * Some compilers may give an "unreachable code" warning here; ignore it.
;;;996       */
;;;997      if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
;;;998        ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
;;;999      /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
;;;1000      * a multiple of SIZEOF(ALIGN_TYPE).
;;;1001      * Again, an "unreachable code" warning may be ignored here.
;;;1002      * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
;;;1003      */
;;;1004     test_mac = (size_t) MAX_ALLOC_CHUNK;
000920  f8df80b4          LDR      r8,|L1.2520|
;;;1005     if ((long) test_mac != MAX_ALLOC_CHUNK ||
000924  4640              MOV      r0,r8
000926  4580              CMP      r8,r0
000928  d100              BNE      |L1.2348|
;;;1006         (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
00092a  e007              B        |L1.2364|
                  |L1.2348|
;;;1007       ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
00092c  f04f0003          MOV      r0,#3
000930  6829              LDR      r1,[r5,#0]
000932  6148              STR      r0,[r1,#0x14]
000934  6828              LDR      r0,[r5,#0]
000936  6801              LDR      r1,[r0,#0]
000938  4628              MOV      r0,r5
00093a  4788              BLX      r1
                  |L1.2364|
;;;1008   
;;;1009     max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
00093c  4628              MOV      r0,r5
00093e  f7fffffe          BL       jpeg_mem_init
000942  4607              MOV      r7,r0
;;;1010   
;;;1011     /* Attempt to allocate memory manager's control block */
;;;1012     mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
000944  f04f0154          MOV      r1,#0x54
000948  4628              MOV      r0,r5
00094a  f7fffffe          BL       jpeg_get_small
00094e  4604              MOV      r4,r0
;;;1013   
;;;1014     if (mem == NULL) {
000950  b974              CBNZ     r4,|L1.2416|
;;;1015       jpeg_mem_term(cinfo);	/* system-dependent cleanup */
000952  4628              MOV      r0,r5
000954  f7fffffe          BL       jpeg_mem_term
;;;1016       ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
000958  f04f0036          MOV      r0,#0x36
00095c  6829              LDR      r1,[r5,#0]
00095e  6148              STR      r0,[r1,#0x14]
000960  f04f0000          MOV      r0,#0
000964  6829              LDR      r1,[r5,#0]
000966  6188              STR      r0,[r1,#0x18]
000968  6828              LDR      r0,[r5,#0]
00096a  6801              LDR      r1,[r0,#0]
00096c  4628              MOV      r0,r5
00096e  4788              BLX      r1
                  |L1.2416|
;;;1017     }
;;;1018   
;;;1019     /* OK, fill in the method pointers */
;;;1020     mem->pub.alloc_small = alloc_small;
000970  481a              LDR      r0,|L1.2524|
000972  6020              STR      r0,[r4,#0]
;;;1021     mem->pub.alloc_large = alloc_large;
000974  481a              LDR      r0,|L1.2528|
000976  6060              STR      r0,[r4,#4]
;;;1022     mem->pub.alloc_sarray = alloc_sarray;
000978  481a              LDR      r0,|L1.2532|
00097a  60a0              STR      r0,[r4,#8]
;;;1023     mem->pub.alloc_barray = alloc_barray;
00097c  481a              LDR      r0,|L1.2536|
00097e  60e0              STR      r0,[r4,#0xc]
;;;1024     mem->pub.request_virt_sarray = request_virt_sarray;
000980  481a              LDR      r0,|L1.2540|
000982  6120              STR      r0,[r4,#0x10]
;;;1025     mem->pub.request_virt_barray = request_virt_barray;
000984  481a              LDR      r0,|L1.2544|
000986  6160              STR      r0,[r4,#0x14]
;;;1026     mem->pub.realize_virt_arrays = realize_virt_arrays;
000988  481a              LDR      r0,|L1.2548|
00098a  61a0              STR      r0,[r4,#0x18]
;;;1027     mem->pub.access_virt_sarray = access_virt_sarray;
00098c  481a              LDR      r0,|L1.2552|
00098e  61e0              STR      r0,[r4,#0x1c]
;;;1028     mem->pub.access_virt_barray = access_virt_barray;
000990  481a              LDR      r0,|L1.2556|
000992  6220              STR      r0,[r4,#0x20]
;;;1029     mem->pub.free_pool = free_pool;
000994  481a              LDR      r0,|L1.2560|
000996  6260              STR      r0,[r4,#0x24]
;;;1030     mem->pub.self_destruct = self_destruct;
000998  481a              LDR      r0,|L1.2564|
00099a  62a0              STR      r0,[r4,#0x28]
;;;1031   
;;;1032     /* Make MAX_ALLOC_CHUNK accessible to other modules */
;;;1033     mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
00099c  480e              LDR      r0,|L1.2520|
00099e  6320              STR      r0,[r4,#0x30]
;;;1034   
;;;1035     /* Initialize working state */
;;;1036     mem->pub.max_memory_to_use = max_to_use;
0009a0  62e7              STR      r7,[r4,#0x2c]
;;;1037   
;;;1038     for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
0009a2  f04f0601          MOV      r6,#1
0009a6  e00b              B        |L1.2496|
                  |L1.2472|
;;;1039       mem->small_list[pool] = NULL;
0009a8  f04f0100          MOV      r1,#0
0009ac  f1040034          ADD      r0,r4,#0x34
0009b0  f8401026          STR      r1,[r0,r6,LSL #2]
;;;1040       mem->large_list[pool] = NULL;
0009b4  f104003c          ADD      r0,r4,#0x3c
0009b8  f8401026          STR      r1,[r0,r6,LSL #2]
0009bc  f1a60601          SUB      r6,r6,#1              ;1038
                  |L1.2496|
0009c0  2e00              CMP      r6,#0                 ;1038
0009c2  daf1              BGE      |L1.2472|
;;;1041     }
;;;1042     mem->virt_sarray_list = NULL;
0009c4  f04f0000          MOV      r0,#0
0009c8  6460              STR      r0,[r4,#0x44]
;;;1043     mem->virt_barray_list = NULL;
0009ca  64a0              STR      r0,[r4,#0x48]
;;;1044   
;;;1045     mem->total_space_allocated = SIZEOF(my_memory_mgr);
0009cc  f04f0054          MOV      r0,#0x54
0009d0  64e0              STR      r0,[r4,#0x4c]
;;;1046   
;;;1047     /* Declare ourselves open for business */
;;;1048     cinfo->mem = & mem->pub;
0009d2  606c              STR      r4,[r5,#4]
;;;1049   
;;;1050     /* Check for an environment variable JPEGMEM; if found, override the
;;;1051      * default max_memory setting from jpeg_mem_init.  Note that the
;;;1052      * surrounding application may again override this value.
;;;1053      * If your system doesn't support getenv(), define NO_GETENV to disable
;;;1054      * this feature.
;;;1055      */
;;;1056   #if 0 /* RS ndef NO_GETENV */
;;;1057     { char * memenv;
;;;1058   
;;;1059       if ((memenv = getenv("JPEGMEM")) != NULL) {
;;;1060         char ch = 'x';
;;;1061   
;;;1062         if (sscanf(memenv, "%ld%c", &max_to_use, &ch) > 0) {
;;;1063   	if (ch == 'm' || ch == 'M')
;;;1064   	  max_to_use *= 1000L;
;;;1065   	mem->pub.max_memory_to_use = max_to_use * 1000L;
;;;1066         }
;;;1067       }
;;;1068     }
;;;1069   #endif
;;;1070   
;;;1071   }
0009d4  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L1.2520|
                          DCD      0x3b9aca00
                  |L1.2524|
                          DCD      alloc_small
                  |L1.2528|
                          DCD      alloc_large
                  |L1.2532|
                          DCD      alloc_sarray
                  |L1.2536|
                          DCD      alloc_barray
                  |L1.2540|
                          DCD      request_virt_sarray
                  |L1.2544|
                          DCD      request_virt_barray
                  |L1.2548|
                          DCD      realize_virt_arrays
                  |L1.2552|
                          DCD      access_virt_sarray
                  |L1.2556|
                          DCD      access_virt_barray
                  |L1.2560|
                          DCD      free_pool
                  |L1.2564|
                          DCD      self_destruct

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  first_pool_slop
                          DCD      0x00000640
                          DCD      0x00003e80
                  extra_pool_slop
                          DCD      0x00000000
                          DCD      0x00001388
