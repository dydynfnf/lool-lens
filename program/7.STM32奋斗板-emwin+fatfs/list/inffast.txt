; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\inffast.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\inffast.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\MALLOC -I.\TFT -I.\EMWIN\EMWIN_INC -I.\EMWIN\DEMO -I.\FATFS -I.\SDIO -I.\PNG -IE:\material\GUI\STM32·Ü¶·°å-emwin+fatfs\RTE -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\inffast.crf PNG\inffast.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  inflate_fast PROC
;;;66      */
;;;67     void inflate_fast(strm, start)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;68     z_streamp strm;
;;;69     unsigned start;         /* inflate()'s starting value for strm->avail_out */
;;;70     {
000004  b08a              SUB      sp,sp,#0x28
000006  4607              MOV      r7,r0
;;;71         struct inflate_state FAR *state;
;;;72         unsigned char FAR *in;      /* local strm->next_in */
;;;73         unsigned char FAR *last;    /* while in < last, enough input available */
;;;74         unsigned char FAR *out;     /* local strm->next_out */
;;;75         unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
;;;76         unsigned char FAR *end;     /* while out < end, enough space available */
;;;77     #ifdef INFLATE_STRICT
;;;78         unsigned dmax;              /* maximum distance from zlib header */
;;;79     #endif
;;;80         unsigned wsize;             /* window size or zero if not using window */
;;;81         unsigned whave;             /* valid bytes in the window */
;;;82         unsigned write;             /* window write index */
;;;83         unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
;;;84         unsigned long hold;         /* local strm->hold */
;;;85         unsigned bits;              /* local strm->bits */
;;;86         code const FAR *lcode;      /* local strm->lencode */
;;;87         code const FAR *dcode;      /* local strm->distcode */
;;;88         unsigned lmask;             /* mask for first level of length codes */
;;;89         unsigned dmask;             /* mask for first level of distance codes */
;;;90         code this;                  /* retrieved table entry */
;;;91         unsigned op;                /* code bits, operation, extra bits, or */
;;;92                                     /*  window position, window bytes to copy */
;;;93         unsigned len;               /* match length, unused bytes */
;;;94         unsigned dist;              /* match distance */
;;;95         unsigned char FAR *from;    /* where to copy match from */
;;;96     
;;;97         /* copy state to local variables */
;;;98         state = (struct inflate_state FAR *)strm->state;
000008  69fe              LDR      r6,[r7,#0x1c]
;;;99         in = strm->next_in - OFF;
00000a  f8d7b000          LDR      r11,[r7,#0]
00000e  f1ab0c01          SUB      r12,r11,#1
;;;100        last = in + (strm->avail_in - 5);
000012  f8d7b004          LDR      r11,[r7,#4]
000016  f1ab0b05          SUB      r11,r11,#5
00001a  eb0b0a0c          ADD      r10,r11,r12
;;;101        out = strm->next_out - OFF;
00001e  f8d7b00c          LDR      r11,[r7,#0xc]
000022  f1ab0101          SUB      r1,r11,#1
;;;102        beg = out - (start - strm->avail_out);
000026  f8d7e010          LDR      lr,[r7,#0x10]
00002a  f8ddb02c          LDR      r11,[sp,#0x2c]
00002e  ebab0b0e          SUB      r11,r11,lr
000032  eba10b0b          SUB      r11,r1,r11
000036  f8cdb024          STR      r11,[sp,#0x24]
;;;103        end = out + (strm->avail_out - 257);
00003a  f8d7b010          LDR      r11,[r7,#0x10]
00003e  f2ab1b01          SUB      r11,r11,#0x101
000042  448b              ADD      r11,r11,r1
000044  f8cdb020          STR      r11,[sp,#0x20]
;;;104    #ifdef INFLATE_STRICT
;;;105        dmax = state->dmax;
;;;106    #endif
;;;107        wsize = state->wsize;
000048  f8d6b028          LDR      r11,[r6,#0x28]
00004c  f8cdb01c          STR      r11,[sp,#0x1c]
;;;108        whave = state->whave;
000050  f8d6b02c          LDR      r11,[r6,#0x2c]
000054  f8cdb018          STR      r11,[sp,#0x18]
;;;109        write = state->write;
000058  f8d68030          LDR      r8,[r6,#0x30]
;;;110        window = state->window;
00005c  f8d6b034          LDR      r11,[r6,#0x34]
000060  f8cdb014          STR      r11,[sp,#0x14]
;;;111        hold = state->hold;
000064  6bb3              LDR      r3,[r6,#0x38]
;;;112        bits = state->bits;
000066  6bf2              LDR      r2,[r6,#0x3c]
;;;113        lcode = state->lencode;
000068  f8d6b04c          LDR      r11,[r6,#0x4c]
00006c  f8cdb010          STR      r11,[sp,#0x10]
;;;114        dcode = state->distcode;
000070  f8d6b050          LDR      r11,[r6,#0x50]
000074  f8cdb00c          STR      r11,[sp,#0xc]
;;;115        lmask = (1U << state->lenbits) - 1;
000078  f896e054          LDRB     lr,[r6,#0x54]
00007c  f04f0b01          MOV      r11,#1
000080  fa0bfb0e          LSL      r11,r11,lr
000084  f1ab0b01          SUB      r11,r11,#1
000088  f8cdb008          STR      r11,[sp,#8]
;;;116        dmask = (1U << state->distbits) - 1;
00008c  f896e058          LDRB     lr,[r6,#0x58]
000090  f04f0b01          MOV      r11,#1
000094  fa0bfb0e          LSL      r11,r11,lr
000098  f1ab0b01          SUB      r11,r11,#1
00009c  f8cdb004          STR      r11,[sp,#4]
;;;117    
;;;118        /* decode literals and length/distances until end-of-block or not enough
;;;119           input data or output space */
;;;120        do {
0000a0  bf00              NOP      
                  |L1.162|
;;;121            if (bits < 15) {
0000a2  2a0f              CMP      r2,#0xf
0000a4  d211              BCS      |L1.202|
;;;122                hold += (unsigned long)(PUP(in)) << bits;
0000a6  f10c0b01          ADD      r11,r12,#1
0000aa  46dc              MOV      r12,r11
0000ac  f89bb000          LDRB     r11,[r11,#0]
0000b0  fa0bfb02          LSL      r11,r11,r2
0000b4  445b              ADD      r3,r3,r11
;;;123                bits += 8;
0000b6  3208              ADDS     r2,r2,#8
;;;124                hold += (unsigned long)(PUP(in)) << bits;
0000b8  f10c0b01          ADD      r11,r12,#1
0000bc  46dc              MOV      r12,r11
0000be  f89bb000          LDRB     r11,[r11,#0]
0000c2  fa0bfb02          LSL      r11,r11,r2
0000c6  445b              ADD      r3,r3,r11
;;;125                bits += 8;
0000c8  3208              ADDS     r2,r2,#8
                  |L1.202|
;;;126            }
;;;127            this = lcode[hold & lmask];
0000ca  f8ddb008          LDR      r11,[sp,#8]
0000ce  ea030b0b          AND      r11,r3,r11
0000d2  f8dde010          LDR      lr,[sp,#0x10]
0000d6  eb0e0b8b          ADD      r11,lr,r11,LSL #2
0000da  f8dbb000          LDR      r11,[r11,#0]
0000de  f8cdb000          STR      r11,[sp,#0]
;;;128          dolen:
0000e2  bf00              NOP      
                  |L1.228|
;;;129            op = (unsigned)(this.bits);
0000e4  f89d0001          LDRB     r0,[sp,#1]
;;;130            hold >>= op;
0000e8  40c3              LSRS     r3,r3,r0
;;;131            bits -= op;
0000ea  1a12              SUBS     r2,r2,r0
;;;132            op = (unsigned)(this.op);
0000ec  f89d0000          LDRB     r0,[sp,#0]
;;;133            if (op == 0) {                          /* literal */
0000f0  b938              CBNZ     r0,|L1.258|
;;;134                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
;;;135                        "inflate:         literal '%c'\n" :
;;;136                        "inflate:         literal 0x%02x\n", this.val));
;;;137                PUP(out) = (unsigned char)(this.val);
0000f2  f8bdb002          LDRH     r11,[sp,#2]
0000f6  f1010e01          ADD      lr,r1,#1
0000fa  4671              MOV      r1,lr
0000fc  f88eb000          STRB     r11,[lr,#0]
000100  e1c3              B        |L1.1162|
                  |L1.258|
;;;138            }
;;;139            else if (op & 16) {                     /* length base */
000102  f0000b10          AND      r11,r0,#0x10
000106  f1bb0f00          CMP      r11,#0
00010a  d078              BEQ      |L1.510|
;;;140                len = (unsigned)(this.val);
00010c  f8bd4002          LDRH     r4,[sp,#2]
;;;141                op &= 15;                           /* number of extra bits */
000110  f000000f          AND      r0,r0,#0xf
;;;142                if (op) {
000114  b1a8              CBZ      r0,|L1.322|
;;;143                    if (bits < op) {
000116  4282              CMP      r2,r0
000118  d208              BCS      |L1.300|
;;;144                        hold += (unsigned long)(PUP(in)) << bits;
00011a  f10c0b01          ADD      r11,r12,#1
00011e  46dc              MOV      r12,r11
000120  f89bb000          LDRB     r11,[r11,#0]
000124  fa0bfb02          LSL      r11,r11,r2
000128  445b              ADD      r3,r3,r11
;;;145                        bits += 8;
00012a  3208              ADDS     r2,r2,#8
                  |L1.300|
;;;146                    }
;;;147                    len += (unsigned)hold & ((1U << op) - 1);
00012c  f04f0b01          MOV      r11,#1
000130  fa0bfb00          LSL      r11,r11,r0
000134  f1ab0b01          SUB      r11,r11,#1
000138  ea0b0b03          AND      r11,r11,r3
00013c  445c              ADD      r4,r4,r11
;;;148                    hold >>= op;
00013e  40c3              LSRS     r3,r3,r0
;;;149                    bits -= op;
000140  1a12              SUBS     r2,r2,r0
                  |L1.322|
;;;150                }
;;;151                Tracevv((stderr, "inflate:         length %u\n", len));
;;;152                if (bits < 15) {
000142  2a0f              CMP      r2,#0xf
000144  d211              BCS      |L1.362|
;;;153                    hold += (unsigned long)(PUP(in)) << bits;
000146  f10c0b01          ADD      r11,r12,#1
00014a  46dc              MOV      r12,r11
00014c  f89bb000          LDRB     r11,[r11,#0]
000150  fa0bfb02          LSL      r11,r11,r2
000154  445b              ADD      r3,r3,r11
;;;154                    bits += 8;
000156  3208              ADDS     r2,r2,#8
;;;155                    hold += (unsigned long)(PUP(in)) << bits;
000158  f10c0b01          ADD      r11,r12,#1
00015c  46dc              MOV      r12,r11
00015e  f89bb000          LDRB     r11,[r11,#0]
000162  fa0bfb02          LSL      r11,r11,r2
000166  445b              ADD      r3,r3,r11
;;;156                    bits += 8;
000168  3208              ADDS     r2,r2,#8
                  |L1.362|
;;;157                }
;;;158                this = dcode[hold & dmask];
00016a  f8ddb004          LDR      r11,[sp,#4]
00016e  ea030b0b          AND      r11,r3,r11
000172  f8dde00c          LDR      lr,[sp,#0xc]
000176  eb0e0b8b          ADD      r11,lr,r11,LSL #2
00017a  f8dbb000          LDR      r11,[r11,#0]
00017e  f8cdb000          STR      r11,[sp,#0]
;;;159              dodist:
000182  bf00              NOP      
                  |L1.388|
;;;160                op = (unsigned)(this.bits);
000184  f89d0001          LDRB     r0,[sp,#1]
;;;161                hold >>= op;
000188  40c3              LSRS     r3,r3,r0
;;;162                bits -= op;
00018a  1a12              SUBS     r2,r2,r0
;;;163                op = (unsigned)(this.op);
00018c  f89d0000          LDRB     r0,[sp,#0]
;;;164                if (op & 16) {                      /* distance base */
000190  f0000b10          AND      r11,r0,#0x10
000194  f1bb0f00          CMP      r11,#0
000198  d07d              BEQ      |L1.662|
;;;165                    dist = (unsigned)(this.val);
00019a  f8bd9002          LDRH     r9,[sp,#2]
;;;166                    op &= 15;                       /* number of extra bits */
00019e  f000000f          AND      r0,r0,#0xf
;;;167                    if (bits < op) {
0001a2  4282              CMP      r2,r0
0001a4  d213              BCS      |L1.462|
;;;168                        hold += (unsigned long)(PUP(in)) << bits;
0001a6  f10c0b01          ADD      r11,r12,#1
0001aa  46dc              MOV      r12,r11
0001ac  f89bb000          LDRB     r11,[r11,#0]
0001b0  fa0bfb02          LSL      r11,r11,r2
0001b4  445b              ADD      r3,r3,r11
;;;169                        bits += 8;
0001b6  3208              ADDS     r2,r2,#8
;;;170                        if (bits < op) {
0001b8  4282              CMP      r2,r0
0001ba  d208              BCS      |L1.462|
;;;171                            hold += (unsigned long)(PUP(in)) << bits;
0001bc  f10c0b01          ADD      r11,r12,#1
0001c0  46dc              MOV      r12,r11
0001c2  f89bb000          LDRB     r11,[r11,#0]
0001c6  fa0bfb02          LSL      r11,r11,r2
0001ca  445b              ADD      r3,r3,r11
;;;172                            bits += 8;
0001cc  3208              ADDS     r2,r2,#8
                  |L1.462|
;;;173                        }
;;;174                    }
;;;175                    dist += (unsigned)hold & ((1U << op) - 1);
0001ce  f04f0b01          MOV      r11,#1
0001d2  fa0bfb00          LSL      r11,r11,r0
0001d6  f1ab0b01          SUB      r11,r11,#1
0001da  ea0b0b03          AND      r11,r11,r3
0001de  44d9              ADD      r9,r9,r11
;;;176    #ifdef INFLATE_STRICT
;;;177                    if (dist > dmax) {
;;;178                        strm->msg = (char *)"invalid distance too far back";
;;;179                        state->mode = BAD;
;;;180                        break;
;;;181                    }
;;;182    #endif
;;;183                    hold >>= op;
0001e0  40c3              LSRS     r3,r3,r0
;;;184                    bits -= op;
0001e2  1a12              SUBS     r2,r2,r0
;;;185                    Tracevv((stderr, "inflate:         distance %u\n", dist));
;;;186                    op = (unsigned)(out - beg);     /* max distance in output */
0001e4  f8ddb024          LDR      r11,[sp,#0x24]
0001e8  eba1000b          SUB      r0,r1,r11
;;;187                    if (dist > op) {                /* see if copy from window */
0001ec  4581              CMP      r9,r0
0001ee  d97c              BLS      |L1.746|
;;;188                        op = dist - op;             /* distance back in window */
0001f0  eba90000          SUB      r0,r9,r0
;;;189                        if (op > whave) {
0001f4  f8ddb018          LDR      r11,[sp,#0x18]
0001f8  4558              CMP      r0,r11
0001fa  d90a              BLS      |L1.530|
;;;190                            strm->msg = (char *)"invalid distance too far back";
0001fc  e000              B        |L1.512|
                  |L1.510|
0001fe  e118              B        |L1.1074|
                  |L1.512|
000200  f20f3b10          ADR      r11,|L1.1300|
000204  f8c7b018          STR      r11,[r7,#0x18]
;;;191                            state->mode = BAD;
000208  f04f0b1b          MOV      r11,#0x1b
00020c  f886b000          STRB     r11,[r6,#0]
;;;192                            break;
000210  e142              B        |L1.1176|
                  |L1.530|
;;;193                        }
;;;194                        from = window - OFF;
000212  f8ddb014          LDR      r11,[sp,#0x14]
000216  f1ab0501          SUB      r5,r11,#1
;;;195                        if (write == 0) {           /* very common case */
00021a  f1b80f00          CMP      r8,#0
00021e  d11a              BNE      |L1.598|
;;;196                            from += wsize - op;
000220  f8ddb01c          LDR      r11,[sp,#0x1c]
000224  ebab0b00          SUB      r11,r11,r0
000228  445d              ADD      r5,r5,r11
;;;197                            if (op < len) {         /* some from window */
00022a  42a0              CMP      r0,r4
00022c  d267              BCS      |L1.766|
;;;198                                len -= op;
00022e  1a24              SUBS     r4,r4,r0
;;;199                                do {
000230  bf00              NOP      
                  |L1.562|
;;;200                                    PUP(out) = PUP(from);
000232  f1050b01          ADD      r11,r5,#1
000236  465d              MOV      r5,r11
000238  f89bb000          LDRB     r11,[r11,#0]
00023c  f1010e01          ADD      lr,r1,#1
000240  4671              MOV      r1,lr
000242  f88eb000          STRB     r11,[lr,#0]
;;;201                                } while (--op);
000246  f1a00b01          SUB      r11,r0,#1
00024a  ea5f000b          MOVS     r0,r11
00024e  d1f0              BNE      |L1.562|
;;;202                                from = out - dist;  /* rest from output */
000250  eba10509          SUB      r5,r1,r9
000254  e053              B        |L1.766|
                  |L1.598|
;;;203                            }
;;;204                        }
;;;205                        else if (write < op) {      /* wrap around window */
000256  4580              CMP      r8,r0
000258  d237              BCS      |L1.714|
;;;206                            from += wsize + write - op;
00025a  f8ddb01c          LDR      r11,[sp,#0x1c]
00025e  44c3              ADD      r11,r11,r8
000260  ebab0b00          SUB      r11,r11,r0
000264  445d              ADD      r5,r5,r11
;;;207                            op -= write;
000266  eba00008          SUB      r0,r0,r8
;;;208                            if (op < len) {         /* some from end of window */
00026a  42a0              CMP      r0,r4
00026c  d247              BCS      |L1.766|
;;;209                                len -= op;
00026e  1a24              SUBS     r4,r4,r0
;;;210                                do {
000270  bf00              NOP      
                  |L1.626|
;;;211                                    PUP(out) = PUP(from);
000272  f1050b01          ADD      r11,r5,#1
000276  465d              MOV      r5,r11
000278  f89bb000          LDRB     r11,[r11,#0]
00027c  f1010e01          ADD      lr,r1,#1
000280  4671              MOV      r1,lr
000282  f88eb000          STRB     r11,[lr,#0]
;;;212                                } while (--op);
000286  f1a00b01          SUB      r11,r0,#1
00028a  ea5f000b          MOVS     r0,r11
00028e  d1f0              BNE      |L1.626|
;;;213                                from = window - OFF;
000290  f8ddb014          LDR      r11,[sp,#0x14]
000294  e000              B        |L1.664|
                  |L1.662|
000296  e0aa              B        |L1.1006|
                  |L1.664|
000298  f1ab0501          SUB      r5,r11,#1
;;;214                                if (write < len) {  /* some from start of window */
00029c  45a0              CMP      r8,r4
00029e  d22e              BCS      |L1.766|
;;;215                                    op = write;
0002a0  4640              MOV      r0,r8
;;;216                                    len -= op;
0002a2  1a24              SUBS     r4,r4,r0
;;;217                                    do {
0002a4  bf00              NOP      
                  |L1.678|
;;;218                                        PUP(out) = PUP(from);
0002a6  f1050b01          ADD      r11,r5,#1
0002aa  465d              MOV      r5,r11
0002ac  f89bb000          LDRB     r11,[r11,#0]
0002b0  f1010e01          ADD      lr,r1,#1
0002b4  4671              MOV      r1,lr
0002b6  f88eb000          STRB     r11,[lr,#0]
;;;219                                    } while (--op);
0002ba  f1a00b01          SUB      r11,r0,#1
0002be  ea5f000b          MOVS     r0,r11
0002c2  d1f0              BNE      |L1.678|
;;;220                                    from = out - dist;      /* rest from output */
0002c4  eba10509          SUB      r5,r1,r9
0002c8  e019              B        |L1.766|
                  |L1.714|
;;;221                                }
;;;222                            }
;;;223                        }
;;;224                        else {                      /* contiguous in window */
;;;225                            from += write - op;
0002ca  eba80b00          SUB      r11,r8,r0
0002ce  445d              ADD      r5,r5,r11
;;;226                            if (op < len) {         /* some from window */
0002d0  42a0              CMP      r0,r4
0002d2  d214              BCS      |L1.766|
;;;227                                len -= op;
0002d4  1a24              SUBS     r4,r4,r0
;;;228                                do {
0002d6  bf00              NOP      
                  |L1.728|
;;;229                                    PUP(out) = PUP(from);
0002d8  f1050b01          ADD      r11,r5,#1
0002dc  465d              MOV      r5,r11
0002de  f89bb000          LDRB     r11,[r11,#0]
0002e2  f1010e01          ADD      lr,r1,#1
0002e6  4671              MOV      r1,lr
0002e8  e000              B        |L1.748|
                  |L1.746|
0002ea  e043              B        |L1.884|
                  |L1.748|
0002ec  f88eb000          STRB     r11,[lr,#0]
;;;230                                } while (--op);
0002f0  f1a00b01          SUB      r11,r0,#1
0002f4  ea5f000b          MOVS     r0,r11
0002f8  d1ee              BNE      |L1.728|
;;;231                                from = out - dist;  /* rest from output */
0002fa  eba10509          SUB      r5,r1,r9
                  |L1.766|
;;;232                            }
;;;233                        }
;;;234                        while (len > 2) {
0002fe  e01e              B        |L1.830|
                  |L1.768|
;;;235                            PUP(out) = PUP(from);
000300  f1050b01          ADD      r11,r5,#1
000304  465d              MOV      r5,r11
000306  f89bb000          LDRB     r11,[r11,#0]
00030a  f1010e01          ADD      lr,r1,#1
00030e  4671              MOV      r1,lr
000310  f88eb000          STRB     r11,[lr,#0]
;;;236                            PUP(out) = PUP(from);
000314  f1050b01          ADD      r11,r5,#1
000318  465d              MOV      r5,r11
00031a  f89bb000          LDRB     r11,[r11,#0]
00031e  f1010e01          ADD      lr,r1,#1
000322  4671              MOV      r1,lr
000324  f88eb000          STRB     r11,[lr,#0]
;;;237                            PUP(out) = PUP(from);
000328  f1050b01          ADD      r11,r5,#1
00032c  465d              MOV      r5,r11
00032e  f89bb000          LDRB     r11,[r11,#0]
000332  f1010e01          ADD      lr,r1,#1
000336  4671              MOV      r1,lr
000338  f88eb000          STRB     r11,[lr,#0]
;;;238                            len -= 3;
00033c  1ee4              SUBS     r4,r4,#3
                  |L1.830|
00033e  2c02              CMP      r4,#2                 ;234
000340  d8de              BHI      |L1.768|
;;;239                        }
;;;240                        if (len) {
000342  2c00              CMP      r4,#0
000344  d015              BEQ      |L1.882|
;;;241                            PUP(out) = PUP(from);
000346  f1050b01          ADD      r11,r5,#1
00034a  465d              MOV      r5,r11
00034c  f89bb000          LDRB     r11,[r11,#0]
000350  f1010e01          ADD      lr,r1,#1
000354  4671              MOV      r1,lr
000356  f88eb000          STRB     r11,[lr,#0]
;;;242                            if (len > 1)
00035a  2c01              CMP      r4,#1
00035c  d909              BLS      |L1.882|
;;;243                                PUP(out) = PUP(from);
00035e  f1050b01          ADD      r11,r5,#1
000362  465d              MOV      r5,r11
000364  f89bb000          LDRB     r11,[r11,#0]
000368  f1010e01          ADD      lr,r1,#1
00036c  4671              MOV      r1,lr
00036e  f88eb000          STRB     r11,[lr,#0]
                  |L1.882|
000372  e08a              B        |L1.1162|
                  |L1.884|
;;;244                        }
;;;245                    }
;;;246                    else {
;;;247                        from = out - dist;          /* copy direct from output */
000374  eba10509          SUB      r5,r1,r9
;;;248                        do {                        /* minimum length is three */
000378  bf00              NOP      
                  |L1.890|
;;;249                            PUP(out) = PUP(from);
00037a  f1050b01          ADD      r11,r5,#1
00037e  465d              MOV      r5,r11
000380  f89bb000          LDRB     r11,[r11,#0]
000384  f1010e01          ADD      lr,r1,#1
000388  4671              MOV      r1,lr
00038a  f88eb000          STRB     r11,[lr,#0]
;;;250                            PUP(out) = PUP(from);
00038e  f1050b01          ADD      r11,r5,#1
000392  465d              MOV      r5,r11
000394  f89bb000          LDRB     r11,[r11,#0]
000398  f1010e01          ADD      lr,r1,#1
00039c  4671              MOV      r1,lr
00039e  f88eb000          STRB     r11,[lr,#0]
;;;251                            PUP(out) = PUP(from);
0003a2  f1050b01          ADD      r11,r5,#1
0003a6  465d              MOV      r5,r11
0003a8  f89bb000          LDRB     r11,[r11,#0]
0003ac  f1010e01          ADD      lr,r1,#1
0003b0  4671              MOV      r1,lr
0003b2  f88eb000          STRB     r11,[lr,#0]
;;;252                            len -= 3;
0003b6  1ee4              SUBS     r4,r4,#3
;;;253                        } while (len > 2);
0003b8  2c02              CMP      r4,#2
0003ba  d8de              BHI      |L1.890|
;;;254                        if (len) {
0003bc  2c00              CMP      r4,#0
0003be  d064              BEQ      |L1.1162|
;;;255                            PUP(out) = PUP(from);
0003c0  f1050b01          ADD      r11,r5,#1
0003c4  465d              MOV      r5,r11
0003c6  f89bb000          LDRB     r11,[r11,#0]
0003ca  f1010e01          ADD      lr,r1,#1
0003ce  4671              MOV      r1,lr
0003d0  f88eb000          STRB     r11,[lr,#0]
;;;256                            if (len > 1)
0003d4  2c01              CMP      r4,#1
0003d6  d958              BLS      |L1.1162|
;;;257                                PUP(out) = PUP(from);
0003d8  f1050b01          ADD      r11,r5,#1
0003dc  465d              MOV      r5,r11
0003de  f89bb000          LDRB     r11,[r11,#0]
0003e2  f1010e01          ADD      lr,r1,#1
0003e6  4671              MOV      r1,lr
0003e8  f88eb000          STRB     r11,[lr,#0]
0003ec  e04d              B        |L1.1162|
                  |L1.1006|
;;;258                        }
;;;259                    }
;;;260                }
;;;261                else if ((op & 64) == 0) {          /* 2nd level distance code */
0003ee  f0000b40          AND      r11,r0,#0x40
0003f2  f1bb0f00          CMP      r11,#0
0003f6  d113              BNE      |L1.1056|
;;;262                    this = dcode[this.val + (hold & ((1U << op) - 1))];
0003f8  f8bde002          LDRH     lr,[sp,#2]
0003fc  f04f0b01          MOV      r11,#1
000400  fa0bfb00          LSL      r11,r11,r0
000404  f1ab0b01          SUB      r11,r11,#1
000408  ea0b0b03          AND      r11,r11,r3
00040c  44de              ADD      lr,lr,r11
00040e  f8ddb00c          LDR      r11,[sp,#0xc]
000412  eb0b0b8e          ADD      r11,r11,lr,LSL #2
000416  f8dbb000          LDR      r11,[r11,#0]
00041a  f8cdb000          STR      r11,[sp,#0]
;;;263                    goto dodist;
00041e  e6b1              B        |L1.388|
                  |L1.1056|
;;;264                }
;;;265                else {
;;;266                    strm->msg = (char *)"invalid distance code";
000420  f20f1b10          ADR      r11,|L1.1332|
000424  f8c7b018          STR      r11,[r7,#0x18]
;;;267                    state->mode = BAD;
000428  f04f0b1b          MOV      r11,#0x1b
00042c  f886b000          STRB     r11,[r6,#0]
;;;268                    break;
000430  e032              B        |L1.1176|
                  |L1.1074|
;;;269                }
;;;270            }
;;;271            else if ((op & 64) == 0) {              /* 2nd level length code */
000432  f0000b40          AND      r11,r0,#0x40
000436  f1bb0f00          CMP      r11,#0
00043a  d113              BNE      |L1.1124|
;;;272                this = lcode[this.val + (hold & ((1U << op) - 1))];
00043c  f8bde002          LDRH     lr,[sp,#2]
000440  f04f0b01          MOV      r11,#1
000444  fa0bfb00          LSL      r11,r11,r0
000448  f1ab0b01          SUB      r11,r11,#1
00044c  ea0b0b03          AND      r11,r11,r3
000450  44de              ADD      lr,lr,r11
000452  f8ddb010          LDR      r11,[sp,#0x10]
000456  eb0b0b8e          ADD      r11,r11,lr,LSL #2
00045a  f8dbb000          LDR      r11,[r11,#0]
00045e  f8cdb000          STR      r11,[sp,#0]
;;;273                goto dolen;
000462  e63f              B        |L1.228|
                  |L1.1124|
;;;274            }
;;;275            else if (op & 32) {                     /* end-of-block */
000464  f0000b20          AND      r11,r0,#0x20
000468  f1bb0f00          CMP      r11,#0
00046c  d004              BEQ      |L1.1144|
;;;276                Tracevv((stderr, "inflate:         end of block\n"));
;;;277                state->mode = TYPE;
00046e  f04f0b0b          MOV      r11,#0xb
000472  f886b000          STRB     r11,[r6,#0]
;;;278                break;
000476  e00f              B        |L1.1176|
                  |L1.1144|
;;;279            }
;;;280            else {
;;;281                strm->msg = (char *)"invalid literal/length code";
000478  f20f0bd0          ADR      r11,|L1.1356|
00047c  f8c7b018          STR      r11,[r7,#0x18]
;;;282                state->mode = BAD;
000480  f04f0b1b          MOV      r11,#0x1b
000484  f886b000          STRB     r11,[r6,#0]
;;;283                break;
000488  e006              B        |L1.1176|
                  |L1.1162|
;;;284            }
;;;285        } while (in < last && out < end);
00048a  45d4              CMP      r12,r10
00048c  d204              BCS      |L1.1176|
00048e  f8ddb020          LDR      r11,[sp,#0x20]
000492  4559              CMP      r1,r11
000494  f4ffae05          BCC      |L1.162|
                  |L1.1176|
000498  bf00              NOP                            ;192
;;;286    
;;;287        /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
;;;288        len = bits >> 3;
00049a  08d4              LSRS     r4,r2,#3
;;;289        in -= len;
00049c  ebac0c04          SUB      r12,r12,r4
;;;290        bits -= len << 3;
0004a0  eba202c4          SUB      r2,r2,r4,LSL #3
;;;291        hold &= (1U << bits) - 1;
0004a4  f04f0b01          MOV      r11,#1
0004a8  fa0bfb02          LSL      r11,r11,r2
0004ac  f1ab0b01          SUB      r11,r11,#1
0004b0  ea0b0303          AND      r3,r11,r3
;;;292    
;;;293        /* update state and return */
;;;294        strm->next_in = in + OFF;
0004b4  f10c0b01          ADD      r11,r12,#1
0004b8  f8c7b000          STR      r11,[r7,#0]
;;;295        strm->next_out = out + OFF;
0004bc  f1010b01          ADD      r11,r1,#1
0004c0  f8c7b00c          STR      r11,[r7,#0xc]
;;;296        strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
0004c4  45d4              CMP      r12,r10
0004c6  d204              BCS      |L1.1234|
0004c8  ebaa0b0c          SUB      r11,r10,r12
0004cc  f10b0b05          ADD      r11,r11,#5
0004d0  e003              B        |L1.1242|
                  |L1.1234|
0004d2  ebac0b0a          SUB      r11,r12,r10
0004d6  f1cb0b05          RSB      r11,r11,#5
                  |L1.1242|
0004da  f8c7b004          STR      r11,[r7,#4]
;;;297        strm->avail_out = (unsigned)(out < end ?
0004de  f8ddb020          LDR      r11,[sp,#0x20]
0004e2  4559              CMP      r1,r11
0004e4  d206              BCS      |L1.1268|
;;;298                                     257 + (end - out) : 257 - (out - end));
0004e6  f8ddb020          LDR      r11,[sp,#0x20]
0004ea  ebab0b01          SUB      r11,r11,r1
0004ee  f20b1b01          ADD      r11,r11,#0x101
0004f2  e007              B        |L1.1284|
                  |L1.1268|
0004f4  f8ddb020          LDR      r11,[sp,#0x20]
0004f8  eba10b0b          SUB      r11,r1,r11
0004fc  f2401e01          MOV      lr,#0x101
000500  ebae0b0b          SUB      r11,lr,r11
                  |L1.1284|
000504  f8c7b010          STR      r11,[r7,#0x10]
;;;299        state->hold = hold;
000508  63b3              STR      r3,[r6,#0x38]
;;;300        state->bits = bits;
00050a  63f2              STR      r2,[r6,#0x3c]
;;;301        return;
;;;302    }
00050c  b00c              ADD      sp,sp,#0x30
00050e  e8bd8ff0          POP      {r4-r11,pc}
;;;303    
                          ENDP

000512  0000              DCW      0x0000
                  |L1.1300|
000514  696e7661          DCB      "invalid distance too far back",0
000518  6c696420
00051c  64697374
000520  616e6365
000524  20746f6f
000528  20666172
00052c  20626163
000530  6b00    
000532  00                DCB      0
000533  00                DCB      0
                  |L1.1332|
000534  696e7661          DCB      "invalid distance code",0
000538  6c696420
00053c  64697374
000540  616e6365
000544  20636f64
000548  6500    
00054a  00                DCB      0
00054b  00                DCB      0
                  |L1.1356|
00054c  696e7661          DCB      "invalid literal/length code",0
000550  6c696420
000554  6c697465
000558  72616c2f
00055c  6c656e67
000560  74682063
000564  6f646500
