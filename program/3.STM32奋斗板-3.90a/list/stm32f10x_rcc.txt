; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\stm32f10x_rcc.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\stm32f10x_rcc.crf FWlib\SRC\stm32f10x_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;216      */
;;;217    void RCC_DeInit(void)
000000  48f7              LDR      r0,|L1.992|
;;;218    {
;;;219      /* Set HSION bit */
;;;220      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  49f5              LDR      r1,|L1.992|
00000a  6008              STR      r0,[r1,#0]
;;;221    
;;;222      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;223    #ifndef STM32F10X_CL
;;;224      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  49f4              LDR      r1,|L1.996|
000012  ea000001          AND      r0,r0,r1
000016  49f2              LDR      r1,|L1.992|
000018  6048              STR      r0,[r1,#4]
;;;225    #else
;;;226      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;227    #endif /* STM32F10X_CL */   
;;;228      
;;;229      /* Reset HSEON, CSSON and PLLON bits */
;;;230      RCC->CR &= (uint32_t)0xFEF6FFFF;
00001a  4608              MOV      r0,r1
00001c  6800              LDR      r0,[r0,#0]
00001e  49f2              LDR      r1,|L1.1000|
000020  ea000001          AND      r0,r0,r1
000024  49ee              LDR      r1,|L1.992|
000026  6008              STR      r0,[r1,#0]
;;;231    
;;;232      /* Reset HSEBYP bit */
;;;233      RCC->CR &= (uint32_t)0xFFFBFFFF;
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  f4202080          BIC      r0,r0,#0x40000
000030  6008              STR      r0,[r1,#0]
;;;234    
;;;235      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;236      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000032  4608              MOV      r0,r1
000034  6840              LDR      r0,[r0,#4]
000036  f42000fe          BIC      r0,r0,#0x7f0000
00003a  6048              STR      r0,[r1,#4]
;;;237    
;;;238    #ifdef STM32F10X_CL
;;;239      /* Reset PLL2ON and PLL3ON bits */
;;;240      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;241    
;;;242      /* Disable all interrupts and clear pending bits  */
;;;243      RCC->CIR = 0x00FF0000;
;;;244    
;;;245      /* Reset CFGR2 register */
;;;246      RCC->CFGR2 = 0x00000000;
;;;247    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;248      /* Disable all interrupts and clear pending bits  */
;;;249      RCC->CIR = 0x009F0000;
;;;250    
;;;251      /* Reset CFGR2 register */
;;;252      RCC->CFGR2 = 0x00000000;      
;;;253    #else
;;;254      /* Disable all interrupts and clear pending bits  */
;;;255      RCC->CIR = 0x009F0000;
00003c  f44f001f          MOV      r0,#0x9f0000
000040  6088              STR      r0,[r1,#8]
;;;256    #endif /* STM32F10X_CL */
;;;257    
;;;258    }
000042  4770              BX       lr
;;;259    
                          ENDP

                  RCC_HSEConfig PROC
;;;269      */
;;;270    void RCC_HSEConfig(uint32_t RCC_HSE)
000044  49e6              LDR      r1,|L1.992|
;;;271    {
;;;272      /* Check the parameters */
;;;273      assert_param(IS_RCC_HSE(RCC_HSE));
;;;274      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;275      /* Reset HSEON bit */
;;;276      RCC->CR &= CR_HSEON_Reset;
000046  6809              LDR      r1,[r1,#0]
000048  f4213180          BIC      r1,r1,#0x10000
00004c  4ae4              LDR      r2,|L1.992|
00004e  6011              STR      r1,[r2,#0]
;;;277      /* Reset HSEBYP bit */
;;;278      RCC->CR &= CR_HSEBYP_Reset;
000050  4611              MOV      r1,r2
000052  6809              LDR      r1,[r1,#0]
000054  f4212180          BIC      r1,r1,#0x40000
000058  6011              STR      r1,[r2,#0]
;;;279      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;280      switch(RCC_HSE)
00005a  f5b03f80          CMP      r0,#0x10000
00005e  d003              BEQ      |L1.104|
000060  f5b02f80          CMP      r0,#0x40000
000064  d10e              BNE      |L1.132|
000066  e006              B        |L1.118|
                  |L1.104|
;;;281      {
;;;282        case RCC_HSE_ON:
;;;283          /* Set HSEON bit */
;;;284          RCC->CR |= CR_HSEON_Set;
000068  49dd              LDR      r1,|L1.992|
00006a  6809              LDR      r1,[r1,#0]
00006c  f4413180          ORR      r1,r1,#0x10000
000070  4adb              LDR      r2,|L1.992|
000072  6011              STR      r1,[r2,#0]
;;;285          break;
000074  e007              B        |L1.134|
                  |L1.118|
;;;286          
;;;287        case RCC_HSE_Bypass:
;;;288          /* Set HSEBYP and HSEON bits */
;;;289          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
000076  49da              LDR      r1,|L1.992|
000078  6809              LDR      r1,[r1,#0]
00007a  f44121a0          ORR      r1,r1,#0x50000
00007e  4ad8              LDR      r2,|L1.992|
000080  6011              STR      r1,[r2,#0]
;;;290          break;
000082  e000              B        |L1.134|
                  |L1.132|
;;;291          
;;;292        default:
;;;293          break;
000084  bf00              NOP      
                  |L1.134|
000086  bf00              NOP                            ;285
;;;294      }
;;;295    }
000088  4770              BX       lr
;;;296    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;1325     */
;;;1326   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
00008a  b510              PUSH     {r4,lr}
;;;1327   {
00008c  4601              MOV      r1,r0
;;;1328     uint32_t tmp = 0;
00008e  f04f0200          MOV      r2,#0
;;;1329     uint32_t statusreg = 0;
000092  4613              MOV      r3,r2
;;;1330     FlagStatus bitstatus = RESET;
000094  4610              MOV      r0,r2
;;;1331     /* Check the parameters */
;;;1332     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1333   
;;;1334     /* Get the RCC register index */
;;;1335     tmp = RCC_FLAG >> 5;
000096  ea4f1261          ASR      r2,r1,#5
;;;1336     if (tmp == 1)               /* The flag to check is in CR register */
00009a  2a01              CMP      r2,#1
00009c  d102              BNE      |L1.164|
;;;1337     {
;;;1338       statusreg = RCC->CR;
00009e  4cd0              LDR      r4,|L1.992|
0000a0  6823              LDR      r3,[r4,#0]
0000a2  e006              B        |L1.178|
                  |L1.164|
;;;1339     }
;;;1340     else if (tmp == 2)          /* The flag to check is in BDCR register */
0000a4  2a02              CMP      r2,#2
0000a6  d102              BNE      |L1.174|
;;;1341     {
;;;1342       statusreg = RCC->BDCR;
0000a8  4ccd              LDR      r4,|L1.992|
0000aa  6a23              LDR      r3,[r4,#0x20]
0000ac  e001              B        |L1.178|
                  |L1.174|
;;;1343     }
;;;1344     else                       /* The flag to check is in CSR register */
;;;1345     {
;;;1346       statusreg = RCC->CSR;
0000ae  4ccc              LDR      r4,|L1.992|
0000b0  6a63              LDR      r3,[r4,#0x24]
                  |L1.178|
;;;1347     }
;;;1348   
;;;1349     /* Get the flag position */
;;;1350     tmp = RCC_FLAG & FLAG_Mask;
0000b2  f001021f          AND      r2,r1,#0x1f
;;;1351     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
0000b6  f04f0401          MOV      r4,#1
0000ba  fa04f402          LSL      r4,r4,r2
0000be  421c              TST      r4,r3
0000c0  d002              BEQ      |L1.200|
;;;1352     {
;;;1353       bitstatus = SET;
0000c2  f04f0001          MOV      r0,#1
0000c6  e001              B        |L1.204|
                  |L1.200|
;;;1354     }
;;;1355     else
;;;1356     {
;;;1357       bitstatus = RESET;
0000c8  f04f0000          MOV      r0,#0
                  |L1.204|
;;;1358     }
;;;1359   
;;;1360     /* Return the flag status */
;;;1361     return bitstatus;
;;;1362   }
0000cc  bd10              POP      {r4,pc}
;;;1363   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;303      */
;;;304    ErrorStatus RCC_WaitForHSEStartUp(void)
0000ce  b570              PUSH     {r4-r6,lr}
;;;305    {
;;;306      __IO uint32_t StartUpCounter = 0;
0000d0  f04f0400          MOV      r4,#0
;;;307      ErrorStatus status = ERROR;
0000d4  4625              MOV      r5,r4
;;;308      FlagStatus HSEStatus = RESET;
0000d6  4626              MOV      r6,r4
;;;309      
;;;310      /* Wait till HSE is ready and if Time out is reached exit */
;;;311      do
0000d8  bf00              NOP      
                  |L1.218|
;;;312      {
;;;313        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
0000da  2031              MOVS     r0,#0x31
0000dc  f7fffffe          BL       RCC_GetFlagStatus
0000e0  4606              MOV      r6,r0
;;;314        StartUpCounter++;  
0000e2  f1040401          ADD      r4,r4,#1
;;;315      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
0000e6  f5b46fa0          CMP      r4,#0x500
0000ea  d001              BEQ      |L1.240|
0000ec  2e00              CMP      r6,#0
0000ee  d0f4              BEQ      |L1.218|
                  |L1.240|
;;;316      
;;;317      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
0000f0  2031              MOVS     r0,#0x31
0000f2  f7fffffe          BL       RCC_GetFlagStatus
0000f6  b110              CBZ      r0,|L1.254|
;;;318      {
;;;319        status = SUCCESS;
0000f8  f04f0501          MOV      r5,#1
0000fc  e001              B        |L1.258|
                  |L1.254|
;;;320      }
;;;321      else
;;;322      {
;;;323        status = ERROR;
0000fe  f04f0500          MOV      r5,#0
                  |L1.258|
;;;324      }  
;;;325      return (status);
000102  4628              MOV      r0,r5
;;;326    }
000104  bd70              POP      {r4-r6,pc}
;;;327    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;333      */
;;;334    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000106  4601              MOV      r1,r0
;;;335    {
;;;336      uint32_t tmpreg = 0;
000108  f04f0000          MOV      r0,#0
;;;337      /* Check the parameters */
;;;338      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;339      tmpreg = RCC->CR;
00010c  4ab4              LDR      r2,|L1.992|
00010e  6810              LDR      r0,[r2,#0]
;;;340      /* Clear HSITRIM[4:0] bits */
;;;341      tmpreg &= CR_HSITRIM_Mask;
000110  f02000f8          BIC      r0,r0,#0xf8
;;;342      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;343      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000114  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;344      /* Store the new value */
;;;345      RCC->CR = tmpreg;
000118  6010              STR      r0,[r2,#0]
;;;346    }
00011a  4770              BX       lr
;;;347    
                          ENDP

                  RCC_HSICmd PROC
;;;353      */
;;;354    void RCC_HSICmd(FunctionalState NewState)
00011c  49b3              LDR      r1,|L1.1004|
;;;355    {
;;;356      /* Check the parameters */
;;;357      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;358      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
00011e  6008              STR      r0,[r1,#0]
;;;359    }
000120  4770              BX       lr
;;;360    
                          ENDP

                  RCC_PLLConfig PROC
;;;377      */
;;;378    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000122  4602              MOV      r2,r0
;;;379    {
;;;380      uint32_t tmpreg = 0;
000124  f04f0000          MOV      r0,#0
;;;381    
;;;382      /* Check the parameters */
;;;383      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;384      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;385    
;;;386      tmpreg = RCC->CFGR;
000128  4bad              LDR      r3,|L1.992|
00012a  6858              LDR      r0,[r3,#4]
;;;387      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;388      tmpreg &= CFGR_PLL_Mask;
00012c  f420107c          BIC      r0,r0,#0x3f0000
;;;389      /* Set the PLL configuration bits */
;;;390      tmpreg |= RCC_PLLSource | RCC_PLLMul;
000130  ea420301          ORR      r3,r2,r1
000134  ea430000          ORR      r0,r3,r0
;;;391      /* Store the new value */
;;;392      RCC->CFGR = tmpreg;
000138  4ba9              LDR      r3,|L1.992|
00013a  6058              STR      r0,[r3,#4]
;;;393    }
00013c  4770              BX       lr
;;;394    
                          ENDP

                  RCC_PLLCmd PROC
;;;400      */
;;;401    void RCC_PLLCmd(FunctionalState NewState)
00013e  49ab              LDR      r1,|L1.1004|
;;;402    {
;;;403      /* Check the parameters */
;;;404      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;405    
;;;406      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000140  6608              STR      r0,[r1,#0x60]
;;;407    }
000142  4770              BX       lr
;;;408    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;563      */
;;;564    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000144  4601              MOV      r1,r0
;;;565    {
;;;566      uint32_t tmpreg = 0;
000146  f04f0000          MOV      r0,#0
;;;567      /* Check the parameters */
;;;568      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;569      tmpreg = RCC->CFGR;
00014a  4aa5              LDR      r2,|L1.992|
00014c  6850              LDR      r0,[r2,#4]
;;;570      /* Clear SW[1:0] bits */
;;;571      tmpreg &= CFGR_SW_Mask;
00014e  f0200003          BIC      r0,r0,#3
;;;572      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;573      tmpreg |= RCC_SYSCLKSource;
000152  ea400001          ORR      r0,r0,r1
;;;574      /* Store the new value */
;;;575      RCC->CFGR = tmpreg;
000156  6050              STR      r0,[r2,#4]
;;;576    }
000158  4770              BX       lr
;;;577    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;586      */
;;;587    uint8_t RCC_GetSYSCLKSource(void)
00015a  48a1              LDR      r0,|L1.992|
;;;588    {
;;;589      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
00015c  6840              LDR      r0,[r0,#4]
00015e  f000000c          AND      r0,r0,#0xc
;;;590    }
000162  4770              BX       lr
;;;591    
                          ENDP

                  RCC_HCLKConfig PROC
;;;607      */
;;;608    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000164  4601              MOV      r1,r0
;;;609    {
;;;610      uint32_t tmpreg = 0;
000166  f04f0000          MOV      r0,#0
;;;611      /* Check the parameters */
;;;612      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;613      tmpreg = RCC->CFGR;
00016a  4a9d              LDR      r2,|L1.992|
00016c  6850              LDR      r0,[r2,#4]
;;;614      /* Clear HPRE[3:0] bits */
;;;615      tmpreg &= CFGR_HPRE_Reset_Mask;
00016e  f02000f0          BIC      r0,r0,#0xf0
;;;616      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;617      tmpreg |= RCC_SYSCLK;
000172  ea400001          ORR      r0,r0,r1
;;;618      /* Store the new value */
;;;619      RCC->CFGR = tmpreg;
000176  6050              STR      r0,[r2,#4]
;;;620    }
000178  4770              BX       lr
;;;621    
                          ENDP

                  RCC_PCLK1Config PROC
;;;633      */
;;;634    void RCC_PCLK1Config(uint32_t RCC_HCLK)
00017a  4601              MOV      r1,r0
;;;635    {
;;;636      uint32_t tmpreg = 0;
00017c  f04f0000          MOV      r0,#0
;;;637      /* Check the parameters */
;;;638      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;639      tmpreg = RCC->CFGR;
000180  4a97              LDR      r2,|L1.992|
000182  6850              LDR      r0,[r2,#4]
;;;640      /* Clear PPRE1[2:0] bits */
;;;641      tmpreg &= CFGR_PPRE1_Reset_Mask;
000184  f42060e0          BIC      r0,r0,#0x700
;;;642      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;643      tmpreg |= RCC_HCLK;
000188  ea400001          ORR      r0,r0,r1
;;;644      /* Store the new value */
;;;645      RCC->CFGR = tmpreg;
00018c  6050              STR      r0,[r2,#4]
;;;646    }
00018e  4770              BX       lr
;;;647    
                          ENDP

                  RCC_PCLK2Config PROC
;;;659      */
;;;660    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000190  4601              MOV      r1,r0
;;;661    {
;;;662      uint32_t tmpreg = 0;
000192  f04f0000          MOV      r0,#0
;;;663      /* Check the parameters */
;;;664      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;665      tmpreg = RCC->CFGR;
000196  4a92              LDR      r2,|L1.992|
000198  6850              LDR      r0,[r2,#4]
;;;666      /* Clear PPRE2[2:0] bits */
;;;667      tmpreg &= CFGR_PPRE2_Reset_Mask;
00019a  f4205060          BIC      r0,r0,#0x3800
;;;668      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;669      tmpreg |= RCC_HCLK << 3;
00019e  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;670      /* Store the new value */
;;;671      RCC->CFGR = tmpreg;
0001a2  6050              STR      r0,[r2,#4]
;;;672    }
0001a4  4770              BX       lr
;;;673    
                          ENDP

                  RCC_ITConfig PROC
;;;699      */
;;;700    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
0001a6  b131              CBZ      r1,|L1.438|
;;;701    {
;;;702      /* Check the parameters */
;;;703      assert_param(IS_RCC_IT(RCC_IT));
;;;704      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;705      if (NewState != DISABLE)
;;;706      {
;;;707        /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
;;;708        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
0001a8  4a8d              LDR      r2,|L1.992|
0001aa  7a52              LDRB     r2,[r2,#9]
0001ac  ea420200          ORR      r2,r2,r0
0001b0  4b8b              LDR      r3,|L1.992|
0001b2  725a              STRB     r2,[r3,#9]
0001b4  e008              B        |L1.456|
                  |L1.438|
;;;709      }
;;;710      else
;;;711      {
;;;712        /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
;;;713        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
0001b6  4a8a              LDR      r2,|L1.992|
0001b8  7a52              LDRB     r2,[r2,#9]
0001ba  ea6f0300          MVN      r3,r0
0001be  b2db              UXTB     r3,r3
0001c0  ea020203          AND      r2,r2,r3
0001c4  4b86              LDR      r3,|L1.992|
0001c6  725a              STRB     r2,[r3,#9]
                  |L1.456|
;;;714      }
;;;715    }
0001c8  4770              BX       lr
;;;716    
                          ENDP

                  RCC_USBCLKConfig PROC
;;;727      */
;;;728    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
0001ca  4989              LDR      r1,|L1.1008|
;;;729    {
;;;730      /* Check the parameters */
;;;731      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;732    
;;;733      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
0001cc  6008              STR      r0,[r1,#0]
;;;734    }
0001ce  4770              BX       lr
;;;735    #else
                          ENDP

                  RCC_ADCCLKConfig PROC
;;;765      */
;;;766    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
0001d0  4601              MOV      r1,r0
;;;767    {
;;;768      uint32_t tmpreg = 0;
0001d2  f04f0000          MOV      r0,#0
;;;769      /* Check the parameters */
;;;770      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;771      tmpreg = RCC->CFGR;
0001d6  4a82              LDR      r2,|L1.992|
0001d8  6850              LDR      r0,[r2,#4]
;;;772      /* Clear ADCPRE[1:0] bits */
;;;773      tmpreg &= CFGR_ADCPRE_Reset_Mask;
0001da  f4204040          BIC      r0,r0,#0xc000
;;;774      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;775      tmpreg |= RCC_PCLK2;
0001de  ea400001          ORR      r0,r0,r1
;;;776      /* Store the new value */
;;;777      RCC->CFGR = tmpreg;
0001e2  6050              STR      r0,[r2,#4]
;;;778    }
0001e4  4770              BX       lr
;;;779    
                          ENDP

                  RCC_LSEConfig PROC
;;;828      */
;;;829    void RCC_LSEConfig(uint8_t RCC_LSE)
0001e6  f04f0100          MOV      r1,#0
;;;830    {
;;;831      /* Check the parameters */
;;;832      assert_param(IS_RCC_LSE(RCC_LSE));
;;;833      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;834      /* Reset LSEON bit */
;;;835      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0001ea  4a82              LDR      r2,|L1.1012|
0001ec  7011              STRB     r1,[r2,#0]
;;;836      /* Reset LSEBYP bit */
;;;837      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0001ee  4a7c              LDR      r2,|L1.992|
0001f0  f8821020          STRB     r1,[r2,#0x20]
;;;838      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;839      switch(RCC_LSE)
0001f4  2801              CMP      r0,#1
0001f6  d002              BEQ      |L1.510|
0001f8  2804              CMP      r0,#4
0001fa  d10a              BNE      |L1.530|
0001fc  e004              B        |L1.520|
                  |L1.510|
;;;840      {
;;;841        case RCC_LSE_ON:
;;;842          /* Set LSEON bit */
;;;843          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
0001fe  f04f0101          MOV      r1,#1
000202  4a7c              LDR      r2,|L1.1012|
000204  7011              STRB     r1,[r2,#0]
;;;844          break;
000206  e005              B        |L1.532|
                  |L1.520|
;;;845          
;;;846        case RCC_LSE_Bypass:
;;;847          /* Set LSEBYP and LSEON bits */
;;;848          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000208  f04f0105          MOV      r1,#5
00020c  4a79              LDR      r2,|L1.1012|
00020e  7011              STRB     r1,[r2,#0]
;;;849          break;            
000210  e000              B        |L1.532|
                  |L1.530|
;;;850          
;;;851        default:
;;;852          break;      
000212  bf00              NOP      
                  |L1.532|
000214  bf00              NOP                            ;844
;;;853      }
;;;854    }
000216  4770              BX       lr
;;;855    
                          ENDP

                  RCC_LSICmd PROC
;;;861      */
;;;862    void RCC_LSICmd(FunctionalState NewState)
000218  4977              LDR      r1,|L1.1016|
;;;863    {
;;;864      /* Check the parameters */
;;;865      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;866      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
00021a  6008              STR      r0,[r1,#0]
;;;867    }
00021c  4770              BX       lr
;;;868    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;878      */
;;;879    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
00021e  4970              LDR      r1,|L1.992|
;;;880    {
;;;881      /* Check the parameters */
;;;882      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;883      /* Select the RTC clock source */
;;;884      RCC->BDCR |= RCC_RTCCLKSource;
000220  6a09              LDR      r1,[r1,#0x20]
000222  ea410100          ORR      r1,r1,r0
000226  4a6e              LDR      r2,|L1.992|
000228  6211              STR      r1,[r2,#0x20]
;;;885    }
00022a  4770              BX       lr
;;;886    
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;892      */
;;;893    void RCC_RTCCLKCmd(FunctionalState NewState)
00022c  4973              LDR      r1,|L1.1020|
;;;894    {
;;;895      /* Check the parameters */
;;;896      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;897      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
00022e  6008              STR      r0,[r1,#0]
;;;898    }
000230  4770              BX       lr
;;;899    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;907      */
;;;908    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000232  b530              PUSH     {r4,r5,lr}
;;;909    {
;;;910      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
000234  f04f0100          MOV      r1,#0
000238  460a              MOV      r2,r1
00023a  460c              MOV      r4,r1
00023c  460b              MOV      r3,r1
;;;911    
;;;912    #ifdef  STM32F10X_CL
;;;913      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;914    #endif /* STM32F10X_CL */
;;;915    
;;;916    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;917      uint32_t prediv1factor = 0;
;;;918    #endif
;;;919        
;;;920      /* Get SYSCLK source -------------------------------------------------------*/
;;;921      tmp = RCC->CFGR & CFGR_SWS_Mask;
00023e  4d68              LDR      r5,|L1.992|
000240  686d              LDR      r5,[r5,#4]
000242  f005010c          AND      r1,r5,#0xc
;;;922      
;;;923      switch (tmp)
000246  b121              CBZ      r1,|L1.594|
000248  2904              CMP      r1,#4
00024a  d005              BEQ      |L1.600|
00024c  2908              CMP      r1,#8
00024e  d127              BNE      |L1.672|
000250  e005              B        |L1.606|
                  |L1.594|
;;;924      {
;;;925        case 0x00:  /* HSI used as system clock */
;;;926          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000252  4d6b              LDR      r5,|L1.1024|
000254  6005              STR      r5,[r0,#0]
;;;927          break;
000256  e026              B        |L1.678|
                  |L1.600|
;;;928        case 0x04:  /* HSE used as system clock */
;;;929          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
000258  4d69              LDR      r5,|L1.1024|
00025a  6005              STR      r5,[r0,#0]
;;;930          break;
00025c  e023              B        |L1.678|
                  |L1.606|
;;;931        case 0x08:  /* PLL used as system clock */
;;;932    
;;;933          /* Get PLL clock source and multiplication factor ----------------------*/
;;;934          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
00025e  4d60              LDR      r5,|L1.992|
000260  686d              LDR      r5,[r5,#4]
000262  f4051270          AND      r2,r5,#0x3c0000
;;;935          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
000266  4d5e              LDR      r5,|L1.992|
000268  686d              LDR      r5,[r5,#4]
00026a  f4053480          AND      r4,r5,#0x10000
;;;936          
;;;937    #ifndef STM32F10X_CL      
;;;938          pllmull = ( pllmull >> 18) + 2;
00026e  f04f0502          MOV      r5,#2
000272  eb054292          ADD      r2,r5,r2,LSR #18
;;;939          
;;;940          if (pllsource == 0x00)
000276  b924              CBNZ     r4,|L1.642|
;;;941          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;942            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
000278  4d62              LDR      r5,|L1.1028|
00027a  fb02f505          MUL      r5,r2,r5
00027e  6005              STR      r5,[r0,#0]
000280  e00d              B        |L1.670|
                  |L1.642|
;;;943          }
;;;944          else
;;;945          {
;;;946     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;947           prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;948           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;949           RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
;;;950     #else
;;;951            /* HSE selected as PLL clock entry */
;;;952            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
000282  4d57              LDR      r5,|L1.992|
000284  686d              LDR      r5,[r5,#4]
000286  f4153f00          TST      r5,#0x20000
00028a  d004              BEQ      |L1.662|
;;;953            {/* HSE oscillator clock divided by 2 */
;;;954              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
00028c  4d5d              LDR      r5,|L1.1028|
00028e  fb02f505          MUL      r5,r2,r5
000292  6005              STR      r5,[r0,#0]
000294  e003              B        |L1.670|
                  |L1.662|
;;;955            }
;;;956            else
;;;957            {
;;;958              RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
000296  4d5a              LDR      r5,|L1.1024|
000298  fb02f505          MUL      r5,r2,r5
00029c  6005              STR      r5,[r0,#0]
                  |L1.670|
;;;959            }
;;;960     #endif
;;;961          }
;;;962    #else
;;;963          pllmull = pllmull >> 18;
;;;964          
;;;965          if (pllmull != 0x0D)
;;;966          {
;;;967             pllmull += 2;
;;;968          }
;;;969          else
;;;970          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;971            pllmull = 13 / 2; 
;;;972          }
;;;973                
;;;974          if (pllsource == 0x00)
;;;975          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;976            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;977          }
;;;978          else
;;;979          {/* PREDIV1 selected as PLL clock entry */
;;;980            
;;;981            /* Get PREDIV1 clock source and division factor */
;;;982            prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
;;;983            prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;984            
;;;985            if (prediv1source == 0)
;;;986            { /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;987              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
;;;988            }
;;;989            else
;;;990            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;991              
;;;992              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;993              prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
;;;994              pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;995              RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;996            }
;;;997          }
;;;998    #endif /* STM32F10X_CL */ 
;;;999          break;
00029e  e002              B        |L1.678|
                  |L1.672|
;;;1000   
;;;1001       default:
;;;1002         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
0002a0  4d57              LDR      r5,|L1.1024|
0002a2  6005              STR      r5,[r0,#0]
;;;1003         break;
0002a4  bf00              NOP      
                  |L1.678|
0002a6  bf00              NOP                            ;927
;;;1004     }
;;;1005   
;;;1006     /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;1007     /* Get HCLK prescaler */
;;;1008     tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
0002a8  4d4d              LDR      r5,|L1.992|
0002aa  686d              LDR      r5,[r5,#4]
0002ac  f00501f0          AND      r1,r5,#0xf0
;;;1009     tmp = tmp >> 4;
0002b0  ea4f1111          LSR      r1,r1,#4
;;;1010     presc = APBAHBPrescTable[tmp];
0002b4  4d54              LDR      r5,|L1.1032|
0002b6  5c6b              LDRB     r3,[r5,r1]
;;;1011     /* HCLK clock frequency */
;;;1012     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
0002b8  6805              LDR      r5,[r0,#0]
0002ba  fa25f503          LSR      r5,r5,r3
0002be  6045              STR      r5,[r0,#4]
;;;1013     /* Get PCLK1 prescaler */
;;;1014     tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
0002c0  4d47              LDR      r5,|L1.992|
0002c2  686d              LDR      r5,[r5,#4]
0002c4  f40561e0          AND      r1,r5,#0x700
;;;1015     tmp = tmp >> 8;
0002c8  ea4f2111          LSR      r1,r1,#8
;;;1016     presc = APBAHBPrescTable[tmp];
0002cc  4d4e              LDR      r5,|L1.1032|
0002ce  5c6b              LDRB     r3,[r5,r1]
;;;1017     /* PCLK1 clock frequency */
;;;1018     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0002d0  6845              LDR      r5,[r0,#4]
0002d2  fa25f503          LSR      r5,r5,r3
0002d6  6085              STR      r5,[r0,#8]
;;;1019     /* Get PCLK2 prescaler */
;;;1020     tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
0002d8  4d41              LDR      r5,|L1.992|
0002da  686d              LDR      r5,[r5,#4]
0002dc  f4055160          AND      r1,r5,#0x3800
;;;1021     tmp = tmp >> 11;
0002e0  ea4f21d1          LSR      r1,r1,#11
;;;1022     presc = APBAHBPrescTable[tmp];
0002e4  4d48              LDR      r5,|L1.1032|
0002e6  5c6b              LDRB     r3,[r5,r1]
;;;1023     /* PCLK2 clock frequency */
;;;1024     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0002e8  6845              LDR      r5,[r0,#4]
0002ea  fa25f503          LSR      r5,r5,r3
0002ee  60c5              STR      r5,[r0,#0xc]
;;;1025     /* Get ADCCLK prescaler */
;;;1026     tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
0002f0  4d3b              LDR      r5,|L1.992|
0002f2  686d              LDR      r5,[r5,#4]
0002f4  f4054140          AND      r1,r5,#0xc000
;;;1027     tmp = tmp >> 14;
0002f8  ea4f3191          LSR      r1,r1,#14
;;;1028     presc = ADCPrescTable[tmp];
0002fc  4d43              LDR      r5,|L1.1036|
0002fe  5c6b              LDRB     r3,[r5,r1]
;;;1029     /* ADCCLK clock frequency */
;;;1030     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
000300  68c5              LDR      r5,[r0,#0xc]
000302  fbb5f5f3          UDIV     r5,r5,r3
000306  6105              STR      r5,[r0,#0x10]
;;;1031   }
000308  bd30              POP      {r4,r5,pc}
;;;1032   
                          ENDP

                  RCC_AHBPeriphClockCmd PROC
;;;1063     */
;;;1064   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
00030a  b131              CBZ      r1,|L1.794|
;;;1065   {
;;;1066     /* Check the parameters */
;;;1067     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1068     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1069   
;;;1070     if (NewState != DISABLE)
;;;1071     {
;;;1072       RCC->AHBENR |= RCC_AHBPeriph;
00030c  4a34              LDR      r2,|L1.992|
00030e  6952              LDR      r2,[r2,#0x14]
000310  ea420200          ORR      r2,r2,r0
000314  4b32              LDR      r3,|L1.992|
000316  615a              STR      r2,[r3,#0x14]
000318  e005              B        |L1.806|
                  |L1.794|
;;;1073     }
;;;1074     else
;;;1075     {
;;;1076       RCC->AHBENR &= ~RCC_AHBPeriph;
00031a  4a31              LDR      r2,|L1.992|
00031c  6952              LDR      r2,[r2,#0x14]
00031e  ea220200          BIC      r2,r2,r0
000322  4b2f              LDR      r3,|L1.992|
000324  615a              STR      r2,[r3,#0x14]
                  |L1.806|
;;;1077     }
;;;1078   }
000326  4770              BX       lr
;;;1079   
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;1094     */
;;;1095   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000328  b131              CBZ      r1,|L1.824|
;;;1096   {
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1099     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1100     if (NewState != DISABLE)
;;;1101     {
;;;1102       RCC->APB2ENR |= RCC_APB2Periph;
00032a  4a2d              LDR      r2,|L1.992|
00032c  6992              LDR      r2,[r2,#0x18]
00032e  ea420200          ORR      r2,r2,r0
000332  4b2b              LDR      r3,|L1.992|
000334  619a              STR      r2,[r3,#0x18]
000336  e005              B        |L1.836|
                  |L1.824|
;;;1103     }
;;;1104     else
;;;1105     {
;;;1106       RCC->APB2ENR &= ~RCC_APB2Periph;
000338  4a29              LDR      r2,|L1.992|
00033a  6992              LDR      r2,[r2,#0x18]
00033c  ea220200          BIC      r2,r2,r0
000340  4b27              LDR      r3,|L1.992|
000342  619a              STR      r2,[r3,#0x18]
                  |L1.836|
;;;1107     }
;;;1108   }
000344  4770              BX       lr
;;;1109   
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;1125     */
;;;1126   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000346  b131              CBZ      r1,|L1.854|
;;;1127   {
;;;1128     /* Check the parameters */
;;;1129     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1130     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1131     if (NewState != DISABLE)
;;;1132     {
;;;1133       RCC->APB1ENR |= RCC_APB1Periph;
000348  4a25              LDR      r2,|L1.992|
00034a  69d2              LDR      r2,[r2,#0x1c]
00034c  ea420200          ORR      r2,r2,r0
000350  4b23              LDR      r3,|L1.992|
000352  61da              STR      r2,[r3,#0x1c]
000354  e005              B        |L1.866|
                  |L1.854|
;;;1134     }
;;;1135     else
;;;1136     {
;;;1137       RCC->APB1ENR &= ~RCC_APB1Periph;
000356  4a22              LDR      r2,|L1.992|
000358  69d2              LDR      r2,[r2,#0x1c]
00035a  ea220200          BIC      r2,r2,r0
00035e  4b20              LDR      r3,|L1.992|
000360  61da              STR      r2,[r3,#0x1c]
                  |L1.866|
;;;1138     }
;;;1139   }
000362  4770              BX       lr
;;;1140   
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;1184     */
;;;1185   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000364  b131              CBZ      r1,|L1.884|
;;;1186   {
;;;1187     /* Check the parameters */
;;;1188     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1189     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1190     if (NewState != DISABLE)
;;;1191     {
;;;1192       RCC->APB2RSTR |= RCC_APB2Periph;
000366  4a1e              LDR      r2,|L1.992|
000368  68d2              LDR      r2,[r2,#0xc]
00036a  ea420200          ORR      r2,r2,r0
00036e  4b1c              LDR      r3,|L1.992|
000370  60da              STR      r2,[r3,#0xc]
000372  e005              B        |L1.896|
                  |L1.884|
;;;1193     }
;;;1194     else
;;;1195     {
;;;1196       RCC->APB2RSTR &= ~RCC_APB2Periph;
000374  4a1a              LDR      r2,|L1.992|
000376  68d2              LDR      r2,[r2,#0xc]
000378  ea220200          BIC      r2,r2,r0
00037c  4b18              LDR      r3,|L1.992|
00037e  60da              STR      r2,[r3,#0xc]
                  |L1.896|
;;;1197     }
;;;1198   }
000380  4770              BX       lr
;;;1199   
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;1215     */
;;;1216   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000382  b131              CBZ      r1,|L1.914|
;;;1217   {
;;;1218     /* Check the parameters */
;;;1219     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1220     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1221     if (NewState != DISABLE)
;;;1222     {
;;;1223       RCC->APB1RSTR |= RCC_APB1Periph;
000384  4a16              LDR      r2,|L1.992|
000386  6912              LDR      r2,[r2,#0x10]
000388  ea420200          ORR      r2,r2,r0
00038c  4b14              LDR      r3,|L1.992|
00038e  611a              STR      r2,[r3,#0x10]
000390  e005              B        |L1.926|
                  |L1.914|
;;;1224     }
;;;1225     else
;;;1226     {
;;;1227       RCC->APB1RSTR &= ~RCC_APB1Periph;
000392  4a13              LDR      r2,|L1.992|
000394  6912              LDR      r2,[r2,#0x10]
000396  ea220200          BIC      r2,r2,r0
00039a  4b11              LDR      r3,|L1.992|
00039c  611a              STR      r2,[r3,#0x10]
                  |L1.926|
;;;1228     }
;;;1229   }
00039e  4770              BX       lr
;;;1230   
                          ENDP

                  RCC_BackupResetCmd PROC
;;;1236     */
;;;1237   void RCC_BackupResetCmd(FunctionalState NewState)
0003a0  491b              LDR      r1,|L1.1040|
;;;1238   {
;;;1239     /* Check the parameters */
;;;1240     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1241     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
0003a2  6008              STR      r0,[r1,#0]
;;;1242   }
0003a4  4770              BX       lr
;;;1243   
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;1249     */
;;;1250   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
0003a6  4911              LDR      r1,|L1.1004|
;;;1251   {
;;;1252     /* Check the parameters */
;;;1253     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1254     *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
0003a8  64c8              STR      r0,[r1,#0x4c]
;;;1255   }
0003aa  4770              BX       lr
;;;1256   
                          ENDP

                  RCC_MCOConfig PROC
;;;1281     */
;;;1282   void RCC_MCOConfig(uint8_t RCC_MCO)
0003ac  490c              LDR      r1,|L1.992|
;;;1283   {
;;;1284     /* Check the parameters */
;;;1285     assert_param(IS_RCC_MCO(RCC_MCO));
;;;1286   
;;;1287     /* Perform Byte access to MCO bits to select the MCO source */
;;;1288     *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
0003ae  71c8              STRB     r0,[r1,#7]
;;;1289   }
0003b0  4770              BX       lr
;;;1290   
                          ENDP

                  RCC_ClearFlag PROC
;;;1370     */
;;;1371   void RCC_ClearFlag(void)
0003b2  480b              LDR      r0,|L1.992|
;;;1372   {
;;;1373     /* Set RMVF bit to clear the reset flags */
;;;1374     RCC->CSR |= CSR_RMVF_Set;
0003b4  6a40              LDR      r0,[r0,#0x24]
0003b6  f0407080          ORR      r0,r0,#0x1000000
0003ba  4909              LDR      r1,|L1.992|
0003bc  6248              STR      r0,[r1,#0x24]
;;;1375   }
0003be  4770              BX       lr
;;;1376   
                          ENDP

                  RCC_GetITStatus PROC
;;;1401     */
;;;1402   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
0003c0  4601              MOV      r1,r0
;;;1403   {
;;;1404     ITStatus bitstatus = RESET;
0003c2  f04f0000          MOV      r0,#0
;;;1405     /* Check the parameters */
;;;1406     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1407   
;;;1408     /* Check the status of the specified RCC interrupt */
;;;1409     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
0003c6  4a06              LDR      r2,|L1.992|
0003c8  6892              LDR      r2,[r2,#8]
0003ca  420a              TST      r2,r1
0003cc  d002              BEQ      |L1.980|
;;;1410     {
;;;1411       bitstatus = SET;
0003ce  f04f0001          MOV      r0,#1
0003d2  e001              B        |L1.984|
                  |L1.980|
;;;1412     }
;;;1413     else
;;;1414     {
;;;1415       bitstatus = RESET;
0003d4  f04f0000          MOV      r0,#0
                  |L1.984|
;;;1416     }
;;;1417   
;;;1418     /* Return the RCC_IT status */
;;;1419     return  bitstatus;
;;;1420   }
0003d8  4770              BX       lr
;;;1421   
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1447     */
;;;1448   void RCC_ClearITPendingBit(uint8_t RCC_IT)
0003da  4901              LDR      r1,|L1.992|
;;;1449   {
;;;1450     /* Check the parameters */
;;;1451     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1452   
;;;1453     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1454        pending bits */
;;;1455     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
0003dc  7288              STRB     r0,[r1,#0xa]
;;;1456   }
0003de  4770              BX       lr
                  |L1.992|
                          DCD      0x40021000
                  |L1.996|
                          DCD      0xf8ff0000
                  |L1.1000|
                          DCD      0xfef6ffff
                  |L1.1004|
                          DCD      0x42420000
                  |L1.1008|
                          DCD      0x424200d8
                  |L1.1012|
                          DCD      0x40021020
                  |L1.1016|
                          DCD      0x42420480
                  |L1.1020|
                          DCD      0x4242043c
                  |L1.1024|
                          DCD      0x007a1200
                  |L1.1028|
                          DCD      0x003d0900
                  |L1.1032|
                          DCD      APBAHBPrescTable
                  |L1.1036|
                          DCD      ADCPrescTable
                  |L1.1040|
                          DCD      0x42420440
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09
                  ADCPrescTable
000010  02040608          DCB      0x02,0x04,0x06,0x08
