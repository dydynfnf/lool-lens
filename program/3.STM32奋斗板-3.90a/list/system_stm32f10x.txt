; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\system_stm32f10x.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\system_stm32f10x.crf CM3\system_stm32f10x.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;986      */
;;;987    static void SetSysClockTo72(void)
000000  f04f0100          MOV      r1,#0
;;;988    {
;;;989      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000004  4608              MOV      r0,r1
;;;990      
;;;991      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;992      /* Enable HSE */    
;;;993      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000006  4a6d              LDR      r2,|L1.444|
000008  6812              LDR      r2,[r2,#0]
00000a  f4423280          ORR      r2,r2,#0x10000
00000e  4b6b              LDR      r3,|L1.444|
000010  601a              STR      r2,[r3,#0]
;;;994     
;;;995      /* Wait till HSE is ready and if Time out is reached exit */
;;;996      do
000012  bf00              NOP      
                  |L1.20|
;;;997      {
;;;998        HSEStatus = RCC->CR & RCC_CR_HSERDY;
000014  4a69              LDR      r2,|L1.444|
000016  6812              LDR      r2,[r2,#0]
000018  f4023000          AND      r0,r2,#0x20000
;;;999        StartUpCounter++;  
00001c  f1010101          ADD      r1,r1,#1
;;;1000     } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
000020  b910              CBNZ     r0,|L1.40|
000022  f5b16fa0          CMP      r1,#0x500
000026  d1f5              BNE      |L1.20|
                  |L1.40|
;;;1001   
;;;1002     if ((RCC->CR & RCC_CR_HSERDY) != RESET)
000028  4a64              LDR      r2,|L1.444|
00002a  6812              LDR      r2,[r2,#0]
00002c  f4123f00          TST      r2,#0x20000
000030  d002              BEQ      |L1.56|
;;;1003     {
;;;1004       HSEStatus = (uint32_t)0x01;
000032  f04f0001          MOV      r0,#1
000036  e001              B        |L1.60|
                  |L1.56|
;;;1005     }
;;;1006     else
;;;1007     {
;;;1008       HSEStatus = (uint32_t)0x00;
000038  f04f0000          MOV      r0,#0
                  |L1.60|
;;;1009     }  
;;;1010   
;;;1011     if (HSEStatus == (uint32_t)0x01)
00003c  2801              CMP      r0,#1
00003e  d142              BNE      |L1.198|
;;;1012     {
;;;1013       /* Enable Prefetch Buffer */
;;;1014       FLASH->ACR |= FLASH_ACR_PRFTBE;
000040  4a5f              LDR      r2,|L1.448|
000042  6812              LDR      r2,[r2,#0]
000044  f0420210          ORR      r2,r2,#0x10
000048  4b5d              LDR      r3,|L1.448|
00004a  601a              STR      r2,[r3,#0]
;;;1015   
;;;1016       /* Flash 2 wait state */
;;;1017       FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
00004c  461a              MOV      r2,r3
00004e  6812              LDR      r2,[r2,#0]
000050  f0220203          BIC      r2,r2,#3
000054  601a              STR      r2,[r3,#0]
;;;1018       FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000056  461a              MOV      r2,r3
000058  6812              LDR      r2,[r2,#0]
00005a  f0420202          ORR      r2,r2,#2
00005e  601a              STR      r2,[r3,#0]
;;;1019   
;;;1020    
;;;1021       /* HCLK = SYSCLK */
;;;1022       RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
000060  4a56              LDR      r2,|L1.444|
000062  6852              LDR      r2,[r2,#4]
000064  4b55              LDR      r3,|L1.444|
000066  605a              STR      r2,[r3,#4]
;;;1023         
;;;1024       /* PCLK2 = HCLK */
;;;1025       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000068  461a              MOV      r2,r3
00006a  6852              LDR      r2,[r2,#4]
00006c  605a              STR      r2,[r3,#4]
;;;1026       
;;;1027       /* PCLK1 = HCLK */
;;;1028       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
00006e  461a              MOV      r2,r3
000070  6852              LDR      r2,[r2,#4]
000072  f4426280          ORR      r2,r2,#0x400
000076  605a              STR      r2,[r3,#4]
;;;1029   
;;;1030   #ifdef STM32F10X_CL
;;;1031       /* Configure PLLs ------------------------------------------------------*/
;;;1032       /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;1033       /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;1034           
;;;1035       RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;1036                                 RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;1037       RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;1038                                RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;1039     
;;;1040       /* Enable PLL2 */
;;;1041       RCC->CR |= RCC_CR_PLL2ON;
;;;1042       /* Wait till PLL2 is ready */
;;;1043       while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;1044       {
;;;1045       }
;;;1046       
;;;1047      
;;;1048       /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;1049       RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;1050       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;1051                               RCC_CFGR_PLLMULL9); 
;;;1052   #else    
;;;1053       /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;1054       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000078  461a              MOV      r2,r3
00007a  6852              LDR      r2,[r2,#4]
00007c  f422127c          BIC      r2,r2,#0x3f0000
000080  605a              STR      r2,[r3,#4]
;;;1055                                           RCC_CFGR_PLLMULL));
;;;1056       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
000082  461a              MOV      r2,r3
000084  6852              LDR      r2,[r2,#4]
000086  f44212e8          ORR      r2,r2,#0x1d0000
00008a  605a              STR      r2,[r3,#4]
;;;1057   #endif /* STM32F10X_CL */
;;;1058   
;;;1059       /* Enable PLL */
;;;1060       RCC->CR |= RCC_CR_PLLON;
00008c  461a              MOV      r2,r3
00008e  6812              LDR      r2,[r2,#0]
000090  f0427280          ORR      r2,r2,#0x1000000
000094  601a              STR      r2,[r3,#0]
;;;1061   
;;;1062       /* Wait till PLL is ready */
;;;1063       while((RCC->CR & RCC_CR_PLLRDY) == 0)
000096  bf00              NOP      
                  |L1.152|
000098  4a48              LDR      r2,|L1.444|
00009a  6812              LDR      r2,[r2,#0]
00009c  f0127f00          TST      r2,#0x2000000
0000a0  d0fa              BEQ      |L1.152|
;;;1064       {
;;;1065       }
;;;1066       
;;;1067       /* Select PLL as system clock source */
;;;1068       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
0000a2  4a46              LDR      r2,|L1.444|
0000a4  6852              LDR      r2,[r2,#4]
0000a6  f0220203          BIC      r2,r2,#3
0000aa  4b44              LDR      r3,|L1.444|
0000ac  605a              STR      r2,[r3,#4]
;;;1069       RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
0000ae  461a              MOV      r2,r3
0000b0  6852              LDR      r2,[r2,#4]
0000b2  f0420202          ORR      r2,r2,#2
0000b6  605a              STR      r2,[r3,#4]
;;;1070   
;;;1071       /* Wait till PLL is used as system clock source */
;;;1072       while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
0000b8  bf00              NOP      
                  |L1.186|
0000ba  4a40              LDR      r2,|L1.444|
0000bc  6852              LDR      r2,[r2,#4]
0000be  f002020c          AND      r2,r2,#0xc
0000c2  2a08              CMP      r2,#8
0000c4  d1f9              BNE      |L1.186|
                  |L1.198|
;;;1073       {
;;;1074       }
;;;1075     }
;;;1076     else
;;;1077     { /* If HSE fails to start-up, the application will have wrong clock 
;;;1078            configuration. User can add here some code to deal with this error */
;;;1079     }
;;;1080   }
0000c6  4770              BX       lr
;;;1081   #endif
                          ENDP

                  SetSysClock PROC
;;;418      */
;;;419    static void SetSysClock(void)
0000c8  b510              PUSH     {r4,lr}
;;;420    {
;;;421    #ifdef SYSCLK_FREQ_HSE
;;;422      SetSysClockToHSE();
;;;423    #elif defined SYSCLK_FREQ_24MHz
;;;424      SetSysClockTo24();
;;;425    #elif defined SYSCLK_FREQ_36MHz
;;;426      SetSysClockTo36();
;;;427    #elif defined SYSCLK_FREQ_48MHz
;;;428      SetSysClockTo48();
;;;429    #elif defined SYSCLK_FREQ_56MHz
;;;430      SetSysClockTo56();  
;;;431    #elif defined SYSCLK_FREQ_72MHz
;;;432      SetSysClockTo72();
0000ca  f7fffffe          BL       SetSysClockTo72
;;;433    #endif
;;;434     
;;;435     /* If none of the define above is enabled, the HSI is used as System clock
;;;436        source (default after reset) */ 
;;;437    }
0000ce  bd10              POP      {r4,pc}
;;;438    
                          ENDP

                  SystemInit PROC
;;;211      */
;;;212    void SystemInit (void)
0000d0  b510              PUSH     {r4,lr}
;;;213    {
;;;214      /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;215      /* Set HSION bit */
;;;216      RCC->CR |= (uint32_t)0x00000001;
0000d2  483a              LDR      r0,|L1.444|
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f0400001          ORR      r0,r0,#1
0000da  4938              LDR      r1,|L1.444|
0000dc  6008              STR      r0,[r1,#0]
;;;217    
;;;218      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;219    #ifndef STM32F10X_CL
;;;220      RCC->CFGR &= (uint32_t)0xF8FF0000;
0000de  4608              MOV      r0,r1
0000e0  6840              LDR      r0,[r0,#4]
0000e2  4938              LDR      r1,|L1.452|
0000e4  ea000001          AND      r0,r0,r1
0000e8  4934              LDR      r1,|L1.444|
0000ea  6048              STR      r0,[r1,#4]
;;;221    #else
;;;222      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;223    #endif /* STM32F10X_CL */   
;;;224      
;;;225      /* Reset HSEON, CSSON and PLLON bits */
;;;226      RCC->CR &= (uint32_t)0xFEF6FFFF;
0000ec  4608              MOV      r0,r1
0000ee  6800              LDR      r0,[r0,#0]
0000f0  4935              LDR      r1,|L1.456|
0000f2  ea000001          AND      r0,r0,r1
0000f6  4931              LDR      r1,|L1.444|
0000f8  6008              STR      r0,[r1,#0]
;;;227    
;;;228      /* Reset HSEBYP bit */
;;;229      RCC->CR &= (uint32_t)0xFFFBFFFF;
0000fa  4608              MOV      r0,r1
0000fc  6800              LDR      r0,[r0,#0]
0000fe  f4202080          BIC      r0,r0,#0x40000
000102  6008              STR      r0,[r1,#0]
;;;230    
;;;231      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;232      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000104  4608              MOV      r0,r1
000106  6840              LDR      r0,[r0,#4]
000108  f42000fe          BIC      r0,r0,#0x7f0000
00010c  6048              STR      r0,[r1,#4]
;;;233    
;;;234    #ifdef STM32F10X_CL
;;;235      /* Reset PLL2ON and PLL3ON bits */
;;;236      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;237    
;;;238      /* Disable all interrupts and clear pending bits  */
;;;239      RCC->CIR = 0x00FF0000;
;;;240    
;;;241      /* Reset CFGR2 register */
;;;242      RCC->CFGR2 = 0x00000000;
;;;243    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;244      /* Disable all interrupts and clear pending bits  */
;;;245      RCC->CIR = 0x009F0000;
;;;246    
;;;247      /* Reset CFGR2 register */
;;;248      RCC->CFGR2 = 0x00000000;      
;;;249    #else
;;;250      /* Disable all interrupts and clear pending bits  */
;;;251      RCC->CIR = 0x009F0000;
00010e  f44f001f          MOV      r0,#0x9f0000
000112  6088              STR      r0,[r1,#8]
;;;252    #endif /* STM32F10X_CL */
;;;253        
;;;254    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;255      #ifdef DATA_IN_ExtSRAM
;;;256        SystemInit_ExtMemCtl(); 
;;;257      #endif /* DATA_IN_ExtSRAM */
;;;258    #endif 
;;;259    
;;;260      /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;261      /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;262      SetSysClock();
000114  f7fffffe          BL       SetSysClock
;;;263    
;;;264    #ifdef VECT_TAB_SRAM
;;;265      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;266    #else
;;;267      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
000118  f04f6000          MOV      r0,#0x8000000
00011c  492b              LDR      r1,|L1.460|
00011e  6008              STR      r0,[r1,#0]
;;;268    #endif 
;;;269    }
000120  bd10              POP      {r4,pc}
;;;270    
                          ENDP

                  SystemCoreClockUpdate PROC
;;;305      */
;;;306    void SystemCoreClockUpdate (void)
000122  b510              PUSH     {r4,lr}
;;;307    {
;;;308      uint32_t tmp = 0, pllmull = 0, pllsource = 0;
000124  f04f0100          MOV      r1,#0
000128  4608              MOV      r0,r1
00012a  4602              MOV      r2,r0
;;;309    
;;;310    #ifdef  STM32F10X_CL
;;;311      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;312    #endif /* STM32F10X_CL */
;;;313    
;;;314    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;315      uint32_t prediv1factor = 0;
;;;316    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;317        
;;;318      /* Get SYSCLK source -------------------------------------------------------*/
;;;319      tmp = RCC->CFGR & RCC_CFGR_SWS;
00012c  4b23              LDR      r3,|L1.444|
00012e  685b              LDR      r3,[r3,#4]
000130  f003010c          AND      r1,r3,#0xc
;;;320      
;;;321      switch (tmp)
000134  b121              CBZ      r1,|L1.320|
000136  2904              CMP      r1,#4
000138  d006              BEQ      |L1.328|
00013a  2908              CMP      r1,#8
00013c  d12c              BNE      |L1.408|
00013e  e007              B        |L1.336|
                  |L1.320|
;;;322      {
;;;323        case 0x00:  /* HSI used as system clock */
;;;324          SystemCoreClock = HSI_VALUE;
000140  4b23              LDR      r3,|L1.464|
000142  4c24              LDR      r4,|L1.468|
000144  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;325          break;
000146  e02b              B        |L1.416|
                  |L1.328|
;;;326        case 0x04:  /* HSE used as system clock */
;;;327          SystemCoreClock = HSE_VALUE;
000148  4b21              LDR      r3,|L1.464|
00014a  4c22              LDR      r4,|L1.468|
00014c  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;328          break;
00014e  e027              B        |L1.416|
                  |L1.336|
;;;329        case 0x08:  /* PLL used as system clock */
;;;330    
;;;331          /* Get PLL clock source and multiplication factor ----------------------*/
;;;332          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
000150  4b1a              LDR      r3,|L1.444|
000152  685b              LDR      r3,[r3,#4]
000154  f4031070          AND      r0,r3,#0x3c0000
;;;333          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000158  4b18              LDR      r3,|L1.444|
00015a  685b              LDR      r3,[r3,#4]
00015c  f4033280          AND      r2,r3,#0x10000
;;;334          
;;;335    #ifndef STM32F10X_CL      
;;;336          pllmull = ( pllmull >> 18) + 2;
000160  f04f0302          MOV      r3,#2
000164  eb034090          ADD      r0,r3,r0,LSR #18
;;;337          
;;;338          if (pllsource == 0x00)
000168  b92a              CBNZ     r2,|L1.374|
;;;339          {
;;;340            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;341            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
00016a  4b1b              LDR      r3,|L1.472|
00016c  fb00f303          MUL      r3,r0,r3
000170  4c18              LDR      r4,|L1.468|
000172  6023              STR      r3,[r4,#0]  ; SystemCoreClock
000174  e00f              B        |L1.406|
                  |L1.374|
;;;342          }
;;;343          else
;;;344          {
;;;345     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;346           prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;347           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;348           SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
;;;349     #else
;;;350            /* HSE selected as PLL clock entry */
;;;351            if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
000176  4b11              LDR      r3,|L1.444|
000178  685b              LDR      r3,[r3,#4]
00017a  f4133f00          TST      r3,#0x20000
00017e  d005              BEQ      |L1.396|
;;;352            {/* HSE oscillator clock divided by 2 */
;;;353              SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
000180  4b15              LDR      r3,|L1.472|
000182  fb00f303          MUL      r3,r0,r3
000186  4c13              LDR      r4,|L1.468|
000188  6023              STR      r3,[r4,#0]  ; SystemCoreClock
00018a  e004              B        |L1.406|
                  |L1.396|
;;;354            }
;;;355            else
;;;356            {
;;;357              SystemCoreClock = HSE_VALUE * pllmull;
00018c  4b10              LDR      r3,|L1.464|
00018e  fb00f303          MUL      r3,r0,r3
000192  4c10              LDR      r4,|L1.468|
000194  6023              STR      r3,[r4,#0]  ; SystemCoreClock
                  |L1.406|
;;;358            }
;;;359     #endif
;;;360          }
;;;361    #else
;;;362          pllmull = pllmull >> 18;
;;;363          
;;;364          if (pllmull != 0x0D)
;;;365          {
;;;366             pllmull += 2;
;;;367          }
;;;368          else
;;;369          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;370            pllmull = 13 / 2; 
;;;371          }
;;;372                
;;;373          if (pllsource == 0x00)
;;;374          {
;;;375            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;376            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;377          }
;;;378          else
;;;379          {/* PREDIV1 selected as PLL clock entry */
;;;380            
;;;381            /* Get PREDIV1 clock source and division factor */
;;;382            prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;383            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;384            
;;;385            if (prediv1source == 0)
;;;386            { 
;;;387              /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;388              SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
;;;389            }
;;;390            else
;;;391            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;392              
;;;393              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;394              prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;395              pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;396              SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;397            }
;;;398          }
;;;399    #endif /* STM32F10X_CL */ 
;;;400          break;
000196  e003              B        |L1.416|
                  |L1.408|
;;;401    
;;;402        default:
;;;403          SystemCoreClock = HSI_VALUE;
000198  4b0d              LDR      r3,|L1.464|
00019a  4c0e              LDR      r4,|L1.468|
00019c  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;404          break;
00019e  bf00              NOP      
                  |L1.416|
0001a0  bf00              NOP                            ;325
;;;405      }
;;;406      
;;;407      /* Compute HCLK clock frequency ----------------*/
;;;408      /* Get HCLK prescaler */
;;;409      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
0001a2  4b06              LDR      r3,|L1.444|
0001a4  685b              LDR      r3,[r3,#4]
0001a6  f3c31303          UBFX     r3,r3,#4,#4
0001aa  4c0c              LDR      r4,|L1.476|
0001ac  5ce1              LDRB     r1,[r4,r3]
;;;410      /* HCLK clock frequency */
;;;411      SystemCoreClock >>= tmp;  
0001ae  4b09              LDR      r3,|L1.468|
0001b0  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
0001b2  fa23f301          LSR      r3,r3,r1
0001b6  4c07              LDR      r4,|L1.468|
0001b8  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;412    }
0001ba  bd10              POP      {r4,pc}
;;;413    
                          ENDP

                  |L1.444|
                          DCD      0x40021000
                  |L1.448|
                          DCD      0x40022000
                  |L1.452|
                          DCD      0xf8ff0000
                  |L1.456|
                          DCD      0xfef6ffff
                  |L1.460|
                          DCD      0xe000ed08
                  |L1.464|
                          DCD      0x007a1200
                  |L1.468|
                          DCD      SystemCoreClock
                  |L1.472|
                          DCD      0x003d0900
                  |L1.476|
                          DCD      AHBPrescTable

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x044aa200
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
