; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\wm.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\wm.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\wm.crf GUI\WM\WM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _CheckCriticalHandles PROC
;;;99     */
;;;100    static void _CheckCriticalHandles(WM_HWIN hWin) {
000000  4601              MOV      r1,r0
;;;101      WM_CRITICAL_HANDLE * pCH;
;;;102      for (pCH = WM__pFirstCriticalHandle; pCH; pCH = pCH->pNext) {
000002  4afe              LDR      r2,|L1.1020|
000004  6810              LDR      r0,[r2,#0]  ; WM__pFirstCriticalHandle
000006  e007              B        |L1.24|
                  |L1.8|
;;;103        if (pCH->hWin == hWin) {
000008  f9b02004          LDRSH    r2,[r0,#4]
00000c  428a              CMP      r2,r1
00000e  d102              BNE      |L1.22|
;;;104          pCH->hWin = 0;
000010  f04f0200          MOV      r2,#0
000014  8082              STRH     r2,[r0,#4]
                  |L1.22|
000016  6800              LDR      r0,[r0,#0]            ;102
                  |L1.24|
000018  2800              CMP      r0,#0                 ;102
00001a  d1f5              BNE      |L1.8|
;;;105        }
;;;106      }
;;;107    }
00001c  4770              BX       lr
;;;108    
                          ENDP

                  _DesktopHandle2Index PROC
;;;119    */
;;;120    static int _DesktopHandle2Index(WM_HWIN hDesktop) {
00001e  4601              MOV      r1,r0
;;;121    #if GUI_NUM_LAYERS > 1
;;;122      int i;
;;;123      for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;124        if (hDesktop == WM__ahDesktopWin[i]) {
;;;125          return i;
;;;126        }
;;;127      }
;;;128    #else
;;;129      if (hDesktop == WM__ahDesktopWin[0]) {
000020  48f7              LDR      r0,|L1.1024|
000022  f9b00000          LDRSH    r0,[r0,#0]  ; WM__ahDesktopWin
000026  4288              CMP      r0,r1
000028  d101              BNE      |L1.46|
;;;130        return 0;
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;131      }
;;;132    #endif
;;;133      return -1;
;;;134    }
00002c  4770              BX       lr
                  |L1.46|
00002e  f04f30ff          MOV      r0,#0xffffffff        ;133
000032  e7fb              B        |L1.44|
;;;135    
                          ENDP

                  WM__RectIsNZ PROC
;;;548    */
;;;549    int WM__RectIsNZ(const GUI_RECT* pr) {
000034  4601              MOV      r1,r0
;;;550      if (pr->x0 > pr->x1)
000036  f9b10000          LDRSH    r0,[r1,#0]
00003a  f9b12004          LDRSH    r2,[r1,#4]
00003e  4290              CMP      r0,r2
000040  dd01              BLE      |L1.70|
;;;551        return 0;
000042  2000              MOVS     r0,#0
                  |L1.68|
;;;552      if (pr->y0 > pr->y1)
;;;553        return 0;
;;;554      return 1;
;;;555    }
000044  4770              BX       lr
                  |L1.70|
000046  f9b10002          LDRSH    r0,[r1,#2]            ;552
00004a  f9b12006          LDRSH    r2,[r1,#6]            ;552
00004e  4290              CMP      r0,r2                 ;552
000050  dd01              BLE      |L1.86|
000052  2000              MOVS     r0,#0                 ;553
000054  e7f6              B        |L1.68|
                  |L1.86|
000056  2001              MOVS     r0,#1                 ;554
000058  e7f4              B        |L1.68|
;;;556    
                          ENDP

                  _Invalidate1Abs PROC
;;;141    */
;;;142    static void _Invalidate1Abs(WM_HWIN hWin, const GUI_RECT*pRect) {
00005a  e92d41fc          PUSH     {r2-r8,lr}
00005e  4607              MOV      r7,r0
000060  460d              MOV      r5,r1
;;;143      GUI_RECT r;
;;;144      WM_Obj* pWin;
;;;145      int Status;
;;;146      pWin = WM_H2P(hWin);
000062  4638              MOV      r0,r7
000064  f7fffffe          BL       GUI_ALLOC_h2p
000068  4604              MOV      r4,r0
;;;147      Status = pWin->Status;
00006a  8ba6              LDRH     r6,[r4,#0x1c]
;;;148      if ((Status & WM_SF_ISVIS) == 0) {
00006c  f0160f02          TST      r6,#2
000070  d101              BNE      |L1.118|
                  |L1.114|
;;;149        return;   /* Window is not visible... we are done */
;;;150      }
;;;151      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
;;;152        return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
;;;153      }
;;;154      if (WM__RectIsNZ(pRect) == 0) {
;;;155        return;   /* Nothing to do ... */
;;;156      }
;;;157      /* Calc affected area */
;;;158      GUI__IntersectRects(&r, pRect, &pWin->Rect);
;;;159      if (WM__RectIsNZ(&r)) {
;;;160        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;161          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;162        #endif
;;;163    
;;;164        if (pWin->Status & WM_SF_INVALID) {
;;;165          GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
;;;166        } else {
;;;167          pWin->InvalidRect = r;
;;;168          pWin->Status |= WM_SF_INVALID;
;;;169          WM__NumInvalidWindows++;
;;;170          /* Optional code: Call external routine to notify that drawing is required */
;;;171          #ifdef GUI_X_REDRAW
;;;172          {
;;;173            GUI_RECT r;
;;;174            r = pWin->Rect;
;;;175            if (WM__ClipAtParentBorders(&r,  hWin)) {
;;;176              GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
;;;177            }
;;;178          }
;;;179          #endif
;;;180          GUI_X_SIGNAL_EVENT();
;;;181        }
;;;182        /* Debug code: shows invalid areas */
;;;183        #if (WM_SUPPORT_DIAG)
;;;184          if (WM__pfShowInvalid) {
;;;185            (WM__pfShowInvalid)(hWin);
;;;186          }
;;;187        #endif
;;;188      }
;;;189    }
000072  e8bd81fc          POP      {r2-r8,pc}
                  |L1.118|
000076  f6400001          MOV      r0,#0x801             ;151
00007a  4030              ANDS     r0,r0,r6              ;151
00007c  2801              CMP      r0,#1                 ;151
00007e  d100              BNE      |L1.130|
000080  e7f7              B        |L1.114|
                  |L1.130|
000082  4628              MOV      r0,r5                 ;154
000084  f7fffffe          BL       WM__RectIsNZ
000088  b900              CBNZ     r0,|L1.140|
00008a  e7f2              B        |L1.114|
                  |L1.140|
00008c  4622              MOV      r2,r4                 ;158
00008e  4629              MOV      r1,r5                 ;158
000090  4668              MOV      r0,sp                 ;158
000092  f7fffffe          BL       GUI__IntersectRects
000096  4668              MOV      r0,sp                 ;159
000098  f7fffffe          BL       WM__RectIsNZ
00009c  b1c0              CBZ      r0,|L1.208|
00009e  8ba0              LDRH     r0,[r4,#0x1c]         ;164
0000a0  f0100f20          TST      r0,#0x20              ;164
0000a4  d006              BEQ      |L1.180|
0000a6  466a              MOV      r2,sp                 ;165
0000a8  f1040108          ADD      r1,r4,#8              ;165
0000ac  4608              MOV      r0,r1                 ;165
0000ae  f7fffffe          BL       GUI_MergeRect
0000b2  e00d              B        |L1.208|
                  |L1.180|
0000b4  9800              LDR      r0,[sp,#0]            ;167
0000b6  60a0              STR      r0,[r4,#8]            ;167
0000b8  9801              LDR      r0,[sp,#4]            ;167
0000ba  60e0              STR      r0,[r4,#0xc]          ;167
0000bc  8ba0              LDRH     r0,[r4,#0x1c]         ;168
0000be  f0400020          ORR      r0,r0,#0x20           ;168
0000c2  83a0              STRH     r0,[r4,#0x1c]         ;168
0000c4  48cf              LDR      r0,|L1.1028|
0000c6  8800              LDRH     r0,[r0,#0]            ;169  ; WM__NumInvalidWindows
0000c8  f1000001          ADD      r0,r0,#1              ;169
0000cc  49cd              LDR      r1,|L1.1028|
0000ce  8008              STRH     r0,[r1,#0]            ;169
                  |L1.208|
0000d0  bf00              NOP      
0000d2  e7ce              B        |L1.114|
;;;190    
                          ENDP

                  ResetNextDrawWin PROC
;;;210    */
;;;211    static void ResetNextDrawWin(void) {
0000d4  f04f0000          MOV      r0,#0
;;;212      NextDrawWin = WM_HWIN_NULL;
0000d8  49cb              LDR      r1,|L1.1032|
0000da  8008              STRH     r0,[r1,#0]
;;;213    }
0000dc  4770              BX       lr
;;;214    
                          ENDP

                  _GethDrawWin PROC
;;;223    */
;;;224    static WM_HWIN _GethDrawWin(void) {
0000de  49cb              LDR      r1,|L1.1036|
;;;225      WM_HWIN h;
;;;226      #if WM_SUPPORT_TRANSPARENCY
;;;227        if (WM__hATransWindow) {
0000e0  8809              LDRH     r1,[r1,#0]  ; WM__hATransWindow
0000e2  b119              CBZ      r1,|L1.236|
;;;228          h = WM__hATransWindow;
0000e4  49c9              LDR      r1,|L1.1036|
0000e6  f9b10000          LDRSH    r0,[r1,#0]  ; WM__hATransWindow
0000ea  e002              B        |L1.242|
                  |L1.236|
;;;229        } else
;;;230      #endif
;;;231      {
;;;232        h = GUI_Context.hAWin;
0000ec  49c8              LDR      r1,|L1.1040|
0000ee  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
                  |L1.242|
;;;233      }
;;;234      return h;
;;;235    }
0000f2  4770              BX       lr
;;;236    
                          ENDP

                  WM__Client2Screen PROC
;;;476    */
;;;477    void WM__Client2Screen(const WM_Obj* pWin, GUI_RECT *pRect) {
0000f4  b570              PUSH     {r4-r6,lr}
0000f6  4604              MOV      r4,r0
0000f8  460d              MOV      r5,r1
;;;478      GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
0000fa  f9b42002          LDRSH    r2,[r4,#2]
0000fe  f9b41000          LDRSH    r1,[r4,#0]
000102  4628              MOV      r0,r5
000104  f7fffffe          BL       GUI_MoveRect
;;;479    }
000108  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP

                  _SetClipRectUserIntersect PROC
;;;244    */
;;;245    static void _SetClipRectUserIntersect(const GUI_RECT* prSrc) {
00010a  b57c              PUSH     {r2-r6,lr}
00010c  4604              MOV      r4,r0
;;;246      if (GUI_Context.WM__pUserClipRect == NULL) {
00010e  48c0              LDR      r0,|L1.1040|
000110  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
000112  b918              CBNZ     r0,|L1.284|
;;;247        LCD_SetClipRectEx(prSrc);
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       LCD_SetClipRectEx
00011a  e016              B        |L1.330|
                  |L1.284|
;;;248      } else {
;;;249        GUI_RECT r;
;;;250        r = *GUI_Context.WM__pUserClipRect;             
00011c  48bc              LDR      r0,|L1.1040|
00011e  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
000120  6801              LDR      r1,[r0,#0]
000122  9100              STR      r1,[sp,#0]
000124  6840              LDR      r0,[r0,#4]
000126  9001              STR      r0,[sp,#4]
;;;251        WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
000128  f7fffffe          BL       _GethDrawWin
00012c  4606              MOV      r6,r0
00012e  f7fffffe          BL       GUI_ALLOC_h2p
000132  4605              MOV      r5,r0
000134  4669              MOV      r1,sp
000136  f7fffffe          BL       WM__Client2Screen
;;;252        /* Set intersection as clip rect */    
;;;253        GUI__IntersectRect(&r, prSrc);
00013a  4621              MOV      r1,r4
00013c  4668              MOV      r0,sp
00013e  f7fffffe          BL       GUI__IntersectRect
;;;254        LCD_SetClipRectEx(&r);
000142  4668              MOV      r0,sp
000144  f7fffffe          BL       LCD_SetClipRectEx
;;;255      }
000148  bf00              NOP      
                  |L1.330|
;;;256    }
00014a  bd7c              POP      {r2-r6,pc}
;;;257    
                          ENDP

                  WM__ClipAtParentBorders PROC
;;;287    */
;;;288    int WM__ClipAtParentBorders(GUI_RECT* pRect, WM_HWIN hWin) {
00014c  b570              PUSH     {r4-r6,lr}
00014e  4606              MOV      r6,r0
000150  460d              MOV      r5,r1
;;;289      WM_Obj* pWin;
;;;290    
;;;291      /* Iterate up the window hierarchy.
;;;292         If the window is invisible, we are done.
;;;293         Clip at parent boarders.
;;;294         We are done with iterating if hWin has no parent.
;;;295      */
;;;296      do {
000152  bf00              NOP      
                  |L1.340|
;;;297        pWin = WM_H2P(hWin);
000154  4628              MOV      r0,r5
000156  f7fffffe          BL       GUI_ALLOC_h2p
00015a  4604              MOV      r4,r0
;;;298        if ((pWin->Status & WM_SF_ISVIS) == 0) {
00015c  8ba0              LDRH     r0,[r4,#0x1c]
00015e  f0100f02          TST      r0,#2
000162  d101              BNE      |L1.360|
;;;299          return 0;                     /* Invisible */
000164  2000              MOVS     r0,#0
                  |L1.358|
;;;300        }
;;;301        GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
;;;302        if (pWin->hParent == 0) {
;;;303          break;   /* hWin is now the top level window which has no parent */
;;;304        }
;;;305        hWin = pWin->hParent;                    /* Go one level up (parent)*/
;;;306      } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
;;;307      
;;;308      /* Now check if the top level window is a desktop window. If it is not,
;;;309        then the window is not visible.
;;;310      */
;;;311      if (_DesktopHandle2Index(hWin) < 0) {
;;;312        return 0;           /* No desktop - (unattached) - Nothing to draw */
;;;313      }
;;;314      return 1;               /* Something may be visible */
;;;315    }
000166  bd70              POP      {r4-r6,pc}
                  |L1.360|
000168  4621              MOV      r1,r4                 ;301
00016a  4630              MOV      r0,r6                 ;301
00016c  f7fffffe          BL       GUI__IntersectRect
000170  8ae0              LDRH     r0,[r4,#0x16]         ;302
000172  b900              CBNZ     r0,|L1.374|
000174  e002              B        |L1.380|
                  |L1.374|
000176  f9b45016          LDRSH    r5,[r4,#0x16]         ;305
00017a  e7eb              B        |L1.340|
                  |L1.380|
00017c  bf00              NOP                            ;303
00017e  4628              MOV      r0,r5                 ;311
000180  f7fffffe          BL       _DesktopHandle2Index
000184  2800              CMP      r0,#0                 ;311
000186  da01              BGE      |L1.396|
000188  2000              MOVS     r0,#0                 ;312
00018a  e7ec              B        |L1.358|
                  |L1.396|
00018c  2001              MOVS     r0,#1                 ;314
00018e  e7ea              B        |L1.358|
;;;316    
                          ENDP

                  WM__ActivateClipRect PROC
;;;320    */
;;;321    void  WM__ActivateClipRect(void) {
000190  b51c              PUSH     {r2-r4,lr}
;;;322      if (WM_IsActive) {
000192  48a0              LDR      r0,|L1.1044|
000194  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000196  b118              CBZ      r0,|L1.416|
;;;323        _SetClipRectUserIntersect(&_ClipContext.CurRect);
000198  489f              LDR      r0,|L1.1048|
00019a  f7fffffe          BL       _SetClipRectUserIntersect
00019e  e016              B        |L1.462|
                  |L1.416|
;;;324      } else {    /* Window manager disabled, typically because meory device is active */
;;;325        GUI_RECT r;
;;;326        WM_Obj *pAWin;
;;;327        pAWin = WM_H2P(GUI_Context.hAWin);
0001a0  499b              LDR      r1,|L1.1040|
0001a2  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
0001a6  f7fffffe          BL       GUI_ALLOC_h2p
0001aa  4604              MOV      r4,r0
;;;328        r = pAWin->Rect;
0001ac  e9d40100          LDRD     r0,r1,[r4,#0]
0001b0  e9cd0100          STRD     r0,r1,[sp,#0]
;;;329        #if WM_SUPPORT_TRANSPARENCY
;;;330          if (WM__hATransWindow) {
0001b4  4895              LDR      r0,|L1.1036|
0001b6  8800              LDRH     r0,[r0,#0]  ; WM__hATransWindow
0001b8  b128              CBZ      r0,|L1.454|
;;;331            WM__ClipAtParentBorders(&r, WM__hATransWindow);
0001ba  4894              LDR      r0,|L1.1036|
0001bc  f9b01000          LDRSH    r1,[r0,#0]  ; WM__hATransWindow
0001c0  4668              MOV      r0,sp
0001c2  f7fffffe          BL       WM__ClipAtParentBorders
                  |L1.454|
;;;332          }
;;;333        #endif
;;;334        /* Take UserClipRect into account */
;;;335        _SetClipRectUserIntersect(&r);
0001c6  4668              MOV      r0,sp
0001c8  f7fffffe          BL       _SetClipRectUserIntersect
;;;336      }
0001cc  bf00              NOP      
                  |L1.462|
;;;337    }
0001ce  bd1c              POP      {r2-r4,pc}
;;;338    
                          ENDP

                  WM__InsertWindowIntoList PROC
;;;350    */
;;;351    void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
0001d0  e92d4ff8          PUSH     {r3-r11,lr}
0001d4  4606              MOV      r6,r0
0001d6  4688              MOV      r8,r1
;;;352      int OnTop;
;;;353      WM_HWIN hi;
;;;354      WM_Obj * pWin;
;;;355      WM_Obj * pParent;
;;;356      WM_Obj * pi;
;;;357    
;;;358      if (hParent) {
0001d8  f1b80f00          CMP      r8,#0
0001dc  d040              BEQ      |L1.608|
;;;359        pWin = WM_H2P(hWin);
0001de  4630              MOV      r0,r6
0001e0  f7fffffe          BL       GUI_ALLOC_h2p
0001e4  4604              MOV      r4,r0
;;;360        pWin->hNext = 0;
0001e6  f04f0000          MOV      r0,#0
0001ea  8360              STRH     r0,[r4,#0x1a]
;;;361        pWin->hParent = hParent;
0001ec  f8a48016          STRH     r8,[r4,#0x16]
;;;362        pParent = WM_H2P(hParent);
0001f0  4640              MOV      r0,r8
0001f2  f7fffffe          BL       GUI_ALLOC_h2p
0001f6  4607              MOV      r7,r0
;;;363        OnTop   = pWin->Status & WM_CF_STAYONTOP;
0001f8  8ba0              LDRH     r0,[r4,#0x1c]
0001fa  f0000b08          AND      r11,r0,#8
;;;364        hi = pParent->hFirstChild;
0001fe  f9b79018          LDRSH    r9,[r7,#0x18]
;;;365        /* Put it at beginning of the list if there is no child */
;;;366        if (hi == 0) {   /* No child yet ... Makes things easy ! */
000202  f1b90f00          CMP      r9,#0
000206  d102              BNE      |L1.526|
;;;367          pParent->hFirstChild = hWin;
000208  833e              STRH     r6,[r7,#0x18]
                  |L1.522|
;;;368          return;                         /* Early out ... We are done */
;;;369        }
;;;370        /* Put it at beginning of the list if first child is a TOP window and new one is not */
;;;371        pi = WM_H2P(hi);
;;;372        if (!OnTop) {
;;;373          if (pi->Status & WM_SF_STAYONTOP) {
;;;374            pWin->hNext = hi;
;;;375            pParent->hFirstChild = hWin;
;;;376            return;                         /* Early out ... We are done */
;;;377          }
;;;378        }
;;;379        /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
;;;380        do {
;;;381          WM_Obj* pNext;
;;;382          WM_HWIN hNext;
;;;383          if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
;;;384            pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
;;;385            break;
;;;386          }
;;;387          pNext = WM_H2P(hNext);
;;;388          if (!OnTop) {
;;;389            if (pNext->Status & WM_SF_STAYONTOP) {
;;;390              pi->hNext = hWin;
;;;391              pWin->hNext = hNext;
;;;392              break;
;;;393            }
;;;394          }
;;;395          pi = pNext;
;;;396        }  while (1);
;;;397        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;398          WM__NotifyVisChanged(hWin, &pWin->Rect);
;;;399        #endif
;;;400      }
;;;401    }
00020a  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.526|
00020e  4648              MOV      r0,r9                 ;371
000210  f7fffffe          BL       GUI_ALLOC_h2p
000214  4605              MOV      r5,r0                 ;371
000216  f1bb0f00          CMP      r11,#0                ;372
00021a  d107              BNE      |L1.556|
00021c  8ba8              LDRH     r0,[r5,#0x1c]         ;373
00021e  f0100f08          TST      r0,#8                 ;373
000222  d003              BEQ      |L1.556|
000224  f8a4901a          STRH     r9,[r4,#0x1a]         ;374
000228  833e              STRH     r6,[r7,#0x18]         ;375
00022a  e7ee              B        |L1.522|
                  |L1.556|
00022c  bf00              NOP                            ;380
                  |L1.558|
00022e  f9b5001a          LDRSH    r0,[r5,#0x1a]         ;383
000232  9000              STR      r0,[sp,#0]            ;383
000234  b908              CBNZ     r0,|L1.570|
000236  836e              STRH     r6,[r5,#0x1a]         ;384
000238  e011              B        |L1.606|
                  |L1.570|
00023a  9800              LDR      r0,[sp,#0]            ;387
00023c  f7fffffe          BL       GUI_ALLOC_h2p
000240  4682              MOV      r10,r0                ;387
000242  f1bb0f00          CMP      r11,#0                ;388
000246  d108              BNE      |L1.602|
000248  f8ba001c          LDRH     r0,[r10,#0x1c]        ;389
00024c  f0100f08          TST      r0,#8                 ;389
000250  d003              BEQ      |L1.602|
000252  836e              STRH     r6,[r5,#0x1a]         ;390
000254  9800              LDR      r0,[sp,#0]            ;391
000256  8360              STRH     r0,[r4,#0x1a]         ;391
000258  e001              B        |L1.606|
                  |L1.602|
00025a  4655              MOV      r5,r10                ;395
00025c  e7e7              B        |L1.558|
                  |L1.606|
00025e  bf00              NOP                            ;385
                  |L1.608|
000260  bf00              NOP      
000262  e7d2              B        |L1.522|
;;;402    
                          ENDP

                  WM__RemoveWindowFromList PROC
;;;406    */
;;;407    void WM__RemoveWindowFromList(WM_HWIN hWin) {
000264  e92d47f0          PUSH     {r4-r10,lr}
000268  4607              MOV      r7,r0
;;;408      WM_HWIN hi, hParent;
;;;409      WM_Obj * pWin, * pParent, * pi;
;;;410      
;;;411      pWin = WM_H2P(hWin);
00026a  4638              MOV      r0,r7
00026c  f7fffffe          BL       GUI_ALLOC_h2p
000270  4681              MOV      r9,r0
;;;412      hParent = pWin->hParent;
000272  f9b98016          LDRSH    r8,[r9,#0x16]
;;;413      if (hParent) {
000276  f1b80f00          CMP      r8,#0
00027a  d020              BEQ      |L1.702|
;;;414        pParent = WM_H2P(hParent);
00027c  4640              MOV      r0,r8
00027e  f7fffffe          BL       GUI_ALLOC_h2p
000282  4606              MOV      r6,r0
;;;415        hi = pParent->hFirstChild;
000284  f9b65018          LDRSH    r5,[r6,#0x18]
;;;416        if (hi == hWin) {
000288  42bd              CMP      r5,r7
00028a  d106              BNE      |L1.666|
;;;417          pi = WM_H2P(hi);
00028c  4628              MOV      r0,r5
00028e  f7fffffe          BL       GUI_ALLOC_h2p
000292  4604              MOV      r4,r0
;;;418          pParent->hFirstChild = pi->hNext;
000294  8b60              LDRH     r0,[r4,#0x1a]
000296  8330              STRH     r0,[r6,#0x18]
000298  e011              B        |L1.702|
                  |L1.666|
;;;419        } else {
;;;420          while (hi) {
00029a  e00d              B        |L1.696|
                  |L1.668|
;;;421            pi = WM_H2P(hi);
00029c  4628              MOV      r0,r5
00029e  f7fffffe          BL       GUI_ALLOC_h2p
0002a2  4604              MOV      r4,r0
;;;422            if (pi->hNext == hWin) {
0002a4  f9b4001a          LDRSH    r0,[r4,#0x1a]
0002a8  42b8              CMP      r0,r7
0002aa  d103              BNE      |L1.692|
;;;423              pi->hNext = pWin->hNext;
0002ac  f8b9001a          LDRH     r0,[r9,#0x1a]
0002b0  8360              STRH     r0,[r4,#0x1a]
;;;424              break;
0002b2  e003              B        |L1.700|
                  |L1.692|
;;;425            }
;;;426            hi = pi->hNext;
0002b4  f9b4501a          LDRSH    r5,[r4,#0x1a]
                  |L1.696|
0002b8  2d00              CMP      r5,#0                 ;420
0002ba  d1ef              BNE      |L1.668|
                  |L1.700|
0002bc  bf00              NOP                            ;424
                  |L1.702|
;;;427          }
;;;428        }
;;;429      }
;;;430    }
0002be  e8bd87f0          POP      {r4-r10,pc}
;;;431    
                          ENDP

                  WM_InvalidateArea PROC
;;;781    */
;;;782    void WM_InvalidateArea(const GUI_RECT* pRect) {
0002c2  b570              PUSH     {r4-r6,lr}
0002c4  4604              MOV      r4,r0
;;;783      WM_HWIN   hWin;
;;;784      WM_LOCK();
;;;785      /* Iterate over all windows */
;;;786      for (hWin = WM__FirstWin; hWin; hWin = WM_H2P(hWin)->hNextLin) {
0002c6  4855              LDR      r0,|L1.1052|
0002c8  f9b05000          LDRSH    r5,[r0,#0]  ; WM__FirstWin
0002cc  e008              B        |L1.736|
                  |L1.718|
;;;787        _Invalidate1Abs(hWin, pRect);
0002ce  4621              MOV      r1,r4
0002d0  4628              MOV      r0,r5
0002d2  f7fffffe          BL       _Invalidate1Abs
0002d6  4628              MOV      r0,r5                 ;786
0002d8  f7fffffe          BL       GUI_ALLOC_h2p
0002dc  f9b05014          LDRSH    r5,[r0,#0x14]         ;786
                  |L1.736|
0002e0  2d00              CMP      r5,#0                 ;786
0002e2  d1f4              BNE      |L1.718|
;;;788      }
;;;789      WM_UNLOCK();
;;;790    }
0002e4  bd70              POP      {r4-r6,pc}
;;;791    
                          ENDP

                  WM__DetachWindow PROC
;;;439    */
;;;440    void WM__DetachWindow(WM_HWIN hWin) {
0002e6  b570              PUSH     {r4-r6,lr}
0002e8  4605              MOV      r5,r0
;;;441      WM_Obj* pWin;
;;;442      WM_HWIN hParent;
;;;443      pWin = WM_H2P(hWin);
0002ea  4628              MOV      r0,r5
0002ec  f7fffffe          BL       GUI_ALLOC_h2p
0002f0  4604              MOV      r4,r0
;;;444      hParent = pWin->hParent;
0002f2  f9b46016          LDRSH    r6,[r4,#0x16]
;;;445      if (hParent) {
0002f6  b146              CBZ      r6,|L1.778|
;;;446        WM__RemoveWindowFromList(hWin);
0002f8  4628              MOV      r0,r5
0002fa  f7fffffe          BL       WM__RemoveWindowFromList
;;;447        /* Clear area used by this window */
;;;448        WM_InvalidateArea(&pWin->Rect);
0002fe  4620              MOV      r0,r4
000300  f7fffffe          BL       WM_InvalidateArea
;;;449        pWin->hParent = 0;
000304  f04f0000          MOV      r0,#0
000308  82e0              STRH     r0,[r4,#0x16]
                  |L1.778|
;;;450      }
;;;451    }
00030a  bd70              POP      {r4-r6,pc}
;;;452    
                          ENDP

                  WM_SelectWindow PROC
;;;958    */
;;;959    WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
00030c  b570              PUSH     {r4-r6,lr}
00030e  4604              MOV      r4,r0
;;;960      WM_HWIN hWinPrev;
;;;961      WM_Obj* pObj;
;;;962    
;;;963      WM_ASSERT_NOT_IN_PAINT();
;;;964      WM_LOCK();
;;;965      hWinPrev = GUI_Context.hAWin;
000310  483f              LDR      r0,|L1.1040|
000312  f9b0603c          LDRSH    r6,[r0,#0x3c]  ; GUI_Context
;;;966      if (hWin == 0) {
000316  b914              CBNZ     r4,|L1.798|
;;;967        hWin = WM__FirstWin;
000318  4840              LDR      r0,|L1.1052|
00031a  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
                  |L1.798|
;;;968      }
;;;969      /* Select new window */
;;;970      GUI_Context.hAWin = hWin;
00031e  483c              LDR      r0,|L1.1040|
000320  8784              STRH     r4,[r0,#0x3c]
;;;971      #if GUI_NUM_LAYERS > 1
;;;972      {
;;;973        WM_HWIN hTop;
;;;974        int LayerIndex;
;;;975        hTop = _GetTopLevelWindow(hWin);
;;;976        LayerIndex = _DesktopHandle2Index(hTop);
;;;977        if (LayerIndex >= 0) {
;;;978          GUI_SelectLayer(LayerIndex);
;;;979        }
;;;980      }
;;;981      #endif
;;;982      pObj = WM_H2P(hWin);
000322  4620              MOV      r0,r4
000324  f7fffffe          BL       GUI_ALLOC_h2p
000328  4605              MOV      r5,r0
;;;983      LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
00032a  f7fffffe          BL       LCD_SetClipRectMax
;;;984      GUI_Context.xOff = pObj->Rect.x0;
00032e  f9b50000          LDRSH    r0,[r5,#0]
000332  4937              LDR      r1,|L1.1040|
000334  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;985      GUI_Context.yOff = pObj->Rect.y0;
000336  f9b50002          LDRSH    r0,[r5,#2]
00033a  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;986      WM_UNLOCK();
;;;987      return hWinPrev;
00033c  4630              MOV      r0,r6
;;;988    }
00033e  bd70              POP      {r4-r6,pc}
;;;989    
                          ENDP

                  WM__RemoveFromLinList PROC
;;;509    */
;;;510    void WM__RemoveFromLinList(WM_HWIN hWin) {
000340  e92d41f0          PUSH     {r4-r8,lr}
000344  4606              MOV      r6,r0
;;;511      WM_Obj* piWin;
;;;512      WM_HWIN hiWin;
;;;513      WM_HWIN hNext;
;;;514      for (hiWin = WM__FirstWin; hiWin; ) {
000346  4835              LDR      r0,|L1.1052|
000348  f9b07000          LDRSH    r7,[r0,#0]  ; WM__FirstWin
00034c  e00e              B        |L1.876|
                  |L1.846|
;;;515        piWin = WM_H2P(hiWin);
00034e  4638              MOV      r0,r7
000350  f7fffffe          BL       GUI_ALLOC_h2p
000354  4604              MOV      r4,r0
;;;516        hNext = piWin->hNextLin;
000356  f9b45014          LDRSH    r5,[r4,#0x14]
;;;517        if (hNext == hWin) {
00035a  42b5              CMP      r5,r6
00035c  d105              BNE      |L1.874|
;;;518          piWin->hNextLin = WM_H2P(hWin)->hNextLin;
00035e  4630              MOV      r0,r6
000360  f7fffffe          BL       GUI_ALLOC_h2p
000364  8a80              LDRH     r0,[r0,#0x14]
000366  82a0              STRH     r0,[r4,#0x14]
;;;519          break;
000368  e002              B        |L1.880|
                  |L1.874|
;;;520        }
;;;521        hiWin = hNext;
00036a  462f              MOV      r7,r5
                  |L1.876|
00036c  2f00              CMP      r7,#0                 ;514
00036e  d1ee              BNE      |L1.846|
                  |L1.880|
000370  bf00              NOP                            ;519
;;;522      }
;;;523    }
000372  e8bd81f0          POP      {r4-r8,pc}
;;;524    
                          ENDP

                  WM_SendMessage PROC
;;;676    */
;;;677    void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000376  b570              PUSH     {r4-r6,lr}
000378  4604              MOV      r4,r0
00037a  460d              MOV      r5,r1
;;;678      if (hWin) {
00037c  b154              CBZ      r4,|L1.916|
;;;679        WM_Obj* pWin;
;;;680        WM_LOCK();
;;;681        pWin = WM_H2P(hWin);
00037e  4620              MOV      r0,r4
000380  f7fffffe          BL       GUI_ALLOC_h2p
000384  4606              MOV      r6,r0
;;;682        if (pWin->cb != NULL) {
000386  6930              LDR      r0,[r6,#0x10]
000388  b118              CBZ      r0,|L1.914|
;;;683          pMsg->hWin = hWin;
00038a  80ac              STRH     r4,[r5,#4]
;;;684          (*pWin->cb)(pMsg);
00038c  4628              MOV      r0,r5
00038e  6931              LDR      r1,[r6,#0x10]
000390  4788              BLX      r1
                  |L1.914|
;;;685        }
;;;686        WM_UNLOCK();
;;;687      }
000392  bf00              NOP      
                  |L1.916|
;;;688    }
000394  bd70              POP      {r4-r6,pc}
;;;689    
                          ENDP

                  WM__SendMsgNoData PROC
;;;693    */
;;;694    void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
000396  b53e              PUSH     {r1-r5,lr}
000398  4605              MOV      r5,r0
00039a  460c              MOV      r4,r1
;;;695      WM_MESSAGE Msg;
;;;696      Msg.hWin  = hWin;
00039c  f8ad5004          STRH     r5,[sp,#4]
;;;697      Msg.MsgId = MsgId;
0003a0  9400              STR      r4,[sp,#0]
;;;698      WM_SendMessage(hWin, &Msg);
0003a2  4669              MOV      r1,sp
0003a4  4628              MOV      r0,r5
0003a6  f7fffffe          BL       WM_SendMessage
;;;699    }
0003aa  bd3e              POP      {r1-r5,pc}
;;;700    
                          ENDP

                  WM__IsWindow PROC
;;;484    */
;;;485    int WM__IsWindow(WM_HWIN hWin) {
0003ac  b570              PUSH     {r4-r6,lr}
0003ae  4605              MOV      r5,r0
;;;486      WM_HWIN iWin;
;;;487      for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
0003b0  481a              LDR      r0,|L1.1052|
0003b2  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
0003b6  e008              B        |L1.970|
                  |L1.952|
;;;488        if (iWin == hWin) {
0003b8  42ac              CMP      r4,r5
0003ba  d101              BNE      |L1.960|
;;;489          return 1;
0003bc  2001              MOVS     r0,#1
                  |L1.958|
;;;490        }
;;;491      }
;;;492      return 0;
;;;493    }
0003be  bd70              POP      {r4-r6,pc}
                  |L1.960|
0003c0  4620              MOV      r0,r4                 ;487
0003c2  f7fffffe          BL       GUI_ALLOC_h2p
0003c6  f9b04014          LDRSH    r4,[r0,#0x14]         ;487
                  |L1.970|
0003ca  2c00              CMP      r4,#0                 ;487
0003cc  d1f4              BNE      |L1.952|
0003ce  2000              MOVS     r0,#0                 ;492
0003d0  e7f5              B        |L1.958|
;;;494    
                          ENDP

                  WM_DeleteWindow PROC
;;;899    */
;;;900    void WM_DeleteWindow (WM_HWIN hWin) {
0003d2  b570              PUSH     {r4-r6,lr}
0003d4  4604              MOV      r4,r0
;;;901      WM_Obj* pWin;
;;;902      if (!hWin) {
0003d6  b904              CBNZ     r4,|L1.986|
                  |L1.984|
;;;903        return;
;;;904      }
;;;905      WM_ASSERT_NOT_IN_PAINT();
;;;906      WM_LOCK();
;;;907      if (WM__IsWindow(hWin)) {
;;;908        pWin = WM_H2P(hWin);
;;;909        ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
;;;910      /* Make sure that focus is set to an existing window */
;;;911        if (WM__hWinFocus == hWin) {
;;;912          WM__hWinFocus = 0;
;;;913        }
;;;914        if (WM__hCapture == hWin) {
;;;915          WM__hCapture = 0;
;;;916        }
;;;917        /* check if critical handles are affected. If so, reset the window handle to 0 */
;;;918        _CheckCriticalHandles(hWin);
;;;919        /* Inform parent */
;;;920        WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
;;;921        /* Delete all children */
;;;922        _DeleteAllChildren(pWin->hFirstChild);
;;;923        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;924          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;925        #endif
;;;926        /* Send WM_DELETE message to window in order to inform window itself */
;;;927        WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
;;;928        WM__DetachWindow(hWin);
;;;929        /* Remove window from window stack */
;;;930        WM__RemoveFromLinList(hWin);
;;;931        /* Handle transparency counter if necessary */
;;;932        #if WM_SUPPORT_TRANSPARENCY
;;;933          if (pWin->Status & WM_SF_HASTRANS) {
;;;934            WM__TransWindowCnt--;
;;;935          }
;;;936        #endif
;;;937        /* Make sure window is no longer counted as invalid */
;;;938        if (pWin->Status & WM_SF_INVALID) {
;;;939          WM__NumInvalidWindows--;
;;;940        }
;;;941      /* Free window memory */
;;;942        WM__NumWindows--;
;;;943        GUI_ALLOC_Free(hWin);
;;;944      /* Select a valid window */
;;;945        WM_SelectWindow(WM__FirstWin);
;;;946      } else {
;;;947        GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
;;;948      }
;;;949      WM_UNLOCK();
;;;950    }
0003d8  bd70              POP      {r4-r6,pc}
                  |L1.986|
0003da  4620              MOV      r0,r4                 ;907
0003dc  f7fffffe          BL       WM__IsWindow
0003e0  2800              CMP      r0,#0                 ;907
0003e2  d063              BEQ      |L1.1196|
0003e4  4620              MOV      r0,r4                 ;908
0003e6  f7fffffe          BL       GUI_ALLOC_h2p
0003ea  4605              MOV      r5,r0                 ;908
0003ec  f7fffffe          BL       ResetNextDrawWin
0003f0  480b              LDR      r0,|L1.1056|
0003f2  f9b00000          LDRSH    r0,[r0,#0]            ;911  ; WM__hWinFocus
0003f6  42a0              CMP      r0,r4                 ;911
0003f8  d118              BNE      |L1.1068|
0003fa  e013              B        |L1.1060|
                  |L1.1020|
                          DCD      WM__pFirstCriticalHandle
                  |L1.1024|
                          DCD      WM__ahDesktopWin
                  |L1.1028|
                          DCD      WM__NumInvalidWindows
                  |L1.1032|
                          DCD      NextDrawWin
                  |L1.1036|
                          DCD      WM__hATransWindow
                  |L1.1040|
                          DCD      GUI_Context
                  |L1.1044|
                          DCD      WM_IsActive
                  |L1.1048|
                          DCD      _ClipContext+0x8
                  |L1.1052|
                          DCD      WM__FirstWin
                  |L1.1056|
                          DCD      WM__hWinFocus
                  |L1.1060|
000424  f04f0000          MOV      r0,#0                 ;912
000428  49fe              LDR      r1,|L1.2084|
00042a  8008              STRH     r0,[r1,#0]            ;912
                  |L1.1068|
00042c  48fe              LDR      r0,|L1.2088|
00042e  f9b00000          LDRSH    r0,[r0,#0]            ;914  ; WM__hCapture
000432  42a0              CMP      r0,r4                 ;914
000434  d103              BNE      |L1.1086|
000436  f04f0000          MOV      r0,#0                 ;915
00043a  49fb              LDR      r1,|L1.2088|
00043c  8008              STRH     r0,[r1,#0]            ;915
                  |L1.1086|
00043e  4620              MOV      r0,r4                 ;918
000440  f7fffffe          BL       _CheckCriticalHandles
000444  2107              MOVS     r1,#7                 ;920
000446  4620              MOV      r0,r4                 ;920
000448  f7fffffe          BL       WM_NotifyParent
00044c  f9b50018          LDRSH    r0,[r5,#0x18]         ;922
000450  f7fffffe          BL       _DeleteAllChildren
000454  210b              MOVS     r1,#0xb               ;927
000456  4620              MOV      r0,r4                 ;927
000458  f7fffffe          BL       WM__SendMsgNoData
00045c  4620              MOV      r0,r4                 ;928
00045e  f7fffffe          BL       WM__DetachWindow
000462  4620              MOV      r0,r4                 ;930
000464  f7fffffe          BL       WM__RemoveFromLinList
000468  8ba8              LDRH     r0,[r5,#0x1c]         ;933
00046a  f0100f01          TST      r0,#1                 ;933
00046e  d005              BEQ      |L1.1148|
000470  48ee              LDR      r0,|L1.2092|
000472  6800              LDR      r0,[r0,#0]            ;934  ; WM__TransWindowCnt
000474  f1a00001          SUB      r0,r0,#1              ;934
000478  49ec              LDR      r1,|L1.2092|
00047a  6008              STR      r0,[r1,#0]            ;934  ; WM__TransWindowCnt
                  |L1.1148|
00047c  8ba8              LDRH     r0,[r5,#0x1c]         ;938
00047e  f0100f20          TST      r0,#0x20              ;938
000482  d005              BEQ      |L1.1168|
000484  48ea              LDR      r0,|L1.2096|
000486  8800              LDRH     r0,[r0,#0]            ;939  ; WM__NumInvalidWindows
000488  f1a00001          SUB      r0,r0,#1              ;939
00048c  49e8              LDR      r1,|L1.2096|
00048e  8008              STRH     r0,[r1,#0]            ;939
                  |L1.1168|
000490  48e8              LDR      r0,|L1.2100|
000492  8800              LDRH     r0,[r0,#0]            ;942  ; WM__NumWindows
000494  f1a00001          SUB      r0,r0,#1              ;942
000498  49e6              LDR      r1,|L1.2100|
00049a  8008              STRH     r0,[r1,#0]            ;942
00049c  4620              MOV      r0,r4                 ;943
00049e  f7fffffe          BL       GUI_ALLOC_Free
0004a2  48e5              LDR      r0,|L1.2104|
0004a4  f9b00000          LDRSH    r0,[r0,#0]            ;945  ; WM__FirstWin
0004a8  f7fffffe          BL       WM_SelectWindow
                  |L1.1196|
0004ac  bf00              NOP      
0004ae  e793              B        |L1.984|
;;;951    
                          ENDP

                  _DeleteAllChildren PROC
;;;457    */
;;;458    static void _DeleteAllChildren(WM_HWIN hChild) {
0004b0  b570              PUSH     {r4-r6,lr}
0004b2  4604              MOV      r4,r0
;;;459      while (hChild) {
0004b4  e00a              B        |L1.1228|
                  |L1.1206|
;;;460        WM_Obj* pChild = WM_H2P(hChild);
0004b6  4620              MOV      r0,r4
0004b8  f7fffffe          BL       GUI_ALLOC_h2p
0004bc  4605              MOV      r5,r0
;;;461        WM_HWIN hNext = pChild->hNext;
0004be  f9b5601a          LDRSH    r6,[r5,#0x1a]
;;;462        WM_DeleteWindow(hChild);
0004c2  4620              MOV      r0,r4
0004c4  f7fffffe          BL       WM_DeleteWindow
;;;463        hChild = hNext;
0004c8  4634              MOV      r4,r6
;;;464      }
0004ca  bf00              NOP      
                  |L1.1228|
0004cc  2c00              CMP      r4,#0                 ;459
0004ce  d1f2              BNE      |L1.1206|
;;;465    }
0004d0  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP

                  WM__InvalidateAreaBelow PROC
;;;500    */
;;;501    void WM__InvalidateAreaBelow(const GUI_RECT* pRect, WM_HWIN StopWin) {
0004d2  b570              PUSH     {r4-r6,lr}
0004d4  4605              MOV      r5,r0
0004d6  460c              MOV      r4,r1
;;;502      GUI_USE_PARA(StopWin);
0004d8  bf00              NOP      
;;;503      WM_InvalidateArea(pRect);      /* Can be optimized to spare windows above */
0004da  4628              MOV      r0,r5
0004dc  f7fffffe          BL       WM_InvalidateArea
;;;504    }
0004e0  bd70              POP      {r4-r6,pc}
;;;505    
                          ENDP

                  _AddToLinList PROC
;;;528    */
;;;529    static void _AddToLinList(WM_HWIN hNew) {
0004e2  b570              PUSH     {r4-r6,lr}
0004e4  4604              MOV      r4,r0
;;;530      WM_Obj* pFirst;
;;;531      WM_Obj* pNew;
;;;532      if (WM__FirstWin) {
0004e6  48d4              LDR      r0,|L1.2104|
0004e8  8800              LDRH     r0,[r0,#0]  ; WM__FirstWin
0004ea  b168              CBZ      r0,|L1.1288|
;;;533        pFirst = WM_H2P(WM__FirstWin);
0004ec  48d2              LDR      r0,|L1.2104|
0004ee  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
0004f2  f7fffffe          BL       GUI_ALLOC_h2p
0004f6  4606              MOV      r6,r0
;;;534        pNew   = WM_H2P(hNew);
0004f8  4620              MOV      r0,r4
0004fa  f7fffffe          BL       GUI_ALLOC_h2p
0004fe  4605              MOV      r5,r0
;;;535        pNew->hNextLin = pFirst->hNextLin;
000500  8ab0              LDRH     r0,[r6,#0x14]
000502  82a8              STRH     r0,[r5,#0x14]
;;;536        pFirst->hNextLin = hNew;
000504  82b4              STRH     r4,[r6,#0x14]
000506  e001              B        |L1.1292|
                  |L1.1288|
;;;537      } else {
;;;538        WM__FirstWin = hNew;
000508  48cb              LDR      r0,|L1.2104|
00050a  8004              STRH     r4,[r0,#0]
                  |L1.1292|
;;;539      }
;;;540    }
00050c  bd70              POP      {r4-r6,pc}
;;;541    
                          ENDP

                  _Findy1 PROC
;;;561    */
;;;562    static void _Findy1(WM_HWIN iWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
00050e  e92d47fc          PUSH     {r2-r10,lr}
000512  4606              MOV      r6,r0
000514  460c              MOV      r4,r1
000516  4617              MOV      r7,r2
;;;563      WM_Obj* pWin;
;;;564      for (; iWin; iWin = pWin->hNext) { 
000518  e04e              B        |L1.1464|
                  |L1.1306|
;;;565        int Status = (pWin = WM_H2P(iWin))->Status;
00051a  4630              MOV      r0,r6
00051c  f7fffffe          BL       GUI_ALLOC_h2p
000520  4605              MOV      r5,r0
000522  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;566        /* Check if this window affects us at all */    
;;;567        if (Status & WM_SF_ISVIS) {
000526  f0180f02          TST      r8,#2
00052a  d043              BEQ      |L1.1460|
;;;568          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;569          if (pParentRect) {
00052c  b12f              CBZ      r7,|L1.1338|
;;;570            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
00052e  463a              MOV      r2,r7
000530  4629              MOV      r1,r5
000532  4668              MOV      r0,sp
000534  f7fffffe          BL       GUI__IntersectRects
000538  e003              B        |L1.1346|
                  |L1.1338|
;;;571          } else {
;;;572            rWinClipped = pWin->Rect;
00053a  e9d50100          LDRD     r0,r1,[r5,#0]
00053e  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1346|
;;;573          }
;;;574          /* Check if this window affects us at all */    
;;;575          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000542  4669              MOV      r1,sp
000544  4620              MOV      r0,r4
000546  f7fffffe          BL       GUI_RectsIntersect
00054a  b1f8              CBZ      r0,|L1.1420|
;;;576            if ((Status & WM_SF_HASTRANS) == 0) {
00054c  f0180f01          TST      r8,#1
000550  d11d              BNE      |L1.1422|
;;;577              if (pWin->Rect.y0 > pRect->y0) {
000552  f9b50002          LDRSH    r0,[r5,#2]
000556  f9b41002          LDRSH    r1,[r4,#2]
00055a  4288              CMP      r0,r1
00055c  dd0d              BLE      |L1.1402|
;;;578                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
00055e  f9bd0002          LDRSH    r0,[sp,#2]
000562  1e40              SUBS     r0,r0,#1
000564  f9b41006          LDRSH    r1,[r4,#6]
000568  4288              CMP      r0,r1
00056a  da22              BGE      |L1.1458|
00056c  f8bd0002          LDRH     r0,[sp,#2]
000570  f1a00001          SUB      r0,r0,#1
000574  b200              SXTH     r0,r0
000576  80e0              STRH     r0,[r4,#6]
000578  e01b              B        |L1.1458|
                  |L1.1402|
;;;579              } else {
;;;580                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
00057a  f9bd0006          LDRSH    r0,[sp,#6]
00057e  f9b41006          LDRSH    r1,[r4,#6]
000582  4288              CMP      r0,r1
000584  da15              BGE      |L1.1458|
000586  f8bd0006          LDRH     r0,[sp,#6]
00058a  80e0              STRH     r0,[r4,#6]
                  |L1.1420|
00058c  e011              B        |L1.1458|
                  |L1.1422|
;;;581              }
;;;582            } else {
;;;583              /* Check all children*/ 
;;;584              WM_HWIN hChild;
;;;585              WM_Obj* pChild;
;;;586              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00058e  f9b59018          LDRSH    r9,[r5,#0x18]
000592  e00a              B        |L1.1450|
                  |L1.1428|
;;;587                pChild = WM_H2P(hChild);
000594  4648              MOV      r0,r9
000596  f7fffffe          BL       GUI_ALLOC_h2p
00059a  4682              MOV      r10,r0
;;;588                _Findy1(hChild, pRect, &rWinClipped);
00059c  466a              MOV      r2,sp
00059e  4621              MOV      r1,r4
0005a0  4648              MOV      r0,r9
0005a2  f7fffffe          BL       _Findy1
0005a6  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;586
                  |L1.1450|
0005aa  f1b90f00          CMP      r9,#0                 ;586
0005ae  d1f1              BNE      |L1.1428|
;;;589              }
;;;590            }
0005b0  bf00              NOP      
                  |L1.1458|
;;;591          }
;;;592        }
0005b2  bf00              NOP      
                  |L1.1460|
0005b4  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;564
                  |L1.1464|
0005b8  2e00              CMP      r6,#0                 ;564
0005ba  d1ae              BNE      |L1.1306|
;;;593      }
;;;594    }
0005bc  e8bd87fc          POP      {r2-r10,pc}
;;;595    
                          ENDP

                  _Findx0 PROC
;;;599    */
;;;600    static int _Findx0(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
0005c0  e92d5ffc          PUSH     {r2-r12,lr}
0005c4  4606              MOV      r6,r0
0005c6  460d              MOV      r5,r1
0005c8  4617              MOV      r7,r2
;;;601      WM_Obj* pWin;
;;;602      int r = 0;
0005ca  f04f0b00          MOV      r11,#0
;;;603      for (; hWin; hWin = pWin->hNext) { 
0005ce  e03c              B        |L1.1610|
                  |L1.1488|
;;;604        int Status = (pWin = WM_H2P(hWin))->Status;
0005d0  4630              MOV      r0,r6
0005d2  f7fffffe          BL       GUI_ALLOC_h2p
0005d6  4604              MOV      r4,r0
0005d8  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;605        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
0005dc  f0180f02          TST      r8,#2
0005e0  d031              BEQ      |L1.1606|
;;;606          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;607          if (pParentRect) {
0005e2  b12f              CBZ      r7,|L1.1520|
;;;608            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
0005e4  463a              MOV      r2,r7
0005e6  4621              MOV      r1,r4
0005e8  4668              MOV      r0,sp
0005ea  f7fffffe          BL       GUI__IntersectRects
0005ee  e003              B        |L1.1528|
                  |L1.1520|
;;;609          } else {
;;;610            rWinClipped = pWin->Rect;
0005f0  e9d40100          LDRD     r0,r1,[r4,#0]
0005f4  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1528|
;;;611          }
;;;612          /* Check if this window affects us at all */    
;;;613          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
0005f8  4669              MOV      r1,sp
0005fa  4628              MOV      r0,r5
0005fc  f7fffffe          BL       GUI_RectsIntersect
000600  b300              CBZ      r0,|L1.1604|
;;;614            if ((Status & WM_SF_HASTRANS) == 0) {
000602  f0180f01          TST      r8,#1
000606  d108              BNE      |L1.1562|
;;;615              pRect->x0 = rWinClipped.x1+1;
000608  f8bd0004          LDRH     r0,[sp,#4]
00060c  f1000001          ADD      r0,r0,#1
000610  b200              SXTH     r0,r0
000612  8028              STRH     r0,[r5,#0]
;;;616              r = 1;
000614  f04f0b01          MOV      r11,#1
000618  e014              B        |L1.1604|
                  |L1.1562|
;;;617            } else {
;;;618              /* Check all children */
;;;619              WM_HWIN hChild;
;;;620              WM_Obj* pChild;
;;;621              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00061a  f9b49018          LDRSH    r9,[r4,#0x18]
00061e  e00d              B        |L1.1596|
                  |L1.1568|
;;;622                pChild = WM_H2P(hChild);
000620  4648              MOV      r0,r9
000622  f7fffffe          BL       GUI_ALLOC_h2p
000626  4682              MOV      r10,r0
;;;623                if (_Findx0(hChild, pRect, &rWinClipped)) {
000628  466a              MOV      r2,sp
00062a  4629              MOV      r1,r5
00062c  4648              MOV      r0,r9
00062e  f7fffffe          BL       _Findx0
000632  b108              CBZ      r0,|L1.1592|
;;;624                  r = 1;
000634  f04f0b01          MOV      r11,#1
                  |L1.1592|
000638  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;621
                  |L1.1596|
00063c  f1b90f00          CMP      r9,#0                 ;621
000640  d1ee              BNE      |L1.1568|
;;;625                }
;;;626              }
;;;627            }
000642  bf00              NOP      
                  |L1.1604|
;;;628          }
;;;629        }
000644  bf00              NOP      
                  |L1.1606|
000646  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;603
                  |L1.1610|
00064a  2e00              CMP      r6,#0                 ;603
00064c  d1c0              BNE      |L1.1488|
;;;630      }
;;;631      return r;
00064e  4658              MOV      r0,r11
;;;632    }
000650  e8bd9ffc          POP      {r2-r12,pc}
;;;633    
                          ENDP

                  _Findx1 PROC
;;;637    */
;;;638    static void _Findx1(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000654  e92d47fc          PUSH     {r2-r10,lr}
000658  4606              MOV      r6,r0
00065a  460d              MOV      r5,r1
00065c  4617              MOV      r7,r2
;;;639      WM_Obj* pWin;
;;;640      for (; hWin; hWin = pWin->hNext) { 
00065e  e037              B        |L1.1744|
                  |L1.1632|
;;;641        int Status = (pWin = WM_H2P(hWin))->Status;
000660  4630              MOV      r0,r6
000662  f7fffffe          BL       GUI_ALLOC_h2p
000666  4604              MOV      r4,r0
000668  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;642        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
00066c  f0180f02          TST      r8,#2
000670  d02c              BEQ      |L1.1740|
;;;643          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;644          if (pParentRect) {
000672  b12f              CBZ      r7,|L1.1664|
;;;645            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
000674  463a              MOV      r2,r7
000676  4621              MOV      r1,r4
000678  4668              MOV      r0,sp
00067a  f7fffffe          BL       GUI__IntersectRects
00067e  e003              B        |L1.1672|
                  |L1.1664|
;;;646          } else {
;;;647            rWinClipped = pWin->Rect;
000680  e9d40100          LDRD     r0,r1,[r4,#0]
000684  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1672|
;;;648          }
;;;649          /* Check if this window affects us at all */    
;;;650          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000688  4669              MOV      r1,sp
00068a  4628              MOV      r0,r5
00068c  f7fffffe          BL       GUI_RectsIntersect
000690  b1d8              CBZ      r0,|L1.1738|
;;;651            if ((Status & WM_SF_HASTRANS) == 0) {
000692  f0180f01          TST      r8,#1
000696  d106              BNE      |L1.1702|
;;;652              pRect->x1 = rWinClipped.x0-1;
000698  f8bd0000          LDRH     r0,[sp,#0]
00069c  f1a00001          SUB      r0,r0,#1
0006a0  b200              SXTH     r0,r0
0006a2  80a8              STRH     r0,[r5,#4]
0006a4  e011              B        |L1.1738|
                  |L1.1702|
;;;653            } else {
;;;654              /* Check all children */
;;;655              WM_HWIN hChild;
;;;656              WM_Obj* pChild;
;;;657              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
0006a6  f9b49018          LDRSH    r9,[r4,#0x18]
0006aa  e00a              B        |L1.1730|
                  |L1.1708|
;;;658                pChild = WM_H2P(hChild);
0006ac  4648              MOV      r0,r9
0006ae  f7fffffe          BL       GUI_ALLOC_h2p
0006b2  4682              MOV      r10,r0
;;;659                _Findx1(hChild, pRect, &rWinClipped);
0006b4  466a              MOV      r2,sp
0006b6  4629              MOV      r1,r5
0006b8  4648              MOV      r0,r9
0006ba  f7fffffe          BL       _Findx1
0006be  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;657
                  |L1.1730|
0006c2  f1b90f00          CMP      r9,#0                 ;657
0006c6  d1f1              BNE      |L1.1708|
;;;660              }
;;;661            }
0006c8  bf00              NOP      
                  |L1.1738|
;;;662          }
;;;663        }
0006ca  bf00              NOP      
                  |L1.1740|
0006cc  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;640
                  |L1.1744|
0006d0  2e00              CMP      r6,#0                 ;640
0006d2  d1c5              BNE      |L1.1632|
;;;664      }
;;;665    }
0006d4  e8bd87fc          POP      {r2-r10,pc}
;;;666    
                          ENDP

                  WM__GetClientRectWin PROC
;;;707    */
;;;708    void WM__GetClientRectWin(const WM_Obj* pWin, GUI_RECT* pRect) {
0006d8  f04f0200          MOV      r2,#0
;;;709      pRect->x0 = pRect->y0 = 0;
0006dc  804a              STRH     r2,[r1,#2]
0006de  800a              STRH     r2,[r1,#0]
;;;710      pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
0006e0  8882              LDRH     r2,[r0,#4]
0006e2  8803              LDRH     r3,[r0,#0]
0006e4  eba20203          SUB      r2,r2,r3
0006e8  b212              SXTH     r2,r2
0006ea  808a              STRH     r2,[r1,#4]
;;;711      pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
0006ec  88c2              LDRH     r2,[r0,#6]
0006ee  8843              LDRH     r3,[r0,#2]
0006f0  eba20203          SUB      r2,r2,r3
0006f4  b212              SXTH     r2,r2
0006f6  80ca              STRH     r2,[r1,#6]
;;;712    }
0006f8  4770              BX       lr
;;;713    
                          ENDP

                  WM__GetInvalidRectAbs PROC
;;;717    */
;;;718    static void WM__GetInvalidRectAbs(WM_Obj* pWin, GUI_RECT* pRect) {
0006fa  6882              LDR      r2,[r0,#8]
;;;719      *pRect = pWin->InvalidRect;
0006fc  600a              STR      r2,[r1,#0]
0006fe  68c2              LDR      r2,[r0,#0xc]
000700  604a              STR      r2,[r1,#4]
;;;720    }
000702  4770              BX       lr
;;;721    
                          ENDP

                  WM_InvalidateRect PROC
;;;735    */
;;;736    void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT*pRect) {
000704  e92d41ff          PUSH     {r0-r8,lr}
000708  4605              MOV      r5,r0
00070a  460e              MOV      r6,r1
;;;737      GUI_RECT r;
;;;738      WM_Obj* pWin;
;;;739      int Status;
;;;740      if (hWin) {
00070c  b33d              CBZ      r5,|L1.1886|
;;;741        WM_LOCK();
;;;742        pWin = WM_H2P(hWin);
00070e  4628              MOV      r0,r5
000710  f7fffffe          BL       GUI_ALLOC_h2p
000714  4604              MOV      r4,r0
;;;743        Status = pWin->Status;
000716  8ba7              LDRH     r7,[r4,#0x1c]
;;;744        if (Status & WM_SF_ISVIS) {
000718  f0170f02          TST      r7,#2
00071c  d024              BEQ      |L1.1896|
;;;745          r = pWin->Rect;
00071e  e9d40100          LDRD     r0,r1,[r4,#0]
000722  e9cd0102          STRD     r0,r1,[sp,#8]
;;;746          if (pRect) {
000726  b166              CBZ      r6,|L1.1858|
;;;747            GUI_RECT rPara;
;;;748            rPara = *pRect;
000728  6830              LDR      r0,[r6,#0]
00072a  9000              STR      r0,[sp,#0]
00072c  6870              LDR      r0,[r6,#4]
00072e  9001              STR      r0,[sp,#4]
;;;749            WM__Client2Screen(pWin, &rPara);
000730  4669              MOV      r1,sp
000732  4620              MOV      r0,r4
000734  f7fffffe          BL       WM__Client2Screen
;;;750            GUI__IntersectRect(&r, &rPara);
000738  4669              MOV      r1,sp
00073a  a802              ADD      r0,sp,#8
00073c  f7fffffe          BL       GUI__IntersectRect
;;;751          }
000740  bf00              NOP      
                  |L1.1858|
;;;752          if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
000742  4629              MOV      r1,r5
000744  a802              ADD      r0,sp,#8
000746  f7fffffe          BL       WM__ClipAtParentBorders
00074a  b140              CBZ      r0,|L1.1886|
;;;753            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
00074c  f6400001          MOV      r0,#0x801
000750  4038              ANDS     r0,r0,r7
000752  2801              CMP      r0,#1
000754  d104              BNE      |L1.1888|
;;;754              WM__InvalidateAreaBelow(&r, hWin);        /* Can be optimized to spare windows above */
000756  4629              MOV      r1,r5
000758  a802              ADD      r0,sp,#8
00075a  f7fffffe          BL       WM__InvalidateAreaBelow
                  |L1.1886|
00075e  e003              B        |L1.1896|
                  |L1.1888|
;;;755            } else {
;;;756              _Invalidate1Abs(hWin, &r);
000760  a902              ADD      r1,sp,#8
000762  4628              MOV      r0,r5
000764  f7fffffe          BL       _Invalidate1Abs
                  |L1.1896|
;;;757            }
;;;758          }
;;;759        }
;;;760        WM_UNLOCK();
;;;761      }
;;;762    }
000768  e8bd81ff          POP      {r0-r8,pc}
;;;763    
                          ENDP

                  WM_InvalidateWindow PROC
;;;769    */
;;;770    void WM_InvalidateWindow(WM_HWIN hWin) {
00076c  b510              PUSH     {r4,lr}
00076e  4604              MOV      r4,r0
;;;771      WM_InvalidateRect(hWin, NULL);
000770  f04f0100          MOV      r1,#0
000774  4620              MOV      r0,r4
000776  f7fffffe          BL       WM_InvalidateRect
;;;772    }
00077a  bd10              POP      {r4,pc}
;;;773    
                          ENDP

                  WM_CreateWindowAsChild PROC
;;;801    */
;;;802    WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
00077c  e92d4ff8          PUSH     {r3-r11,lr}
;;;803                                   ,WM_HWIN hParent, U16 Style, WM_CALLBACK* cb
;;;804                                   ,int NumExtraBytes) {
000780  4680              MOV      r8,r0
000782  4689              MOV      r9,r1
000784  4692              MOV      r10,r2
000786  469b              MOV      r11,r3
000788  e9dd750a          LDRD     r7,r5,[sp,#0x28]
;;;805      WM_Obj* pWin;
;;;806      WM_HWIN hWin;
;;;807      WM_ASSERT_NOT_IN_PAINT();
;;;808      WM_LOCK();
;;;809      Style |= WM__CreateFlags;
00078c  482b              LDR      r0,|L1.2108|
00078e  8800              LDRH     r0,[r0,#0]  ; WM__CreateFlags
000790  ea450500          ORR      r5,r5,r0
;;;810      /* Default parent is Desktop 0 */
;;;811      if (!hParent) {
000794  b92f              CBNZ     r7,|L1.1954|
;;;812        if (WM__NumWindows) {
000796  4827              LDR      r0,|L1.2100|
000798  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
00079a  b110              CBZ      r0,|L1.1954|
;;;813        #if GUI_NUM_LAYERS == 1
;;;814          hParent = WM__ahDesktopWin[0];
00079c  4828              LDR      r0,|L1.2112|
00079e  f9b07000          LDRSH    r7,[r0,#0]  ; WM__ahDesktopWin
                  |L1.1954|
;;;815        #else
;;;816          hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
;;;817        #endif
;;;818        }
;;;819      }
;;;820      if (hParent == WM_UNATTACHED) {
0007a2  1c78              ADDS     r0,r7,#1
0007a4  d100              BNE      |L1.1960|
;;;821        hParent = WM_HWIN_NULL;
0007a6  4607              MOV      r7,r0
                  |L1.1960|
;;;822      }  
;;;823      if (hParent) {
0007a8  b307              CBZ      r7,|L1.2028|
;;;824        WM_Obj* pParent = WM_H2P(hParent);
0007aa  4638              MOV      r0,r7
0007ac  f7fffffe          BL       GUI_ALLOC_h2p
0007b0  4606              MOV      r6,r0
;;;825        x0 += pParent->Rect.x0;
0007b2  f9b60000          LDRSH    r0,[r6,#0]
0007b6  4480              ADD      r8,r8,r0
;;;826        y0 += pParent->Rect.y0;
0007b8  f9b60002          LDRSH    r0,[r6,#2]
0007bc  4481              ADD      r9,r9,r0
;;;827        if (width==0) {
0007be  f1ba0f00          CMP      r10,#0
0007c2  d107              BNE      |L1.2004|
;;;828          width = pParent->Rect.x1 - pParent->Rect.x0+1;
0007c4  f9b60004          LDRSH    r0,[r6,#4]
0007c8  f9b61000          LDRSH    r1,[r6,#0]
0007cc  eba00001          SUB      r0,r0,r1
0007d0  f1000a01          ADD      r10,r0,#1
                  |L1.2004|
;;;829        }
;;;830        if (height==0) {
0007d4  f1bb0f00          CMP      r11,#0
0007d8  d107              BNE      |L1.2026|
;;;831          height = pParent->Rect.y1 - pParent->Rect.y0+1;
0007da  f9b60006          LDRSH    r0,[r6,#6]
0007de  f9b61002          LDRSH    r1,[r6,#2]
0007e2  eba00001          SUB      r0,r0,r1
0007e6  f1000b01          ADD      r11,r0,#1
                  |L1.2026|
;;;832        }
;;;833      }
0007ea  bf00              NOP      
                  |L1.2028|
;;;834      if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
0007ec  980d              LDR      r0,[sp,#0x34]
0007ee  3020              ADDS     r0,r0,#0x20
0007f0  b200              SXTH     r0,r0
0007f2  f7fffffe          BL       GUI_ALLOC_AllocZero
0007f6  9000              STR      r0,[sp,#0]
0007f8  2800              CMP      r0,#0
0007fa  d061              BEQ      |L1.2240|
;;;835        GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
;;;836      } else {
;;;837        WM__NumWindows++;
0007fc  480d              LDR      r0,|L1.2100|
0007fe  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
000800  f1000001          ADD      r0,r0,#1
000804  490b              LDR      r1,|L1.2100|
000806  8008              STRH     r0,[r1,#0]
;;;838        pWin = WM_H2P(hWin);
000808  9800              LDR      r0,[sp,#0]
00080a  f7fffffe          BL       GUI_ALLOC_h2p
00080e  4604              MOV      r4,r0
;;;839        pWin->Rect.x0 = x0;
000810  fa0ff088          SXTH     r0,r8
000814  8020              STRH     r0,[r4,#0]
;;;840        pWin->Rect.y0 = y0;
000816  fa0ff089          SXTH     r0,r9
00081a  8060              STRH     r0,[r4,#2]
;;;841        pWin->Rect.x1 = x0 + width - 1;
00081c  eb08000a          ADD      r0,r8,r10
000820  e010              B        |L1.2116|
000822  0000              DCW      0x0000
                  |L1.2084|
                          DCD      WM__hWinFocus
                  |L1.2088|
                          DCD      WM__hCapture
                  |L1.2092|
                          DCD      WM__TransWindowCnt
                  |L1.2096|
                          DCD      WM__NumInvalidWindows
                  |L1.2100|
                          DCD      WM__NumWindows
                  |L1.2104|
                          DCD      WM__FirstWin
                  |L1.2108|
                          DCD      WM__CreateFlags
                  |L1.2112|
                          DCD      WM__ahDesktopWin
                  |L1.2116|
000844  f1a00001          SUB      r0,r0,#1
000848  b200              SXTH     r0,r0
00084a  80a0              STRH     r0,[r4,#4]
;;;842        pWin->Rect.y1 = y0 + height - 1;
00084c  eb09000b          ADD      r0,r9,r11
000850  f1a00001          SUB      r0,r0,#1
000854  b200              SXTH     r0,r0
000856  80e0              STRH     r0,[r4,#6]
;;;843        pWin->cb = cb;
000858  980c              LDR      r0,[sp,#0x30]
00085a  6120              STR      r0,[r4,#0x10]
;;;844        /* Copy the flags which can simply be accepted */
;;;845        pWin->Status |= (Style & (WM_CF_SHOW |
00085c  8ba0              LDRH     r0,[r4,#0x1c]
00085e  f643718f          MOV      r1,#0x3f8f
000862  ea050101          AND      r1,r5,r1
000866  ea400001          ORR      r0,r0,r1
00086a  83a0              STRH     r0,[r4,#0x1c]
;;;846                                  WM_SF_MEMDEV |
;;;847                                  WM_CF_MEMDEV_ON_REDRAW |
;;;848                                  WM_SF_STAYONTOP |
;;;849                                  WM_SF_CONST_OUTLINE |
;;;850                                  WM_SF_HASTRANS |
;;;851                                  WM_CF_ANCHOR_RIGHT |
;;;852                                  WM_CF_ANCHOR_BOTTOM |
;;;853                                  WM_CF_ANCHOR_LEFT |
;;;854                                  WM_CF_ANCHOR_TOP |
;;;855                                  WM_CF_LATE_CLIP));
;;;856        /* Add to linked lists */
;;;857        _AddToLinList(hWin);
00086c  9800              LDR      r0,[sp,#0]
00086e  f7fffffe          BL       _AddToLinList
;;;858        WM__InsertWindowIntoList(hWin, hParent);
000872  4639              MOV      r1,r7
000874  9800              LDR      r0,[sp,#0]
000876  f7fffffe          BL       WM__InsertWindowIntoList
;;;859        /* Activate window if WM_CF_ACTIVATE is specified */
;;;860        if (Style & WM_CF_ACTIVATE) {
00087a  f0150f20          TST      r5,#0x20
00087e  d002              BEQ      |L1.2182|
;;;861          WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
000880  9800              LDR      r0,[sp,#0]
000882  f7fffffe          BL       WM_SelectWindow
                  |L1.2182|
;;;862        }
;;;863        /* Handle the Style flags, one at a time */
;;;864        #if WM_SUPPORT_TRANSPARENCY
;;;865          if (Style & WM_SF_HASTRANS) {
000886  f0150f01          TST      r5,#1
00088a  d005              BEQ      |L1.2200|
;;;866            WM__TransWindowCnt++;          /* Increment counter for transparency windows */
00088c  48fe              LDR      r0,|L1.3208|
00088e  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
000890  f1000001          ADD      r0,r0,#1
000894  49fc              LDR      r1,|L1.3208|
000896  6008              STR      r0,[r1,#0]  ; WM__TransWindowCnt
                  |L1.2200|
;;;867          }
;;;868        #endif
;;;869        if (Style & WM_CF_BGND) {
000898  f0150f40          TST      r5,#0x40
00089c  d002              BEQ      |L1.2212|
;;;870          WM_BringToBottom(hWin);
00089e  9800              LDR      r0,[sp,#0]
0008a0  f7fffffe          BL       WM_BringToBottom
                  |L1.2212|
;;;871        }
;;;872        if (Style & WM_CF_SHOW) {
0008a4  f0150f02          TST      r5,#2
0008a8  d006              BEQ      |L1.2232|
;;;873          pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
0008aa  8ba0              LDRH     r0,[r4,#0x1c]
0008ac  f0400002          ORR      r0,r0,#2
0008b0  83a0              STRH     r0,[r4,#0x1c]
;;;874          WM_InvalidateWindow(hWin);    /* Mark content as invalid */
0008b2  9800              LDR      r0,[sp,#0]
0008b4  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2232|
;;;875        }
;;;876        WM__SendMsgNoData(hWin, WM_CREATE);
0008b8  2101              MOVS     r1,#1
0008ba  9800              LDR      r0,[sp,#0]
0008bc  f7fffffe          BL       WM__SendMsgNoData
                  |L1.2240|
;;;877      }
;;;878      WM_UNLOCK();
;;;879      return hWin;
0008c0  9800              LDR      r0,[sp,#0]
;;;880    }
0008c2  e8bd8ff8          POP      {r3-r11,pc}
;;;881    
                          ENDP

                  WM_CreateWindow PROC
;;;885    */
;;;886    WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U16 Style, WM_CALLBACK* cb, int NumExtraBytes) {
0008c6  e92d47ff          PUSH     {r0-r10,lr}
0008ca  4604              MOV      r4,r0
0008cc  460d              MOV      r5,r1
0008ce  4616              MOV      r6,r2
0008d0  461f              MOV      r7,r3
0008d2  e9dd9a0d          LDRD     r9,r10,[sp,#0x34]
0008d6  f8dd8030          LDR      r8,[sp,#0x30]
;;;887      return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
0008da  f04f0000          MOV      r0,#0
0008de  463b              MOV      r3,r7
0008e0  4632              MOV      r2,r6
0008e2  4629              MOV      r1,r5
0008e4  e88d0701          STM      sp,{r0,r8-r10}
0008e8  4620              MOV      r0,r4
0008ea  f7fffffe          BL       WM_CreateWindowAsChild
;;;888    }
0008ee  b004              ADD      sp,sp,#0x10
0008f0  e8bd87f0          POP      {r4-r10,pc}
;;;889    
                          ENDP

                  WM_GetActiveWindow PROC
;;;993    */
;;;994    WM_HWIN WM_GetActiveWindow(void) {
0008f4  48e5              LDR      r0,|L1.3212|
;;;995      return GUI_Context.hAWin;
0008f6  f9b0003c          LDRSH    r0,[r0,#0x3c]  ; GUI_Context
;;;996    }
0008fa  4770              BX       lr
;;;997    
                          ENDP

                  _FindNext_IVR PROC
;;;1028   #if WM_SUPPORT_OBSTRUCT
;;;1029   static int _FindNext_IVR(void) {
0008fc  b57c              PUSH     {r2-r6,lr}
;;;1030     WM_HMEM hParent;
;;;1031     GUI_RECT r;
;;;1032     WM_Obj* pAWin;
;;;1033     WM_Obj* pParent;
;;;1034     r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
0008fe  49e4              LDR      r1,|L1.3216|
000900  e9d10102          LDRD     r0,r1,[r1,#8]
000904  e9cd0100          STRD     r0,r1,[sp,#0]
;;;1035     /*
;;;1036        STEP 1:
;;;1037          Set the next position which could be part of the next IVR
;;;1038          This will be the first unhandle pixel in reading order, i.e. next one to the right
;;;1039          or next one down if we are at the right border.
;;;1040     */
;;;1041     if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
000908  48e1              LDR      r0,|L1.3216|
00090a  6900              LDR      r0,[r0,#0x10]  ; _ClipContext
00090c  b940              CBNZ     r0,|L1.2336|
;;;1042       r.x0 = _ClipContext.ClientRect.x0;
00090e  48e0              LDR      r0,|L1.3216|
000910  8800              LDRH     r0,[r0,#0]  ; _ClipContext
000912  f8ad0000          STRH     r0,[sp,#0]
;;;1043       r.y0 = _ClipContext.ClientRect.y0;
000916  48de              LDR      r0,|L1.3216|
000918  8840              LDRH     r0,[r0,#2]  ; _ClipContext
00091a  f8ad0002          STRH     r0,[sp,#2]
00091e  e01d              B        |L1.2396|
                  |L1.2336|
;;;1044     } else {
;;;1045       r.x0 = _ClipContext.CurRect.x1+1;
000920  48db              LDR      r0,|L1.3216|
000922  8980              LDRH     r0,[r0,#0xc]
000924  f1000001          ADD      r0,r0,#1
000928  b200              SXTH     r0,r0
00092a  f8ad0000          STRH     r0,[sp,#0]
;;;1046       r.y0 = _ClipContext.CurRect.y0;
00092e  48d8              LDR      r0,|L1.3216|
000930  8940              LDRH     r0,[r0,#0xa]
000932  f8ad0002          STRH     r0,[sp,#2]
;;;1047       if (r.x0 > _ClipContext.ClientRect.x1) {
000936  f9bd0000          LDRSH    r0,[sp,#0]
00093a  49d5              LDR      r1,|L1.3216|
00093c  f9b11004          LDRSH    r1,[r1,#4]  ; _ClipContext
000940  4288              CMP      r0,r1
000942  dd0b              BLE      |L1.2396|
;;;1048   NextStripe:  /* go down to next stripe */
000944  bf00              NOP      
                  |L1.2374|
;;;1049         r.x0 = _ClipContext.ClientRect.x0;
000946  48d2              LDR      r0,|L1.3216|
000948  8800              LDRH     r0,[r0,#0]  ; _ClipContext
00094a  f8ad0000          STRH     r0,[sp,#0]
;;;1050         r.y0 = _ClipContext.CurRect.y1+1;
00094e  48d0              LDR      r0,|L1.3216|
000950  89c0              LDRH     r0,[r0,#0xe]
000952  f1000001          ADD      r0,r0,#1
000956  b200              SXTH     r0,r0
000958  f8ad0002          STRH     r0,[sp,#2]
                  |L1.2396|
;;;1051       }
;;;1052     }
;;;1053     /*
;;;1054        STEP 2:
;;;1055          Check if we are done completely.
;;;1056     */
;;;1057     if (r.y0 >_ClipContext.ClientRect.y1) {
00095c  f9bd0002          LDRSH    r0,[sp,#2]
000960  49cb              LDR      r1,|L1.3216|
000962  f9b11006          LDRSH    r1,[r1,#6]  ; _ClipContext
000966  4288              CMP      r0,r1
000968  dd01              BLE      |L1.2414|
;;;1058       return 0;
00096a  2000              MOVS     r0,#0
                  |L1.2412|
;;;1059     }
;;;1060     /* STEP 3:
;;;1061          Find out the max. height (r.y1) if we are at the left border.
;;;1062          Since we are using the same height for all IVRs at the same y0,
;;;1063          we do this only for the leftmost one.
;;;1064     */
;;;1065     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1066     if (r.x0 == _ClipContext.ClientRect.x0) {
;;;1067       r.y1 = _ClipContext.ClientRect.y1;
;;;1068       r.x1 = _ClipContext.ClientRect.x1;
;;;1069       /* Iterate over all windows which are above */
;;;1070       /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1071       for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
;;;1072         pParent = WM_H2P(hParent);
;;;1073         _Findy1(pParent->hNext, &r, NULL);
;;;1074       }
;;;1075       /* Check all children */
;;;1076       _Findy1(pAWin->hFirstChild, &r, NULL);
;;;1077     }
;;;1078     /* 
;;;1079       STEP 4
;;;1080         Find out x0 for the given y0, y1 by iterating over windows above.
;;;1081         if we find one that intersects, adjust x0 to the right.
;;;1082     */
;;;1083   Find_x0:
;;;1084     r.x1 = r.x0;
;;;1085     /* Iterate over all windows which are above */
;;;1086     /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
;;;1087     #if 0   /* This is a planned, but not yet released optimization */
;;;1088       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1089       {
;;;1090         hParent = pAWin->hParent;
;;;1091       } else
;;;1092     #endif
;;;1093     {
;;;1094       hParent = GUI_Context.hAWin;
;;;1095     }
;;;1096     for (; hParent; hParent = pParent->hParent) {
;;;1097       pParent = WM_H2P(hParent);
;;;1098       if (_Findx0(pParent->hNext, &r, NULL)) {
;;;1099         goto Find_x0;
;;;1100       }
;;;1101     }
;;;1102     /* Check all children */
;;;1103     if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
;;;1104       goto Find_x0;
;;;1105     }
;;;1106     /* 
;;;1107      STEP 5:
;;;1108        If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
;;;1109        Find out x1 for the given x0, y0, y1
;;;1110     */
;;;1111     r.x1 = _ClipContext.ClientRect.x1;
;;;1112     if (r.x1 < r.x0) {/* horizontal border reached ? */
;;;1113       _ClipContext.CurRect = r;
;;;1114       goto NextStripe;
;;;1115     }    
;;;1116     /* 
;;;1117      STEP 6:
;;;1118        Find r.x1. We have to Iterate over all windows which are above
;;;1119     */
;;;1120     /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1121     #if 0   /* This is a planned, but not yet released optimization */
;;;1122       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1123       {
;;;1124         hParent = pAWin->hParent;
;;;1125       } else
;;;1126     #endif
;;;1127     {
;;;1128       hParent = GUI_Context.hAWin;
;;;1129     }
;;;1130     for (; hParent; hParent = pParent->hParent) {
;;;1131       pParent = WM_H2P(hParent);
;;;1132       _Findx1(pParent->hNext, &r, NULL);
;;;1133     }
;;;1134     /* Check all children */
;;;1135     _Findx1(pAWin->hFirstChild, &r, NULL);
;;;1136     /* We are done. Return the rectangle we found in the _ClipContext. */
;;;1137     if (_ClipContext.Cnt >200) {
;;;1138       return 0;  /* error !!! This should not happen !*/
;;;1139     }
;;;1140     _ClipContext.CurRect = r;
;;;1141     return 1;  /* IVR is valid ! */
;;;1142   }
00096c  bd7c              POP      {r2-r6,pc}
                  |L1.2414|
00096e  49c7              LDR      r1,|L1.3212|
000970  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1065  ; GUI_Context
000974  f7fffffe          BL       GUI_ALLOC_h2p
000978  4605              MOV      r5,r0                 ;1065
00097a  f9bd0000          LDRSH    r0,[sp,#0]            ;1066
00097e  49c4              LDR      r1,|L1.3216|
000980  f9b11000          LDRSH    r1,[r1,#0]            ;1066  ; _ClipContext
000984  4288              CMP      r0,r1                 ;1066
000986  d120              BNE      |L1.2506|
000988  48c1              LDR      r0,|L1.3216|
00098a  88c0              LDRH     r0,[r0,#6]            ;1067  ; _ClipContext
00098c  f8ad0006          STRH     r0,[sp,#6]            ;1067
000990  48bf              LDR      r0,|L1.3216|
000992  8880              LDRH     r0,[r0,#4]            ;1068  ; _ClipContext
000994  f8ad0004          STRH     r0,[sp,#4]            ;1068
000998  48bc              LDR      r0,|L1.3212|
00099a  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1071  ; GUI_Context
00099e  e00c              B        |L1.2490|
                  |L1.2464|
0009a0  4630              MOV      r0,r6                 ;1072
0009a2  f7fffffe          BL       GUI_ALLOC_h2p
0009a6  4604              MOV      r4,r0                 ;1072
0009a8  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1073
0009ac  f04f0200          MOV      r2,#0                 ;1073
0009b0  4669              MOV      r1,sp                 ;1073
0009b2  f7fffffe          BL       _Findy1
0009b6  f9b46016          LDRSH    r6,[r4,#0x16]         ;1071
                  |L1.2490|
0009ba  2e00              CMP      r6,#0                 ;1071
0009bc  d1f0              BNE      |L1.2464|
0009be  f9b50018          LDRSH    r0,[r5,#0x18]         ;1076
0009c2  2200              MOVS     r2,#0                 ;1076
0009c4  4669              MOV      r1,sp                 ;1076
0009c6  f7fffffe          BL       _Findy1
                  |L1.2506|
0009ca  bf00              NOP                            ;1083
                  |L1.2508|
0009cc  f8bd0000          LDRH     r0,[sp,#0]            ;1084
0009d0  f8ad0004          STRH     r0,[sp,#4]            ;1084
0009d4  48ad              LDR      r0,|L1.3212|
0009d6  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1094  ; GUI_Context
0009da  e00e              B        |L1.2554|
                  |L1.2524|
0009dc  4630              MOV      r0,r6                 ;1097
0009de  f7fffffe          BL       GUI_ALLOC_h2p
0009e2  4604              MOV      r4,r0                 ;1097
0009e4  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1098
0009e8  f04f0200          MOV      r2,#0                 ;1098
0009ec  4669              MOV      r1,sp                 ;1098
0009ee  f7fffffe          BL       _Findx0
0009f2  b100              CBZ      r0,|L1.2550|
0009f4  e7ea              B        |L1.2508|
                  |L1.2550|
0009f6  f9b46016          LDRSH    r6,[r4,#0x16]         ;1096
                  |L1.2554|
0009fa  2e00              CMP      r6,#0                 ;1096
0009fc  d1ee              BNE      |L1.2524|
0009fe  f9b50018          LDRSH    r0,[r5,#0x18]         ;1103
000a02  2200              MOVS     r2,#0                 ;1103
000a04  4669              MOV      r1,sp                 ;1103
000a06  f7fffffe          BL       _Findx0
000a0a  b100              CBZ      r0,|L1.2574|
000a0c  e7de              B        |L1.2508|
                  |L1.2574|
000a0e  48a0              LDR      r0,|L1.3216|
000a10  8880              LDRH     r0,[r0,#4]            ;1111  ; _ClipContext
000a12  f8ad0004          STRH     r0,[sp,#4]            ;1111
000a16  f9bd0004          LDRSH    r0,[sp,#4]            ;1112
000a1a  f9bd1000          LDRSH    r1,[sp,#0]            ;1112
000a1e  4288              CMP      r0,r1                 ;1112
000a20  da05              BGE      |L1.2606|
000a22  489b              LDR      r0,|L1.3216|
000a24  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1113
000a28  e9c01202          STRD     r1,r2,[r0,#8]         ;1113
000a2c  e78b              B        |L1.2374|
                  |L1.2606|
000a2e  4897              LDR      r0,|L1.3212|
000a30  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1128  ; GUI_Context
000a34  e00c              B        |L1.2640|
                  |L1.2614|
000a36  4630              MOV      r0,r6                 ;1131
000a38  f7fffffe          BL       GUI_ALLOC_h2p
000a3c  4604              MOV      r4,r0                 ;1131
000a3e  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1132
000a42  f04f0200          MOV      r2,#0                 ;1132
000a46  4669              MOV      r1,sp                 ;1132
000a48  f7fffffe          BL       _Findx1
000a4c  f9b46016          LDRSH    r6,[r4,#0x16]         ;1130
                  |L1.2640|
000a50  2e00              CMP      r6,#0                 ;1130
000a52  d1f0              BNE      |L1.2614|
000a54  f9b50018          LDRSH    r0,[r5,#0x18]         ;1135
000a58  2200              MOVS     r2,#0                 ;1135
000a5a  4669              MOV      r1,sp                 ;1135
000a5c  f7fffffe          BL       _Findx1
000a60  488b              LDR      r0,|L1.3216|
000a62  6900              LDR      r0,[r0,#0x10]         ;1137  ; _ClipContext
000a64  28c8              CMP      r0,#0xc8              ;1137
000a66  dd01              BLE      |L1.2668|
000a68  2000              MOVS     r0,#0                 ;1138
000a6a  e77f              B        |L1.2412|
                  |L1.2668|
000a6c  4888              LDR      r0,|L1.3216|
000a6e  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1140
000a72  e9c01202          STRD     r1,r2,[r0,#8]         ;1140
000a76  2001              MOVS     r0,#1                 ;1141
000a78  e778              B        |L1.2412|
;;;1143   
                          ENDP

                  WM__GetNextIVR PROC
;;;1167   */
;;;1168   int  WM__GetNextIVR(void) {
000a7a  b510              PUSH     {r4,lr}
;;;1169     #if GUI_SUPPORT_CURSOR
;;;1170       static char _CursorHidden;
;;;1171     #endif
;;;1172     /* If WM is not active, we have no rectangles to return */
;;;1173     if (WM_IsActive==0) {
000a7c  4885              LDR      r0,|L1.3220|
000a7e  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000a80  b908              CBNZ     r0,|L1.2694|
;;;1174       return 0;
000a82  2000              MOVS     r0,#0
                  |L1.2692|
;;;1175     }
;;;1176     if (_ClipContext.EntranceCnt > 1) {
;;;1177       _ClipContext.EntranceCnt--;
;;;1178       return 0;
;;;1179     }
;;;1180     #if GUI_SUPPORT_CURSOR
;;;1181       if (_CursorHidden) {
;;;1182         _CursorHidden = 0;
;;;1183         (*GUI_CURSOR_pfTempUnhide) ();
;;;1184       }
;;;1185     #endif
;;;1186     ++_ClipContext.Cnt;
;;;1187     /* Find next rectangle and use it as ClipRect */
;;;1188     if (!_FindNext_IVR()) {
;;;1189       _ClipContext.EntranceCnt--;  /* This search is over ! */
;;;1190       return 0;        /* Could not find an other one ! */
;;;1191     }
;;;1192     WM__ActivateClipRect();
;;;1193     /* Hide cursor if necessary */
;;;1194     #if GUI_SUPPORT_CURSOR
;;;1195       if (GUI_CURSOR_pfTempHide) {
;;;1196         _CursorHidden = (*GUI_CURSOR_pfTempHide) ( &_ClipContext.CurRect);
;;;1197       }
;;;1198     #endif
;;;1199     return 1;
;;;1200   }
000a84  bd10              POP      {r4,pc}
                  |L1.2694|
000a86  4882              LDR      r0,|L1.3216|
000a88  6940              LDR      r0,[r0,#0x14]         ;1176  ; _ClipContext
000a8a  2801              CMP      r0,#1                 ;1176
000a8c  dd08              BLE      |L1.2720|
000a8e  4880              LDR      r0,|L1.3216|
000a90  6940              LDR      r0,[r0,#0x14]         ;1177  ; _ClipContext
000a92  f1a00001          SUB      r0,r0,#1              ;1177
000a96  497e              LDR      r1,|L1.3216|
000a98  6148              STR      r0,[r1,#0x14]         ;1177  ; _ClipContext
000a9a  f04f0000          MOV      r0,#0                 ;1178
000a9e  e7f1              B        |L1.2692|
                  |L1.2720|
000aa0  487b              LDR      r0,|L1.3216|
000aa2  6900              LDR      r0,[r0,#0x10]         ;1186  ; _ClipContext
000aa4  f1000001          ADD      r0,r0,#1              ;1186
000aa8  4979              LDR      r1,|L1.3216|
000aaa  6108              STR      r0,[r1,#0x10]         ;1186  ; _ClipContext
000aac  f7fffffe          BL       _FindNext_IVR
000ab0  b940              CBNZ     r0,|L1.2756|
000ab2  4877              LDR      r0,|L1.3216|
000ab4  6940              LDR      r0,[r0,#0x14]         ;1189  ; _ClipContext
000ab6  f1a00001          SUB      r0,r0,#1              ;1189
000aba  4975              LDR      r1,|L1.3216|
000abc  6148              STR      r0,[r1,#0x14]         ;1189  ; _ClipContext
000abe  f04f0000          MOV      r0,#0                 ;1190
000ac2  e7df              B        |L1.2692|
                  |L1.2756|
000ac4  f7fffffe          BL       WM__ActivateClipRect
000ac8  2001              MOVS     r0,#1                 ;1199
000aca  e7db              B        |L1.2692|
;;;1201   
                          ENDP

                  WM__InitIVRSearch PROC
;;;1213   */
;;;1214   int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
000acc  b57f              PUSH     {r0-r6,lr}
000ace  4605              MOV      r5,r0
;;;1215     GUI_RECT r;
;;;1216     WM_Obj* pAWin;
;;;1217     GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
;;;1218      /* If WM is not active -> nothing to do, leave cliprect alone */
;;;1219     if (WM_IsActive==0) {
000ad0  4870              LDR      r0,|L1.3220|
000ad2  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000ad4  b920              CBNZ     r0,|L1.2784|
;;;1220       WM__ActivateClipRect();
000ad6  f7fffffe          BL       WM__ActivateClipRect
;;;1221       return 1;
000ada  2001              MOVS     r0,#1
                  |L1.2780|
;;;1222     }
;;;1223     /* If we entered multiple times, leave Cliprect alone */
;;;1224     if (++_ClipContext.EntranceCnt > 1)
;;;1225       return 1;
;;;1226     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1227     _ClipContext.Cnt        = -1;
;;;1228    /* When using callback mechanism, it is legal to reduce drawing
;;;1229       area to the invalid area ! */
;;;1230     if (WM__PaintCallbackCnt) {
;;;1231       WM__GetInvalidRectAbs(pAWin, &r);
;;;1232     } else {  /* Not using callback mechanism, therefor allow entire rectangle */
;;;1233       if (pAWin->Status & WM_SF_ISVIS) {
;;;1234         r = pAWin->Rect;
;;;1235       } else {
;;;1236         --_ClipContext.EntranceCnt;
;;;1237         return 0;  /* window is not even visible ! */
;;;1238       }
;;;1239     }
;;;1240     /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
;;;1241     if (pMaxRect) {
;;;1242       GUI__IntersectRect(&r, pMaxRect);
;;;1243     }
;;;1244     /* If user has reduced the cliprect size, reduce the rectangle */
;;;1245     if (GUI_Context.WM__pUserClipRect) {
;;;1246       WM_Obj* pWin = pAWin;
;;;1247       GUI_RECT rUser = *(GUI_Context.WM__pUserClipRect);
;;;1248       #if WM_SUPPORT_TRANSPARENCY
;;;1249         if (WM__hATransWindow) {
;;;1250           pWin = WM_H2P(WM__hATransWindow);
;;;1251         }   
;;;1252       #endif
;;;1253       WM__Client2Screen(pWin, &rUser);
;;;1254       GUI__IntersectRect(&r, &rUser);
;;;1255     }
;;;1256     /* For transparent windows, we need to further reduce the rectangle */
;;;1257     #if WM_SUPPORT_TRANSPARENCY
;;;1258       if (WM__hATransWindow) {
;;;1259         if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
;;;1260           --_ClipContext.EntranceCnt;
;;;1261           return 0;           /* Nothing to draw */
;;;1262         }
;;;1263       }
;;;1264     #endif
;;;1265     /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
;;;1266     if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
;;;1267       --_ClipContext.EntranceCnt;
;;;1268       return 0;           /* Nothing to draw */
;;;1269     }
;;;1270     /* Store the rectangle and find the first rectangle of the area */
;;;1271     _ClipContext.ClientRect = r;
;;;1272     return WM__GetNextIVR();
;;;1273   }
000adc  b004              ADD      sp,sp,#0x10
000ade  bd70              POP      {r4-r6,pc}
                  |L1.2784|
000ae0  486b              LDR      r0,|L1.3216|
000ae2  6940              LDR      r0,[r0,#0x14]         ;1224  ; _ClipContext
000ae4  1c40              ADDS     r0,r0,#1              ;1224
000ae6  496a              LDR      r1,|L1.3216|
000ae8  6148              STR      r0,[r1,#0x14]         ;1224  ; _ClipContext
000aea  2801              CMP      r0,#1                 ;1224
000aec  dd01              BLE      |L1.2802|
000aee  2001              MOVS     r0,#1                 ;1225
000af0  e7f4              B        |L1.2780|
                  |L1.2802|
000af2  4966              LDR      r1,|L1.3212|
000af4  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1226  ; GUI_Context
000af8  f7fffffe          BL       GUI_ALLOC_h2p
000afc  4604              MOV      r4,r0                 ;1226
000afe  f04f30ff          MOV      r0,#0xffffffff        ;1227
000b02  4963              LDR      r1,|L1.3216|
000b04  6108              STR      r0,[r1,#0x10]         ;1227  ; _ClipContext
000b06  4864              LDR      r0,|L1.3224|
000b08  7800              LDRB     r0,[r0,#0]            ;1230  ; WM__PaintCallbackCnt
000b0a  b120              CBZ      r0,|L1.2838|
000b0c  a902              ADD      r1,sp,#8              ;1231
000b0e  4620              MOV      r0,r4                 ;1231
000b10  f7fffffe          BL       WM__GetInvalidRectAbs
000b14  e011              B        |L1.2874|
                  |L1.2838|
000b16  8ba0              LDRH     r0,[r4,#0x1c]         ;1233
000b18  f0100f02          TST      r0,#2                 ;1233
000b1c  d004              BEQ      |L1.2856|
000b1e  e9d40100          LDRD     r0,r1,[r4,#0]         ;1234
000b22  e9cd0102          STRD     r0,r1,[sp,#8]         ;1234
000b26  e008              B        |L1.2874|
                  |L1.2856|
000b28  4859              LDR      r0,|L1.3216|
000b2a  6940              LDR      r0,[r0,#0x14]         ;1236  ; _ClipContext
000b2c  f1a00001          SUB      r0,r0,#1              ;1236
000b30  4957              LDR      r1,|L1.3216|
000b32  6148              STR      r0,[r1,#0x14]         ;1236  ; _ClipContext
000b34  f04f0000          MOV      r0,#0                 ;1237
000b38  e7d0              B        |L1.2780|
                  |L1.2874|
000b3a  b11d              CBZ      r5,|L1.2884|
000b3c  4629              MOV      r1,r5                 ;1242
000b3e  a802              ADD      r0,sp,#8              ;1242
000b40  f7fffffe          BL       GUI__IntersectRect
                  |L1.2884|
000b44  4851              LDR      r0,|L1.3212|
000b46  6b80              LDR      r0,[r0,#0x38]         ;1245  ; GUI_Context
000b48  b1c0              CBZ      r0,|L1.2940|
000b4a  4626              MOV      r6,r4                 ;1246
000b4c  484f              LDR      r0,|L1.3212|
000b4e  6b80              LDR      r0,[r0,#0x38]         ;1247  ; GUI_Context
000b50  6801              LDR      r1,[r0,#0]            ;1247
000b52  9100              STR      r1,[sp,#0]            ;1247
000b54  6840              LDR      r0,[r0,#4]            ;1247
000b56  9001              STR      r0,[sp,#4]            ;1247
000b58  4850              LDR      r0,|L1.3228|
000b5a  8800              LDRH     r0,[r0,#0]            ;1249  ; WM__hATransWindow
000b5c  b128              CBZ      r0,|L1.2922|
000b5e  484f              LDR      r0,|L1.3228|
000b60  f9b00000          LDRSH    r0,[r0,#0]            ;1250  ; WM__hATransWindow
000b64  f7fffffe          BL       GUI_ALLOC_h2p
000b68  4606              MOV      r6,r0                 ;1250
                  |L1.2922|
000b6a  4669              MOV      r1,sp                 ;1253
000b6c  4630              MOV      r0,r6                 ;1253
000b6e  f7fffffe          BL       WM__Client2Screen
000b72  4669              MOV      r1,sp                 ;1254
000b74  a802              ADD      r0,sp,#8              ;1254
000b76  f7fffffe          BL       GUI__IntersectRect
000b7a  bf00              NOP                            ;1255
                  |L1.2940|
000b7c  4847              LDR      r0,|L1.3228|
000b7e  8800              LDRH     r0,[r0,#0]            ;1258  ; WM__hATransWindow
000b80  b178              CBZ      r0,|L1.2978|
000b82  4846              LDR      r0,|L1.3228|
000b84  f9b01000          LDRSH    r1,[r0,#0]            ;1259  ; WM__hATransWindow
000b88  a802              ADD      r0,sp,#8              ;1259
000b8a  f7fffffe          BL       WM__ClipAtParentBorders
000b8e  b940              CBNZ     r0,|L1.2978|
000b90  483f              LDR      r0,|L1.3216|
000b92  6940              LDR      r0,[r0,#0x14]         ;1260  ; _ClipContext
000b94  f1a00001          SUB      r0,r0,#1              ;1260
000b98  493d              LDR      r1,|L1.3216|
000b9a  6148              STR      r0,[r1,#0x14]         ;1260  ; _ClipContext
000b9c  f04f0000          MOV      r0,#0                 ;1261
000ba0  e79c              B        |L1.2780|
                  |L1.2978|
000ba2  483a              LDR      r0,|L1.3212|
000ba4  f9b0103c          LDRSH    r1,[r0,#0x3c]         ;1266  ; GUI_Context
000ba8  a802              ADD      r0,sp,#8              ;1266
000baa  f7fffffe          BL       WM__ClipAtParentBorders
000bae  b940              CBNZ     r0,|L1.3010|
000bb0  4837              LDR      r0,|L1.3216|
000bb2  6940              LDR      r0,[r0,#0x14]         ;1267  ; _ClipContext
000bb4  f1a00001          SUB      r0,r0,#1              ;1267
000bb8  4935              LDR      r1,|L1.3216|
000bba  6148              STR      r0,[r1,#0x14]         ;1267  ; _ClipContext
000bbc  f04f0000          MOV      r0,#0                 ;1268
000bc0  e78c              B        |L1.2780|
                  |L1.3010|
000bc2  4833              LDR      r0,|L1.3216|
000bc4  e9dd1202          LDRD     r1,r2,[sp,#8]         ;1271
000bc8  c006              STM      r0!,{r1,r2}           ;1271
000bca  f7fffffe          BL       WM__GetNextIVR
000bce  e785              B        |L1.2780|
;;;1274   
                          ENDP

                  WM_SetDefault PROC
;;;1283   */
;;;1284   void WM_SetDefault(void) {
000bd0  b510              PUSH     {r4,lr}
;;;1285     GL_SetDefault();
000bd2  f7fffffe          BL       GL_SetDefault
;;;1286     GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
000bd6  f04f0000          MOV      r0,#0
000bda  492c              LDR      r1,|L1.3212|
000bdc  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1287   }
000bde  bd10              POP      {r4,pc}
;;;1288   
                          ENDP

                  _Paint1 PROC
;;;1292   */
;;;1293   static void _Paint1(WM_HWIN hWin, WM_Obj* pWin) {
000be0  b5fe              PUSH     {r1-r7,lr}
000be2  4605              MOV      r5,r0
000be4  460c              MOV      r4,r1
;;;1294     int Status = pWin->Status;
000be6  8ba6              LDRH     r6,[r4,#0x1c]
;;;1295     /* Send WM_PAINT if window is visible and a callback is defined */
;;;1296     if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
000be8  6920              LDR      r0,[r4,#0x10]
000bea  2800              CMP      r0,#0
000bec  d039              BEQ      |L1.3170|
000bee  f0160f02          TST      r6,#2
000bf2  d036              BEQ      |L1.3170|
;;;1297       WM_MESSAGE Msg;
;;;1298       WM__PaintCallbackCnt++;
000bf4  4828              LDR      r0,|L1.3224|
000bf6  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000bf8  f1000001          ADD      r0,r0,#1
000bfc  4926              LDR      r1,|L1.3224|
000bfe  7008              STRB     r0,[r1,#0]
;;;1299       if (Status & WM_SF_LATE_CLIP) {
000c00  f4165f80          TST      r6,#0x1000
000c04  d00e              BEQ      |L1.3108|
;;;1300         Msg.hWin   = hWin;
000c06  f8ad5004          STRH     r5,[sp,#4]
;;;1301         Msg.MsgId  = WM_PAINT;
000c0a  f04f000f          MOV      r0,#0xf
000c0e  9000              STR      r0,[sp,#0]
;;;1302         Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000c10  f1040008          ADD      r0,r4,#8
000c14  9002              STR      r0,[sp,#8]
;;;1303         WM_SetDefault();
000c16  f7fffffe          BL       WM_SetDefault
;;;1304         WM_SendMessage(hWin, &Msg);
000c1a  4669              MOV      r1,sp
000c1c  4628              MOV      r0,r5
000c1e  f7fffffe          BL       WM_SendMessage
000c22  e017              B        |L1.3156|
                  |L1.3108|
;;;1305       } else {
;;;1306         WM_ITERATE_START(&pWin->InvalidRect) {
000c24  f1040008          ADD      r0,r4,#8
000c28  f7fffffe          BL       WM__InitIVRSearch
000c2c  b190              CBZ      r0,|L1.3156|
000c2e  bf00              NOP      
                  |L1.3120|
;;;1307           Msg.hWin   = hWin;
000c30  f8ad5004          STRH     r5,[sp,#4]
;;;1308           Msg.MsgId  = WM_PAINT;
000c34  f04f000f          MOV      r0,#0xf
000c38  9000              STR      r0,[sp,#0]
;;;1309           Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000c3a  f1040008          ADD      r0,r4,#8
000c3e  9002              STR      r0,[sp,#8]
;;;1310           WM_SetDefault();
000c40  f7fffffe          BL       WM_SetDefault
;;;1311           WM_SendMessage(hWin, &Msg);
000c44  4669              MOV      r1,sp
000c46  4628              MOV      r0,r5
000c48  f7fffffe          BL       WM_SendMessage
;;;1312         } WM_ITERATE_END();
000c4c  f7fffffe          BL       WM__GetNextIVR
000c50  2800              CMP      r0,#0
000c52  d1ed              BNE      |L1.3120|
                  |L1.3156|
;;;1313       }
;;;1314       WM__PaintCallbackCnt--;
000c54  4810              LDR      r0,|L1.3224|
000c56  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000c58  f1a00001          SUB      r0,r0,#1
000c5c  490e              LDR      r1,|L1.3224|
000c5e  7008              STRB     r0,[r1,#0]
;;;1315     }
000c60  bf00              NOP      
                  |L1.3170|
;;;1316   }
000c62  bdfe              POP      {r1-r7,pc}
;;;1317   /*********************************************************************
                          ENDP

                  _Paint1Trans PROC
;;;1339   #if WM_SUPPORT_TRANSPARENCY
;;;1340   static int _Paint1Trans(WM_HWIN hWin, WM_Obj* pWin) {
000c64  e92d41f0          PUSH     {r4-r8,lr}
000c68  4605              MOV      r5,r0
000c6a  460c              MOV      r4,r1
;;;1341     int xPrev, yPrev;
;;;1342     WM_Obj* pAWin = WM_H2P(GUI_Context.hAWin);
000c6c  4907              LDR      r1,|L1.3212|
000c6e  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
000c72  f7fffffe          BL       GUI_ALLOC_h2p
000c76  4680              MOV      r8,r0
;;;1343     /* Check if we need to do any drawing */
;;;1344     if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
000c78  4621              MOV      r1,r4
000c7a  f1080008          ADD      r0,r8,#8
000c7e  f7fffffe          BL       GUI_RectsIntersect
000c82  b370              CBZ      r0,|L1.3298|
;;;1345       /* Save old values */
;;;1346       xPrev = GUI_Context.xOff;
000c84  4801              LDR      r0,|L1.3212|
000c86  e00b              B        |L1.3232|
                  |L1.3208|
                          DCD      WM__TransWindowCnt
                  |L1.3212|
                          DCD      GUI_Context
                  |L1.3216|
                          DCD      _ClipContext
                  |L1.3220|
                          DCD      WM_IsActive
                  |L1.3224|
                          DCD      WM__PaintCallbackCnt
                  |L1.3228|
                          DCD      WM__hATransWindow
                  |L1.3232|
000ca0  6c06              LDR      r6,[r0,#0x40]  ; GUI_Context
;;;1347       yPrev = GUI_Context.yOff;
000ca2  6c47              LDR      r7,[r0,#0x44]  ; GUI_Context
;;;1348       /* Set values for the current (transparent) window, rather than the one below */
;;;1349       GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
000ca4  f1080208          ADD      r2,r8,#8
000ca8  4621              MOV      r1,r4
000caa  f1040008          ADD      r0,r4,#8
000cae  f7fffffe          BL       GUI__IntersectRects
;;;1350       WM__hATransWindow = hWin;
000cb2  48f5              LDR      r0,|L1.4232|
000cb4  8005              STRH     r5,[r0,#0]
;;;1351       GUI_Context.xOff = pWin->Rect.x0;
000cb6  f9b40000          LDRSH    r0,[r4,#0]
000cba  49f4              LDR      r1,|L1.4236|
000cbc  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;1352       GUI_Context.yOff = pWin->Rect.y0;
000cbe  f9b40002          LDRSH    r0,[r4,#2]
000cc2  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;1353       /* Do the actual drawing ... */
;;;1354       _Paint1(hWin, pWin);
000cc4  4621              MOV      r1,r4
000cc6  4628              MOV      r0,r5
000cc8  f7fffffe          BL       _Paint1
;;;1355       /* Restore settings */
;;;1356       WM__hATransWindow = 0;
000ccc  f04f0000          MOV      r0,#0
000cd0  49ed              LDR      r1,|L1.4232|
000cd2  8008              STRH     r0,[r1,#0]
;;;1357       GUI_Context.xOff = xPrev;
000cd4  48ed              LDR      r0,|L1.4236|
000cd6  6406              STR      r6,[r0,#0x40]  ; GUI_Context
;;;1358       GUI_Context.yOff = yPrev;
000cd8  6447              STR      r7,[r0,#0x44]  ; GUI_Context
;;;1359       return 1;                       /* Some drawing took place */
000cda  f04f0001          MOV      r0,#1
                  |L1.3294|
;;;1360     }
;;;1361     return 0;                         /* No invalid area, so nothing was drawn */
;;;1362   }
000cde  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3298|
000ce2  e7ff              B        |L1.3300|
                  |L1.3300|
000ce4  2000              MOVS     r0,#0                 ;1361
000ce6  e7fa              B        |L1.3294|
;;;1363   #endif
                          ENDP

                  _PaintTransChildren PROC
;;;1376   #if WM_SUPPORT_TRANSPARENCY
;;;1377   static void _PaintTransChildren(WM_Obj* pWin) {
000ce8  b57c              PUSH     {r2-r6,lr}
000cea  4604              MOV      r4,r0
;;;1378     WM_HWIN hChild;
;;;1379     WM_Obj* pChild;
;;;1380     if (pWin->Status & WM_SF_ISVIS) {
000cec  8ba0              LDRH     r0,[r4,#0x1c]
000cee  f0100f02          TST      r0,#2
000cf2  d026              BEQ      |L1.3394|
;;;1381       for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000cf4  f9b46018          LDRSH    r6,[r4,#0x18]
000cf8  e021              B        |L1.3390|
                  |L1.3322|
;;;1382         pChild = WM_H2P(hChild);
000cfa  4630              MOV      r0,r6
000cfc  f7fffffe          BL       GUI_ALLOC_h2p
000d00  4605              MOV      r5,r0
;;;1383         if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
000d02  8ba8              LDRH     r0,[r5,#0x1c]
000d04  f0000003          AND      r0,r0,#3
000d08  2803              CMP      r0,#3
000d0a  d116              BNE      |L1.3386|
;;;1384   		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
;;;1385           /* Set invalid area of the window to draw */
;;;1386           if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
000d0c  f1040108          ADD      r1,r4,#8
000d10  4628              MOV      r0,r5
000d12  f7fffffe          BL       GUI_RectsIntersect
000d16  b180              CBZ      r0,|L1.3386|
;;;1387             GUI_RECT InvalidRectPrev;
;;;1388             InvalidRectPrev = pWin->InvalidRect;
000d18  68a0              LDR      r0,[r4,#8]
000d1a  9000              STR      r0,[sp,#0]
000d1c  68e0              LDR      r0,[r4,#0xc]
000d1e  9001              STR      r0,[sp,#4]
;;;1389             if(_Paint1Trans(hChild, pChild)) {
000d20  4629              MOV      r1,r5
000d22  4630              MOV      r0,r6
000d24  f7fffffe          BL       _Paint1Trans
000d28  b110              CBZ      r0,|L1.3376|
;;;1390               _PaintTransChildren(pChild);
000d2a  4628              MOV      r0,r5
000d2c  f7fffffe          BL       _PaintTransChildren
                  |L1.3376|
;;;1391             }
;;;1392             pWin->InvalidRect = InvalidRectPrev;
000d30  9800              LDR      r0,[sp,#0]
000d32  60a0              STR      r0,[r4,#8]
000d34  9801              LDR      r0,[sp,#4]
000d36  60e0              STR      r0,[r4,#0xc]
;;;1393           }
000d38  bf00              NOP      
                  |L1.3386|
000d3a  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;1381
                  |L1.3390|
000d3e  2e00              CMP      r6,#0                 ;1381
000d40  d1db              BNE      |L1.3322|
                  |L1.3394|
;;;1394         }
;;;1395       }
;;;1396     }
;;;1397   }
000d42  bd7c              POP      {r2-r6,pc}
;;;1398   #endif
                          ENDP

                  _PaintTransTopSiblings PROC
;;;1411   #if WM_SUPPORT_TRANSPARENCY
;;;1412   static void _PaintTransTopSiblings(WM_HWIN hWin, WM_Obj* pWin) {
000d44  e92d41f0          PUSH     {r4-r8,lr}
000d48  4606              MOV      r6,r0
000d4a  460c              MOV      r4,r1
;;;1413     WM_HWIN hParent;
;;;1414     WM_Obj* pParent;
;;;1415     hParent = pWin->hParent;
000d4c  f9b47016          LDRSH    r7,[r4,#0x16]
;;;1416     hWin = pWin->hNext;
000d50  f9b4601a          LDRSH    r6,[r4,#0x1a]
;;;1417     while (hParent) { /* Go hierarchy up to desktop window */
000d54  e01c              B        |L1.3472|
                  |L1.3414|
;;;1418       for (; hWin; hWin = pWin->hNext) {
000d56  e011              B        |L1.3452|
                  |L1.3416|
;;;1419         pWin = WM_H2P(hWin);
000d58  4630              MOV      r0,r6
000d5a  f7fffffe          BL       GUI_ALLOC_h2p
000d5e  4604              MOV      r4,r0
;;;1420         /* paint window if it is transparent & visible */
;;;1421         if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_ISVIS)) ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
000d60  8ba0              LDRH     r0,[r4,#0x1c]
000d62  f0000003          AND      r0,r0,#3
000d66  2803              CMP      r0,#3
000d68  d103              BNE      |L1.3442|
;;;1422           _Paint1Trans(hWin, pWin);
000d6a  4621              MOV      r1,r4
000d6c  4630              MOV      r0,r6
000d6e  f7fffffe          BL       _Paint1Trans
                  |L1.3442|
;;;1423         }
;;;1424         /* paint transparent & visible children */
;;;1425         _PaintTransChildren(pWin);
000d72  4620              MOV      r0,r4
000d74  f7fffffe          BL       _PaintTransChildren
000d78  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;1418
                  |L1.3452|
000d7c  2e00              CMP      r6,#0                 ;1418
000d7e  d1eb              BNE      |L1.3416|
;;;1426       }
;;;1427       pParent = WM_H2P(hParent);
000d80  4638              MOV      r0,r7
000d82  f7fffffe          BL       GUI_ALLOC_h2p
000d86  4605              MOV      r5,r0
;;;1428       hWin = pParent->hNext;
000d88  f9b5601a          LDRSH    r6,[r5,#0x1a]
;;;1429       hParent = pParent->hParent;
000d8c  f9b57016          LDRSH    r7,[r5,#0x16]
                  |L1.3472|
000d90  2f00              CMP      r7,#0                 ;1417
000d92  d1e0              BNE      |L1.3414|
;;;1430     }
;;;1431   }
000d94  e8bd81f0          POP      {r4-r8,pc}
;;;1432   #endif
                          ENDP

                  WM__PaintWinAndOverlays PROC
;;;1453   */
;;;1454   void WM__PaintWinAndOverlays(WM_PAINTINFO* pInfo) {
000d98  b570              PUSH     {r4-r6,lr}
000d9a  4604              MOV      r4,r0
;;;1455     WM_HWIN hWin;
;;;1456     WM_Obj* pWin;
;;;1457     hWin = pInfo->hWin;
000d9c  f9b46000          LDRSH    r6,[r4,#0]
;;;1458     pWin = pInfo->pWin;
000da0  6865              LDR      r5,[r4,#4]
;;;1459     #if WM_SUPPORT_TRANSPARENCY
;;;1460       /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
;;;1461       if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
000da2  8ba8              LDRH     r0,[r5,#0x1c]
000da4  f6400101          MOV      r1,#0x801
000da8  ea000001          AND      r0,r0,r1
000dac  2801              CMP      r0,#1
000dae  d003              BEQ      |L1.3512|
;;;1462     #endif
;;;1463     _Paint1(hWin, pWin);    /* Draw the window itself */
000db0  4629              MOV      r1,r5
000db2  4630              MOV      r0,r6
000db4  f7fffffe          BL       _Paint1
                  |L1.3512|
;;;1464     #if WM_SUPPORT_TRANSPARENCY
;;;1465       }
;;;1466       if (WM__TransWindowCnt != 0) {
000db8  48b5              LDR      r0,|L1.4240|
000dba  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
000dbc  b130              CBZ      r0,|L1.3532|
;;;1467         _PaintTransChildren(pWin);       /* Draw all transparent children */
000dbe  4628              MOV      r0,r5
000dc0  f7fffffe          BL       _PaintTransChildren
;;;1468         _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
000dc4  4629              MOV      r1,r5
000dc6  4630              MOV      r0,r6
000dc8  f7fffffe          BL       _PaintTransTopSiblings
                  |L1.3532|
;;;1469       }
;;;1470     #endif
;;;1471   }
000dcc  bd70              POP      {r4-r6,pc}
;;;1472   
                          ENDP

                  _cbPaintMemDev PROC
;;;1485   #if GUI_SUPPORT_MEMDEV
;;;1486   static void _cbPaintMemDev(void* p) {
000dce  b57c              PUSH     {r2-r6,lr}
000dd0  4605              MOV      r5,r0
;;;1487     GUI_RECT Rect;
;;;1488     WM_Obj* pWin = WM_H2P(GUI_Context.hAWin);
000dd2  49ae              LDR      r1,|L1.4236|
000dd4  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
000dd8  f7fffffe          BL       GUI_ALLOC_h2p
000ddc  4604              MOV      r4,r0
;;;1489     Rect = pWin->InvalidRect;
000dde  68a0              LDR      r0,[r4,#8]
000de0  9000              STR      r0,[sp,#0]
000de2  68e0              LDR      r0,[r4,#0xc]
000de4  9001              STR      r0,[sp,#4]
;;;1490     pWin->InvalidRect = GUI_Context.ClipRect;
000de6  48a9              LDR      r0,|L1.4236|
000de8  6841              LDR      r1,[r0,#4]  ; GUI_Context
000dea  60a1              STR      r1,[r4,#8]
000dec  6880              LDR      r0,[r0,#8]  ; GUI_Context
000dee  60e0              STR      r0,[r4,#0xc]
;;;1491     WM__PaintWinAndOverlays((WM_PAINTINFO*)p);
000df0  4628              MOV      r0,r5
000df2  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1492     pWin->InvalidRect = Rect;
000df6  9800              LDR      r0,[sp,#0]
000df8  60a0              STR      r0,[r4,#8]
000dfa  9801              LDR      r0,[sp,#4]
000dfc  60e0              STR      r0,[r4,#0xc]
;;;1493   }
000dfe  bd7c              POP      {r2-r6,pc}
;;;1494   #endif
                          ENDP

                  _Paint PROC
;;;1502   */
;;;1503   static int _Paint(WM_HWIN hWin, WM_Obj* pWin) {
000e00  b5f0              PUSH     {r4-r7,lr}
000e02  b085              SUB      sp,sp,#0x14
000e04  4605              MOV      r5,r0
000e06  460c              MOV      r4,r1
;;;1504     int Ret = 0;
000e08  f04f0600          MOV      r6,#0
;;;1505     if (pWin->Status & WM_SF_INVALID) {
000e0c  8ba0              LDRH     r0,[r4,#0x1c]
000e0e  f0100f20          TST      r0,#0x20
000e12  d03d              BEQ      |L1.3728|
;;;1506       if (pWin->cb) {
000e14  6920              LDR      r0,[r4,#0x10]
000e16  b348              CBZ      r0,|L1.3692|
;;;1507         if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
000e18  4629              MOV      r1,r5
000e1a  f1040008          ADD      r0,r4,#8
000e1e  f7fffffe          BL       WM__ClipAtParentBorders
000e22  b318              CBZ      r0,|L1.3692|
;;;1508           WM_PAINTINFO Info;
;;;1509           Info.hWin = hWin;
000e24  f8ad500c          STRH     r5,[sp,#0xc]
;;;1510           Info.pWin = pWin;
000e28  9404              STR      r4,[sp,#0x10]
;;;1511           WM_SelectWindow(hWin);
000e2a  4628              MOV      r0,r5
000e2c  f7fffffe          BL       WM_SelectWindow
;;;1512           #if GUI_SUPPORT_MEMDEV
;;;1513             if (pWin->Status & WM_SF_MEMDEV) {
000e30  8ba0              LDRH     r0,[r4,#0x1c]
000e32  f0100f04          TST      r0,#4
000e36  d013              BEQ      |L1.3680|
;;;1514               int Flags;
;;;1515               GUI_RECT r = pWin->InvalidRect;
000e38  68a0              LDR      r0,[r4,#8]
000e3a  9001              STR      r0,[sp,#4]
000e3c  68e0              LDR      r0,[r4,#0xc]
000e3e  9002              STR      r0,[sp,#8]
;;;1516               Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
000e40  8ba0              LDRH     r0,[r4,#0x1c]
000e42  f0000001          AND      r0,r0,#1
000e46  f0800701          EOR      r7,r0,#1
;;;1517               /*
;;;1518                * Currently we treat a desktop window as transparent, because per default it does not repaint itself.
;;;1519                */
;;;1520               if (pWin->hParent == 0) {
000e4a  8ae0              LDRH     r0,[r4,#0x16]
000e4c  b900              CBNZ     r0,|L1.3664|
;;;1521                 Flags = GUI_MEMDEV_HASTRANS;
000e4e  4637              MOV      r7,r6
                  |L1.3664|
;;;1522               }
;;;1523               GUI_MEMDEV_Draw(&r, _cbPaintMemDev, &Info, 0, Flags);
000e50  2300              MOVS     r3,#0
000e52  aa03              ADD      r2,sp,#0xc
000e54  498f              LDR      r1,|L1.4244|
000e56  a801              ADD      r0,sp,#4
000e58  9700              STR      r7,[sp,#0]
000e5a  f7fffffe          BL       GUI_MEMDEV_Draw
;;;1524             } else
000e5e  e004              B        |L1.3690|
                  |L1.3680|
;;;1525           #endif
;;;1526           {
;;;1527             WM__PaintWinAndOverlays(&Info);
000e60  a803              ADD      r0,sp,#0xc
000e62  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1528             Ret = 1;    /* Something has been done */
000e66  f04f0601          MOV      r6,#1
                  |L1.3690|
;;;1529           }
;;;1530         }
000e6a  bf00              NOP      
                  |L1.3692|
;;;1531       }
;;;1532       /* We purposly clear the invalid flag after painting so we can still query the invalid rectangle while painting */
;;;1533       pWin->Status &=  ~WM_SF_INVALID; /* Clear invalid flag */
000e6c  8ba0              LDRH     r0,[r4,#0x1c]
000e6e  f0200020          BIC      r0,r0,#0x20
000e72  83a0              STRH     r0,[r4,#0x1c]
;;;1534       if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
000e74  8ba0              LDRH     r0,[r4,#0x1c]
000e76  f4105f00          TST      r0,#0x2000
000e7a  d003              BEQ      |L1.3716|
;;;1535         pWin->Status |= WM_CF_MEMDEV;
000e7c  8ba0              LDRH     r0,[r4,#0x1c]
000e7e  f0400004          ORR      r0,r0,#4
000e82  83a0              STRH     r0,[r4,#0x1c]
                  |L1.3716|
;;;1536       }
;;;1537       WM__NumInvalidWindows--;
000e84  4884              LDR      r0,|L1.4248|
000e86  8800              LDRH     r0,[r0,#0]  ; WM__NumInvalidWindows
000e88  f1a00001          SUB      r0,r0,#1
000e8c  4982              LDR      r1,|L1.4248|
000e8e  8008              STRH     r0,[r1,#0]
                  |L1.3728|
;;;1538     }
;;;1539     return Ret;      /* Nothing done */
000e90  4630              MOV      r0,r6
;;;1540   }
000e92  b005              ADD      sp,sp,#0x14
000e94  bdf0              POP      {r4-r7,pc}
;;;1541   
                          ENDP

                  _DrawNext PROC
;;;1545   */
;;;1546   static void _DrawNext(void) {
000e96  b570              PUSH     {r4-r6,lr}
000e98  b098              SUB      sp,sp,#0x60
;;;1547     int UpdateRem = 1;
000e9a  f04f0601          MOV      r6,#1
;;;1548     WM_HWIN iWin = (NextDrawWin == WM_HWIN_NULL) ? WM__FirstWin : NextDrawWin;
000e9e  487f              LDR      r0,|L1.4252|
000ea0  8800              LDRH     r0,[r0,#0]  ; NextDrawWin
000ea2  b918              CBNZ     r0,|L1.3756|
000ea4  487e              LDR      r0,|L1.4256|
000ea6  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
000eaa  e002              B        |L1.3762|
                  |L1.3756|
000eac  487b              LDR      r0,|L1.4252|
000eae  f9b00000          LDRSH    r0,[r0,#0]  ; NextDrawWin
                  |L1.3762|
000eb2  4604              MOV      r4,r0
;;;1549     GUI_CONTEXT ContextOld;
;;;1550     GUI_SaveContext(&ContextOld);
000eb4  4668              MOV      r0,sp
000eb6  f7fffffe          BL       GUI_SaveContext_W_M
;;;1551     /* Make sure the next window to redraw is valid */
;;;1552     for (; iWin && UpdateRem; ) {
000eba  e00d              B        |L1.3800|
                  |L1.3772|
;;;1553       WM_Obj* pWin = WM_H2P(iWin);
000ebc  4620              MOV      r0,r4
000ebe  f7fffffe          BL       GUI_ALLOC_h2p
000ec2  4605              MOV      r5,r0
;;;1554       if (_Paint(iWin, pWin)) {
000ec4  4629              MOV      r1,r5
000ec6  4620              MOV      r0,r4
000ec8  f7fffffe          BL       _Paint
000ecc  b108              CBZ      r0,|L1.3794|
;;;1555         UpdateRem--;  /* Only the given number of windows at a time ... */
000ece  f1a60601          SUB      r6,r6,#1
                  |L1.3794|
;;;1556       }
;;;1557       iWin = pWin->hNextLin;
000ed2  f9b54014          LDRSH    r4,[r5,#0x14]
;;;1558     }  
000ed6  bf00              NOP      
                  |L1.3800|
000ed8  b10c              CBZ      r4,|L1.3806|
000eda  2e00              CMP      r6,#0                 ;1552
000edc  d1ee              BNE      |L1.3772|
                  |L1.3806|
;;;1559     NextDrawWin = iWin;   /* Remember the window */
000ede  486f              LDR      r0,|L1.4252|
000ee0  8004              STRH     r4,[r0,#0]
;;;1560     GUI_RestoreContext(&ContextOld);
000ee2  4668              MOV      r0,sp
000ee4  f7fffffe          BL       GUI_RestoreContext
;;;1561   }
000ee8  b018              ADD      sp,sp,#0x60
000eea  bd70              POP      {r4-r6,pc}
;;;1562   
                          ENDP

                  WM_Exec1 PROC
;;;1566   */
;;;1567   int WM_Exec1(void) {
000eec  b510              PUSH     {r4,lr}
;;;1568     /* Poll PID if necessary */
;;;1569     if (WM_pfPollPID) {
000eee  486d              LDR      r0,|L1.4260|
000ef0  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000ef2  b110              CBZ      r0,|L1.3834|
;;;1570       WM_pfPollPID();
000ef4  486b              LDR      r0,|L1.4260|
000ef6  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000ef8  4780              BLX      r0
                  |L1.3834|
;;;1571     }
;;;1572     if (WM_pfHandlePID) {
000efa  486b              LDR      r0,|L1.4264|
000efc  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000efe  b128              CBZ      r0,|L1.3852|
;;;1573       if (WM_pfHandlePID())
000f00  4869              LDR      r0,|L1.4264|
000f02  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000f04  4780              BLX      r0
000f06  b108              CBZ      r0,|L1.3852|
;;;1574         return 1;               /* We have done something ... */
000f08  2001              MOVS     r0,#1
                  |L1.3850|
;;;1575     }
;;;1576     if (GUI_PollKeyMsg()) {
;;;1577       return 1;               /* We have done something ... */
;;;1578     }
;;;1579     if (WM_IsActive && WM__NumInvalidWindows) {
;;;1580       WM_LOCK();
;;;1581       _DrawNext();
;;;1582       WM_UNLOCK();
;;;1583       return 1;               /* We have done something ... */
;;;1584     }
;;;1585     return 0;                  /* There was nothing to do ... */
;;;1586   }
000f0a  bd10              POP      {r4,pc}
                  |L1.3852|
000f0c  f7fffffe          BL       GUI_PollKeyMsg
000f10  b108              CBZ      r0,|L1.3862|
000f12  2001              MOVS     r0,#1                 ;1577
000f14  e7f9              B        |L1.3850|
                  |L1.3862|
000f16  4865              LDR      r0,|L1.4268|
000f18  7800              LDRB     r0,[r0,#0]            ;1579  ; WM_IsActive
000f1a  b130              CBZ      r0,|L1.3882|
000f1c  485e              LDR      r0,|L1.4248|
000f1e  8800              LDRH     r0,[r0,#0]            ;1579  ; WM__NumInvalidWindows
000f20  b118              CBZ      r0,|L1.3882|
000f22  f7fffffe          BL       _DrawNext
000f26  2001              MOVS     r0,#1                 ;1583
000f28  e7ef              B        |L1.3850|
                  |L1.3882|
000f2a  2000              MOVS     r0,#0                 ;1585
000f2c  e7ed              B        |L1.3850|
;;;1587   
                          ENDP

                  WM_Exec PROC
;;;1591   */
;;;1592   int WM_Exec(void) {
000f2e  b510              PUSH     {r4,lr}
;;;1593     int r = 0;
000f30  f04f0400          MOV      r4,#0
;;;1594     while (WM_Exec1()) {
000f34  e001              B        |L1.3898|
                  |L1.3894|
;;;1595       r = 1;                  /* We have done something */
000f36  f04f0401          MOV      r4,#1
                  |L1.3898|
000f3a  f7fffffe          BL       WM_Exec1
000f3e  2800              CMP      r0,#0                 ;1594
000f40  d1f9              BNE      |L1.3894|
;;;1596     }
;;;1597     return r;
000f42  4620              MOV      r0,r4
;;;1598   }
000f44  bd10              POP      {r4,pc}
;;;1599   
                          ENDP

                  WM_DefaultProc PROC
;;;1663   */
;;;1664   void WM_DefaultProc(WM_MESSAGE* pMsg) {
000f46  e92d41f0          PUSH     {r4-r8,lr}
000f4a  4604              MOV      r4,r0
;;;1665     WM_HWIN hWin = pMsg->hWin;
000f4c  f9b45004          LDRSH    r5,[r4,#4]
;;;1666     const void *p = pMsg->Data.p;
000f50  68a6              LDR      r6,[r4,#8]
;;;1667     WM_Obj* pWin = WM_H2P(hWin);
000f52  4628              MOV      r0,r5
000f54  f7fffffe          BL       GUI_ALLOC_h2p
000f58  4607              MOV      r7,r0
;;;1668     /* Exec message */
;;;1669     switch (pMsg->MsgId) {
000f5a  6820              LDR      r0,[r4,#0]
000f5c  2817              CMP      r0,#0x17
000f5e  d00f              BEQ      |L1.3968|
000f60  dc04              BGT      |L1.3948|
000f62  280e              CMP      r0,#0xe
000f64  d00f              BEQ      |L1.3974|
000f66  2814              CMP      r0,#0x14
000f68  d11a              BNE      |L1.4000|
000f6a  e004              B        |L1.3958|
                  |L1.3948|
000f6c  2822              CMP      r0,#0x22
000f6e  d00f              BEQ      |L1.3984|
000f70  2828              CMP      r0,#0x28
000f72  d115              BNE      |L1.4000|
000f74  e010              B        |L1.3992|
                  |L1.3958|
;;;1670     case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
;;;1671       WM__GetClientRectWin(pWin, (GUI_RECT*)p);
000f76  4631              MOV      r1,r6
000f78  4638              MOV      r0,r7
000f7a  f7fffffe          BL       WM__GetClientRectWin
;;;1672       break;
000f7e  e00f              B        |L1.4000|
                  |L1.3968|
;;;1673     case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
;;;1674       pMsg->Data.v = (int)hWin;
000f80  60a5              STR      r5,[r4,#8]
                  |L1.3970|
;;;1675       return;                       /* Message handled */
;;;1676     case WM_KEY:
;;;1677       WM_SendToParent(hWin, pMsg);
;;;1678       return;                       /* Message handled */
;;;1679      case WM_GET_BKCOLOR:
;;;1680       pMsg->Data.Color = GUI_INVALID_COLOR;
;;;1681       return;                       /* Message handled */
;;;1682     case WM_NOTIFY_ENABLE:
;;;1683       WM_InvalidateWindow(hWin);    
;;;1684       return;                       /* Message handled */
;;;1685     }
;;;1686     /* Message not handled. If it queries something, we return 0 to be on the safe side. */
;;;1687     pMsg->Data.v = 0;
;;;1688     pMsg->Data.p = 0;
;;;1689   }
000f82  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3974|
000f86  4621              MOV      r1,r4                 ;1677
000f88  4628              MOV      r0,r5                 ;1677
000f8a  f7fffffe          BL       WM_SendToParent
000f8e  e7f8              B        |L1.3970|
                  |L1.3984|
000f90  f06f4070          MVN      r0,#0xf0000000        ;1680
000f94  60a0              STR      r0,[r4,#8]            ;1680
000f96  e7f4              B        |L1.3970|
                  |L1.3992|
000f98  4628              MOV      r0,r5                 ;1683
000f9a  f7fffffe          BL       WM_InvalidateWindow
000f9e  e7f0              B        |L1.3970|
                  |L1.4000|
000fa0  bf00              NOP                            ;1672
000fa2  f04f0000          MOV      r0,#0                 ;1687
000fa6  60a0              STR      r0,[r4,#8]            ;1687
000fa8  60a0              STR      r0,[r4,#8]            ;1688
000faa  bf00              NOP      
000fac  e7e9              B        |L1.3970|
;;;1690   
                          ENDP

                  cbBackWin PROC
;;;1607   */
;;;1608   static void cbBackWin( WM_MESSAGE* pMsg) {
000fae  b570              PUSH     {r4-r6,lr}
000fb0  4604              MOV      r4,r0
;;;1609     const WM_KEY_INFO* pKeyInfo;
;;;1610     switch (pMsg->MsgId) {
000fb2  6820              LDR      r0,[r4,#0]
000fb4  280e              CMP      r0,#0xe
000fb6  d002              BEQ      |L1.4030|
000fb8  280f              CMP      r0,#0xf
000fba  d119              BNE      |L1.4080|
000fbc  e007              B        |L1.4046|
                  |L1.4030|
;;;1611     case WM_KEY:
;;;1612       pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
000fbe  68a5              LDR      r5,[r4,#8]
;;;1613       if (pKeyInfo->PressedCnt == 1) {
000fc0  6868              LDR      r0,[r5,#4]
000fc2  2801              CMP      r0,#1
000fc4  d102              BNE      |L1.4044|
;;;1614         GUI_StoreKey(pKeyInfo->Key);
000fc6  6828              LDR      r0,[r5,#0]
000fc8  f7fffffe          BL       GUI_StoreKey
                  |L1.4044|
;;;1615       }
;;;1616       break;
000fcc  e014              B        |L1.4088|
                  |L1.4046|
;;;1617     case WM_PAINT:
;;;1618       {
;;;1619         int LayerIndex;
;;;1620         #if GUI_NUM_LAYERS > 1
;;;1621           LayerIndex = _DesktopHandle2Index(pMsg->hWin);
;;;1622         #else
;;;1623           LayerIndex = 0;
000fce  f04f0600          MOV      r6,#0
;;;1624         #endif
;;;1625         if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
000fd2  4837              LDR      r0,|L1.4272|
000fd4  f8500026          LDR      r0,[r0,r6,LSL #2]
000fd8  f06f4170          MVN      r1,#0xf0000000
000fdc  4288              CMP      r0,r1
000fde  d006              BEQ      |L1.4078|
;;;1626           GUI_SetBkColor(WM__aBkColor[LayerIndex]);
000fe0  4933              LDR      r1,|L1.4272|
000fe2  f8510026          LDR      r0,[r1,r6,LSL #2]
000fe6  f7fffffe          BL       GUI_SetBkColor
;;;1627           GUI_Clear();
000fea  f7fffffe          BL       GUI_Clear
                  |L1.4078|
;;;1628         }
;;;1629       }
;;;1630     default:
000fee  bf00              NOP      
                  |L1.4080|
;;;1631       WM_DefaultProc(pMsg);
000ff0  4620              MOV      r0,r4
000ff2  f7fffffe          BL       WM_DefaultProc
000ff6  bf00              NOP                            ;1610
                  |L1.4088|
000ff8  bf00              NOP                            ;1616
;;;1632     }
;;;1633   }
000ffa  bd70              POP      {r4-r6,pc}
;;;1634   
                          ENDP

                  WM_Activate PROC
;;;1638   */
;;;1639   void WM_Activate(void) {
000ffc  f04f0001          MOV      r0,#1
;;;1640     WM_IsActive = 1;       /* Running */
001000  492a              LDR      r1,|L1.4268|
001002  7008              STRB     r0,[r1,#0]
;;;1641   }
001004  4770              BX       lr
;;;1642   
                          ENDP

                  WM_Deactivate PROC
;;;1646   */
;;;1647   void WM_Deactivate(void) {
001006  b510              PUSH     {r4,lr}
;;;1648     WM_IsActive = 0;       /* No clipping performed by WM */
001008  f04f0000          MOV      r0,#0
00100c  4927              LDR      r1,|L1.4268|
00100e  7008              STRB     r0,[r1,#0]
;;;1649     WM_LOCK();
;;;1650     LCD_SetClipRectMax();
001010  f7fffffe          BL       LCD_SetClipRectMax
;;;1651     WM_UNLOCK();
;;;1652   }
001014  bd10              POP      {r4,pc}
;;;1653   
                          ENDP

                  WM_Init PROC
;;;1694   */
;;;1695   void WM_Init(void) {
001016  b50e              PUSH     {r1-r3,lr}
;;;1696   	if (!_IsInited) {
001018  4826              LDR      r0,|L1.4276|
00101a  7800              LDRB     r0,[r0,#0]  ; _IsInited
00101c  bb98              CBNZ     r0,|L1.4230|
;;;1697   	  NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
00101e  f04f0000          MOV      r0,#0
001022  491f              LDR      r1,|L1.4256|
001024  8008              STRH     r0,[r1,#0]
001026  491d              LDR      r1,|L1.4252|
001028  8008              STRH     r0,[r1,#0]
;;;1698   	  GUI_Context.WM__pUserClipRect = NULL;
00102a  4918              LDR      r1,|L1.4236|
00102c  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1699   	  WM__NumWindows = WM__NumInvalidWindows =0;
00102e  491a              LDR      r1,|L1.4248|
001030  8008              STRH     r0,[r1,#0]
001032  4921              LDR      r1,|L1.4280|
001034  8008              STRH     r0,[r1,#0]
;;;1700   	  /* Make sure we have at least one window. This greatly simplifies the
;;;1701   		  drawing routines as they do not have to check if the window is valid.
;;;1702   	  */
;;;1703       #if GUI_NUM_LAYERS == 1
;;;1704         WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
001036  4921              LDR      r1,|L1.4284|
001038  f04f0202          MOV      r2,#2
00103c  f64073ff          MOV      r3,#0xfff
001040  e9cd2100          STRD     r2,r1,[sp,#0]
001044  9002              STR      r0,[sp,#8]
001046  461a              MOV      r2,r3
001048  4601              MOV      r1,r0
00104a  f7fffffe          BL       WM_CreateWindow
00104e  491c              LDR      r1,|L1.4288|
001050  8008              STRH     r0,[r1,#0]
;;;1705         WM__aBkColor[0] = GUI_INVALID_COLOR;
001052  f06f4070          MVN      r0,#0xf0000000
001056  4916              LDR      r1,|L1.4272|
001058  6008              STR      r0,[r1,#0]  ; WM__aBkColor
;;;1706         WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
00105a  4919              LDR      r1,|L1.4288|
00105c  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
001060  f7fffffe          BL       WM_InvalidateWindow
;;;1707       #else
;;;1708       {
;;;1709         int i;
;;;1710         for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;1711           WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
;;;1712           WM__aBkColor[i] = GUI_INVALID_COLOR;
;;;1713           WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
;;;1714         }
;;;1715       }
;;;1716       #endif
;;;1717       /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
;;;1718       WM__AddCriticalHandle(&WM__CHWinModal);
001064  4817              LDR      r0,|L1.4292|
001066  f7fffffe          BL       WM__AddCriticalHandle
;;;1719       WM__AddCriticalHandle(&WM__CHWinLast);
00106a  4817              LDR      r0,|L1.4296|
00106c  f7fffffe          BL       WM__AddCriticalHandle
;;;1720   
;;;1721       WM_SelectWindow(WM__ahDesktopWin[0]);
001070  4913              LDR      r1,|L1.4288|
001072  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
001076  f7fffffe          BL       WM_SelectWindow
;;;1722   	  WM_Activate();
00107a  f7fffffe          BL       WM_Activate
;;;1723       _IsInited =1;
00107e  f04f0001          MOV      r0,#1
001082  490c              LDR      r1,|L1.4276|
001084  7008              STRB     r0,[r1,#0]
                  |L1.4230|
;;;1724   	}
;;;1725   }
001086  bd0e              POP      {r1-r3,pc}
;;;1726   
                          ENDP

                  |L1.4232|
                          DCD      WM__hATransWindow
                  |L1.4236|
                          DCD      GUI_Context
                  |L1.4240|
                          DCD      WM__TransWindowCnt
                  |L1.4244|
                          DCD      _cbPaintMemDev
                  |L1.4248|
                          DCD      WM__NumInvalidWindows
                  |L1.4252|
                          DCD      NextDrawWin
                  |L1.4256|
                          DCD      WM__FirstWin
                  |L1.4260|
                          DCD      WM_pfPollPID
                  |L1.4264|
                          DCD      WM_pfHandlePID
                  |L1.4268|
                          DCD      WM_IsActive
                  |L1.4272|
                          DCD      WM__aBkColor
                  |L1.4276|
                          DCD      _IsInited
                  |L1.4280|
                          DCD      WM__NumWindows
                  |L1.4284|
                          DCD      cbBackWin
                  |L1.4288|
                          DCD      WM__ahDesktopWin
                  |L1.4292|
                          DCD      WM__CHWinModal
                  |L1.4296|
                          DCD      WM__CHWinLast

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  WM_PID__StateLast
                          %        12
                  _ClipContext
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  WM__NumWindows
000000  0000              DCB      0x00,0x00
                  WM__NumInvalidWindows
000002  0000              DCB      0x00,0x00
                  WM__FirstWin
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__pFirstCriticalHandle
                          DCD      0x00000000
                  WM__ahDesktopWin
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__aBkColor
                          DCD      0x00000000
                  WM_IsActive
000014  0000              DCB      0x00,0x00
                  WM__CreateFlags
000016  0000              DCB      0x00,0x00
                  WM__hCapture
000018  0000              DCB      0x00,0x00
                  WM__hWinFocus
00001a  0000              DCB      0x00,0x00
                  WM__CaptureReleaseAuto
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM_pfPollPID
                          DCD      0x00000000
                  WM__PaintCallbackCnt
000024  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__TransWindowCnt
                          DCD      0x00000000
                  WM__hATransWindow
00002c  0000              DCB      0x00,0x00
                  NextDrawWin
00002e  0000              DCB      0x00,0x00
                  _IsInited
000030  00                DCB      0x00
