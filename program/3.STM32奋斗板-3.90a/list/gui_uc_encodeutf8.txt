; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\gui_uc_encodeutf8.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\gui_uc_encodeutf8.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\gui_uc_encodeutf8.crf GUI\Core\GUI_UC_EncodeUTF8.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _GetCharCode PROC
;;;34     */
;;;35     static U16 _GetCharCode(const char GUI_UNI_PTR * s) {
000000  4602              MOV      r2,r0
;;;36       U16 r;
;;;37       U8 Char = *(const U8*)s;
000002  7811              LDRB     r1,[r2,#0]
;;;38       if ((Char & 0x80) == 0) {                /* Single byte (ASCII)  */
000004  f0110f80          TST      r1,#0x80
000008  d101              BNE      |L1.14|
;;;39         r = Char;
00000a  4608              MOV      r0,r1
00000c  e02b              B        |L1.102|
                  |L1.14|
;;;40       } else if ((Char & 0xe0) == 0xc0) {      /* Double byte sequence */
00000e  f00103e0          AND      r3,r1,#0xe0
000012  2bc0              CMP      r3,#0xc0
000014  d10c              BNE      |L1.48|
;;;41         r = (Char & 0x1f) << 6;
000016  ea4f63c1          LSL      r3,r1,#27
00001a  ea4f5053          LSR      r0,r3,#21
;;;42         Char = *(++s);
00001e  f1020301          ADD      r3,r2,#1
000022  461a              MOV      r2,r3
000024  7819              LDRB     r1,[r3,#0]
;;;43         Char &= 0x3f;
000026  f001013f          AND      r1,r1,#0x3f
;;;44         r |= Char;
00002a  ea400001          ORR      r0,r0,r1
00002e  e01a              B        |L1.102|
                  |L1.48|
;;;45       } else if ((Char & 0xf0) == 0xe0) {      /* 3 byte sequence      */
000030  f00103f0          AND      r3,r1,#0xf0
000034  2be0              CMP      r3,#0xe0
000036  d114              BNE      |L1.98|
;;;46         r = (Char & 0x0f) << 12;
000038  ea4f7301          LSL      r3,r1,#28
00003c  ea4f4013          LSR      r0,r3,#16
;;;47         Char = *(++s);
000040  f1020301          ADD      r3,r2,#1
000044  461a              MOV      r2,r3
000046  7819              LDRB     r1,[r3,#0]
;;;48         Char &= 0x3f;
000048  f001013f          AND      r1,r1,#0x3f
;;;49         r |= (Char << 6);
00004c  ea401081          ORR      r0,r0,r1,LSL #6
;;;50         Char = *(++s);
000050  f1020301          ADD      r3,r2,#1
000054  461a              MOV      r2,r3
000056  7819              LDRB     r1,[r3,#0]
;;;51         Char &= 0x3f;
000058  f001013f          AND      r1,r1,#0x3f
;;;52         r |= Char;
00005c  ea400001          ORR      r0,r0,r1
000060  e001              B        |L1.102|
                  |L1.98|
;;;53       } else {
;;;54         GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
;;;55         r = 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
000062  f04f0001          MOV      r0,#1
                  |L1.102|
;;;56       }
;;;57       return r;
;;;58     }
000066  4770              BX       lr
;;;59     
                          ENDP

                  _GetCharSize PROC
;;;66     */
;;;67     static int _GetCharSize(const char GUI_UNI_PTR * s) {
000068  4602              MOV      r2,r0
;;;68       U8 Char = *s;
00006a  7811              LDRB     r1,[r2,#0]
;;;69       if ((Char & 0x80) == 0) {
00006c  f0110f80          TST      r1,#0x80
000070  d101              BNE      |L1.118|
;;;70         return 1;
000072  2001              MOVS     r0,#1
                  |L1.116|
;;;71       } else if ((Char & 0xe0) == 0xc0) {
;;;72         return 2;
;;;73       } else if ((Char & 0xf0) == 0xe0) {
;;;74         return 3;
;;;75       }
;;;76       GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
;;;77       return 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
;;;78     }
000074  4770              BX       lr
                  |L1.118|
000076  f00100e0          AND      r0,r1,#0xe0           ;71
00007a  28c0              CMP      r0,#0xc0              ;71
00007c  d101              BNE      |L1.130|
00007e  2002              MOVS     r0,#2                 ;72
000080  e7f8              B        |L1.116|
                  |L1.130|
000082  f00100f0          AND      r0,r1,#0xf0           ;73
000086  28e0              CMP      r0,#0xe0              ;73
000088  d101              BNE      |L1.142|
00008a  2003              MOVS     r0,#3                 ;74
00008c  e7f2              B        |L1.116|
                  |L1.142|
00008e  2001              MOVS     r0,#1                 ;77
000090  e7f0              B        |L1.116|
;;;79     
                          ENDP

                  _CalcSizeOfChar PROC
;;;86     */
;;;87     static int _CalcSizeOfChar(U16 Char) {
000092  4601              MOV      r1,r0
;;;88       int r;
;;;89       if (Char & 0xF800) {                /* Single byte (ASCII)  */
000094  f4114f78          TST      r1,#0xf800
000098  d002              BEQ      |L1.160|
;;;90         r = 3;
00009a  f04f0003          MOV      r0,#3
00009e  e008              B        |L1.178|
                  |L1.160|
;;;91       } else if (Char & 0xFF80) {         /* Double byte sequence */
0000a0  f64f7280          MOV      r2,#0xff80
0000a4  4211              TST      r1,r2
0000a6  d002              BEQ      |L1.174|
;;;92         r = 2;
0000a8  f04f0002          MOV      r0,#2
0000ac  e001              B        |L1.178|
                  |L1.174|
;;;93       } else {                            /* 3 byte sequence      */
;;;94         r = 1;
0000ae  f04f0001          MOV      r0,#1
                  |L1.178|
;;;95       }
;;;96       return r;
;;;97     }
0000b2  4770              BX       lr
;;;98     
                          ENDP

                  _Encode PROC
;;;105    */
;;;106    static int _Encode(char *s, U16 Char) {
0000b4  b570              PUSH     {r4-r6,lr}
0000b6  4604              MOV      r4,r0
0000b8  460d              MOV      r5,r1
;;;107      int r;
;;;108      r = _CalcSizeOfChar(Char);
0000ba  4628              MOV      r0,r5
0000bc  f7fffffe          BL       _CalcSizeOfChar
0000c0  4606              MOV      r6,r0
;;;109      switch (r) {
0000c2  2e01              CMP      r6,#1
0000c4  d004              BEQ      |L1.208|
0000c6  2e02              CMP      r6,#2
0000c8  d004              BEQ      |L1.212|
0000ca  2e03              CMP      r6,#3
0000cc  d120              BNE      |L1.272|
0000ce  e00d              B        |L1.236|
                  |L1.208|
;;;110      case 1:
;;;111        *s = (char)Char;
0000d0  7025              STRB     r5,[r4,#0]
;;;112        break;
0000d2  e01d              B        |L1.272|
                  |L1.212|
;;;113      case 2:
;;;114        *s++ = 0xC0 | (Char >> 6);
0000d4  f04f00c0          MOV      r0,#0xc0
0000d8  ea4010a5          ORR      r0,r0,r5,ASR #6
0000dc  f8040b01          STRB     r0,[r4],#1
;;;115        *s   = 0x80 | (Char & 0x3F);
0000e0  f005003f          AND      r0,r5,#0x3f
0000e4  f0400080          ORR      r0,r0,#0x80
0000e8  7020              STRB     r0,[r4,#0]
;;;116        break;
0000ea  e011              B        |L1.272|
                  |L1.236|
;;;117      case 3:
;;;118        *s++ = 0xE0 | (Char >> 12);
0000ec  f04f00e0          MOV      r0,#0xe0
0000f0  ea403025          ORR      r0,r0,r5,ASR #12
0000f4  f8040b01          STRB     r0,[r4],#1
;;;119        *s++ = 0x80 | ((Char >> 6) & 0x3F);
0000f8  f3c51085          UBFX     r0,r5,#6,#6
0000fc  f0400080          ORR      r0,r0,#0x80
000100  f8040b01          STRB     r0,[r4],#1
;;;120        *s   = 0x80 | (Char & 0x3F);
000104  f005003f          AND      r0,r5,#0x3f
000108  f0400080          ORR      r0,r0,#0x80
00010c  7020              STRB     r0,[r4,#0]
;;;121        break;
00010e  bf00              NOP      
                  |L1.272|
000110  bf00              NOP                            ;112
;;;122      }
;;;123      return r;
000112  4630              MOV      r0,r6
;;;124    }
000114  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP

                  GUI_UC_SetEncodeUTF8 PROC
;;;146    */
;;;147    void GUI_UC_SetEncodeUTF8(void) {
000116  4802              LDR      r0,|L1.288|
;;;148      GUI_LOCK();
;;;149      GUI_Context.pUC_API = &_API_Table;
000118  4902              LDR      r1,|L1.292|
00011a  61c8              STR      r0,[r1,#0x1c]  ; GUI_Context
;;;150      GUI_UNLOCK();
;;;151    }
00011c  4770              BX       lr
;;;152    
                          ENDP

00011e  0000              DCW      0x0000
                  |L1.288|
                          DCD      _API_Table
                  |L1.292|
                          DCD      GUI_Context

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  _API_Table
                          DCD      _GetCharCode
                          DCD      _GetCharSize
                          DCD      _CalcSizeOfChar
                          DCD      _Encode
