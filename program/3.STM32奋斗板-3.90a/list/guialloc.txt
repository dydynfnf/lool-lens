; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\guialloc.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\guialloc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\guialloc.crf GUI\Core\GUIAlloc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _Size2LegalSize PROC
;;;135    */
;;;136    static GUI_ALLOC_DATATYPE _Size2LegalSize(GUI_ALLOC_DATATYPE size) {
000000  4601              MOV      r1,r0
;;;137      return (size + ((1 << GUI_BLOCK_ALIGN) - 1)) & ~((1 << GUI_BLOCK_ALIGN) - 1);
000002  f1010003          ADD      r0,r1,#3
000006  f0200003          BIC      r0,r0,#3
00000a  b200              SXTH     r0,r0
;;;138    }
00000c  4770              BX       lr
;;;139      
                          ENDP

                  _GetSize PROC
;;;143    */
;;;144    static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
00000e  4601              MOV      r1,r0
;;;145      return aBlock[hMem].Size;
000010  48ee              LDR      r0,|L1.972|
000012  eb0000c1          ADD      r0,r0,r1,LSL #3
000016  f9b00002          LDRSH    r0,[r0,#2]
;;;146    }
00001a  4770              BX       lr
;;;147    
                          ENDP

                  _Free PROC
;;;151    */
;;;152    static void _Free(GUI_HMEM hMem) {
00001c  b530              PUSH     {r4,r5,lr}
;;;153      GUI_ALLOC_DATATYPE Size;
;;;154      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;155      /* Do some error checking ... */
;;;156      #if GUI_DEBUG_LEVEL>0
;;;157        /* Block not allocated ? */
;;;158        if (aBlock[hMem].Size == 0) {
00001e  49eb              LDR      r1,|L1.972|
000020  eb0101c0          ADD      r1,r1,r0,LSL #3
000024  8849              LDRH     r1,[r1,#2]
000026  b901              CBNZ     r1,|L1.42|
                  |L1.40|
;;;159          GUI_DEBUG_ERROROUT("GUI_ALLOC_Free(): Invalid hMem");
;;;160          return;
;;;161        }
;;;162      #endif
;;;163      Size = aBlock[hMem].Size;
;;;164      #ifdef WIN32
;;;165        GUI_MEMSET(&GUI_Heap.abHeap[aBlock[hMem].Off], 0xcc, Size);
;;;166      #endif
;;;167      GUI_ALLOC.NumFreeBytes += Size;
;;;168      GUI_ALLOC.NumUsedBytes -= Size;
;;;169      aBlock[hMem].Size = 0;
;;;170      {
;;;171        int Next = aBlock[hMem].Next;
;;;172        int Prev = aBlock[hMem].Prev;
;;;173        aBlock[Prev].Next = Next;
;;;174        if (Next) {
;;;175          aBlock[Next].Prev = Prev;
;;;176        }
;;;177      }  
;;;178      GUI_ALLOC.NumFreeBlocks++;
;;;179      GUI_ALLOC.NumUsedBlocks--;
;;;180    }
000028  bd30              POP      {r4,r5,pc}
                  |L1.42|
00002a  49e8              LDR      r1,|L1.972|
00002c  eb0101c0          ADD      r1,r1,r0,LSL #3       ;163
000030  f9b12002          LDRSH    r2,[r1,#2]            ;163
000034  49e6              LDR      r1,|L1.976|
000036  89c9              LDRH     r1,[r1,#0xe]          ;167  ; GUI_ALLOC
000038  4411              ADD      r1,r1,r2              ;167
00003a  b209              SXTH     r1,r1                 ;167
00003c  4be4              LDR      r3,|L1.976|
00003e  81d9              STRH     r1,[r3,#0xe]          ;167
000040  4619              MOV      r1,r3                 ;168
000042  8989              LDRH     r1,[r1,#0xc]          ;168  ; GUI_ALLOC
000044  eba10102          SUB      r1,r1,r2              ;168
000048  b209              SXTH     r1,r1                 ;168
00004a  8199              STRH     r1,[r3,#0xc]          ;168
00004c  f04f0100          MOV      r1,#0                 ;169
000050  4bde              LDR      r3,|L1.972|
000052  eb0303c0          ADD      r3,r3,r0,LSL #3       ;169
000056  8059              STRH     r1,[r3,#2]            ;169
000058  4cdc              LDR      r4,|L1.972|
00005a  eb0404c0          ADD      r4,r4,r0,LSL #3       ;171
00005e  88a1              LDRH     r1,[r4,#4]            ;171
000060  4cda              LDR      r4,|L1.972|
000062  eb0404c0          ADD      r4,r4,r0,LSL #3       ;172
000066  88e3              LDRH     r3,[r4,#6]            ;172
000068  4cd8              LDR      r4,|L1.972|
00006a  eb0404c3          ADD      r4,r4,r3,LSL #3       ;173
00006e  80a1              STRH     r1,[r4,#4]            ;173
000070  b119              CBZ      r1,|L1.122|
000072  4dd6              LDR      r5,|L1.972|
000074  eb0505c1          ADD      r5,r5,r1,LSL #3       ;175
000078  80eb              STRH     r3,[r5,#6]            ;175
                  |L1.122|
00007a  49d5              LDR      r1,|L1.976|
00007c  6849              LDR      r1,[r1,#4]            ;178  ; GUI_ALLOC
00007e  f1010101          ADD      r1,r1,#1              ;178
000082  4bd3              LDR      r3,|L1.976|
000084  6059              STR      r1,[r3,#4]            ;178  ; GUI_ALLOC
000086  4619              MOV      r1,r3                 ;179
000088  6809              LDR      r1,[r1,#0]            ;179  ; GUI_ALLOC
00008a  f1a10101          SUB      r1,r1,#1              ;179
00008e  6019              STR      r1,[r3,#0]            ;179  ; GUI_ALLOC
000090  bf00              NOP      
000092  e7c9              B        |L1.40|
;;;181    
                          ENDP

                  _FindFreeHandle PROC
;;;188    */
;;;189    static GUI_HMEM _FindFreeHandle(void) {
000094  f04f0101          MOV      r1,#1
;;;190      int i;
;;;191      for (i=1; i< GUI_MAXBLOCKS; i++) {
000098  e008              B        |L1.172|
                  |L1.154|
;;;192        if (aBlock[i].Size ==0)
00009a  48cc              LDR      r0,|L1.972|
00009c  eb0000c1          ADD      r0,r0,r1,LSL #3
0000a0  8840              LDRH     r0,[r0,#2]
0000a2  b908              CBNZ     r0,|L1.168|
;;;193    	  return i;
0000a4  b208              SXTH     r0,r1
                  |L1.166|
;;;194      }
;;;195      GUI_DEBUG_ERROROUT1("Insufficient memory handles configured (GUI_MAXBLOCKS == %d (See GUIConf.h))", GUI_MAXBLOCKS);
;;;196      return GUI_HMEM_NULL;
;;;197    }
0000a6  4770              BX       lr
                  |L1.168|
0000a8  f1010101          ADD      r1,r1,#1              ;191
                  |L1.172|
0000ac  f5b17fa1          CMP      r1,#0x142             ;191
0000b0  dbf3              BLT      |L1.154|
0000b2  2000              MOVS     r0,#0                 ;196
0000b4  e7f7              B        |L1.166|
;;;198    
                          ENDP

                  _FindHole PROC
;;;206    */
;;;207    static GUI_HMEM _FindHole(GUI_ALLOC_DATATYPE Size) {
0000b6  b530              PUSH     {r4,r5,lr}
0000b8  4602              MOV      r2,r0
;;;208      int i, iNext;
;;;209      for (i=0; (iNext = aBlock[i].Next) != 0; i = iNext) {
0000ba  f04f0100          MOV      r1,#0
0000be  e012              B        |L1.230|
                  |L1.192|
;;;210        int NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
0000c0  48c2              LDR      r0,|L1.972|
0000c2  f9300031          LDRSH    r0,[r0,r1,LSL #3]
0000c6  4dc1              LDR      r5,|L1.972|
0000c8  eb0505c1          ADD      r5,r5,r1,LSL #3
0000cc  f9b55002          LDRSH    r5,[r5,#2]
0000d0  4428              ADD      r0,r0,r5
0000d2  4dbe              LDR      r5,|L1.972|
0000d4  f9355033          LDRSH    r5,[r5,r3,LSL #3]
0000d8  eba50400          SUB      r4,r5,r0
;;;211        if (NumFreeBytes>=Size) {
0000dc  4294              CMP      r4,r2
0000de  db01              BLT      |L1.228|
;;;212          return i;
0000e0  b208              SXTH     r0,r1
                  |L1.226|
;;;213        }
;;;214      }
;;;215      /* Check last block */
;;;216      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
;;;217        return i;
;;;218      }
;;;219      return -1;
;;;220    }
0000e2  bd30              POP      {r4,r5,pc}
                  |L1.228|
0000e4  4619              MOV      r1,r3                 ;209
                  |L1.230|
0000e6  48b9              LDR      r0,|L1.972|
0000e8  eb0000c1          ADD      r0,r0,r1,LSL #3       ;209
0000ec  8883              LDRH     r3,[r0,#4]            ;209
0000ee  2b00              CMP      r3,#0                 ;209
0000f0  d1e6              BNE      |L1.192|
0000f2  48b6              LDR      r0,|L1.972|
0000f4  f9300031          LDRSH    r0,[r0,r1,LSL #3]     ;216
0000f8  4cb4              LDR      r4,|L1.972|
0000fa  eb0404c1          ADD      r4,r4,r1,LSL #3       ;216
0000fe  f9b44002          LDRSH    r4,[r4,#2]            ;216
000102  4420              ADD      r0,r0,r4              ;216
000104  f5c05020          RSB      r0,r0,#0x2800         ;216
000108  4290              CMP      r0,r2                 ;216
00010a  db01              BLT      |L1.272|
00010c  b208              SXTH     r0,r1                 ;217
00010e  e7e8              B        |L1.226|
                  |L1.272|
000110  f04f30ff          MOV      r0,#0xffffffff        ;219
000114  e7e5              B        |L1.226|
;;;221    
                          ENDP

                  _CreateHole PROC
;;;229    */
;;;230    static GUI_HMEM _CreateHole(GUI_ALLOC_DATATYPE Size) {
000116  e92d47f0          PUSH     {r4-r10,lr}
00011a  4606              MOV      r6,r0
;;;231      int i, iNext;
;;;232      int r = -1;
00011c  f04f39ff          MOV      r9,#0xffffffff
;;;233      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
000120  f04f0400          MOV      r4,#0
000124  e03b              B        |L1.414|
                  |L1.294|
;;;234        GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
000126  48a9              LDR      r0,|L1.972|
000128  f8300034          LDRH     r0,[r0,r4,LSL #3]
00012c  49a7              LDR      r1,|L1.972|
00012e  eb0101c4          ADD      r1,r1,r4,LSL #3
000132  8849              LDRH     r1,[r1,#2]
000134  4408              ADD      r0,r0,r1
000136  49a5              LDR      r1,|L1.972|
000138  f8311035          LDRH     r1,[r1,r5,LSL #3]
00013c  eba10000          SUB      r0,r1,r0
000140  fa0ffa80          SXTH     r10,r0
;;;235        if (NumFreeBytes < Size) {
000144  45b2              CMP      r10,r6
000146  da29              BGE      |L1.412|
;;;236          GUI_ALLOC_DATATYPE NumBytesBeforeBlock = aBlock[iNext].Off - (aBlock[i].Off+aBlock[i].Size);
000148  48a0              LDR      r0,|L1.972|
00014a  f8300034          LDRH     r0,[r0,r4,LSL #3]
00014e  499f              LDR      r1,|L1.972|
000150  eb0101c4          ADD      r1,r1,r4,LSL #3
000154  8849              LDRH     r1,[r1,#2]
000156  4408              ADD      r0,r0,r1
000158  499c              LDR      r1,|L1.972|
00015a  f8311035          LDRH     r1,[r1,r5,LSL #3]
00015e  eba10000          SUB      r0,r1,r0
000162  b207              SXTH     r7,r0
;;;237          if (NumBytesBeforeBlock) {
000164  b1cf              CBZ      r7,|L1.410|
;;;238            U8* pData = &GUI_Heap.abHeap[aBlock[iNext].Off];
000166  4899              LDR      r0,|L1.972|
000168  f9300035          LDRSH    r0,[r0,r5,LSL #3]
00016c  4999              LDR      r1,|L1.980|
00016e  eb000801          ADD      r8,r0,r1
;;;239            memmove(pData-NumBytesBeforeBlock, pData, aBlock[iNext].Size);
000172  4996              LDR      r1,|L1.972|
000174  eb0101c5          ADD      r1,r1,r5,LSL #3
000178  f9b12002          LDRSH    r2,[r1,#2]
00017c  eba80007          SUB      r0,r8,r7
000180  4641              MOV      r1,r8
000182  f7fffffe          BL       __aeabi_memmove
;;;240            aBlock[iNext].Off -=NumBytesBeforeBlock;
000186  4891              LDR      r0,|L1.972|
000188  f8300035          LDRH     r0,[r0,r5,LSL #3]
00018c  eba00007          SUB      r0,r0,r7
000190  b200              SXTH     r0,r0
000192  498e              LDR      r1,|L1.972|
000194  f8210035          STRH     r0,[r1,r5,LSL #3]
;;;241          }
000198  bf00              NOP      
                  |L1.410|
;;;242        }
00019a  bf00              NOP      
                  |L1.412|
00019c  462c              MOV      r4,r5                 ;233
                  |L1.414|
00019e  488b              LDR      r0,|L1.972|
0001a0  eb0000c4          ADD      r0,r0,r4,LSL #3       ;233
0001a4  8885              LDRH     r5,[r0,#4]            ;233
0001a6  2d00              CMP      r5,#0                 ;233
0001a8  d1bd              BNE      |L1.294|
;;;243      }
;;;244      /* Check last block */
;;;245      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
0001aa  4888              LDR      r0,|L1.972|
0001ac  f9300034          LDRSH    r0,[r0,r4,LSL #3]
0001b0  4986              LDR      r1,|L1.972|
0001b2  eb0101c4          ADD      r1,r1,r4,LSL #3
0001b6  f9b11002          LDRSH    r1,[r1,#2]
0001ba  4408              ADD      r0,r0,r1
0001bc  f5c05020          RSB      r0,r0,#0x2800
0001c0  42b0              CMP      r0,r6
0001c2  db00              BLT      |L1.454|
;;;246        r = i;
0001c4  46a1              MOV      r9,r4
                  |L1.454|
;;;247      }
;;;248      return r;
0001c6  fa0ff089          SXTH     r0,r9
;;;249    }
0001ca  e8bd87f0          POP      {r4-r10,pc}
;;;250    
                          ENDP

                  GUI_ALLOC_Init PROC
;;;323    */
;;;324    void GUI_ALLOC_Init(void) {
0001ce  f2401041          MOV      r0,#0x141
;;;325      GUI_DEBUG_LOG("\nGUI_ALLOC_Init...");
;;;326      GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks = GUI_MAXBLOCKS-1;
0001d2  497f              LDR      r1,|L1.976|
0001d4  6048              STR      r0,[r1,#4]  ; GUI_ALLOC
0001d6  6088              STR      r0,[r1,#8]  ; GUI_ALLOC
;;;327      GUI_ALLOC.NumFreeBytesMin  = GUI_ALLOC.NumFreeBytes  = GUI_ALLOC_SIZE;
0001d8  f44f5020          MOV      r0,#0x2800
0001dc  81c8              STRH     r0,[r1,#0xe]
0001de  8208              STRH     r0,[r1,#0x10]
;;;328      GUI_ALLOC.NumUsedBlocks = 0;
0001e0  f04f0000          MOV      r0,#0
0001e4  6008              STR      r0,[r1,#0]  ; GUI_ALLOC
;;;329      GUI_ALLOC.NumUsedBytes = 0;
0001e6  8188              STRH     r0,[r1,#0xc]
;;;330      aBlock[0].Size = (1<<GUI_BLOCK_ALIGN);  /* occupy minimum for a block */
0001e8  f04f0004          MOV      r0,#4
0001ec  4977              LDR      r1,|L1.972|
0001ee  8048              STRH     r0,[r1,#2]
;;;331      aBlock[0].Off  = 0;
0001f0  f04f0000          MOV      r0,#0
0001f4  8008              STRH     r0,[r1,#0]
;;;332      aBlock[0].Next = 0;
0001f6  8088              STRH     r0,[r1,#4]
;;;333      IsInitialized =1;
0001f8  f04f0001          MOV      r0,#1
0001fc  4976              LDR      r1,|L1.984|
0001fe  7008              STRB     r0,[r1,#0]
;;;334    }
000200  4770              BX       lr
;;;335    
                          ENDP

                  _CheckInit PROC
;;;254    */
;;;255    static void _CheckInit(void) {
000202  b500              PUSH     {lr}
;;;256      if (!IsInitialized) {
000204  4874              LDR      r0,|L1.984|
000206  7800              LDRB     r0,[r0,#0]  ; IsInitialized
000208  b908              CBNZ     r0,|L1.526|
;;;257        GUI_ALLOC_Init();
00020a  f7fffffe          BL       GUI_ALLOC_Init
                  |L1.526|
;;;258      }
;;;259    }
00020e  bd00              POP      {pc}
;;;260    
                          ENDP

                  _Alloc PROC
;;;264    */
;;;265    static GUI_HMEM _Alloc(GUI_ALLOC_DATATYPE size) {
000210  b570              PUSH     {r4-r6,lr}
000212  4606              MOV      r6,r0
;;;266      GUI_HMEM hMemNew, hMemIns;
;;;267      _CheckInit();
000214  f7fffffe          BL       _CheckInit
;;;268      size = _Size2LegalSize(size);
000218  4630              MOV      r0,r6
00021a  f7fffffe          BL       _Size2LegalSize
00021e  4606              MOV      r6,r0
;;;269      /* Check if memory is available at all ...*/
;;;270      if (size > GUI_ALLOC.NumFreeBytes) {
000220  486b              LDR      r0,|L1.976|
000222  f9b0000e          LDRSH    r0,[r0,#0xe]  ; GUI_ALLOC
000226  42b0              CMP      r0,r6
000228  da01              BGE      |L1.558|
;;;271        GUI_DEBUG_WARN1("GUI_ALLOC_Alloc: Insufficient memory configured (Trying to alloc % bytes)", size);
;;;272        return 0;
00022a  2000              MOVS     r0,#0
                  |L1.556|
;;;273      }
;;;274      /* Locate free handle */
;;;275      if ((hMemNew = _FindFreeHandle()) == 0)
;;;276        return 0;
;;;277      /* Locate or Create hole of sufficient size */
;;;278      hMemIns = _FindHole(size);
;;;279      #if GUI_ALLOC_AUTDEFRAG
;;;280        if (hMemIns == -1) {
;;;281          hMemIns = _CreateHole(size);
;;;282        }
;;;283      #endif
;;;284      /* Occupy hole */
;;;285      if (hMemIns==-1) {
;;;286        GUI_DEBUG_ERROROUT1("GUI_ALLOC_Alloc: Could not allocate %d bytes",size);
;;;287        return 0;
;;;288    	}
;;;289      {
;;;290        GUI_ALLOC_DATATYPE Off = aBlock[hMemIns].Off + aBlock[hMemIns].Size;
;;;291        int Next = aBlock[hMemIns].Next;
;;;292        aBlock[hMemNew].Size  = size;
;;;293        aBlock[hMemNew].Off   = Off;
;;;294        if ((aBlock[hMemNew].Next  = Next) >0) {
;;;295          aBlock[Next].Prev = hMemNew;  
;;;296        }
;;;297        aBlock[hMemNew].Prev  = hMemIns;
;;;298        aBlock[hMemIns].Next  = hMemNew;
;;;299      }
;;;300      /* Keep track of number of blocks and av. memory */
;;;301      GUI_ALLOC.NumUsedBlocks++;
;;;302      GUI_ALLOC.NumFreeBlocks--;
;;;303      if (GUI_ALLOC.NumFreeBlocksMin > GUI_ALLOC.NumFreeBlocks) {
;;;304        GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks;
;;;305      }
;;;306      GUI_ALLOC.NumUsedBytes += size;
;;;307      GUI_ALLOC.NumFreeBytes -= size;
;;;308      if (GUI_ALLOC.NumFreeBytesMin > GUI_ALLOC.NumFreeBytes) {
;;;309        GUI_ALLOC.NumFreeBytesMin = GUI_ALLOC.NumFreeBytes;
;;;310      }
;;;311      return hMemNew;
;;;312    }
00022c  bd70              POP      {r4-r6,pc}
                  |L1.558|
00022e  f7fffffe          BL       _FindFreeHandle
000232  0005              MOVS     r5,r0                 ;275
000234  d100              BNE      |L1.568|
000236  e7f9              B        |L1.556|
                  |L1.568|
000238  4630              MOV      r0,r6                 ;278
00023a  f7fffffe          BL       _FindHole
00023e  4604              MOV      r4,r0                 ;278
000240  1c60              ADDS     r0,r4,#1              ;280
000242  d103              BNE      |L1.588|
000244  4630              MOV      r0,r6                 ;281
000246  f7fffffe          BL       _CreateHole
00024a  4604              MOV      r4,r0                 ;281
                  |L1.588|
00024c  1c60              ADDS     r0,r4,#1              ;285
00024e  d100              BNE      |L1.594|
000250  e7ec              B        |L1.556|
                  |L1.594|
000252  4a5e              LDR      r2,|L1.972|
000254  f8322034          LDRH     r2,[r2,r4,LSL #3]     ;290
000258  4b5c              LDR      r3,|L1.972|
00025a  eb0303c4          ADD      r3,r3,r4,LSL #3       ;290
00025e  885b              LDRH     r3,[r3,#2]            ;290
000260  441a              ADD      r2,r2,r3              ;290
000262  b211              SXTH     r1,r2                 ;290
000264  4a59              LDR      r2,|L1.972|
000266  eb0202c4          ADD      r2,r2,r4,LSL #3       ;291
00026a  8890              LDRH     r0,[r2,#4]            ;291
00026c  4a57              LDR      r2,|L1.972|
00026e  eb0202c5          ADD      r2,r2,r5,LSL #3       ;292
000272  8056              STRH     r6,[r2,#2]            ;292
000274  4a55              LDR      r2,|L1.972|
000276  f8221035          STRH     r1,[r2,r5,LSL #3]     ;293
00027a  eb0202c5          ADD      r2,r2,r5,LSL #3       ;294
00027e  8090              STRH     r0,[r2,#4]            ;294
000280  2800              CMP      r0,#0                 ;294
000282  dd03              BLE      |L1.652|
000284  4b51              LDR      r3,|L1.972|
000286  eb0303c0          ADD      r3,r3,r0,LSL #3       ;295
00028a  80dd              STRH     r5,[r3,#6]            ;295
                  |L1.652|
00028c  4b4f              LDR      r3,|L1.972|
00028e  eb0303c5          ADD      r3,r3,r5,LSL #3       ;297
000292  80dc              STRH     r4,[r3,#6]            ;297
000294  4b4d              LDR      r3,|L1.972|
000296  eb0303c4          ADD      r3,r3,r4,LSL #3       ;298
00029a  809d              STRH     r5,[r3,#4]            ;298
00029c  484c              LDR      r0,|L1.976|
00029e  6800              LDR      r0,[r0,#0]            ;301  ; GUI_ALLOC
0002a0  f1000001          ADD      r0,r0,#1              ;301
0002a4  494a              LDR      r1,|L1.976|
0002a6  6008              STR      r0,[r1,#0]            ;301  ; GUI_ALLOC
0002a8  4608              MOV      r0,r1                 ;302
0002aa  6840              LDR      r0,[r0,#4]            ;302  ; GUI_ALLOC
0002ac  f1a00001          SUB      r0,r0,#1              ;302
0002b0  6048              STR      r0,[r1,#4]            ;302  ; GUI_ALLOC
0002b2  4608              MOV      r0,r1                 ;303
0002b4  6880              LDR      r0,[r0,#8]            ;303  ; GUI_ALLOC
0002b6  6849              LDR      r1,[r1,#4]            ;303  ; GUI_ALLOC
0002b8  4288              CMP      r0,r1                 ;303
0002ba  dd03              BLE      |L1.708|
0002bc  4844              LDR      r0,|L1.976|
0002be  6840              LDR      r0,[r0,#4]            ;304  ; GUI_ALLOC
0002c0  4943              LDR      r1,|L1.976|
0002c2  6088              STR      r0,[r1,#8]            ;304  ; GUI_ALLOC
                  |L1.708|
0002c4  4842              LDR      r0,|L1.976|
0002c6  8980              LDRH     r0,[r0,#0xc]          ;306  ; GUI_ALLOC
0002c8  4430              ADD      r0,r0,r6              ;306
0002ca  b200              SXTH     r0,r0                 ;306
0002cc  4940              LDR      r1,|L1.976|
0002ce  8188              STRH     r0,[r1,#0xc]          ;306
0002d0  4608              MOV      r0,r1                 ;307
0002d2  89c0              LDRH     r0,[r0,#0xe]          ;307  ; GUI_ALLOC
0002d4  eba00006          SUB      r0,r0,r6              ;307
0002d8  b200              SXTH     r0,r0                 ;307
0002da  81c8              STRH     r0,[r1,#0xe]          ;307
0002dc  4608              MOV      r0,r1                 ;308
0002de  f9b00010          LDRSH    r0,[r0,#0x10]         ;308  ; GUI_ALLOC
0002e2  f9b1100e          LDRSH    r1,[r1,#0xe]          ;308  ; GUI_ALLOC
0002e6  4288              CMP      r0,r1                 ;308
0002e8  dd03              BLE      |L1.754|
0002ea  4839              LDR      r0,|L1.976|
0002ec  89c0              LDRH     r0,[r0,#0xe]          ;309  ; GUI_ALLOC
0002ee  4938              LDR      r1,|L1.976|
0002f0  8208              STRH     r0,[r1,#0x10]         ;309
                  |L1.754|
0002f2  4628              MOV      r0,r5                 ;311
0002f4  e79a              B        |L1.556|
;;;313    
                          ENDP

                  GUI_ALLOC_AllocNoInit PROC
;;;339    */
;;;340    GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
0002f6  b570              PUSH     {r4-r6,lr}
0002f8  4604              MOV      r4,r0
;;;341      GUI_HMEM hMem;
;;;342      if (Size == 0) {
0002fa  b90c              CBNZ     r4,|L1.768|
;;;343        return (GUI_HMEM)0;
0002fc  2000              MOVS     r0,#0
                  |L1.766|
;;;344      }
;;;345      GUI_LOCK();
;;;346      GUI_DEBUG_LOG2("\nGUI_ALLOC_AllocNoInit... requesting %d, %d avail", Size, GUI_ALLOC.NumFreeBytes);
;;;347      hMem = _Alloc(Size);
;;;348      GUI_DEBUG_LOG1("\nGUI_ALLOC_AllocNoInit : Handle", hMem);
;;;349      GUI_UNLOCK();
;;;350      return hMem;
;;;351    }
0002fe  bd70              POP      {r4-r6,pc}
                  |L1.768|
000300  4620              MOV      r0,r4                 ;347
000302  f7fffffe          BL       _Alloc
000306  4605              MOV      r5,r0                 ;347
000308  4628              MOV      r0,r5                 ;350
00030a  e7f8              B        |L1.766|
;;;352    
                          ENDP

                  GUI_ALLOC_h2p PROC
;;;356    */
;;;357    void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
00030c  4601              MOV      r1,r0
;;;358      GUI_ASSERT_LOCK();
;;;359      #if GUI_DEBUG_LEVEL > 0
;;;360        if (!hMem) {
00030e  b909              CBNZ     r1,|L1.788|
;;;361          GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
;;;362          return 0;
000310  2000              MOVS     r0,#0
                  |L1.786|
;;;363        }
;;;364        if (aBlock[hMem].Size == 0) {
;;;365          GUI_DEBUG_ERROROUT("Dereferencing free block");
;;;366        }
;;;367    
;;;368      #endif
;;;369      return HMEM2PTR(hMem);
;;;370    }
000312  4770              BX       lr
                  |L1.788|
000314  482d              LDR      r0,|L1.972|
000316  f9300031          LDRSH    r0,[r0,r1,LSL #3]     ;369
00031a  4a2e              LDR      r2,|L1.980|
00031c  4410              ADD      r0,r0,r2              ;369
00031e  e7f8              B        |L1.786|
;;;371    
                          ENDP

                  GUI_ALLOC_GetNumFreeBytes PROC
;;;375    */
;;;376    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes(void) {
000320  b510              PUSH     {r4,lr}
;;;377      _CheckInit();
000322  f7fffffe          BL       _CheckInit
;;;378      return GUI_ALLOC.NumFreeBytes;  
000326  482a              LDR      r0,|L1.976|
000328  f9b0000e          LDRSH    r0,[r0,#0xe]  ; GUI_ALLOC
;;;379    }
00032c  bd10              POP      {r4,pc}
;;;380    
                          ENDP

                  GUI_ALLOC_GetMaxSize PROC
;;;387    */
;;;388    GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
00032e  e92d41f0          PUSH     {r4-r8,lr}
;;;389      GUI_ALLOC_DATATYPE r = 0;
000332  f04f0600          MOV      r6,#0
;;;390      GUI_ALLOC_DATATYPE NumFreeBytes;
;;;391      int i, iNext;
;;;392    
;;;393      GUI_LOCK();
;;;394      _CheckInit();
000336  f7fffffe          BL       _CheckInit
;;;395      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
00033a  4635              MOV      r5,r6
00033c  e011              B        |L1.866|
                  |L1.830|
;;;396        NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
00033e  4823              LDR      r0,|L1.972|
000340  f8300035          LDRH     r0,[r0,r5,LSL #3]
000344  4921              LDR      r1,|L1.972|
000346  eb0101c5          ADD      r1,r1,r5,LSL #3
00034a  8849              LDRH     r1,[r1,#2]
00034c  4408              ADD      r0,r0,r1
00034e  491f              LDR      r1,|L1.972|
000350  f8311037          LDRH     r1,[r1,r7,LSL #3]
000354  eba10000          SUB      r0,r1,r0
000358  b204              SXTH     r4,r0
;;;397        if (NumFreeBytes > r) {
00035a  42b4              CMP      r4,r6
00035c  dd00              BLE      |L1.864|
;;;398          r = NumFreeBytes;
00035e  4626              MOV      r6,r4
                  |L1.864|
000360  463d              MOV      r5,r7                 ;395
                  |L1.866|
000362  481a              LDR      r0,|L1.972|
000364  eb0000c5          ADD      r0,r0,r5,LSL #3       ;395
000368  8887              LDRH     r7,[r0,#4]            ;395
00036a  2f00              CMP      r7,#0                 ;395
00036c  d1e7              BNE      |L1.830|
;;;399        }
;;;400      }
;;;401      /* Check last block */
;;;402      NumFreeBytes = (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size));
00036e  4817              LDR      r0,|L1.972|
000370  f9300035          LDRSH    r0,[r0,r5,LSL #3]
000374  4915              LDR      r1,|L1.972|
000376  eb0101c5          ADD      r1,r1,r5,LSL #3
00037a  f9b11002          LDRSH    r1,[r1,#2]
00037e  4408              ADD      r0,r0,r1
000380  f5c05020          RSB      r0,r0,#0x2800
000384  b204              SXTH     r4,r0
;;;403      if (NumFreeBytes > r) {
000386  42b4              CMP      r4,r6
000388  dd00              BLE      |L1.908|
;;;404        r = NumFreeBytes;
00038a  4626              MOV      r6,r4
                  |L1.908|
;;;405      }
;;;406      GUI_UNLOCK();
;;;407      return r;
00038c  4630              MOV      r0,r6
;;;408    }
00038e  e8bd81f0          POP      {r4-r8,pc}
;;;409    
                          ENDP

                  GUI_ALLOC_GetSize PROC
;;;509    */
;;;510    GUI_ALLOC_DATATYPE GUI_ALLOC_GetSize(GUI_HMEM  hMem) {
000392  b510              PUSH     {r4,lr}
000394  4604              MOV      r4,r0
;;;511      /* Do the error checking first */
;;;512      #if GUI_DEBUG_LEVEL>0
;;;513        if (!hMem) {
000396  b90c              CBNZ     r4,|L1.924|
;;;514          GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
;;;515          return 0;
000398  2000              MOVS     r0,#0
                  |L1.922|
;;;516        }
;;;517      #endif
;;;518      return _GetSize(hMem);
;;;519    }
00039a  bd10              POP      {r4,pc}
                  |L1.924|
00039c  4620              MOV      r0,r4                 ;518
00039e  f7fffffe          BL       _GetSize
0003a2  e7fa              B        |L1.922|
;;;520    
                          ENDP

                  GUI_ALLOC_Free PROC
;;;524    */
;;;525    void GUI_ALLOC_Free(GUI_HMEM hMem) {
0003a4  b510              PUSH     {r4,lr}
0003a6  4604              MOV      r4,r0
;;;526      if (hMem == GUI_HMEM_NULL) { /* Note: This is not an error, it is permitted */
0003a8  b904              CBNZ     r4,|L1.940|
                  |L1.938|
;;;527        return;
;;;528      }
;;;529      GUI_LOCK();
;;;530      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;531      _Free(hMem);
;;;532      GUI_UNLOCK();
;;;533    }
0003aa  bd10              POP      {r4,pc}
                  |L1.940|
0003ac  4620              MOV      r0,r4                 ;531
0003ae  f7fffffe          BL       _Free
0003b2  bf00              NOP      
0003b4  e7f9              B        |L1.938|
;;;534    
                          ENDP

                  GUI_ALLOC_FreePtr PROC
;;;539    */
;;;540    void GUI_ALLOC_FreePtr(GUI_HMEM *ph) {
0003b6  b510              PUSH     {r4,lr}
0003b8  4604              MOV      r4,r0
;;;541      GUI_LOCK();
;;;542      GUI_ALLOC_Free(*ph);
0003ba  f9b40000          LDRSH    r0,[r4,#0]
0003be  f7fffffe          BL       GUI_ALLOC_Free
;;;543      *ph =0;
0003c2  f04f0000          MOV      r0,#0
0003c6  8020              STRH     r0,[r4,#0]
;;;544      GUI_UNLOCK();
;;;545    }
0003c8  bd10              POP      {r4,pc}
;;;546    
                          ENDP

0003ca  0000              DCW      0x0000
                  |L1.972|
                          DCD      aBlock
                  |L1.976|
                          DCD      GUI_ALLOC
                  |L1.980|
                          DCD      GUI_Heap
                  |L1.984|
                          DCD      IsInitialized

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  GUI_Heap
                          %        10240
                  aBlock
                          %        2576
                  GUI_ALLOC
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  IsInitialized
000000  00                DCB      0x00
