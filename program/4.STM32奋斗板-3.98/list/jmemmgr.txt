; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jmemmgr.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jmemmgr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jmemmgr.crf GUI\JPEG\jmemmgr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  out_of_memory PROC
;;;209    LOCAL(void)
;;;210    out_of_memory (j_common_ptr cinfo, int which)
000000  b570              PUSH     {r4-r6,lr}
;;;211    /* Report an out-of-memory error and stop execution */
;;;212    /* If we compiled MEM_STATS support, report alloc requests before dying */
;;;213    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;214    #ifdef MEM_STATS
;;;215      cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
;;;216    #endif
;;;217      ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
000006  2036              MOVS     r0,#0x36
000008  6821              LDR      r1,[r4,#0]
00000a  6148              STR      r0,[r1,#0x14]
00000c  6820              LDR      r0,[r4,#0]
00000e  6185              STR      r5,[r0,#0x18]
000010  6820              LDR      r0,[r4,#0]
000012  6801              LDR      r1,[r0,#0]
000014  4620              MOV      r0,r4
000016  4788              BLX      r1
;;;218    }
000018  bd70              POP      {r4-r6,pc}
;;;219    
                          ENDP

                  alloc_small PROC
;;;248    
;;;249    METHODDEF(void *) alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
00001a  e92d5ffc          PUSH     {r2-r12,lr}
;;;250    /* Allocate a "small" object */
;;;251    {
00001e  4680              MOV      r8,r0
000020  460e              MOV      r6,r1
000022  4615              MOV      r5,r2
;;;252      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000024  f8d8b004          LDR      r11,[r8,#4]
;;;253      small_pool_ptr hdr_ptr, prev_hdr_ptr;
;;;254      char * data_ptr;
;;;255      size_t odd_bytes, min_request, slop;
;;;256    
;;;257      /* Check for unsatisfiable request (do now to ensure no overflow below) */
;;;258      if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
000028  48f8              LDR      r0,|L1.1036|
00002a  4285              CMP      r5,r0
00002c  d903              BLS      |L1.54|
;;;259        out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
00002e  2101              MOVS     r1,#1
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       out_of_memory
                  |L1.54|
;;;260    
;;;261      /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
;;;262      odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
000036  f0050007          AND      r0,r5,#7
00003a  9000              STR      r0,[sp,#0]
;;;263      if (odd_bytes > 0)
00003c  9800              LDR      r0,[sp,#0]
00003e  b118              CBZ      r0,|L1.72|
;;;264        sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
000040  9800              LDR      r0,[sp,#0]
000042  f1c00008          RSB      r0,r0,#8
000046  4405              ADD      r5,r5,r0
                  |L1.72|
;;;265    
;;;266      /* See if space is available in any existing pool */
;;;267      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
000048  2e00              CMP      r6,#0
00004a  db01              BLT      |L1.80|
00004c  2e02              CMP      r6,#2
00004e  db0b              BLT      |L1.104|
                  |L1.80|
;;;268        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000050  200e              MOVS     r0,#0xe
000052  f8d81000          LDR      r1,[r8,#0]
000056  6148              STR      r0,[r1,#0x14]
000058  f8d80000          LDR      r0,[r8,#0]
00005c  6186              STR      r6,[r0,#0x18]
00005e  f8d80000          LDR      r0,[r8,#0]
000062  6801              LDR      r1,[r0,#0]
000064  4640              MOV      r0,r8
000066  4788              BLX      r1
                  |L1.104|
;;;269      prev_hdr_ptr = NULL;
000068  f04f0900          MOV      r9,#0
;;;270      hdr_ptr = mem->small_list[pool_id];
00006c  f10b0034          ADD      r0,r11,#0x34
000070  f8504026          LDR      r4,[r0,r6,LSL #2]
;;;271      while (hdr_ptr != NULL) {
000074  e005              B        |L1.130|
                  |L1.118|
;;;272        if (hdr_ptr->hdr.bytes_left >= sizeofobject)
000076  68a0              LDR      r0,[r4,#8]
000078  42a8              CMP      r0,r5
00007a  d300              BCC      |L1.126|
;;;273          break;			/* found pool with enough space */
00007c  e003              B        |L1.134|
                  |L1.126|
;;;274        prev_hdr_ptr = hdr_ptr;
00007e  46a1              MOV      r9,r4
;;;275        hdr_ptr = hdr_ptr->hdr.next;
000080  6824              LDR      r4,[r4,#0]
                  |L1.130|
000082  2c00              CMP      r4,#0                 ;271
000084  d1f7              BNE      |L1.118|
                  |L1.134|
000086  bf00              NOP                            ;273
;;;276      }
;;;277    
;;;278      /* Time to make a new pool? */
;;;279      if (hdr_ptr == NULL) {
000088  bbd4              CBNZ     r4,|L1.256|
;;;280        /* min_request is what we need now, slop is what will be leftover */
;;;281        min_request = sizeofobject + SIZEOF(small_pool_hdr);
00008a  f1050a10          ADD      r10,r5,#0x10
;;;282        if (prev_hdr_ptr == NULL)	/* first pool in class? */
00008e  f1b90f00          CMP      r9,#0
000092  d103              BNE      |L1.156|
;;;283          slop = first_pool_slop[pool_id];
000094  48de              LDR      r0,|L1.1040|
000096  f8507026          LDR      r7,[r0,r6,LSL #2]
00009a  e002              B        |L1.162|
                  |L1.156|
;;;284        else
;;;285          slop = extra_pool_slop[pool_id];
00009c  48dd              LDR      r0,|L1.1044|
00009e  f8507026          LDR      r7,[r0,r6,LSL #2]
                  |L1.162|
;;;286        /* Don't ask for more than MAX_ALLOC_CHUNK */
;;;287        if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
0000a2  48da              LDR      r0,|L1.1036|
0000a4  3010              ADDS     r0,r0,#0x10
0000a6  eba0000a          SUB      r0,r0,r10
0000aa  42b8              CMP      r0,r7
0000ac  d203              BCS      |L1.182|
;;;288          slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
0000ae  48d7              LDR      r0,|L1.1036|
0000b0  3010              ADDS     r0,r0,#0x10
0000b2  eba0070a          SUB      r7,r0,r10
                  |L1.182|
;;;289        /* Try to get space, if fail reduce slop and try again */
;;;290        while(1) {
0000b6  e00e              B        |L1.214|
                  |L1.184|
;;;291          hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
0000b8  eb0a0107          ADD      r1,r10,r7
0000bc  4640              MOV      r0,r8
0000be  f7fffffe          BL       jpeg_get_small
0000c2  4604              MOV      r4,r0
;;;292          if (hdr_ptr != NULL)
0000c4  b104              CBZ      r4,|L1.200|
;;;293    	break;
0000c6  e007              B        |L1.216|
                  |L1.200|
;;;294          slop /= 2;
0000c8  087f              LSRS     r7,r7,#1
;;;295          if (slop < MIN_SLOP)	/* give up when it gets real small */
0000ca  2f32              CMP      r7,#0x32
0000cc  d203              BCS      |L1.214|
;;;296    	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
0000ce  2102              MOVS     r1,#2
0000d0  4640              MOV      r0,r8
0000d2  f7fffffe          BL       out_of_memory
                  |L1.214|
0000d6  e7ef              B        |L1.184|
                  |L1.216|
0000d8  bf00              NOP                            ;293
;;;297        }
;;;298        mem->total_space_allocated += min_request + slop;
0000da  eb0a0107          ADD      r1,r10,r7
0000de  f8db004c          LDR      r0,[r11,#0x4c]
0000e2  4408              ADD      r0,r0,r1
0000e4  f8cb004c          STR      r0,[r11,#0x4c]
;;;299        /* Success, initialize the new pool header and add to end of list */
;;;300        hdr_ptr->hdr.next = NULL;
0000e8  2000              MOVS     r0,#0
0000ea  6020              STR      r0,[r4,#0]
;;;301        hdr_ptr->hdr.bytes_used = 0;
0000ec  6060              STR      r0,[r4,#4]
;;;302        hdr_ptr->hdr.bytes_left = sizeofobject + slop;
0000ee  19e8              ADDS     r0,r5,r7
0000f0  60a0              STR      r0,[r4,#8]
;;;303        if (prev_hdr_ptr == NULL)	/* first pool in class? */
0000f2  f1b90f00          CMP      r9,#0
0000f6  d104              BNE      |L1.258|
;;;304          mem->small_list[pool_id] = hdr_ptr;
0000f8  f10b0034          ADD      r0,r11,#0x34
0000fc  f8404026          STR      r4,[r0,r6,LSL #2]
                  |L1.256|
000100  e001              B        |L1.262|
                  |L1.258|
;;;305        else
;;;306          prev_hdr_ptr->hdr.next = hdr_ptr;
000102  f8c94000          STR      r4,[r9,#0]
                  |L1.262|
;;;307      }
;;;308    
;;;309      /* OK, allocate the object from the current pool */
;;;310      data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
000106  f1040010          ADD      r0,r4,#0x10
00010a  9001              STR      r0,[sp,#4]
;;;311      data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
00010c  9801              LDR      r0,[sp,#4]
00010e  6861              LDR      r1,[r4,#4]
000110  4408              ADD      r0,r0,r1
000112  9001              STR      r0,[sp,#4]
;;;312      hdr_ptr->hdr.bytes_used += sizeofobject;
000114  6860              LDR      r0,[r4,#4]
000116  4428              ADD      r0,r0,r5
000118  6060              STR      r0,[r4,#4]
;;;313      hdr_ptr->hdr.bytes_left -= sizeofobject;
00011a  68a0              LDR      r0,[r4,#8]
00011c  1b40              SUBS     r0,r0,r5
00011e  60a0              STR      r0,[r4,#8]
;;;314    
;;;315      return (void *) data_ptr;
000120  9801              LDR      r0,[sp,#4]
;;;316    }
000122  e8bd9ffc          POP      {r2-r12,pc}
;;;317    
                          ENDP

                  alloc_large PROC
;;;332    
;;;333    METHODDEF(void FAR *) alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject) /* Allocate a "large" object */ {
000126  e92d47f0          PUSH     {r4-r10,lr}
00012a  4607              MOV      r7,r0
00012c  460e              MOV      r6,r1
00012e  4615              MOV      r5,r2
;;;334      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000130  f8d78004          LDR      r8,[r7,#4]
;;;335      large_pool_ptr hdr_ptr;
;;;336      size_t odd_bytes;
;;;337    
;;;338      /* Check for unsatisfiable request (do now to ensure no overflow below) */
;;;339      if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr))) {
000134  48b5              LDR      r0,|L1.1036|
000136  4285              CMP      r5,r0
000138  d903              BLS      |L1.322|
;;;340        out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
00013a  2103              MOVS     r1,#3
00013c  4638              MOV      r0,r7
00013e  f7fffffe          BL       out_of_memory
                  |L1.322|
;;;341      }
;;;342      /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
;;;343      odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
000142  f0050907          AND      r9,r5,#7
;;;344      if (odd_bytes > 0) {
000146  f1b90f00          CMP      r9,#0
00014a  d002              BEQ      |L1.338|
;;;345        sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
00014c  f1c90008          RSB      r0,r9,#8
000150  4405              ADD      r5,r5,r0
                  |L1.338|
;;;346      }
;;;347      /* Always make a new pool */
;;;348      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS) {
000152  2e00              CMP      r6,#0
000154  db01              BLT      |L1.346|
000156  2e02              CMP      r6,#2
000158  db08              BLT      |L1.364|
                  |L1.346|
;;;349        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
00015a  200e              MOVS     r0,#0xe
00015c  6839              LDR      r1,[r7,#0]
00015e  6148              STR      r0,[r1,#0x14]
000160  6838              LDR      r0,[r7,#0]
000162  6186              STR      r6,[r0,#0x18]
000164  6838              LDR      r0,[r7,#0]
000166  6801              LDR      r1,[r0,#0]
000168  4638              MOV      r0,r7
00016a  4788              BLX      r1
                  |L1.364|
;;;350      }
;;;351    
;;;352      hdr_ptr = (large_pool_ptr) jpeg_get_small/*RS: Changed from jpeg_get_large*/ (cinfo, sizeofobject +  SIZEOF(large_pool_hdr));
00016c  f1050110          ADD      r1,r5,#0x10
000170  4638              MOV      r0,r7
000172  f7fffffe          BL       jpeg_get_small
000176  4604              MOV      r4,r0
;;;353      if (hdr_ptr == NULL) {
000178  b91c              CBNZ     r4,|L1.386|
;;;354        out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
00017a  2104              MOVS     r1,#4
00017c  4638              MOV      r0,r7
00017e  f7fffffe          BL       out_of_memory
                  |L1.386|
;;;355      }
;;;356      mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
000182  f1050010          ADD      r0,r5,#0x10
000186  f8d8104c          LDR      r1,[r8,#0x4c]
00018a  4408              ADD      r0,r0,r1
00018c  f8c8004c          STR      r0,[r8,#0x4c]
;;;357      /* Success, initialize the new pool header and add to list */
;;;358      hdr_ptr->hdr.next = mem->large_list[pool_id];
000190  f108003c          ADD      r0,r8,#0x3c
000194  f8500026          LDR      r0,[r0,r6,LSL #2]
000198  6020              STR      r0,[r4,#0]
;;;359      /* We maintain space counts in each pool header for statistical purposes,
;;;360       * even though they are not needed for allocation.
;;;361       */
;;;362      hdr_ptr->hdr.bytes_used = sizeofobject;
00019a  6065              STR      r5,[r4,#4]
;;;363      hdr_ptr->hdr.bytes_left = 0;
00019c  2000              MOVS     r0,#0
00019e  60a0              STR      r0,[r4,#8]
;;;364      mem->large_list[pool_id] = hdr_ptr;
0001a0  f108003c          ADD      r0,r8,#0x3c
0001a4  f8404026          STR      r4,[r0,r6,LSL #2]
;;;365    
;;;366      return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
0001a8  f1040010          ADD      r0,r4,#0x10
;;;367    }
0001ac  e8bd87f0          POP      {r4-r10,pc}
;;;368    
                          ENDP

                  alloc_sarray PROC
;;;382    
;;;383    METHODDEF(JSAMPARRAY) alloc_sarray (j_common_ptr cinfo, int pool_id, JDIMENSION samplesperrow, JDIMENSION numrows) {
0001b0  e92d4fff          PUSH     {r0-r11,lr}
0001b4  b083              SUB      sp,sp,#0xc
0001b6  4680              MOV      r8,r0
0001b8  4616              MOV      r6,r2
0001ba  461c              MOV      r4,r3
;;;384    /* Allocate a 2-D sample array */
;;;385      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
0001bc  f8d80004          LDR      r0,[r8,#4]
0001c0  9002              STR      r0,[sp,#8]
;;;386      JSAMPARRAY result;
;;;387      JSAMPROW workspace;
;;;388      JDIMENSION rowsperchunk, currow, i;
;;;389      long ltemp;
;;;390    
;;;391      /* Calculate max # of rows allowed in one allocation chunk */
;;;392      ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
0001c2  4892              LDR      r0,|L1.1036|
0001c4  fbb0faf6          UDIV     r10,r0,r6
;;;393    	  ((long) samplesperrow * SIZEOF(JSAMPLE));
;;;394      if (ltemp <= 0)
0001c8  f1ba0f00          CMP      r10,#0
0001cc  dc08              BGT      |L1.480|
;;;395        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
0001ce  2046              MOVS     r0,#0x46
0001d0  f8d81000          LDR      r1,[r8,#0]
0001d4  6148              STR      r0,[r1,#0x14]
0001d6  f8d80000          LDR      r0,[r8,#0]
0001da  6801              LDR      r1,[r0,#0]
0001dc  4640              MOV      r0,r8
0001de  4788              BLX      r1
                  |L1.480|
;;;396      if (ltemp < (long) numrows)
0001e0  45a2              CMP      r10,r4
0001e2  da01              BGE      |L1.488|
;;;397        rowsperchunk = (JDIMENSION) ltemp;
0001e4  4655              MOV      r5,r10
0001e6  e000              B        |L1.490|
                  |L1.488|
;;;398      else
;;;399        rowsperchunk = numrows;
0001e8  4625              MOV      r5,r4
                  |L1.490|
;;;400      mem->last_rowsperchunk = rowsperchunk;
0001ea  9802              LDR      r0,[sp,#8]
0001ec  6505              STR      r5,[r0,#0x50]
;;;401    
;;;402      /* Get space for row pointers (small object) */
;;;403      result = (JSAMPARRAY) alloc_small(cinfo, pool_id, (size_t) (numrows * SIZEOF(JSAMPROW)));
0001ee  00a2              LSLS     r2,r4,#2
0001f0  4640              MOV      r0,r8
0001f2  9904              LDR      r1,[sp,#0x10]
0001f4  f7fffffe          BL       alloc_small
0001f8  4681              MOV      r9,r0
;;;404      /* Get the rows themselves (large objects) */
;;;405      currow = 0;
0001fa  2700              MOVS     r7,#0
;;;406      while (currow < numrows) {
0001fc  e01a              B        |L1.564|
                  |L1.510|
;;;407        rowsperchunk = MIN(rowsperchunk, numrows - currow);
0001fe  1be0              SUBS     r0,r4,r7
000200  42a8              CMP      r0,r5
000202  d901              BLS      |L1.520|
000204  4628              MOV      r0,r5
000206  e000              B        |L1.522|
                  |L1.520|
000208  1be0              SUBS     r0,r4,r7
                  |L1.522|
00020a  4605              MOV      r5,r0
;;;408        workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
00020c  fb05f206          MUL      r2,r5,r6
000210  4640              MOV      r0,r8
000212  9904              LDR      r1,[sp,#0x10]
000214  f7fffffe          BL       alloc_large
000218  4683              MOV      r11,r0
;;;409    	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
;;;410    		  * SIZEOF(JSAMPLE)));
;;;411        for (i = rowsperchunk; i > 0; i--) {
00021a  9501              STR      r5,[sp,#4]
00021c  e007              B        |L1.558|
                  |L1.542|
;;;412          result[currow++] = workspace;
00021e  4638              MOV      r0,r7
000220  1c7f              ADDS     r7,r7,#1
000222  f849b020          STR      r11,[r9,r0,LSL #2]
;;;413          workspace += samplesperrow;
000226  44b3              ADD      r11,r11,r6
000228  9801              LDR      r0,[sp,#4]            ;411
00022a  1e40              SUBS     r0,r0,#1              ;411
00022c  9001              STR      r0,[sp,#4]            ;411
                  |L1.558|
00022e  9801              LDR      r0,[sp,#4]            ;411
000230  2800              CMP      r0,#0                 ;411
000232  d1f4              BNE      |L1.542|
                  |L1.564|
000234  42a7              CMP      r7,r4                 ;406
000236  d3e2              BCC      |L1.510|
;;;414        }
;;;415      }
;;;416    
;;;417      return result;
000238  4648              MOV      r0,r9
;;;418    }
00023a  b007              ADD      sp,sp,#0x1c
00023c  e8bd8ff0          POP      {r4-r11,pc}
;;;419    
                          ENDP

                  alloc_barray PROC
;;;425    
;;;426    METHODDEF(JBLOCKARRAY) alloc_barray (j_common_ptr cinfo, int pool_id,  JDIMENSION blocksperrow, JDIMENSION numrows) {
000240  e92d4fff          PUSH     {r0-r11,lr}
000244  b083              SUB      sp,sp,#0xc
000246  4607              MOV      r7,r0
000248  4690              MOV      r8,r2
00024a  461c              MOV      r4,r3
;;;427      /* Allocate a 2-D coefficient-block array */
;;;428      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
00024c  6878              LDR      r0,[r7,#4]
00024e  9002              STR      r0,[sp,#8]
;;;429      JBLOCKARRAY result;
;;;430      JBLOCKROW workspace;
;;;431      JDIMENSION rowsperchunk, currow, i;
;;;432      long ltemp;
;;;433    
;;;434      /* Calculate max # of rows allowed in one allocation chunk */
;;;435      ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
000250  ea4f10c8          LSL      r0,r8,#7
000254  496d              LDR      r1,|L1.1036|
000256  fbb1faf0          UDIV     r10,r1,r0
;;;436    	  ((long) blocksperrow * SIZEOF(JBLOCK));
;;;437      if (ltemp <= 0)
00025a  f1ba0f00          CMP      r10,#0
00025e  dc06              BGT      |L1.622|
;;;438        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
000260  2046              MOVS     r0,#0x46
000262  6839              LDR      r1,[r7,#0]
000264  6148              STR      r0,[r1,#0x14]
000266  6838              LDR      r0,[r7,#0]
000268  6801              LDR      r1,[r0,#0]
00026a  4638              MOV      r0,r7
00026c  4788              BLX      r1
                  |L1.622|
;;;439      if (ltemp < (long) numrows)
00026e  45a2              CMP      r10,r4
000270  da01              BGE      |L1.630|
;;;440        rowsperchunk = (JDIMENSION) ltemp;
000272  4655              MOV      r5,r10
000274  e000              B        |L1.632|
                  |L1.630|
;;;441      else
;;;442        rowsperchunk = numrows;
000276  4625              MOV      r5,r4
                  |L1.632|
;;;443      mem->last_rowsperchunk = rowsperchunk;
000278  9802              LDR      r0,[sp,#8]
00027a  6505              STR      r5,[r0,#0x50]
;;;444    
;;;445      /* Get space for row pointers (small object) */
;;;446      result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
00027c  00a2              LSLS     r2,r4,#2
00027e  4638              MOV      r0,r7
000280  9904              LDR      r1,[sp,#0x10]
000282  f7fffffe          BL       alloc_small
000286  4681              MOV      r9,r0
;;;447    				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
;;;448    
;;;449      /* Get the rows themselves (large objects) */
;;;450      currow = 0;
000288  2600              MOVS     r6,#0
;;;451      while (currow < numrows) {
00028a  e01c              B        |L1.710|
                  |L1.652|
;;;452        rowsperchunk = MIN(rowsperchunk, numrows - currow);
00028c  1ba0              SUBS     r0,r4,r6
00028e  42a8              CMP      r0,r5
000290  d901              BLS      |L1.662|
000292  4628              MOV      r0,r5
000294  e000              B        |L1.664|
                  |L1.662|
000296  1ba0              SUBS     r0,r4,r6
                  |L1.664|
000298  4605              MOV      r5,r0
;;;453        workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
00029a  fb05f008          MUL      r0,r5,r8
00029e  01c2              LSLS     r2,r0,#7
0002a0  4638              MOV      r0,r7
0002a2  9904              LDR      r1,[sp,#0x10]
0002a4  f7fffffe          BL       alloc_large
0002a8  4683              MOV      r11,r0
;;;454    	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
;;;455    		  * SIZEOF(JBLOCK)));
;;;456        for (i = rowsperchunk; i > 0; i--) {
0002aa  9501              STR      r5,[sp,#4]
0002ac  e008              B        |L1.704|
                  |L1.686|
;;;457          result[currow++] = workspace;
0002ae  4630              MOV      r0,r6
0002b0  1c76              ADDS     r6,r6,#1
0002b2  f849b020          STR      r11,[r9,r0,LSL #2]
;;;458          workspace += blocksperrow;
0002b6  eb0b1bc8          ADD      r11,r11,r8,LSL #7
0002ba  9801              LDR      r0,[sp,#4]            ;456
0002bc  1e40              SUBS     r0,r0,#1              ;456
0002be  9001              STR      r0,[sp,#4]            ;456
                  |L1.704|
0002c0  9801              LDR      r0,[sp,#4]            ;456
0002c2  2800              CMP      r0,#0                 ;456
0002c4  d1f3              BNE      |L1.686|
                  |L1.710|
0002c6  42a6              CMP      r6,r4                 ;451
0002c8  d3e0              BCC      |L1.652|
;;;459        }
;;;460      }
;;;461    
;;;462      return result;
0002ca  4648              MOV      r0,r9
;;;463    }
0002cc  b007              ADD      sp,sp,#0x1c
0002ce  e8bd8ff0          POP      {r4-r11,pc}
;;;464    
                          ENDP

                  request_virt_sarray PROC
;;;502    
;;;503    METHODDEF(jvirt_sarray_ptr) request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION samplesperrow, JDIMENSION numrows, JDIMENSION maxaccess) {
0002d2  e92d5ff0          PUSH     {r4-r12,lr}
0002d6  4605              MOV      r5,r0
0002d8  460e              MOV      r6,r1
0002da  4617              MOV      r7,r2
0002dc  4698              MOV      r8,r3
0002de  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;504      /* Request a virtual 2-D sample array */
;;;505      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
0002e2  f8d59004          LDR      r9,[r5,#4]
;;;506      jvirt_sarray_ptr result;
;;;507    
;;;508      /* Only IMAGE-lifetime virtual arrays are currently supported */
;;;509      if (pool_id != JPOOL_IMAGE) {
0002e6  2e01              CMP      r6,#1
0002e8  d008              BEQ      |L1.764|
;;;510        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
0002ea  200e              MOVS     r0,#0xe
0002ec  6829              LDR      r1,[r5,#0]
0002ee  6148              STR      r0,[r1,#0x14]
0002f0  6828              LDR      r0,[r5,#0]
0002f2  6186              STR      r6,[r0,#0x18]
0002f4  6828              LDR      r0,[r5,#0]
0002f6  6801              LDR      r1,[r0,#0]
0002f8  4628              MOV      r0,r5
0002fa  4788              BLX      r1
                  |L1.764|
;;;511      }
;;;512      /* get control block */
;;;513      result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id, SIZEOF(struct jvirt_sarray_control));
0002fc  227c              MOVS     r2,#0x7c
0002fe  4631              MOV      r1,r6
000300  4628              MOV      r0,r5
000302  f7fffffe          BL       alloc_small
000306  4604              MOV      r4,r0
;;;514      result->mem_buffer = NULL;	/* marks array not yet realized */
000308  2100              MOVS     r1,#0
00030a  6021              STR      r1,[r4,#0]
;;;515      result->rows_in_array = numrows;
00030c  f8c4a004          STR      r10,[r4,#4]
;;;516      result->samplesperrow = samplesperrow;
000310  f8c48008          STR      r8,[r4,#8]
;;;517      result->maxaccess = maxaccess;
000314  f8c4b00c          STR      r11,[r4,#0xc]
;;;518      result->pre_zero = pre_zero;
000318  6227              STR      r7,[r4,#0x20]
;;;519      result->b_s_open = FALSE;	/* no associated backing-store object */
00031a  62a1              STR      r1,[r4,#0x28]
;;;520      result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
00031c  f8d91044          LDR      r1,[r9,#0x44]
000320  62e1              STR      r1,[r4,#0x2c]
;;;521      mem->virt_sarray_list = result;
000322  f8c94044          STR      r4,[r9,#0x44]
;;;522    
;;;523      return result;
000326  4620              MOV      r0,r4
;;;524    }
000328  e8bd9ff0          POP      {r4-r12,pc}
;;;525    
                          ENDP

                  request_virt_barray PROC
;;;526    
;;;527    METHODDEF(jvirt_barray_ptr) request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION blocksperrow, JDIMENSION numrows, JDIMENSION maxaccess) {
00032c  e92d5ff0          PUSH     {r4-r12,lr}
000330  4605              MOV      r5,r0
000332  460e              MOV      r6,r1
000334  4617              MOV      r7,r2
000336  4698              MOV      r8,r3
000338  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;528      /* Request a virtual 2-D coefficient-block array */
;;;529      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
00033c  f8d59004          LDR      r9,[r5,#4]
;;;530      jvirt_barray_ptr result;
;;;531      /* Only IMAGE-lifetime virtual arrays are currently supported */
;;;532      if (pool_id != JPOOL_IMAGE)
000340  2e01              CMP      r6,#1
000342  d008              BEQ      |L1.854|
;;;533        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000344  200e              MOVS     r0,#0xe
000346  6829              LDR      r1,[r5,#0]
000348  6148              STR      r0,[r1,#0x14]
00034a  6828              LDR      r0,[r5,#0]
00034c  6186              STR      r6,[r0,#0x18]
00034e  6828              LDR      r0,[r5,#0]
000350  6801              LDR      r1,[r0,#0]
000352  4628              MOV      r0,r5
000354  4788              BLX      r1
                  |L1.854|
;;;534    
;;;535      /* get control block */
;;;536      result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id, SIZEOF(struct jvirt_barray_control));
000356  227c              MOVS     r2,#0x7c
000358  4631              MOV      r1,r6
00035a  4628              MOV      r0,r5
00035c  f7fffffe          BL       alloc_small
000360  4604              MOV      r4,r0
;;;537      result->mem_buffer = NULL;	/* marks array not yet realized */
000362  2100              MOVS     r1,#0
000364  6021              STR      r1,[r4,#0]
;;;538      result->rows_in_array = numrows;
000366  f8c4a004          STR      r10,[r4,#4]
;;;539      result->blocksperrow = blocksperrow;
00036a  f8c48008          STR      r8,[r4,#8]
;;;540      result->maxaccess = maxaccess;
00036e  f8c4b00c          STR      r11,[r4,#0xc]
;;;541      result->pre_zero = pre_zero;
000372  6227              STR      r7,[r4,#0x20]
;;;542      result->b_s_open = FALSE;	/* no associated backing-store object */
000374  62a1              STR      r1,[r4,#0x28]
;;;543      result->next = mem->virt_barray_list; /* add to list of virtual arrays */
000376  f8d91048          LDR      r1,[r9,#0x48]
00037a  62e1              STR      r1,[r4,#0x2c]
;;;544      mem->virt_barray_list = result;
00037c  f8c94048          STR      r4,[r9,#0x48]
;;;545    
;;;546      return result;
000380  4620              MOV      r0,r4
;;;547    }
000382  e8bd9ff0          POP      {r4-r12,pc}
;;;548    
                          ENDP

                  realize_virt_arrays PROC
;;;549    
;;;550    METHODDEF(void) realize_virt_arrays (j_common_ptr cinfo) {
000386  e92d47f0          PUSH     {r4-r10,lr}
00038a  4606              MOV      r6,r0
;;;551    /* Allocate the in-memory buffers for any unrealized virtual arrays */
;;;552      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
00038c  f8d68004          LDR      r8,[r6,#4]
;;;553      long space_per_minheight, maximum_space/*, avail_mem*/;
;;;554    /*  long minheights, max_minheights;*/
;;;555      jvirt_sarray_ptr sptr;
;;;556      jvirt_barray_ptr bptr;
;;;557    
;;;558      /* Compute the minimum space needed (maxaccess rows in each buffer)
;;;559       * and the maximum space needed (full image height in each buffer).
;;;560       * These may be of use to the system-dependent jpeg_mem_available routine.
;;;561       */
;;;562      space_per_minheight = 0;
000390  2700              MOVS     r7,#0
;;;563      maximum_space = 0;
000392  46b9              MOV      r9,r7
;;;564      for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
000394  f8d85044          LDR      r5,[r8,#0x44]
000398  e00a              B        |L1.944|
                  |L1.922|
;;;565        if (sptr->mem_buffer == NULL) { /* if not realized yet */
00039a  6828              LDR      r0,[r5,#0]
00039c  b938              CBNZ     r0,|L1.942|
;;;566          space_per_minheight += (long) sptr->maxaccess *
00039e  e9d51002          LDRD     r1,r0,[r5,#8]
0003a2  fb007701          MLA      r7,r0,r1,r7
;;;567    			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
;;;568          maximum_space += (long) sptr->rows_in_array *
0003a6  e9d50101          LDRD     r0,r1,[r5,#4]
0003aa  fb009901          MLA      r9,r0,r1,r9
                  |L1.942|
0003ae  6aed              LDR      r5,[r5,#0x2c]         ;564
                  |L1.944|
0003b0  2d00              CMP      r5,#0                 ;564
0003b2  d1f2              BNE      |L1.922|
;;;569    		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
;;;570        }
;;;571      }
;;;572      for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
0003b4  f8d84048          LDR      r4,[r8,#0x48]
0003b8  e00c              B        |L1.980|
                  |L1.954|
;;;573        if (bptr->mem_buffer == NULL) { /* if not realized yet */
0003ba  6820              LDR      r0,[r4,#0]
0003bc  b948              CBNZ     r0,|L1.978|
;;;574          space_per_minheight += (long) bptr->maxaccess *
0003be  e9d41002          LDRD     r1,r0,[r4,#8]
0003c2  4348              MULS     r0,r1,r0
0003c4  eb0717c0          ADD      r7,r7,r0,LSL #7
;;;575    			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
;;;576          maximum_space += (long) bptr->rows_in_array *
0003c8  e9d40101          LDRD     r0,r1,[r4,#4]
0003cc  4348              MULS     r0,r1,r0
0003ce  eb0919c0          ADD      r9,r9,r0,LSL #7
                  |L1.978|
0003d2  6ae4              LDR      r4,[r4,#0x2c]         ;572
                  |L1.980|
0003d4  2c00              CMP      r4,#0                 ;572
0003d6  d1f0              BNE      |L1.954|
;;;577    		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
;;;578        }
;;;579      }
;;;580    
;;;581      if (space_per_minheight <= 0)
0003d8  2f00              CMP      r7,#0
0003da  dc01              BGT      |L1.992|
                  |L1.988|
;;;582        return;			/* no unrealized arrays, no work */
;;;583    
;;;584    #if 0  /*RS*/
;;;585      /* Determine amount of memory to actually use; this is system-dependent. */
;;;586      avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space, mem->total_space_allocated);
;;;587    
;;;588      /* If the maximum space needed is available, make all the buffers full
;;;589       * height; otherwise parcel it out with the same number of minheights
;;;590       * in each buffer.
;;;591       */
;;;592      if (avail_mem >= maximum_space)
;;;593        max_minheights = 1000000000L;
;;;594      else {
;;;595        max_minheights = avail_mem / space_per_minheight;
;;;596        /* If there doesn't seem to be enough space, try to get the minimum
;;;597         * anyway.  This allows a "stub" implementation of jpeg_mem_available().
;;;598         */
;;;599        if (max_minheights <= 0)
;;;600          max_minheights = 1;
;;;601      }
;;;602    
;;;603      /* Allocate the in-memory buffers and initialize backing store as needed. */
;;;604      for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
;;;605        if (sptr->mem_buffer == NULL) { /* if not realized yet */
;;;606          minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
;;;607          if (minheights <= max_minheights) {
;;;608    	/* This buffer fits in memory */
;;;609    	sptr->rows_in_mem = sptr->rows_in_array;
;;;610          } else {
;;;611    	/* It doesn't fit in memory, create backing store. */
;;;612    	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
;;;613    	jpeg_open_backing_store(cinfo, & sptr->b_s_info, (long) sptr->rows_in_array * (long) sptr->samplesperrow * (long) SIZEOF(JSAMPLE));
;;;614    	sptr->b_s_open = TRUE;
;;;615          }
;;;616          sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
;;;617    				      sptr->samplesperrow, sptr->rows_in_mem);
;;;618          sptr->rowsperchunk = mem->last_rowsperchunk;
;;;619          sptr->cur_start_row = 0;
;;;620          sptr->first_undef_row = 0;
;;;621          sptr->dirty = FALSE;
;;;622        }
;;;623      }
;;;624    
;;;625      for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
;;;626        if (bptr->mem_buffer == NULL) { /* if not realized yet */
;;;627          minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
;;;628          if (minheights <= max_minheights) {
;;;629    	/* This buffer fits in memory */
;;;630    	bptr->rows_in_mem = bptr->rows_in_array;
;;;631          } else {
;;;632    	/* It doesn't fit in memory, create backing store. */
;;;633    	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
;;;634    	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
;;;635    				(long) bptr->rows_in_array *
;;;636    				(long) bptr->blocksperrow *
;;;637    				(long) SIZEOF(JBLOCK));
;;;638    	bptr->b_s_open = TRUE;
;;;639          }
;;;640          bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
;;;641    				      bptr->blocksperrow, bptr->rows_in_mem);
;;;642          bptr->rowsperchunk = mem->last_rowsperchunk;
;;;643          bptr->cur_start_row = 0;
;;;644          bptr->first_undef_row = 0;
;;;645          bptr->dirty = FALSE;
;;;646        }
;;;647      }
;;;648    # else
;;;649      ERREXIT(cinfo, JERR_NO_BACKING_STORE);
;;;650    #endif
;;;651    }
0003dc  e8bd87f0          POP      {r4-r10,pc}
                  |L1.992|
0003e0  2031              MOVS     r0,#0x31              ;649
0003e2  6831              LDR      r1,[r6,#0]            ;649
0003e4  6148              STR      r0,[r1,#0x14]         ;649
0003e6  6830              LDR      r0,[r6,#0]            ;649
0003e8  6801              LDR      r1,[r0,#0]            ;649
0003ea  4630              MOV      r0,r6                 ;649
0003ec  4788              BLX      r1                    ;649
0003ee  bf00              NOP      
0003f0  e7f4              B        |L1.988|
;;;652    
                          ENDP

                  do_sarray_io PROC
;;;653    
;;;654    LOCAL(void) do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing) {
0003f2  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
0003f6  b082              SUB      sp,sp,#8
0003f8  460c              MOV      r4,r1
0003fa  4691              MOV      r9,r2
;;;655    /* Do backing store read or write of a virtual sample array */
;;;656      long bytesperrow, file_offset, byte_count, rows, thisrow, i;
;;;657    
;;;658      bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
0003fc  f8d4a008          LDR      r10,[r4,#8]
;;;659      file_offset = ptr->cur_start_row * bytesperrow;
000400  69a0              LDR      r0,[r4,#0x18]
000402  fb00fb0a          MUL      r11,r0,r10
;;;660      /* Loop to read or write each allocation chunk in mem_buffer */
;;;661      for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
000406  2500              MOVS     r5,#0
000408  e047              B        |L1.1178|
00040a  0000              DCW      0x0000
                  |L1.1036|
                          DCD      0x3b9ac9f0
                  |L1.1040|
                          DCD      first_pool_slop
                  |L1.1044|
                          DCD      extra_pool_slop
                  |L1.1048|
;;;662        /* One chunk, but check for short chunk at end of buffer */
;;;663        rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
000418  e9d41004          LDRD     r1,r0,[r4,#0x10]
00041c  1b49              SUBS     r1,r1,r5
00041e  4288              CMP      r0,r1
000420  da01              BGE      |L1.1062|
000422  6960              LDR      r0,[r4,#0x14]
000424  e001              B        |L1.1066|
                  |L1.1062|
000426  6920              LDR      r0,[r4,#0x10]
000428  1b40              SUBS     r0,r0,r5
                  |L1.1066|
00042a  4680              MOV      r8,r0
;;;664        /* Transfer no more than is currently defined */
;;;665        thisrow = (long) ptr->cur_start_row + i;
00042c  69a0              LDR      r0,[r4,#0x18]
00042e  1946              ADDS     r6,r0,r5
;;;666        rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
000430  69e0              LDR      r0,[r4,#0x1c]
000432  1b80              SUBS     r0,r0,r6
000434  4540              CMP      r0,r8
000436  dd01              BLE      |L1.1084|
000438  4640              MOV      r0,r8
00043a  e001              B        |L1.1088|
                  |L1.1084|
00043c  69e0              LDR      r0,[r4,#0x1c]
00043e  1b80              SUBS     r0,r0,r6
                  |L1.1088|
000440  4680              MOV      r8,r0
;;;667        /* Transfer no more than fits in file */
;;;668        rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
000442  6860              LDR      r0,[r4,#4]
000444  1b80              SUBS     r0,r0,r6
000446  4540              CMP      r0,r8
000448  dd01              BLE      |L1.1102|
00044a  4640              MOV      r0,r8
00044c  e001              B        |L1.1106|
                  |L1.1102|
00044e  6860              LDR      r0,[r4,#4]
000450  1b80              SUBS     r0,r0,r6
                  |L1.1106|
000452  4680              MOV      r8,r0
;;;669        if (rows <= 0)		/* this chunk might be past end of file! */
000454  f1b80f00          CMP      r8,#0
000458  dc00              BGT      |L1.1116|
;;;670          break;
00045a  e021              B        |L1.1184|
                  |L1.1116|
;;;671        byte_count = rows * bytesperrow;
00045c  fb08f70a          MUL      r7,r8,r10
;;;672        if (writing)
000460  f1b90f00          CMP      r9,#0
000464  d00b              BEQ      |L1.1150|
;;;673          (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
000466  9700              STR      r7,[sp,#0]
000468  6820              LDR      r0,[r4,#0]
00046a  f8502025          LDR      r2,[r0,r5,LSL #2]
00046e  465b              MOV      r3,r11
000470  f1040130          ADD      r1,r4,#0x30
000474  f8d4c034          LDR      r12,[r4,#0x34]
000478  9802              LDR      r0,[sp,#8]
00047a  47e0              BLX      r12
00047c  e00a              B        |L1.1172|
                  |L1.1150|
;;;674    					    (void FAR *) ptr->mem_buffer[i],
;;;675    					    file_offset, byte_count);
;;;676        else
;;;677          (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
00047e  9700              STR      r7,[sp,#0]
000480  6820              LDR      r0,[r4,#0]
000482  f8502025          LDR      r2,[r0,r5,LSL #2]
000486  465b              MOV      r3,r11
000488  f1040130          ADD      r1,r4,#0x30
00048c  f8d4c030          LDR      r12,[r4,#0x30]
000490  9802              LDR      r0,[sp,#8]
000492  47e0              BLX      r12
                  |L1.1172|
;;;678    					   (void FAR *) ptr->mem_buffer[i],
;;;679    					   file_offset, byte_count);
;;;680        file_offset += byte_count;
000494  44bb              ADD      r11,r11,r7
000496  6960              LDR      r0,[r4,#0x14]         ;661
000498  4405              ADD      r5,r5,r0              ;661
                  |L1.1178|
00049a  6920              LDR      r0,[r4,#0x10]         ;661
00049c  42a8              CMP      r0,r5                 ;661
00049e  dcbb              BGT      |L1.1048|
                  |L1.1184|
0004a0  bf00              NOP                            ;670
;;;681      }
;;;682    }
0004a2  b005              ADD      sp,sp,#0x14
0004a4  e8bd8ff0          POP      {r4-r11,pc}
;;;683    
                          ENDP

                  do_barray_io PROC
;;;685    /* Do backing store read or write of a virtual coefficient-block array */
;;;686    LOCAL(void) do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing) {
0004a8  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
0004ac  b082              SUB      sp,sp,#8
0004ae  460c              MOV      r4,r1
0004b0  4691              MOV      r9,r2
;;;687      long bytesperrow, file_offset, byte_count, rows, thisrow, i;
;;;688    
;;;689      bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
0004b2  68a0              LDR      r0,[r4,#8]
0004b4  ea4f1ac0          LSL      r10,r0,#7
;;;690      file_offset = ptr->cur_start_row * bytesperrow;
0004b8  69a0              LDR      r0,[r4,#0x18]
0004ba  fb00fb0a          MUL      r11,r0,r10
;;;691      /* Loop to read or write each allocation chunk in mem_buffer */
;;;692      for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
0004be  2500              MOVS     r5,#0
0004c0  e040              B        |L1.1348|
                  |L1.1218|
;;;693        /* One chunk, but check for short chunk at end of buffer */
;;;694        rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
0004c2  e9d41004          LDRD     r1,r0,[r4,#0x10]
0004c6  1b49              SUBS     r1,r1,r5
0004c8  4288              CMP      r0,r1
0004ca  da01              BGE      |L1.1232|
0004cc  6960              LDR      r0,[r4,#0x14]
0004ce  e001              B        |L1.1236|
                  |L1.1232|
0004d0  6920              LDR      r0,[r4,#0x10]
0004d2  1b40              SUBS     r0,r0,r5
                  |L1.1236|
0004d4  4680              MOV      r8,r0
;;;695        /* Transfer no more than is currently defined */
;;;696        thisrow = (long) ptr->cur_start_row + i;
0004d6  69a0              LDR      r0,[r4,#0x18]
0004d8  1946              ADDS     r6,r0,r5
;;;697        rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
0004da  69e0              LDR      r0,[r4,#0x1c]
0004dc  1b80              SUBS     r0,r0,r6
0004de  4540              CMP      r0,r8
0004e0  dd01              BLE      |L1.1254|
0004e2  4640              MOV      r0,r8
0004e4  e001              B        |L1.1258|
                  |L1.1254|
0004e6  69e0              LDR      r0,[r4,#0x1c]
0004e8  1b80              SUBS     r0,r0,r6
                  |L1.1258|
0004ea  4680              MOV      r8,r0
;;;698        /* Transfer no more than fits in file */
;;;699        rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
0004ec  6860              LDR      r0,[r4,#4]
0004ee  1b80              SUBS     r0,r0,r6
0004f0  4540              CMP      r0,r8
0004f2  dd01              BLE      |L1.1272|
0004f4  4640              MOV      r0,r8
0004f6  e001              B        |L1.1276|
                  |L1.1272|
0004f8  6860              LDR      r0,[r4,#4]
0004fa  1b80              SUBS     r0,r0,r6
                  |L1.1276|
0004fc  4680              MOV      r8,r0
;;;700        if (rows <= 0)		/* this chunk might be past end of file! */
0004fe  f1b80f00          CMP      r8,#0
000502  dc00              BGT      |L1.1286|
;;;701          break;
000504  e021              B        |L1.1354|
                  |L1.1286|
;;;702        byte_count = rows * bytesperrow;
000506  fb08f70a          MUL      r7,r8,r10
;;;703        if (writing)
00050a  f1b90f00          CMP      r9,#0
00050e  d00b              BEQ      |L1.1320|
;;;704          (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
000510  9700              STR      r7,[sp,#0]
000512  6820              LDR      r0,[r4,#0]
000514  f8502025          LDR      r2,[r0,r5,LSL #2]
000518  465b              MOV      r3,r11
00051a  f1040130          ADD      r1,r4,#0x30
00051e  f8d4c034          LDR      r12,[r4,#0x34]
000522  9802              LDR      r0,[sp,#8]
000524  47e0              BLX      r12
000526  e00a              B        |L1.1342|
                  |L1.1320|
;;;705    					    (void FAR *) ptr->mem_buffer[i],
;;;706    					    file_offset, byte_count);
;;;707        else
;;;708          (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
000528  9700              STR      r7,[sp,#0]
00052a  6820              LDR      r0,[r4,#0]
00052c  f8502025          LDR      r2,[r0,r5,LSL #2]
000530  465b              MOV      r3,r11
000532  f1040130          ADD      r1,r4,#0x30
000536  f8d4c030          LDR      r12,[r4,#0x30]
00053a  9802              LDR      r0,[sp,#8]
00053c  47e0              BLX      r12
                  |L1.1342|
;;;709    					   (void FAR *) ptr->mem_buffer[i],
;;;710    					   file_offset, byte_count);
;;;711        file_offset += byte_count;
00053e  44bb              ADD      r11,r11,r7
000540  6960              LDR      r0,[r4,#0x14]         ;692
000542  4405              ADD      r5,r5,r0              ;692
                  |L1.1348|
000544  6920              LDR      r0,[r4,#0x10]         ;692
000546  42a8              CMP      r0,r5                 ;692
000548  dcbb              BGT      |L1.1218|
                  |L1.1354|
00054a  bf00              NOP                            ;701
;;;712      }
;;;713    }
00054c  b005              ADD      sp,sp,#0x14
00054e  e8bd8ff0          POP      {r4-r11,pc}
;;;714    
                          ENDP

                  access_virt_sarray PROC
;;;718    /* caller intends to modify the accessed area. */
;;;719    METHODDEF(JSAMPARRAY) access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable) {
000552  e92d5ff0          PUSH     {r4-r12,lr}
000556  4605              MOV      r5,r0
000558  460c              MOV      r4,r1
00055a  4616              MOV      r6,r2
00055c  469a              MOV      r10,r3
00055e  f8dd9028          LDR      r9,[sp,#0x28]
;;;720      JDIMENSION end_row = start_row + num_rows;
000562  eb06070a          ADD      r7,r6,r10
;;;721      JDIMENSION undef_row;
;;;722    
;;;723      /* debugging check */
;;;724      if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
000566  6860              LDR      r0,[r4,#4]
000568  42b8              CMP      r0,r7
00056a  d304              BCC      |L1.1398|
00056c  68e0              LDR      r0,[r4,#0xc]
00056e  4550              CMP      r0,r10
000570  d301              BCC      |L1.1398|
;;;725          ptr->mem_buffer == NULL)
000572  6820              LDR      r0,[r4,#0]
000574  b930              CBNZ     r0,|L1.1412|
                  |L1.1398|
;;;726        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000576  2016              MOVS     r0,#0x16
000578  6829              LDR      r1,[r5,#0]
00057a  6148              STR      r0,[r1,#0x14]
00057c  6828              LDR      r0,[r5,#0]
00057e  6801              LDR      r1,[r0,#0]
000580  4628              MOV      r0,r5
000582  4788              BLX      r1
                  |L1.1412|
;;;727    
;;;728      /* Make the desired part of the virtual array accessible */
;;;729      if (start_row < ptr->cur_start_row ||
000584  69a0              LDR      r0,[r4,#0x18]
000586  42b0              CMP      r0,r6
000588  d804              BHI      |L1.1428|
;;;730          end_row > ptr->cur_start_row+ptr->rows_in_mem) {
00058a  6921              LDR      r1,[r4,#0x10]
00058c  69a0              LDR      r0,[r4,#0x18]
00058e  4408              ADD      r0,r0,r1
000590  42b8              CMP      r0,r7
000592  d222              BCS      |L1.1498|
                  |L1.1428|
;;;731        if (! ptr->b_s_open)
000594  6aa0              LDR      r0,[r4,#0x28]
000596  b930              CBNZ     r0,|L1.1446|
;;;732          ERREXIT(cinfo, JERR_VIRTUAL_BUG);
000598  2045              MOVS     r0,#0x45
00059a  6829              LDR      r1,[r5,#0]
00059c  6148              STR      r0,[r1,#0x14]
00059e  6828              LDR      r0,[r5,#0]
0005a0  6801              LDR      r1,[r0,#0]
0005a2  4628              MOV      r0,r5
0005a4  4788              BLX      r1
                  |L1.1446|
;;;733        /* Flush old buffer contents if necessary */
;;;734        if (ptr->dirty) {
0005a6  6a60              LDR      r0,[r4,#0x24]
0005a8  b130              CBZ      r0,|L1.1464|
;;;735          do_sarray_io(cinfo, ptr, TRUE);
0005aa  2201              MOVS     r2,#1
0005ac  4621              MOV      r1,r4
0005ae  4628              MOV      r0,r5
0005b0  f7fffffe          BL       do_sarray_io
;;;736          ptr->dirty = FALSE;
0005b4  2000              MOVS     r0,#0
0005b6  6260              STR      r0,[r4,#0x24]
                  |L1.1464|
;;;737        }
;;;738        /* Decide what part of virtual array to access.
;;;739         * Algorithm: if target address > current window, assume forward scan,
;;;740         * load starting at target address.  If target address < current window,
;;;741         * assume backward scan, load so that target area is top of window.
;;;742         * Note that when switching from forward write to forward read, will have
;;;743         * start_row = 0, so the limiting case applies and we load from 0 anyway.
;;;744         */
;;;745        if (start_row > ptr->cur_start_row) {
0005b8  69a0              LDR      r0,[r4,#0x18]
0005ba  42b0              CMP      r0,r6
0005bc  d201              BCS      |L1.1474|
;;;746          ptr->cur_start_row = start_row;
0005be  61a6              STR      r6,[r4,#0x18]
0005c0  e006              B        |L1.1488|
                  |L1.1474|
;;;747        } else {
;;;748          /* use long arithmetic here to avoid overflow & unsigned problems */
;;;749          long ltemp;
;;;750    
;;;751          ltemp = (long) end_row - (long) ptr->rows_in_mem;
0005c2  6921              LDR      r1,[r4,#0x10]
0005c4  1a78              SUBS     r0,r7,r1
;;;752          if (ltemp < 0)
0005c6  2800              CMP      r0,#0
0005c8  da00              BGE      |L1.1484|
;;;753    	ltemp = 0;		/* don't fall off front end of file */
0005ca  2000              MOVS     r0,#0
                  |L1.1484|
;;;754          ptr->cur_start_row = (JDIMENSION) ltemp;
0005cc  61a0              STR      r0,[r4,#0x18]
;;;755        }
0005ce  bf00              NOP      
                  |L1.1488|
;;;756        /* Read in the selected part of the array.
;;;757         * During the initial write pass, we will do no actual read
;;;758         * because the selected part is all undefined.
;;;759         */
;;;760        do_sarray_io(cinfo, ptr, FALSE);
0005d0  2200              MOVS     r2,#0
0005d2  4621              MOV      r1,r4
0005d4  4628              MOV      r0,r5
0005d6  f7fffffe          BL       do_sarray_io
                  |L1.1498|
;;;761      }
;;;762      /* Ensure the accessed part of the array is defined; prezero if needed.
;;;763       * To improve locality of access, we only prezero the part of the array
;;;764       * that the caller is about to access, not the entire in-memory array.
;;;765       */
;;;766      if (ptr->first_undef_row < end_row) {
0005da  69e0              LDR      r0,[r4,#0x1c]
0005dc  42b8              CMP      r0,r7
0005de  d233              BCS      |L1.1608|
;;;767        if (ptr->first_undef_row < start_row) {
0005e0  69e0              LDR      r0,[r4,#0x1c]
0005e2  42b0              CMP      r0,r6
0005e4  d20b              BCS      |L1.1534|
;;;768          if (writable)		/* writer skipped over a section of array */
0005e6  f1b90f00          CMP      r9,#0
0005ea  d006              BEQ      |L1.1530|
;;;769    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
0005ec  2016              MOVS     r0,#0x16
0005ee  6829              LDR      r1,[r5,#0]
0005f0  6148              STR      r0,[r1,#0x14]
0005f2  6828              LDR      r0,[r5,#0]
0005f4  6801              LDR      r1,[r0,#0]
0005f6  4628              MOV      r0,r5
0005f8  4788              BLX      r1
                  |L1.1530|
;;;770          undef_row = start_row;	/* but reader is allowed to read ahead */
0005fa  46b0              MOV      r8,r6
0005fc  e001              B        |L1.1538|
                  |L1.1534|
;;;771        } else {
;;;772          undef_row = ptr->first_undef_row;
0005fe  f8d4801c          LDR      r8,[r4,#0x1c]
                  |L1.1538|
;;;773        }
;;;774        if (writable)
000602  f1b90f00          CMP      r9,#0
000606  d000              BEQ      |L1.1546|
;;;775          ptr->first_undef_row = end_row;
000608  61e7              STR      r7,[r4,#0x1c]
                  |L1.1546|
;;;776        if (ptr->pre_zero) {
00060a  6a20              LDR      r0,[r4,#0x20]
00060c  b190              CBZ      r0,|L1.1588|
;;;777          size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
00060e  f8d4b008          LDR      r11,[r4,#8]
;;;778          undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
000612  69a0              LDR      r0,[r4,#0x18]
000614  eba80800          SUB      r8,r8,r0
;;;779          end_row -= ptr->cur_start_row;
000618  69a0              LDR      r0,[r4,#0x18]
00061a  1a3f              SUBS     r7,r7,r0
;;;780          while (undef_row < end_row) {
00061c  e007              B        |L1.1582|
                  |L1.1566|
;;;781    	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
00061e  6821              LDR      r1,[r4,#0]
000620  f8510028          LDR      r0,[r1,r8,LSL #2]
000624  4659              MOV      r1,r11
000626  f7fffffe          BL       jzero_far
;;;782    	undef_row++;
00062a  f1080801          ADD      r8,r8,#1
                  |L1.1582|
00062e  45b8              CMP      r8,r7                 ;780
000630  d3f5              BCC      |L1.1566|
;;;783          }
;;;784        } else {
000632  e009              B        |L1.1608|
                  |L1.1588|
;;;785          if (! writable)		/* reader looking at undefined data */
000634  f1b90f00          CMP      r9,#0
000638  d106              BNE      |L1.1608|
;;;786    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
00063a  2016              MOVS     r0,#0x16
00063c  6829              LDR      r1,[r5,#0]
00063e  6148              STR      r0,[r1,#0x14]
000640  6828              LDR      r0,[r5,#0]
000642  6801              LDR      r1,[r0,#0]
000644  4628              MOV      r0,r5
000646  4788              BLX      r1
                  |L1.1608|
;;;787        }
;;;788      }
;;;789      /* Flag the buffer dirty if caller will write in it */
;;;790      if (writable)
000648  f1b90f00          CMP      r9,#0
00064c  d001              BEQ      |L1.1618|
;;;791        ptr->dirty = TRUE;
00064e  2001              MOVS     r0,#1
000650  6260              STR      r0,[r4,#0x24]
                  |L1.1618|
;;;792      /* Return address of proper part of the buffer */
;;;793      return ptr->mem_buffer + (start_row - ptr->cur_start_row);
000652  69a1              LDR      r1,[r4,#0x18]
000654  1a71              SUBS     r1,r6,r1
000656  6820              LDR      r0,[r4,#0]
000658  eb000081          ADD      r0,r0,r1,LSL #2
;;;794    }
00065c  e8bd9ff0          POP      {r4-r12,pc}
;;;795    
                          ENDP

                  access_virt_barray PROC
;;;799    /* caller intends to modify the accessed area. */
;;;800    METHODDEF(JBLOCKARRAY) access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows,  boolean writable) {
000660  e92d5ff0          PUSH     {r4-r12,lr}
000664  4605              MOV      r5,r0
000666  460c              MOV      r4,r1
000668  4616              MOV      r6,r2
00066a  469a              MOV      r10,r3
00066c  f8dd9028          LDR      r9,[sp,#0x28]
;;;801      JDIMENSION end_row = start_row + num_rows;
000670  eb06070a          ADD      r7,r6,r10
;;;802      JDIMENSION undef_row;
;;;803    
;;;804      /* debugging check */
;;;805      if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
000674  6860              LDR      r0,[r4,#4]
000676  42b8              CMP      r0,r7
000678  d304              BCC      |L1.1668|
00067a  68e0              LDR      r0,[r4,#0xc]
00067c  4550              CMP      r0,r10
00067e  d301              BCC      |L1.1668|
;;;806          ptr->mem_buffer == NULL)
000680  6820              LDR      r0,[r4,#0]
000682  b930              CBNZ     r0,|L1.1682|
                  |L1.1668|
;;;807        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000684  2016              MOVS     r0,#0x16
000686  6829              LDR      r1,[r5,#0]
000688  6148              STR      r0,[r1,#0x14]
00068a  6828              LDR      r0,[r5,#0]
00068c  6801              LDR      r1,[r0,#0]
00068e  4628              MOV      r0,r5
000690  4788              BLX      r1
                  |L1.1682|
;;;808    
;;;809      /* Make the desired part of the virtual array accessible */
;;;810      if (start_row < ptr->cur_start_row ||
000692  69a0              LDR      r0,[r4,#0x18]
000694  42b0              CMP      r0,r6
000696  d804              BHI      |L1.1698|
;;;811          end_row > ptr->cur_start_row+ptr->rows_in_mem) {
000698  6921              LDR      r1,[r4,#0x10]
00069a  69a0              LDR      r0,[r4,#0x18]
00069c  4408              ADD      r0,r0,r1
00069e  42b8              CMP      r0,r7
0006a0  d222              BCS      |L1.1768|
                  |L1.1698|
;;;812        if (! ptr->b_s_open)
0006a2  6aa0              LDR      r0,[r4,#0x28]
0006a4  b930              CBNZ     r0,|L1.1716|
;;;813          ERREXIT(cinfo, JERR_VIRTUAL_BUG);
0006a6  2045              MOVS     r0,#0x45
0006a8  6829              LDR      r1,[r5,#0]
0006aa  6148              STR      r0,[r1,#0x14]
0006ac  6828              LDR      r0,[r5,#0]
0006ae  6801              LDR      r1,[r0,#0]
0006b0  4628              MOV      r0,r5
0006b2  4788              BLX      r1
                  |L1.1716|
;;;814        /* Flush old buffer contents if necessary */
;;;815        if (ptr->dirty) {
0006b4  6a60              LDR      r0,[r4,#0x24]
0006b6  b130              CBZ      r0,|L1.1734|
;;;816          do_barray_io(cinfo, ptr, TRUE);
0006b8  2201              MOVS     r2,#1
0006ba  4621              MOV      r1,r4
0006bc  4628              MOV      r0,r5
0006be  f7fffffe          BL       do_barray_io
;;;817          ptr->dirty = FALSE;
0006c2  2000              MOVS     r0,#0
0006c4  6260              STR      r0,[r4,#0x24]
                  |L1.1734|
;;;818        }
;;;819        /* Decide what part of virtual array to access.
;;;820         * Algorithm: if target address > current window, assume forward scan,
;;;821         * load starting at target address.  If target address < current window,
;;;822         * assume backward scan, load so that target area is top of window.
;;;823         * Note that when switching from forward write to forward read, will have
;;;824         * start_row = 0, so the limiting case applies and we load from 0 anyway.
;;;825         */
;;;826        if (start_row > ptr->cur_start_row) {
0006c6  69a0              LDR      r0,[r4,#0x18]
0006c8  42b0              CMP      r0,r6
0006ca  d201              BCS      |L1.1744|
;;;827          ptr->cur_start_row = start_row;
0006cc  61a6              STR      r6,[r4,#0x18]
0006ce  e006              B        |L1.1758|
                  |L1.1744|
;;;828        } else {
;;;829          /* use long arithmetic here to avoid overflow & unsigned problems */
;;;830          long ltemp;
;;;831    
;;;832          ltemp = (long) end_row - (long) ptr->rows_in_mem;
0006d0  6921              LDR      r1,[r4,#0x10]
0006d2  1a78              SUBS     r0,r7,r1
;;;833          if (ltemp < 0)
0006d4  2800              CMP      r0,#0
0006d6  da00              BGE      |L1.1754|
;;;834    	ltemp = 0;		/* don't fall off front end of file */
0006d8  2000              MOVS     r0,#0
                  |L1.1754|
;;;835          ptr->cur_start_row = (JDIMENSION) ltemp;
0006da  61a0              STR      r0,[r4,#0x18]
;;;836        }
0006dc  bf00              NOP      
                  |L1.1758|
;;;837        /* Read in the selected part of the array.
;;;838         * During the initial write pass, we will do no actual read
;;;839         * because the selected part is all undefined.
;;;840         */
;;;841        do_barray_io(cinfo, ptr, FALSE);
0006de  2200              MOVS     r2,#0
0006e0  4621              MOV      r1,r4
0006e2  4628              MOV      r0,r5
0006e4  f7fffffe          BL       do_barray_io
                  |L1.1768|
;;;842      }
;;;843      /* Ensure the accessed part of the array is defined; prezero if needed.
;;;844       * To improve locality of access, we only prezero the part of the array
;;;845       * that the caller is about to access, not the entire in-memory array.
;;;846       */
;;;847      if (ptr->first_undef_row < end_row) {
0006e8  69e0              LDR      r0,[r4,#0x1c]
0006ea  42b8              CMP      r0,r7
0006ec  d234              BCS      |L1.1880|
;;;848        if (ptr->first_undef_row < start_row) {
0006ee  69e0              LDR      r0,[r4,#0x1c]
0006f0  42b0              CMP      r0,r6
0006f2  d20b              BCS      |L1.1804|
;;;849          if (writable)		/* writer skipped over a section of array */
0006f4  f1b90f00          CMP      r9,#0
0006f8  d006              BEQ      |L1.1800|
;;;850    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
0006fa  2016              MOVS     r0,#0x16
0006fc  6829              LDR      r1,[r5,#0]
0006fe  6148              STR      r0,[r1,#0x14]
000700  6828              LDR      r0,[r5,#0]
000702  6801              LDR      r1,[r0,#0]
000704  4628              MOV      r0,r5
000706  4788              BLX      r1
                  |L1.1800|
;;;851          undef_row = start_row;	/* but reader is allowed to read ahead */
000708  46b0              MOV      r8,r6
00070a  e001              B        |L1.1808|
                  |L1.1804|
;;;852        } else {
;;;853          undef_row = ptr->first_undef_row;
00070c  f8d4801c          LDR      r8,[r4,#0x1c]
                  |L1.1808|
;;;854        }
;;;855        if (writable)
000710  f1b90f00          CMP      r9,#0
000714  d000              BEQ      |L1.1816|
;;;856          ptr->first_undef_row = end_row;
000716  61e7              STR      r7,[r4,#0x1c]
                  |L1.1816|
;;;857        if (ptr->pre_zero) {
000718  6a20              LDR      r0,[r4,#0x20]
00071a  b198              CBZ      r0,|L1.1860|
;;;858          size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
00071c  68a0              LDR      r0,[r4,#8]
00071e  ea4f1bc0          LSL      r11,r0,#7
;;;859          undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
000722  69a0              LDR      r0,[r4,#0x18]
000724  eba80800          SUB      r8,r8,r0
;;;860          end_row -= ptr->cur_start_row;
000728  69a0              LDR      r0,[r4,#0x18]
00072a  1a3f              SUBS     r7,r7,r0
;;;861          while (undef_row < end_row) {
00072c  e007              B        |L1.1854|
                  |L1.1838|
;;;862    	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
00072e  6821              LDR      r1,[r4,#0]
000730  f8510028          LDR      r0,[r1,r8,LSL #2]
000734  4659              MOV      r1,r11
000736  f7fffffe          BL       jzero_far
;;;863    	undef_row++;
00073a  f1080801          ADD      r8,r8,#1
                  |L1.1854|
00073e  45b8              CMP      r8,r7                 ;861
000740  d3f5              BCC      |L1.1838|
;;;864          }
;;;865        } else {
000742  e009              B        |L1.1880|
                  |L1.1860|
;;;866          if (! writable)		/* reader looking at undefined data */
000744  f1b90f00          CMP      r9,#0
000748  d106              BNE      |L1.1880|
;;;867    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
00074a  2016              MOVS     r0,#0x16
00074c  6829              LDR      r1,[r5,#0]
00074e  6148              STR      r0,[r1,#0x14]
000750  6828              LDR      r0,[r5,#0]
000752  6801              LDR      r1,[r0,#0]
000754  4628              MOV      r0,r5
000756  4788              BLX      r1
                  |L1.1880|
;;;868        }
;;;869      }
;;;870      /* Flag the buffer dirty if caller will write in it */
;;;871      if (writable)
000758  f1b90f00          CMP      r9,#0
00075c  d001              BEQ      |L1.1890|
;;;872        ptr->dirty = TRUE;
00075e  2001              MOVS     r0,#1
000760  6260              STR      r0,[r4,#0x24]
                  |L1.1890|
;;;873      /* Return address of proper part of the buffer */
;;;874      return ptr->mem_buffer + (start_row - ptr->cur_start_row);
000762  69a1              LDR      r1,[r4,#0x18]
000764  1a71              SUBS     r1,r6,r1
000766  6820              LDR      r0,[r4,#0]
000768  eb000081          ADD      r0,r0,r1,LSL #2
;;;875    }
00076c  e8bd9ff0          POP      {r4-r12,pc}
;;;876    
                          ENDP

                  free_pool PROC
;;;882    METHODDEF(void)
;;;883    free_pool (j_common_ptr cinfo, int pool_id)
000770  e92d5ff0          PUSH     {r4-r12,lr}
;;;884    {
000774  4682              MOV      r10,r0
000776  460d              MOV      r5,r1
;;;885      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
000778  f8da4004          LDR      r4,[r10,#4]
;;;886      small_pool_ptr shdr_ptr;
;;;887      large_pool_ptr lhdr_ptr;
;;;888      size_t space_freed;
;;;889    
;;;890      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
00077c  2d00              CMP      r5,#0
00077e  db01              BLT      |L1.1924|
000780  2d02              CMP      r5,#2
000782  db0b              BLT      |L1.1948|
                  |L1.1924|
;;;891        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000784  200e              MOVS     r0,#0xe
000786  f8da1000          LDR      r1,[r10,#0]
00078a  6148              STR      r0,[r1,#0x14]
00078c  f8da0000          LDR      r0,[r10,#0]
000790  6185              STR      r5,[r0,#0x18]
000792  f8da0000          LDR      r0,[r10,#0]
000796  6801              LDR      r1,[r0,#0]
000798  4650              MOV      r0,r10
00079a  4788              BLX      r1
                  |L1.1948|
;;;892    
;;;893    #ifdef MEM_STATS
;;;894      if (cinfo->err->trace_level > 1)
;;;895        print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
;;;896    #endif
;;;897    
;;;898      /* If freeing IMAGE pool, close any virtual arrays first */
;;;899      if (pool_id == JPOOL_IMAGE) {
00079c  2d01              CMP      r5,#1
00079e  d126              BNE      |L1.2030|
;;;900        jvirt_sarray_ptr sptr;
;;;901        jvirt_barray_ptr bptr;
;;;902    
;;;903        for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
0007a0  f8d49044          LDR      r9,[r4,#0x44]
0007a4  e00d              B        |L1.1986|
                  |L1.1958|
;;;904          if (sptr->b_s_open) {	/* there may be no backing store */
0007a6  f8d90028          LDR      r0,[r9,#0x28]
0007aa  b140              CBZ      r0,|L1.1982|
;;;905    	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
0007ac  2000              MOVS     r0,#0
0007ae  f8c90028          STR      r0,[r9,#0x28]
;;;906    	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
0007b2  f1090130          ADD      r1,r9,#0x30
0007b6  4650              MOV      r0,r10
0007b8  f8d92038          LDR      r2,[r9,#0x38]
0007bc  4790              BLX      r2
                  |L1.1982|
0007be  f8d9902c          LDR      r9,[r9,#0x2c]         ;903
                  |L1.1986|
0007c2  f1b90f00          CMP      r9,#0                 ;903
0007c6  d1ee              BNE      |L1.1958|
;;;907          }
;;;908        }
;;;909        mem->virt_sarray_list = NULL;
0007c8  2000              MOVS     r0,#0
0007ca  6460              STR      r0,[r4,#0x44]
;;;910        for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
0007cc  6ca6              LDR      r6,[r4,#0x48]
0007ce  e009              B        |L1.2020|
                  |L1.2000|
;;;911          if (bptr->b_s_open) {	/* there may be no backing store */
0007d0  6ab0              LDR      r0,[r6,#0x28]
0007d2  b130              CBZ      r0,|L1.2018|
;;;912    	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
0007d4  2000              MOVS     r0,#0
0007d6  62b0              STR      r0,[r6,#0x28]
;;;913    	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
0007d8  f1060130          ADD      r1,r6,#0x30
0007dc  4650              MOV      r0,r10
0007de  6bb2              LDR      r2,[r6,#0x38]
0007e0  4790              BLX      r2
                  |L1.2018|
0007e2  6af6              LDR      r6,[r6,#0x2c]         ;910
                  |L1.2020|
0007e4  2e00              CMP      r6,#0                 ;910
0007e6  d1f3              BNE      |L1.2000|
;;;914          }
;;;915        }
;;;916        mem->virt_barray_list = NULL;
0007e8  2000              MOVS     r0,#0
0007ea  64a0              STR      r0,[r4,#0x48]
;;;917      }
0007ec  bf00              NOP      
                  |L1.2030|
;;;918    
;;;919      /* Release large objects */
;;;920      lhdr_ptr = mem->large_list[pool_id];
0007ee  f104003c          ADD      r0,r4,#0x3c
0007f2  f8508025          LDR      r8,[r0,r5,LSL #2]
;;;921      mem->large_list[pool_id] = NULL;
0007f6  2100              MOVS     r1,#0
0007f8  f8401025          STR      r1,[r0,r5,LSL #2]
;;;922    
;;;923      while (lhdr_ptr != NULL) {
0007fc  e011              B        |L1.2082|
                  |L1.2046|
;;;924        large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
0007fe  f8d86000          LDR      r6,[r8,#0]
;;;925        space_freed = lhdr_ptr->hdr.bytes_used +
000802  e9d80101          LDRD     r0,r1,[r8,#4]
000806  4408              ADD      r0,r0,r1
000808  f1000b10          ADD      r11,r0,#0x10
;;;926    		  lhdr_ptr->hdr.bytes_left +
;;;927    		  SIZEOF(large_pool_hdr);
;;;928        jpeg_free_small/*RS: Changed from jpeg_free_large*/(cinfo, (void FAR *) lhdr_ptr, space_freed);
00080c  465a              MOV      r2,r11
00080e  4641              MOV      r1,r8
000810  4650              MOV      r0,r10
000812  f7fffffe          BL       jpeg_free_small
;;;929        mem->total_space_allocated -= space_freed;
000816  6ce0              LDR      r0,[r4,#0x4c]
000818  eba0000b          SUB      r0,r0,r11
00081c  64e0              STR      r0,[r4,#0x4c]
;;;930        lhdr_ptr = next_lhdr_ptr;
00081e  46b0              MOV      r8,r6
;;;931      }
000820  bf00              NOP      
                  |L1.2082|
000822  f1b80f00          CMP      r8,#0                 ;923
000826  d1ea              BNE      |L1.2046|
;;;932    
;;;933      /* Release small objects */
;;;934      shdr_ptr = mem->small_list[pool_id];
000828  f1040034          ADD      r0,r4,#0x34
00082c  f8507025          LDR      r7,[r0,r5,LSL #2]
;;;935      mem->small_list[pool_id] = NULL;
000830  2100              MOVS     r1,#0
000832  f8401025          STR      r1,[r0,r5,LSL #2]
;;;936    
;;;937      while (shdr_ptr != NULL) {
000836  e010              B        |L1.2138|
                  |L1.2104|
;;;938        small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
000838  683e              LDR      r6,[r7,#0]
;;;939        space_freed = shdr_ptr->hdr.bytes_used +
00083a  e9d70101          LDRD     r0,r1,[r7,#4]
00083e  4408              ADD      r0,r0,r1
000840  f1000b10          ADD      r11,r0,#0x10
;;;940    		  shdr_ptr->hdr.bytes_left +
;;;941    		  SIZEOF(small_pool_hdr);
;;;942        jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
000844  465a              MOV      r2,r11
000846  4639              MOV      r1,r7
000848  4650              MOV      r0,r10
00084a  f7fffffe          BL       jpeg_free_small
;;;943        mem->total_space_allocated -= space_freed;
00084e  6ce0              LDR      r0,[r4,#0x4c]
000850  eba0000b          SUB      r0,r0,r11
000854  64e0              STR      r0,[r4,#0x4c]
;;;944        shdr_ptr = next_shdr_ptr;
000856  4637              MOV      r7,r6
;;;945      }
000858  bf00              NOP      
                  |L1.2138|
00085a  2f00              CMP      r7,#0                 ;937
00085c  d1ec              BNE      |L1.2104|
;;;946    }
00085e  e8bd9ff0          POP      {r4-r12,pc}
;;;947    
                          ENDP

                  self_destruct PROC
;;;954    METHODDEF(void)
;;;955    self_destruct (j_common_ptr cinfo)
000862  b570              PUSH     {r4-r6,lr}
;;;956    {
000864  4604              MOV      r4,r0
;;;957      int pool;
;;;958    
;;;959      /* Close all backing store, release all memory.
;;;960       * Releasing pools in reverse order might help avoid fragmentation
;;;961       * with some (brain-damaged) malloc libraries.
;;;962       */
;;;963      for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
000866  2501              MOVS     r5,#1
000868  e004              B        |L1.2164|
                  |L1.2154|
;;;964        free_pool(cinfo, pool);
00086a  4629              MOV      r1,r5
00086c  4620              MOV      r0,r4
00086e  f7fffffe          BL       free_pool
000872  1e6d              SUBS     r5,r5,#1              ;963
                  |L1.2164|
000874  2d00              CMP      r5,#0                 ;963
000876  daf8              BGE      |L1.2154|
;;;965      }
;;;966    
;;;967      /* Release the memory manager control block too. */
;;;968      jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
000878  2254              MOVS     r2,#0x54
00087a  4620              MOV      r0,r4
00087c  6861              LDR      r1,[r4,#4]
00087e  f7fffffe          BL       jpeg_free_small
;;;969      cinfo->mem = NULL;		/* ensures I will be called only once */
000882  2000              MOVS     r0,#0
000884  6060              STR      r0,[r4,#4]
;;;970    
;;;971      jpeg_mem_term(cinfo);		/* system-dependent cleanup */
000886  4620              MOV      r0,r4
000888  f7fffffe          BL       jpeg_mem_term
;;;972    }
00088c  bd70              POP      {r4-r6,pc}
;;;973    
                          ENDP

                  jinit_memory_mgr PROC
;;;980    GLOBAL(void)
;;;981    jinit_memory_mgr (j_common_ptr cinfo)
00088e  e92d41f0          PUSH     {r4-r8,lr}
;;;982    {
000892  4605              MOV      r5,r0
;;;983      my_mem_ptr mem;
;;;984      long max_to_use;
;;;985      int pool;
;;;986      size_t test_mac;
;;;987    
;;;988      cinfo->mem = NULL;		/* for safety if init fails */
000894  2000              MOVS     r0,#0
000896  6068              STR      r0,[r5,#4]
;;;989    
;;;990      /* Check for configuration errors.
;;;991       * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
;;;992       * doesn't reflect any real hardware alignment requirement.
;;;993       * The test is a little tricky: for X>0, X and X-1 have no one-bits
;;;994       * in common if and only if X is a power of 2, ie has only one one-bit.
;;;995       * Some compilers may give an "unreachable code" warning here; ignore it.
;;;996       */
;;;997      if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
;;;998        ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
;;;999      /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
;;;1000      * a multiple of SIZEOF(ALIGN_TYPE).
;;;1001      * Again, an "unreachable code" warning may be ignored here.
;;;1002      * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
;;;1003      */
;;;1004     test_mac = (size_t) MAX_ALLOC_CHUNK;
000898  f8df80a0          LDR      r8,|L1.2364|
;;;1005     if ((long) test_mac != MAX_ALLOC_CHUNK ||
00089c  4640              MOV      r0,r8
00089e  4580              CMP      r8,r0
0008a0  d100              BNE      |L1.2212|
;;;1006         (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
0008a2  e006              B        |L1.2226|
                  |L1.2212|
;;;1007       ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
0008a4  2003              MOVS     r0,#3
0008a6  6829              LDR      r1,[r5,#0]
0008a8  6148              STR      r0,[r1,#0x14]
0008aa  6828              LDR      r0,[r5,#0]
0008ac  6801              LDR      r1,[r0,#0]
0008ae  4628              MOV      r0,r5
0008b0  4788              BLX      r1
                  |L1.2226|
;;;1008   
;;;1009     max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
0008b2  4628              MOV      r0,r5
0008b4  f7fffffe          BL       jpeg_mem_init
0008b8  4607              MOV      r7,r0
;;;1010   
;;;1011     /* Attempt to allocate memory manager's control block */
;;;1012     mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
0008ba  2154              MOVS     r1,#0x54
0008bc  4628              MOV      r0,r5
0008be  f7fffffe          BL       jpeg_get_small
0008c2  4604              MOV      r4,r0
;;;1013   
;;;1014     if (mem == NULL) {
0008c4  b964              CBNZ     r4,|L1.2272|
;;;1015       jpeg_mem_term(cinfo);	/* system-dependent cleanup */
0008c6  4628              MOV      r0,r5
0008c8  f7fffffe          BL       jpeg_mem_term
;;;1016       ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
0008cc  2036              MOVS     r0,#0x36
0008ce  6829              LDR      r1,[r5,#0]
0008d0  6148              STR      r0,[r1,#0x14]
0008d2  2000              MOVS     r0,#0
0008d4  6829              LDR      r1,[r5,#0]
0008d6  6188              STR      r0,[r1,#0x18]
0008d8  6828              LDR      r0,[r5,#0]
0008da  6801              LDR      r1,[r0,#0]
0008dc  4628              MOV      r0,r5
0008de  4788              BLX      r1
                  |L1.2272|
;;;1017     }
;;;1018   
;;;1019     /* OK, fill in the method pointers */
;;;1020     mem->pub.alloc_small = alloc_small;
0008e0  4817              LDR      r0,|L1.2368|
0008e2  6020              STR      r0,[r4,#0]
;;;1021     mem->pub.alloc_large = alloc_large;
0008e4  4817              LDR      r0,|L1.2372|
0008e6  6060              STR      r0,[r4,#4]
;;;1022     mem->pub.alloc_sarray = alloc_sarray;
0008e8  4817              LDR      r0,|L1.2376|
0008ea  60a0              STR      r0,[r4,#8]
;;;1023     mem->pub.alloc_barray = alloc_barray;
0008ec  4817              LDR      r0,|L1.2380|
0008ee  60e0              STR      r0,[r4,#0xc]
;;;1024     mem->pub.request_virt_sarray = request_virt_sarray;
0008f0  4817              LDR      r0,|L1.2384|
0008f2  6120              STR      r0,[r4,#0x10]
;;;1025     mem->pub.request_virt_barray = request_virt_barray;
0008f4  4817              LDR      r0,|L1.2388|
0008f6  6160              STR      r0,[r4,#0x14]
;;;1026     mem->pub.realize_virt_arrays = realize_virt_arrays;
0008f8  4817              LDR      r0,|L1.2392|
0008fa  61a0              STR      r0,[r4,#0x18]
;;;1027     mem->pub.access_virt_sarray = access_virt_sarray;
0008fc  4817              LDR      r0,|L1.2396|
0008fe  61e0              STR      r0,[r4,#0x1c]
;;;1028     mem->pub.access_virt_barray = access_virt_barray;
000900  4817              LDR      r0,|L1.2400|
000902  6220              STR      r0,[r4,#0x20]
;;;1029     mem->pub.free_pool = free_pool;
000904  4817              LDR      r0,|L1.2404|
000906  6260              STR      r0,[r4,#0x24]
;;;1030     mem->pub.self_destruct = self_destruct;
000908  4817              LDR      r0,|L1.2408|
00090a  62a0              STR      r0,[r4,#0x28]
;;;1031   
;;;1032     /* Make MAX_ALLOC_CHUNK accessible to other modules */
;;;1033     mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
00090c  480b              LDR      r0,|L1.2364|
00090e  6320              STR      r0,[r4,#0x30]
;;;1034   
;;;1035     /* Initialize working state */
;;;1036     mem->pub.max_memory_to_use = max_to_use;
000910  62e7              STR      r7,[r4,#0x2c]
;;;1037   
;;;1038     for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
000912  2601              MOVS     r6,#1
000914  e008              B        |L1.2344|
                  |L1.2326|
;;;1039       mem->small_list[pool] = NULL;
000916  2100              MOVS     r1,#0
000918  f1040034          ADD      r0,r4,#0x34
00091c  f8401026          STR      r1,[r0,r6,LSL #2]
;;;1040       mem->large_list[pool] = NULL;
000920  3008              ADDS     r0,r0,#8
000922  f8401026          STR      r1,[r0,r6,LSL #2]
000926  1e76              SUBS     r6,r6,#1              ;1038
                  |L1.2344|
000928  2e00              CMP      r6,#0                 ;1038
00092a  daf4              BGE      |L1.2326|
;;;1041     }
;;;1042     mem->virt_sarray_list = NULL;
00092c  2000              MOVS     r0,#0
00092e  6460              STR      r0,[r4,#0x44]
;;;1043     mem->virt_barray_list = NULL;
000930  64a0              STR      r0,[r4,#0x48]
;;;1044   
;;;1045     mem->total_space_allocated = SIZEOF(my_memory_mgr);
000932  2054              MOVS     r0,#0x54
000934  64e0              STR      r0,[r4,#0x4c]
;;;1046   
;;;1047     /* Declare ourselves open for business */
;;;1048     cinfo->mem = & mem->pub;
000936  606c              STR      r4,[r5,#4]
;;;1049   
;;;1050     /* Check for an environment variable JPEGMEM; if found, override the
;;;1051      * default max_memory setting from jpeg_mem_init.  Note that the
;;;1052      * surrounding application may again override this value.
;;;1053      * If your system doesn't support getenv(), define NO_GETENV to disable
;;;1054      * this feature.
;;;1055      */
;;;1056   #if 0 /* RS ndef NO_GETENV */
;;;1057     { char * memenv;
;;;1058   
;;;1059       if ((memenv = getenv("JPEGMEM")) != NULL) {
;;;1060         char ch = 'x';
;;;1061   
;;;1062         if (sscanf(memenv, "%ld%c", &max_to_use, &ch) > 0) {
;;;1063   	if (ch == 'm' || ch == 'M')
;;;1064   	  max_to_use *= 1000L;
;;;1065   	mem->pub.max_memory_to_use = max_to_use * 1000L;
;;;1066         }
;;;1067       }
;;;1068     }
;;;1069   #endif
;;;1070   
;;;1071   }
000938  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L1.2364|
                          DCD      0x3b9aca00
                  |L1.2368|
                          DCD      alloc_small
                  |L1.2372|
                          DCD      alloc_large
                  |L1.2376|
                          DCD      alloc_sarray
                  |L1.2380|
                          DCD      alloc_barray
                  |L1.2384|
                          DCD      request_virt_sarray
                  |L1.2388|
                          DCD      request_virt_barray
                  |L1.2392|
                          DCD      realize_virt_arrays
                  |L1.2396|
                          DCD      access_virt_sarray
                  |L1.2400|
                          DCD      access_virt_barray
                  |L1.2404|
                          DCD      free_pool
                  |L1.2408|
                          DCD      self_destruct

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  first_pool_slop
                          DCD      0x00000640
                          DCD      0x00003e80
                  extra_pool_slop
                          DCD      0x00000000
                          DCD      0x00001388
