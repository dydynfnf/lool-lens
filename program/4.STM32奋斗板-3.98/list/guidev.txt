; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\guidev.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\guidev.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\guidev.crf GUI\MemDev\GUIDEV.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__GetRect PROC
;;;43     */
;;;44     void GUI_MEMDEV__GetRect(GUI_RECT* pRect) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;45       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  49fc              LDR      r1,|L1.1016|
000006  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
;;;46       pRect->x0 = pDev->x0;
000010  8820              LDRH     r0,[r4,#0]
000012  8028              STRH     r0,[r5,#0]
;;;47       pRect->y0 = pDev->y0;
000014  8860              LDRH     r0,[r4,#2]
000016  8068              STRH     r0,[r5,#2]
;;;48       pRect->x1 = pDev->x0 + pDev->XSize-1;
000018  8820              LDRH     r0,[r4,#0]
00001a  88a1              LDRH     r1,[r4,#4]
00001c  4408              ADD      r0,r0,r1
00001e  1e40              SUBS     r0,r0,#1
000020  b200              SXTH     r0,r0
000022  80a8              STRH     r0,[r5,#4]
;;;49       pRect->y1 = pDev->y0 + pDev->YSize-1;
000024  8860              LDRH     r0,[r4,#2]
000026  88e1              LDRH     r1,[r4,#6]
000028  4408              ADD      r0,r0,r1
00002a  1e40              SUBS     r0,r0,#1
00002c  b200              SXTH     r0,r0
00002e  80e8              STRH     r0,[r5,#6]
;;;50     }
000030  bd70              POP      {r4-r6,pc}
;;;51     
                          ENDP

                  GUI_MEMDEV__Color2Index PROC
;;;55     */
;;;56     unsigned int GUI_MEMDEV__Color2Index(LCD_COLOR Color) {
000032  b570              PUSH     {r4-r6,lr}
000034  4604              MOV      r4,r0
;;;57       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000036  49f0              LDR      r1,|L1.1016|
000038  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
00003c  f7fffffe          BL       GUI_ALLOC_h2p
000040  4605              MOV      r5,r0
;;;58       return pDev->pfColor2Index(Color);
000042  4620              MOV      r0,r4
000044  69e9              LDR      r1,[r5,#0x1c]
000046  4788              BLX      r1
;;;59     }
000048  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

                  GUI_MEMDEV__Index2Color PROC
;;;64     */
;;;65     LCD_COLOR GUI_MEMDEV__Index2Color(int Index) {
00004a  b570              PUSH     {r4-r6,lr}
00004c  4604              MOV      r4,r0
;;;66       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
00004e  49ea              LDR      r1,|L1.1016|
000050  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
000054  f7fffffe          BL       GUI_ALLOC_h2p
000058  4605              MOV      r5,r0
;;;67       return pDev->pfIndex2Color(Index);
00005a  4620              MOV      r0,r4
00005c  6a29              LDR      r1,[r5,#0x20]
00005e  4788              BLX      r1
;;;68     }
000060  bd70              POP      {r4-r6,pc}
;;;69     
                          ENDP

                  GUI_MEMDEV__GetIndexMask PROC
;;;73     */
;;;74     unsigned int GUI_MEMDEV__GetIndexMask(void) {
000062  b510              PUSH     {r4,lr}
;;;75       GUI_MEMDEV * pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000064  49e4              LDR      r1,|L1.1016|
000066  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
00006a  f7fffffe          BL       GUI_ALLOC_h2p
00006e  4604              MOV      r4,r0
;;;76       return pDev->pfGetIndexMask();
000070  6a60              LDR      r0,[r4,#0x24]
000072  4780              BLX      r0
;;;77     }
000074  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  GUI_MEMDEV_Delete PROC
;;;88     */
;;;89     void GUI_MEMDEV_Delete(GUI_MEMDEV_Handle hMemDev) {
000076  b570              PUSH     {r4-r6,lr}
000078  4605              MOV      r5,r0
;;;90     /* Make sure memory device is not used */
;;;91       GUI_LOCK();
;;;92       if (hMemDev) {
00007a  b1a5              CBZ      r5,|L1.166|
;;;93         GUI_MEMDEV* pDev;
;;;94         if (GUI_Context.hDevData == hMemDev) {
00007c  48de              LDR      r0,|L1.1016|
00007e  f9b0004c          LDRSH    r0,[r0,#0x4c]  ; GUI_Context
000082  42a8              CMP      r0,r5
000084  d101              BNE      |L1.138|
;;;95     	    GUI_SelectLCD();
000086  f7fffffe          BL       GUI_SelectLCD
                  |L1.138|
;;;96         }
;;;97         pDev = GUI_MEMDEV_H2P(hMemDev);
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       GUI_ALLOC_h2p
000090  4604              MOV      r4,r0
;;;98         /* Delete the associated usage device */
;;;99         if (pDev->hUsage)
000092  8b20              LDRH     r0,[r4,#0x18]
000094  b118              CBZ      r0,|L1.158|
;;;100          GUI_USAGE_DecUseCnt(pDev->hUsage);
000096  f9b40018          LDRSH    r0,[r4,#0x18]
00009a  f7fffffe          BL       GUI_USAGE_DecUseCnt
                  |L1.158|
;;;101        GUI_ALLOC_Free(hMemDev);
00009e  4628              MOV      r0,r5
0000a0  f7fffffe          BL       GUI_ALLOC_Free
;;;102      }
0000a4  bf00              NOP      
                  |L1.166|
;;;103      GUI_UNLOCK();
;;;104    }
0000a6  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP

                  GUI_MEMDEV__CreateFixed PROC
;;;109    */
;;;110    GUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xsize, int ysize, int Flags
0000a8  e92d4fff          PUSH     {r0-r11,lr}
;;;111                                            ,const tLCDDEV_APIList * pMemDevAPI
;;;112                                            ,tLCDDEV_Color2Index*        pfColor2Index
;;;113                                            ,tLCDDEV_Index2Color*        pfIndex2Color
;;;114                                            ,tLCDDEV_GetIndexMask*       pfGetIndexMask) {
0000ac  b083              SUB      sp,sp,#0xc
0000ae  4690              MOV      r8,r2
0000b0  461d              MOV      r5,r3
0000b2  f8dd9040          LDR      r9,[sp,#0x40]
;;;115      I32 MemSize;
;;;116      GUI_USAGE_Handle hUsage = 0;
0000b6  f04f0a00          MOV      r10,#0
;;;117      unsigned int BitsPerPixel, BytesPerLine;
;;;118      GUI_MEMDEV_Handle hMemDev;
;;;119      BitsPerPixel = pMemDevAPI->BitsPerPixel;
0000ba  9811              LDR      r0,[sp,#0x44]
0000bc  6c00              LDR      r0,[r0,#0x40]
0000be  9002              STR      r0,[sp,#8]
;;;120      BytesPerLine = (xsize * BitsPerPixel + 7) >> 3;     /* Note: This code works with 8 and 16 bit memory devices. If other BPPs are introduced for MemDevs, it needs to be changed */
0000c0  9902              LDR      r1,[sp,#8]
0000c2  fb08f001          MUL      r0,r8,r1
0000c6  1dc0              ADDS     r0,r0,#7
0000c8  ea4f0bd0          LSR      r11,r0,#3
;;;121      /* Calc available MemSize */
;;;122      MemSize = GUI_ALLOC_GetMaxSize();
0000cc  f7fffffe          BL       GUI_ALLOC_GetMaxSize
0000d0  4606              MOV      r6,r0
;;;123      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
0000d2  f0090001          AND      r0,r9,#1
0000d6  b930              CBNZ     r0,|L1.230|
;;;124        MemSize = (MemSize / 4) * 3;   /* We need to reserve some memory for usage object ... TBD: This can be optimized as we do not use memory perfectly. */
0000d8  4630              MOV      r0,r6
0000da  17f1              ASRS     r1,r6,#31
0000dc  eb067191          ADD      r1,r6,r1,LSR #30
0000e0  1089              ASRS     r1,r1,#2
0000e2  eb010641          ADD      r6,r1,r1,LSL #1
                  |L1.230|
;;;125      }
;;;126      if (ysize<=0) {
0000e6  2d00              CMP      r5,#0
0000e8  dc0b              BGT      |L1.258|
;;;127        int MaxLines = (MemSize - sizeof(GUI_MEMDEV)) / BytesPerLine;
0000ea  f1a6012c          SUB      r1,r6,#0x2c
0000ee  fbb1f0fb          UDIV     r0,r1,r11
;;;128        ysize = (MaxLines > -ysize) ? -ysize : MaxLines;
0000f2  4269              RSBS     r1,r5,#0
0000f4  4288              CMP      r0,r1
0000f6  dd01              BLE      |L1.252|
0000f8  4269              RSBS     r1,r5,#0
0000fa  e000              B        |L1.254|
                  |L1.252|
0000fc  4601              MOV      r1,r0
                  |L1.254|
0000fe  460d              MOV      r5,r1
;;;129      }
000100  bf00              NOP      
                  |L1.258|
;;;130      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
000102  f0090001          AND      r0,r9,#1
000106  b940              CBNZ     r0,|L1.282|
;;;131        /* Create the usage map */
;;;132        hUsage = GUI_USAGE_BM_Create(x0, y0, xsize, ysize, 0);
000108  2000              MOVS     r0,#0
00010a  462b              MOV      r3,r5
00010c  4642              MOV      r2,r8
00010e  9000              STR      r0,[sp,#0]
000110  e9dd0103          LDRD     r0,r1,[sp,#0xc]
000114  f7fffffe          BL       GUI_USAGE_BM_Create
000118  4682              MOV      r10,r0
                  |L1.282|
;;;133      }
;;;134      /* Check if we can alloc sufficient memory */
;;;135      if (ysize <= 0) {
00011a  2d00              CMP      r5,#0
00011c  dc03              BGT      |L1.294|
;;;136        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Too little memory");
;;;137        GUI_UNLOCK();
;;;138        return 0;    
00011e  2000              MOVS     r0,#0
                  |L1.288|
;;;139      }
;;;140      MemSize = ysize * BytesPerLine + sizeof(GUI_MEMDEV);
;;;141      if (Flags & GUI_MEMDEV_NOTRANS) {
;;;142        hMemDev = GUI_ALLOC_AllocNoInit(MemSize);
;;;143      } else {
;;;144        hMemDev = GUI_ALLOC_AllocZero(MemSize);
;;;145      }
;;;146      if (hMemDev) {
;;;147        GUI_MEMDEV* pDevData;
;;;148        pDevData = GUI_MEMDEV_H2P(hMemDev);
;;;149        pDevData->x0            = x0;
;;;150        pDevData->y0            = y0;
;;;151        pDevData->XSize         = xsize;
;;;152        pDevData->YSize         = ysize;
;;;153        pDevData->NumColors     = 
;;;154        #if GUI_NUM_LAYERS == 1
;;;155          LCD_GET_NUMCOLORS();
;;;156        #else
;;;157          LCD_GetNumColorsEx(GUI_Context.SelLayer);
;;;158        #endif
;;;159        pDevData->BytesPerLine  = BytesPerLine;
;;;160        pDevData->hUsage        = hUsage;
;;;161        /* Set color conversion routine pointers */
;;;162        pDevData->pfColor2Index = pfColor2Index;    /* LCD_L0_Color2Index; */
;;;163        pDevData->pfIndex2Color = pfIndex2Color;    /* LCD_L0_Index2Color; */
;;;164        pDevData->pfGetIndexMask= pfGetIndexMask;   /* LCD_L0_GetIndexMask */
;;;165    
;;;166        pDevData->pAPIList      = pMemDevAPI;
;;;167        pDevData->BitsPerPixel  = BitsPerPixel;
;;;168        #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;169          pDevData->LayerIndex  = GUI_Context.SelLayer;
;;;170        #else
;;;171          pDevData->LayerIndex  = 0;
;;;172        #endif
;;;173      } else {
;;;174        if (hUsage) {
;;;175          GUI_ALLOC_Free(hUsage);
;;;176        }
;;;177        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Alloc failed");
;;;178      }
;;;179      return hMemDev;
;;;180    }
000120  b007              ADD      sp,sp,#0x1c
000122  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.294|
000126  fb05f00b          MUL      r0,r5,r11             ;140
00012a  f100062c          ADD      r6,r0,#0x2c           ;140
00012e  f0090001          AND      r0,r9,#1              ;141
000132  b120              CBZ      r0,|L1.318|
000134  b230              SXTH     r0,r6                 ;142
000136  f7fffffe          BL       GUI_ALLOC_AllocNoInit
00013a  4607              MOV      r7,r0                 ;142
00013c  e003              B        |L1.326|
                  |L1.318|
00013e  b230              SXTH     r0,r6                 ;144
000140  f7fffffe          BL       GUI_ALLOC_AllocZero
000144  4607              MOV      r7,r0                 ;144
                  |L1.326|
000146  b317              CBZ      r7,|L1.398|
000148  4638              MOV      r0,r7                 ;148
00014a  f7fffffe          BL       GUI_ALLOC_h2p
00014e  4604              MOV      r4,r0                 ;148
000150  9803              LDR      r0,[sp,#0xc]          ;149
000152  b200              SXTH     r0,r0                 ;149
000154  8020              STRH     r0,[r4,#0]            ;149
000156  9804              LDR      r0,[sp,#0x10]         ;150
000158  b200              SXTH     r0,r0                 ;150
00015a  8060              STRH     r0,[r4,#2]            ;150
00015c  fa0ff088          SXTH     r0,r8                 ;151
000160  80a0              STRH     r0,[r4,#4]            ;151
000162  b228              SXTH     r0,r5                 ;152
000164  80e0              STRH     r0,[r4,#6]            ;152
000166  f7fffffe          BL       LCD_GetNumColors
00016a  60a0              STR      r0,[r4,#8]            ;153
00016c  f8c4b00c          STR      r11,[r4,#0xc]         ;159
000170  f8a4a018          STRH     r10,[r4,#0x18]        ;160
000174  9812              LDR      r0,[sp,#0x48]         ;162
000176  61e0              STR      r0,[r4,#0x1c]         ;162
000178  9813              LDR      r0,[sp,#0x4c]         ;163
00017a  6220              STR      r0,[r4,#0x20]         ;163
00017c  9814              LDR      r0,[sp,#0x50]         ;164
00017e  6260              STR      r0,[r4,#0x24]         ;164
000180  9811              LDR      r0,[sp,#0x44]         ;166
000182  62a0              STR      r0,[r4,#0x28]         ;166
000184  9802              LDR      r0,[sp,#8]            ;167
000186  6120              STR      r0,[r4,#0x10]         ;167
000188  2000              MOVS     r0,#0                 ;171
00018a  6160              STR      r0,[r4,#0x14]         ;171
00018c  e005              B        |L1.410|
                  |L1.398|
00018e  f1ba0f00          CMP      r10,#0                ;174
000192  d002              BEQ      |L1.410|
000194  4650              MOV      r0,r10                ;175
000196  f7fffffe          BL       GUI_ALLOC_Free
                  |L1.410|
00019a  4638              MOV      r0,r7                 ;179
00019c  e7c0              B        |L1.288|
;;;181    
                          ENDP

                  GUI_MEMDEV_CreateEx PROC
;;;185    */
;;;186    GUI_MEMDEV_Handle GUI_MEMDEV_CreateEx(int x0, int y0, int xSize, int ySize, int Flags) {
00019e  e92d4fff          PUSH     {r0-r11,lr}
0001a2  b085              SUB      sp,sp,#0x14
0001a4  4681              MOV      r9,r0
0001a6  468a              MOV      r10,r1
;;;187      GUI_MEMDEV_Handle hMemDev;
;;;188      const tLCDDEV_APIList * pDeviceAPI;
;;;189      tLCDDEV_Color2Index   * pfColor2Index;
;;;190      tLCDDEV_Index2Color   * pfIndex2Color;
;;;191      tLCDDEV_GetIndexMask  * pfGetIndexMask;
;;;192      GUI_LOCK();
;;;193      #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;194        pDeviceAPI = LCD_aAPI[GUI_Context.SelLayer];
;;;195      #else
;;;196        pDeviceAPI = LCD_aAPI[0];
0001a8  4894              LDR      r0,|L1.1020|
0001aa  f8d0b000          LDR      r11,[r0,#0]  ; LCD_aAPI
;;;197      #endif
;;;198      if (GUI_Context.hDevData == 0) {
0001ae  4892              LDR      r0,|L1.1016|
0001b0  f8b0004c          LDRH     r0,[r0,#0x4c]  ; GUI_Context
0001b4  b948              CBNZ     r0,|L1.458|
;;;199        pfColor2Index = GUI_Context.pDeviceAPI->pfColor2Index;    /* LCD_L0_Color2Index; */
0001b6  4890              LDR      r0,|L1.1016|
0001b8  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
0001ba  6804              LDR      r4,[r0,#0]
;;;200        pfIndex2Color = GUI_Context.pDeviceAPI->pfIndex2Color;    /* LCD_L0_Index2Color; */
0001bc  488e              LDR      r0,|L1.1016|
0001be  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
0001c0  6845              LDR      r5,[r0,#4]
;;;201        pfGetIndexMask= GUI_Context.pDeviceAPI->pfGetIndexMask;   /* LCD_L0_GetIndexMask */
0001c2  488d              LDR      r0,|L1.1016|
0001c4  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
0001c6  6886              LDR      r6,[r0,#8]
0001c8  e009              B        |L1.478|
                  |L1.458|
;;;202      } else {
;;;203        /* If a memory device is already selected, we create a compatible one by copying its data */
;;;204        GUI_MEMDEV* pDevSel;
;;;205        pDevSel = GUI_MEMDEV_H2P(GUI_Context.hDevData);
0001ca  498b              LDR      r1,|L1.1016|
0001cc  f9b1004c          LDRSH    r0,[r1,#0x4c]  ; GUI_Context
0001d0  f7fffffe          BL       GUI_ALLOC_h2p
0001d4  4607              MOV      r7,r0
;;;206        pfColor2Index = pDevSel->pfColor2Index;
0001d6  69fc              LDR      r4,[r7,#0x1c]
;;;207        pfIndex2Color = pDevSel->pfIndex2Color;
0001d8  6a3d              LDR      r5,[r7,#0x20]
;;;208        pfGetIndexMask= pDevSel->pfGetIndexMask;
0001da  6a7e              LDR      r6,[r7,#0x24]
;;;209      }
0001dc  bf00              NOP      
                  |L1.478|
;;;210      hMemDev = GUI_MEMDEV__CreateFixed(x0, y0, xSize, ySize, Flags, pDeviceAPI->pMemDevAPI, 
0001de  f8db003c          LDR      r0,[r11,#0x3c]
0001e2  a901              ADD      r1,sp,#4
0001e4  c171              STM      r1!,{r0,r4-r6}
0001e6  9812              LDR      r0,[sp,#0x48]
0001e8  9000              STR      r0,[sp,#0]
0001ea  4651              MOV      r1,r10
0001ec  4648              MOV      r0,r9
0001ee  e9dd2307          LDRD     r2,r3,[sp,#0x1c]
0001f2  f7fffffe          BL       GUI_MEMDEV__CreateFixed
0001f6  4680              MOV      r8,r0
;;;211                                        pfColor2Index, pfIndex2Color ,pfGetIndexMask);
;;;212      GUI_UNLOCK();
;;;213      return hMemDev;
0001f8  4640              MOV      r0,r8
;;;214    }
0001fa  b009              ADD      sp,sp,#0x24
0001fc  e8bd8ff0          POP      {r4-r11,pc}
;;;215    /*********************************************************************
                          ENDP

                  GUI_MEMDEV_Create PROC
;;;218    */
;;;219    GUI_MEMDEV_Handle GUI_MEMDEV_Create(int x0, int y0, int xsize, int ysize) {
000200  b5f8              PUSH     {r3-r7,lr}
000202  4604              MOV      r4,r0
000204  460d              MOV      r5,r1
000206  4616              MOV      r6,r2
000208  461f              MOV      r7,r3
;;;220      return GUI_MEMDEV_CreateEx(x0, y0, xsize, ysize, GUI_MEMDEV_HASTRANS);
00020a  2000              MOVS     r0,#0
00020c  463b              MOV      r3,r7
00020e  4632              MOV      r2,r6
000210  4629              MOV      r1,r5
000212  9000              STR      r0,[sp,#0]
000214  4620              MOV      r0,r4
000216  f7fffffe          BL       GUI_MEMDEV_CreateEx
;;;221    }
00021a  bdf8              POP      {r3-r7,pc}
;;;222    
                          ENDP

                  GUI_MEMDEV_Select PROC
;;;226    */
;;;227    GUI_MEMDEV_Handle GUI_MEMDEV_Select(GUI_MEMDEV_Handle hMem) {
00021c  b570              PUSH     {r4-r6,lr}
00021e  4604              MOV      r4,r0
;;;228      GUI_MEMDEV_Handle r;
;;;229      GUI_LOCK();
;;;230      r = GUI_Context.hDevData;
000220  4875              LDR      r0,|L1.1016|
000222  f9b0504c          LDRSH    r5,[r0,#0x4c]  ; GUI_Context
;;;231      if (hMem == 0) {
000226  b914              CBNZ     r4,|L1.558|
;;;232        GUI_SelectLCD();
000228  f7fffffe          BL       GUI_SelectLCD
00022c  e019              B        |L1.610|
                  |L1.558|
;;;233      } else {
;;;234        GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
00022e  4620              MOV      r0,r4
000230  f7fffffe          BL       GUI_ALLOC_h2p
000234  4606              MOV      r6,r0
;;;235        #if GUI_WINSUPPORT
;;;236          WM_Deactivate();
000236  f7fffffe          BL       WM_Deactivate
;;;237        #endif
;;;238        /* If LCD was selected Save cliprect */
;;;239        if (GUI_Context.hDevData == 0) {
00023a  486f              LDR      r0,|L1.1016|
00023c  f8b0004c          LDRH     r0,[r0,#0x4c]  ; GUI_Context
000240  b930              CBNZ     r0,|L1.592|
;;;240          GUI_Context.ClipRectPrev = GUI_Context.ClipRect;
000242  486d              LDR      r0,|L1.1016|
000244  304e              ADDS     r0,r0,#0x4e
000246  496c              LDR      r1,|L1.1016|
000248  688a              LDR      r2,[r1,#8]  ; GUI_Context
00024a  6002              STR      r2,[r0,#0]  ; GUI_Context
00024c  68c9              LDR      r1,[r1,#0xc]  ; GUI_Context
00024e  6041              STR      r1,[r0,#4]  ; GUI_Context
                  |L1.592|
;;;241        }
;;;242        GUI_Context.hDevData = hMem;
000250  4869              LDR      r0,|L1.1016|
000252  f8a0404c          STRH     r4,[r0,#0x4c]
;;;243        GUI_Context.pDeviceAPI = pDev->pAPIList;
000256  4968              LDR      r1,|L1.1016|
000258  6ab0              LDR      r0,[r6,#0x28]
00025a  6488              STR      r0,[r1,#0x48]  ; GUI_Context
;;;244        LCD_SetClipRectMax();
00025c  f7fffffe          BL       LCD_SetClipRectMax
;;;245      }
000260  bf00              NOP      
                  |L1.610|
;;;246      GUI_UNLOCK();
;;;247      return r;
000262  4628              MOV      r0,r5
;;;248    }
000264  bd70              POP      {r4-r6,pc}
;;;249    
                          ENDP

                  GUI_MEMDEV__WriteToActiveAt PROC
;;;253    */
;;;254    void GUI_MEMDEV__WriteToActiveAt(GUI_MEMDEV_Handle hMem,int x, int y) {
000266  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
00026a  b08c              SUB      sp,sp,#0x30
00026c  4692              MOV      r10,r2
;;;255      GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
00026e  980c              LDR      r0,[sp,#0x30]
000270  f7fffffe          BL       GUI_ALLOC_h2p
000274  4605              MOV      r5,r0
;;;256      GUI_USAGE_h hUsage = pDev->hUsage; 
000276  f9b50018          LDRSH    r0,[r5,#0x18]
00027a  900b              STR      r0,[sp,#0x2c]
;;;257      GUI_USAGE*  pUsage;
;;;258      int YSize = pDev->YSize;
00027c  f9b50006          LDRSH    r0,[r5,#6]
000280  900a              STR      r0,[sp,#0x28]
;;;259      int yi;
;;;260      unsigned int BytesPerLine = pDev->BytesPerLine;
000282  68ef              LDR      r7,[r5,#0xc]
;;;261      unsigned int BitsPerPixel = pDev->BitsPerPixel;
000284  f8d5b010          LDR      r11,[r5,#0x10]
;;;262      int BytesPerPixel = BitsPerPixel >> 3;
000288  ea4f00db          LSR      r0,r11,#3
00028c  9009              STR      r0,[sp,#0x24]
;;;263      U8* pData = (U8*)(pDev+1);
00028e  f105082c          ADD      r8,r5,#0x2c
;;;264      if (hUsage) {
000292  980b              LDR      r0,[sp,#0x2c]
000294  2800              CMP      r0,#0
000296  d05f              BEQ      |L1.856|
;;;265        pUsage = GUI_USAGE_H2P(hUsage);
000298  980b              LDR      r0,[sp,#0x2c]
00029a  f7fffffe          BL       GUI_ALLOC_h2p
00029e  4606              MOV      r6,r0
;;;266        for (yi = 0; yi < YSize; yi++) {
0002a0  2400              MOVS     r4,#0
0002a2  e055              B        |L1.848|
                  |L1.676|
;;;267          int xOff = 0;
0002a4  2000              MOVS     r0,#0
0002a6  9008              STR      r0,[sp,#0x20]
;;;268          int XSize;
;;;269          XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
0002a8  68b0              LDR      r0,[r6,#8]
0002aa  4622              MOV      r2,r4
0002ac  a908              ADD      r1,sp,#0x20
0002ae  6943              LDR      r3,[r0,#0x14]
0002b0  4630              MOV      r0,r6
0002b2  4798              BLX      r3
0002b4  4681              MOV      r9,r0
;;;270          if (XSize == pDev->XSize) {
0002b6  f9b50004          LDRSH    r0,[r5,#4]
0002ba  4548              CMP      r0,r9
0002bc  d123              BNE      |L1.774|
;;;271            /* If the entire line is affected, calculate the number of entire lines */
;;;272            int y0 = yi;
0002be  9407              STR      r4,[sp,#0x1c]
;;;273            while ((GUI_USAGE_GetNextDirty(pUsage, &xOff, yi + 1)) == XSize) {
0002c0  e000              B        |L1.708|
                  |L1.706|
;;;274              yi++;
0002c2  1c64              ADDS     r4,r4,#1
                  |L1.708|
0002c4  68b0              LDR      r0,[r6,#8]            ;273
0002c6  1c62              ADDS     r2,r4,#1              ;273
0002c8  a908              ADD      r1,sp,#0x20           ;273
0002ca  6943              LDR      r3,[r0,#0x14]         ;273
0002cc  4630              MOV      r0,r6                 ;273
0002ce  4798              BLX      r3                    ;273
0002d0  4548              CMP      r0,r9                 ;273
0002d2  d0f6              BEQ      |L1.706|
;;;275            }
;;;276    		    LCD_DrawBitmap(x, y + y0, pDev->XSize, yi - y0 + 1, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
0002d4  2000              MOVS     r0,#0
0002d6  e9cdb702          STRD     r11,r7,[sp,#8]
0002da  e9cd8004          STRD     r8,r0,[sp,#0x10]
0002de  2001              MOVS     r0,#1
0002e0  9000              STR      r0,[sp,#0]
0002e2  9001              STR      r0,[sp,#4]
0002e4  9807              LDR      r0,[sp,#0x1c]
0002e6  1a20              SUBS     r0,r4,r0
0002e8  1c43              ADDS     r3,r0,#1
0002ea  f9b52004          LDRSH    r2,[r5,#4]
0002ee  9807              LDR      r0,[sp,#0x1c]
0002f0  eb0a0100          ADD      r1,r10,r0
0002f4  980d              LDR      r0,[sp,#0x34]
0002f6  f7fffffe          BL       LCD_DrawBitmap
;;;277            pData += (yi - y0 + 1) * BytesPerLine;
0002fa  9807              LDR      r0,[sp,#0x1c]
0002fc  1a20              SUBS     r0,r4,r0
0002fe  1c40              ADDS     r0,r0,#1
000300  fb008807          MLA      r8,r0,r7,r8
;;;278          } else {
000304  e023              B        |L1.846|
                  |L1.774|
;;;279            /* Draw the partial line which needs to be drawn */
;;;280            for (; XSize; ) {
000306  e01e              B        |L1.838|
                  |L1.776|
;;;281              LCD_DrawBitmap(x + xOff, y + yi, XSize, 1, 1, 1, BitsPerPixel, BytesPerLine, pData + xOff * BytesPerPixel, NULL);
000308  2100              MOVS     r1,#0
00030a  e9dd2008          LDRD     r2,r0,[sp,#0x20]
00030e  fb028000          MLA      r0,r2,r0,r8
000312  e9cdb702          STRD     r11,r7,[sp,#8]
000316  e9cd0104          STRD     r0,r1,[sp,#0x10]
00031a  2001              MOVS     r0,#1
00031c  9000              STR      r0,[sp,#0]
00031e  eb0a0104          ADD      r1,r10,r4
000322  9001              STR      r0,[sp,#4]
000324  9b08              LDR      r3,[sp,#0x20]
000326  9a0d              LDR      r2,[sp,#0x34]
000328  18d0              ADDS     r0,r2,r3
00032a  2301              MOVS     r3,#1
00032c  464a              MOV      r2,r9
00032e  f7fffffe          BL       LCD_DrawBitmap
;;;282              xOff += XSize;
000332  9808              LDR      r0,[sp,#0x20]
000334  4448              ADD      r0,r0,r9
000336  9008              STR      r0,[sp,#0x20]
;;;283              XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
000338  68b0              LDR      r0,[r6,#8]
00033a  4622              MOV      r2,r4
00033c  a908              ADD      r1,sp,#0x20
00033e  6943              LDR      r3,[r0,#0x14]
000340  4630              MOV      r0,r6
000342  4798              BLX      r3
000344  4681              MOV      r9,r0
                  |L1.838|
000346  f1b90f00          CMP      r9,#0                 ;280
00034a  d1dd              BNE      |L1.776|
;;;284            }
;;;285            pData += BytesPerLine;
00034c  44b8              ADD      r8,r8,r7
                  |L1.846|
00034e  1c64              ADDS     r4,r4,#1              ;266
                  |L1.848|
000350  980a              LDR      r0,[sp,#0x28]         ;266
000352  4284              CMP      r4,r0                 ;266
000354  dba6              BLT      |L1.676|
000356  e00e              B        |L1.886|
                  |L1.856|
;;;286          }
;;;287        }
;;;288      } else {
;;;289    		LCD_DrawBitmap(x, y, pDev->XSize, YSize, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
000358  2000              MOVS     r0,#0
00035a  e9cdb702          STRD     r11,r7,[sp,#8]
00035e  e9cd8004          STRD     r8,r0,[sp,#0x10]
000362  2001              MOVS     r0,#1
000364  9000              STR      r0,[sp,#0]
000366  9001              STR      r0,[sp,#4]
000368  f9b52004          LDRSH    r2,[r5,#4]
00036c  4651              MOV      r1,r10
00036e  9b0a              LDR      r3,[sp,#0x28]
000370  980d              LDR      r0,[sp,#0x34]
000372  f7fffffe          BL       LCD_DrawBitmap
                  |L1.886|
;;;290      }
;;;291    }
000376  b00f              ADD      sp,sp,#0x3c
000378  e8bd8ff0          POP      {r4-r11,pc}
;;;292    
                          ENDP

                  GUI_MEMDEV_CopyToLCDAt PROC
;;;296    */
;;;297    void GUI_MEMDEV_CopyToLCDAt(GUI_MEMDEV_Handle hMem, int x, int y) {
00037c  e92d41fc          PUSH     {r2-r8,lr}
000380  4606              MOV      r6,r0
000382  460d              MOV      r5,r1
000384  4617              MOV      r7,r2
;;;298      if (hMem) {
000386  b3ae              CBZ      r6,|L1.1012|
;;;299        GUI_MEMDEV_Handle hMemPrev;
;;;300        GUI_MEMDEV* pDevData;
;;;301      #if (GUI_WINSUPPORT)
;;;302        GUI_RECT r;
;;;303      #endif
;;;304      #if GUI_NUM_LAYERS > 1
;;;305        int PrevLayer;
;;;306      #endif
;;;307        GUI_LOCK();
;;;308        hMemPrev = GUI_Context.hDevData;
000388  481b              LDR      r0,|L1.1016|
00038a  f9b0804c          LDRSH    r8,[r0,#0x4c]  ; GUI_Context
;;;309        pDevData = (GUI_MEMDEV*) GUI_ALLOC_h2p(hMem);  /* Convert to pointer */
00038e  4630              MOV      r0,r6
000390  f7fffffe          BL       GUI_ALLOC_h2p
000394  4604              MOV      r4,r0
;;;310        /* Make sure LCD is selected as device */
;;;311      #if GUI_NUM_LAYERS > 1
;;;312        PrevLayer = GUI_SelectLayer(pDevData->LayerIndex);
;;;313      #else
;;;314        GUI_SelectLCD();  /* Activate LCD */
000396  f7fffffe          BL       GUI_SelectLCD
;;;315      #endif
;;;316        if (x == GUI_POS_AUTO) {
00039a  4819              LDR      r0,|L1.1024|
00039c  4285              CMP      r5,r0
00039e  d103              BNE      |L1.936|
;;;317          x = pDevData->x0;
0003a0  f9b45000          LDRSH    r5,[r4,#0]
;;;318          y = pDevData->y0;
0003a4  f9b47002          LDRSH    r7,[r4,#2]
                  |L1.936|
;;;319        }
;;;320      #if (GUI_WINSUPPORT)
;;;321        /* Calculate rectangle */
;;;322        r.x1 = (r.x0 = x) + pDevData->XSize-1;
0003a8  b228              SXTH     r0,r5
0003aa  f8ad0000          STRH     r0,[sp,#0]
0003ae  88a1              LDRH     r1,[r4,#4]
0003b0  4408              ADD      r0,r0,r1
0003b2  1e40              SUBS     r0,r0,#1
0003b4  b200              SXTH     r0,r0
0003b6  f8ad0004          STRH     r0,[sp,#4]
;;;323        r.y1 = (r.y0 = y) + pDevData->YSize-1;;
0003ba  b238              SXTH     r0,r7
0003bc  f8ad0002          STRH     r0,[sp,#2]
0003c0  88e1              LDRH     r1,[r4,#6]
0003c2  4408              ADD      r0,r0,r1
0003c4  1e40              SUBS     r0,r0,#1
0003c6  b200              SXTH     r0,r0
0003c8  f8ad0006          STRH     r0,[sp,#6]
;;;324        /* Do the drawing. Window manager has to be on */
;;;325        WM_Activate();
0003cc  f7fffffe          BL       WM_Activate
;;;326        WM_ITERATE_START(&r) {
0003d0  4668              MOV      r0,sp
0003d2  f7fffffe          BL       WM__InitIVRSearch
0003d6  b148              CBZ      r0,|L1.1004|
0003d8  bf00              NOP      
                  |L1.986|
;;;327      #endif
;;;328        GUI_MEMDEV__WriteToActiveAt(hMem, x, y);
0003da  463a              MOV      r2,r7
0003dc  4629              MOV      r1,r5
0003de  4630              MOV      r0,r6
0003e0  f7fffffe          BL       GUI_MEMDEV__WriteToActiveAt
;;;329      #if (GUI_WINSUPPORT)
;;;330        } WM_ITERATE_END();
0003e4  f7fffffe          BL       WM__GetNextIVR
0003e8  2800              CMP      r0,#0
0003ea  d1f6              BNE      |L1.986|
                  |L1.1004|
;;;331      #endif
;;;332      #if GUI_NUM_LAYERS > 1
;;;333        GUI_SelectLayer(PrevLayer);
;;;334      #endif
;;;335        /* Reactivate previously used device */
;;;336        GUI_MEMDEV_Select(hMemPrev);
0003ec  4640              MOV      r0,r8
0003ee  f7fffffe          BL       GUI_MEMDEV_Select
;;;337        GUI_UNLOCK();
;;;338      }
0003f2  bf00              NOP      
                  |L1.1012|
;;;339    }
0003f4  e8bd81fc          POP      {r2-r8,pc}
                  |L1.1016|
                          DCD      GUI_Context
                  |L1.1020|
                          DCD      LCD_aAPI
                  |L1.1024|
                          DCD      0xfffff001
                          ENDP

                  GUI_MEMDEV_CopyToLCD PROC
;;;344    */
;;;345    void GUI_MEMDEV_CopyToLCD(GUI_MEMDEV_Handle hMem) {
000404  b510              PUSH     {r4,lr}
000406  4604              MOV      r4,r0
;;;346      GUI_MEMDEV_CopyToLCDAt(hMem, GUI_POS_AUTO, GUI_POS_AUTO);
000408  4a02              LDR      r2,|L1.1044|
00040a  4611              MOV      r1,r2
00040c  4620              MOV      r0,r4
00040e  f7fffffe          BL       GUI_MEMDEV_CopyToLCDAt
;;;347    }
000412  bd10              POP      {r4,pc}
;;;348    
                          ENDP

                  |L1.1044|
                          DCD      0xfffff001
