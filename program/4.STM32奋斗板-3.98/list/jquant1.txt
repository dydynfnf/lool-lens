; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jquant1.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jquant1.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jquant1.crf GUI\JPEG\jquant1.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  select_ncolors PROC
;;;185    LOCAL(int)
;;;186    select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;187    /* Determine allocation of desired colors to components, */
;;;188    /* and fill in Ncolors[] array to indicate choice. */
;;;189    /* Return value is total number of colors (product of Ncolors[] values). */
;;;190    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;191      int nc = cinfo->out_color_components; /* number of color components */
000008  f8d5b078          LDR      r11,[r5,#0x78]
;;;192      int max_colors = cinfo->desired_number_of_colors;
00000c  6e28              LDR      r0,[r5,#0x60]
00000e  9001              STR      r0,[sp,#4]
;;;193      int total_colors, iroot, i, j;
;;;194      boolean changed;
;;;195      long temp;
;;;196      static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };
;;;197    
;;;198      /* We can allocate at least the nc'th root of max_colors per component. */
;;;199      /* Compute floor(nc'th root of max_colors). */
;;;200      iroot = 1;
000010  2601              MOVS     r6,#1
;;;201      do {
000012  bf00              NOP      
                  |L1.20|
;;;202        iroot++;
000014  1c76              ADDS     r6,r6,#1
;;;203        temp = iroot;		/* set temp = iroot ** nc */
000016  46b0              MOV      r8,r6
;;;204        for (i = 1; i < nc; i++)
000018  2401              MOVS     r4,#1
00001a  e002              B        |L1.34|
                  |L1.28|
;;;205          temp *= iroot;
00001c  fb08f806          MUL      r8,r8,r6
000020  1c64              ADDS     r4,r4,#1              ;204
                  |L1.34|
000022  455c              CMP      r4,r11                ;204
000024  dbfa              BLT      |L1.28|
;;;206      } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
000026  9801              LDR      r0,[sp,#4]
000028  4580              CMP      r8,r0
00002a  ddf3              BLE      |L1.20|
;;;207      iroot--;			/* now iroot = floor(root) */
00002c  1e76              SUBS     r6,r6,#1
;;;208    
;;;209      /* Must have at least 2 color values per component */
;;;210      if (iroot < 2)
00002e  2e02              CMP      r6,#2
000030  da09              BGE      |L1.70|
;;;211        ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);
000032  2038              MOVS     r0,#0x38
000034  6829              LDR      r1,[r5,#0]
000036  6148              STR      r0,[r1,#0x14]
000038  6828              LDR      r0,[r5,#0]
00003a  f8c08018          STR      r8,[r0,#0x18]
00003e  6828              LDR      r0,[r5,#0]
000040  6801              LDR      r1,[r0,#0]
000042  4628              MOV      r0,r5
000044  4788              BLX      r1
                  |L1.70|
;;;212    
;;;213      /* Initialize to iroot color values for each component */
;;;214      total_colors = 1;
000046  f04f0901          MOV      r9,#1
;;;215      for (i = 0; i < nc; i++) {
00004a  2400              MOVS     r4,#0
00004c  e004              B        |L1.88|
                  |L1.78|
;;;216        Ncolors[i] = iroot;
00004e  f8476024          STR      r6,[r7,r4,LSL #2]
;;;217        total_colors *= iroot;
000052  fb09f906          MUL      r9,r9,r6
000056  1c64              ADDS     r4,r4,#1              ;215
                  |L1.88|
000058  455c              CMP      r4,r11                ;215
00005a  dbf8              BLT      |L1.78|
;;;218      }
;;;219      /* We may be able to increment the count for one or more components without
;;;220       * exceeding max_colors, though we know not all can be incremented.
;;;221       * Sometimes, the first component can be incremented more than once!
;;;222       * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
;;;223       * In RGB colorspace, try to increment G first, then R, then B.
;;;224       */
;;;225      do {
00005c  bf00              NOP      
                  |L1.94|
;;;226        changed = FALSE;
00005e  2000              MOVS     r0,#0
000060  9000              STR      r0,[sp,#0]
;;;227        for (i = 0; i < nc; i++) {
000062  2400              MOVS     r4,#0
000064  e01f              B        |L1.166|
                  |L1.102|
;;;228          j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
000066  f8950029          LDRB     r0,[r5,#0x29]
00006a  2802              CMP      r0,#2
00006c  d103              BNE      |L1.118|
00006e  48fe              LDR      r0,|L1.1128|
000070  f8500024          LDR      r0,[r0,r4,LSL #2]
000074  e000              B        |L1.120|
                  |L1.118|
000076  4620              MOV      r0,r4
                  |L1.120|
000078  4682              MOV      r10,r0
;;;229          /* calculate new total_colors if Ncolors[j] is incremented */
;;;230          temp = total_colors / Ncolors[j];
00007a  f857002a          LDR      r0,[r7,r10,LSL #2]
00007e  fb99f8f0          SDIV     r8,r9,r0
;;;231          temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
000082  f857002a          LDR      r0,[r7,r10,LSL #2]
000086  1c40              ADDS     r0,r0,#1
000088  fb08f800          MUL      r8,r8,r0
;;;232          if (temp > (long) max_colors)
00008c  9801              LDR      r0,[sp,#4]
00008e  4580              CMP      r8,r0
000090  dd00              BLE      |L1.148|
;;;233    	break;			/* won't fit, done with this pass */
000092  e00a              B        |L1.170|
                  |L1.148|
;;;234          Ncolors[j]++;		/* OK, apply the increment */
000094  f857002a          LDR      r0,[r7,r10,LSL #2]
000098  1c40              ADDS     r0,r0,#1
00009a  f847002a          STR      r0,[r7,r10,LSL #2]
;;;235          total_colors = (int) temp;
00009e  46c1              MOV      r9,r8
;;;236          changed = TRUE;
0000a0  2001              MOVS     r0,#1
0000a2  9000              STR      r0,[sp,#0]
0000a4  1c64              ADDS     r4,r4,#1              ;227
                  |L1.166|
0000a6  455c              CMP      r4,r11                ;227
0000a8  dbdd              BLT      |L1.102|
                  |L1.170|
0000aa  bf00              NOP                            ;233
;;;237        }
;;;238      } while (changed);
0000ac  9800              LDR      r0,[sp,#0]
0000ae  2800              CMP      r0,#0
0000b0  d1d5              BNE      |L1.94|
;;;239    
;;;240      return total_colors;
0000b2  4648              MOV      r0,r9
;;;241    }
0000b4  e8bd9ffc          POP      {r2-r12,pc}
;;;242    
                          ENDP

                  output_value PROC
;;;244    LOCAL(int)
;;;245    output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
0000b8  b570              PUSH     {r4-r6,lr}
;;;246    /* Return j'th output value, where j will range from 0 to maxj */
;;;247    /* The output values must fall in 0..MAXJSAMPLE in increasing order */
;;;248    {
0000ba  4604              MOV      r4,r0
;;;249      /* We always provide values 0 and MAXJSAMPLE for each component;
;;;250       * any additional values are equally spaced between these limits.
;;;251       * (Forcing the upper and lower values to the limits ensures that
;;;252       * dithering can't produce a color outside the selected gamut.)
;;;253       */
;;;254      GUI_USE_PARA(cinfo);
0000bc  bf00              NOP      
;;;255      GUI_USE_PARA(ci);
0000be  bf00              NOP      
;;;256      return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
0000c0  461d              MOV      r5,r3
0000c2  eb0370d5          ADD      r0,r3,r5,LSR #31
0000c6  ebc22602          RSB      r6,r2,r2,LSL #8
0000ca  eb060060          ADD      r0,r6,r0,ASR #1
0000ce  fb90f0f3          SDIV     r0,r0,r3
;;;257    }
0000d2  bd70              POP      {r4-r6,pc}
;;;258    
                          ENDP

                  largest_input_value PROC
;;;260    LOCAL(int)
;;;261    largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
0000d4  b530              PUSH     {r4,r5,lr}
;;;262    /* Return largest input value that should map to j'th output value */
;;;263    /* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
;;;264    {
0000d6  4604              MOV      r4,r0
;;;265      GUI_USE_PARA(cinfo);
0000d8  bf00              NOP      
;;;266      GUI_USE_PARA(ci);
0000da  bf00              NOP      
;;;267      /* Breakpoints are halfway between values returned by output_value */
;;;268      return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
0000dc  0050              LSLS     r0,r2,#1
0000de  1c40              ADDS     r0,r0,#1
0000e0  ebc02000          RSB      r0,r0,r0,LSL #8
0000e4  4418              ADD      r0,r0,r3
0000e6  005d              LSLS     r5,r3,#1
0000e8  fb90f0f5          SDIV     r0,r0,r5
;;;269    }
0000ec  bd30              POP      {r4,r5,pc}
;;;270    
                          ENDP

                  create_colormap PROC
;;;276    LOCAL(void)
;;;277    create_colormap (j_decompress_ptr cinfo)
0000ee  e92d4ff0          PUSH     {r4-r11,lr}
;;;278    {
0000f2  b085              SUB      sp,sp,#0x14
0000f4  4604              MOV      r4,r0
;;;279      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0000f6  f8d451cc          LDR      r5,[r4,#0x1cc]
;;;280      JSAMPARRAY colormap;		/* Created colormap */
;;;281      int total_colors;		/* Number of distinct output colors */
;;;282      int i,j,k, nci, blksize, blkdist, ptr, val;
;;;283    
;;;284      /* Select number of colors for each component */
;;;285      total_colors = select_ncolors(cinfo, cquantize->Ncolors);
0000fa  f1050120          ADD      r1,r5,#0x20
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       select_ncolors
000104  4606              MOV      r6,r0
;;;286    
;;;287      /* Report selected color counts */
;;;288      if (cinfo->out_color_components == 3)
000106  6fa0              LDR      r0,[r4,#0x78]
000108  2803              CMP      r0,#3
00010a  d117              BNE      |L1.316|
;;;289        TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
00010c  bf00              NOP      
00010e  6820              LDR      r0,[r4,#0]
000110  f1000b18          ADD      r11,r0,#0x18
000114  f8cb6000          STR      r6,[r11,#0]
000118  6a28              LDR      r0,[r5,#0x20]
00011a  f8cb0004          STR      r0,[r11,#4]
00011e  6a68              LDR      r0,[r5,#0x24]
000120  f8cb0008          STR      r0,[r11,#8]
000124  6aa8              LDR      r0,[r5,#0x28]
000126  f8cb000c          STR      r0,[r11,#0xc]
00012a  205e              MOVS     r0,#0x5e
00012c  6821              LDR      r1,[r4,#0]
00012e  6148              STR      r0,[r1,#0x14]
000130  6820              LDR      r0,[r4,#0]
000132  2101              MOVS     r1,#1
000134  6842              LDR      r2,[r0,#4]
000136  4620              MOV      r0,r4
000138  4790              BLX      r2
00013a  e009              B        |L1.336|
                  |L1.316|
;;;290    	     total_colors, cquantize->Ncolors[0],
;;;291    	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
;;;292      else
;;;293        TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);
00013c  205f              MOVS     r0,#0x5f
00013e  6821              LDR      r1,[r4,#0]
000140  6148              STR      r0,[r1,#0x14]
000142  6820              LDR      r0,[r4,#0]
000144  6186              STR      r6,[r0,#0x18]
000146  6820              LDR      r0,[r4,#0]
000148  2101              MOVS     r1,#1
00014a  6842              LDR      r2,[r0,#4]
00014c  4620              MOV      r0,r4
00014e  4790              BLX      r2
                  |L1.336|
;;;294    
;;;295      /* Allocate and fill in the colormap. */
;;;296      /* The colors are ordered in the map in standard row-major order, */
;;;297      /* i.e. rightmost (highest-indexed) color changes most rapidly. */
;;;298    
;;;299      colormap = (*cinfo->mem->alloc_sarray)
000150  6fa3              LDR      r3,[r4,#0x78]
000152  6860              LDR      r0,[r4,#4]
000154  4632              MOV      r2,r6
000156  2101              MOVS     r1,#1
000158  f8d0c008          LDR      r12,[r0,#8]
00015c  4620              MOV      r0,r4
00015e  47e0              BLX      r12
000160  4680              MOV      r8,r0
;;;300        ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;301         (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
;;;302    
;;;303      /* blksize is number of adjacent repeated entries for a component */
;;;304      /* blkdist is distance between groups of identical entries for a component */
;;;305      blkdist = total_colors;
000162  9602              STR      r6,[sp,#8]
;;;306    
;;;307      for (i = 0; i < cinfo->out_color_components; i++) {
000164  2700              MOVS     r7,#0
000166  e037              B        |L1.472|
                  |L1.360|
;;;308        /* fill in colormap entries for i'th color component */
;;;309        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
000168  f1050020          ADD      r0,r5,#0x20
00016c  f850a027          LDR      r10,[r0,r7,LSL #2]
;;;310        blksize = blkdist / nci;
000170  9802              LDR      r0,[sp,#8]
000172  fb90f0fa          SDIV     r0,r0,r10
000176  9003              STR      r0,[sp,#0xc]
;;;311        for (j = 0; j < nci; j++) {
000178  f04f0900          MOV      r9,#0
00017c  e027              B        |L1.462|
                  |L1.382|
;;;312          /* Compute j'th output value (out of nci) for component */
;;;313          val = output_value(cinfo, i, j, nci-1);
00017e  f1aa0301          SUB      r3,r10,#1
000182  464a              MOV      r2,r9
000184  4639              MOV      r1,r7
000186  4620              MOV      r0,r4
000188  f7fffffe          BL       output_value
00018c  9000              STR      r0,[sp,#0]
;;;314          /* Fill in all colormap entries that have this value of this component */
;;;315          for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
00018e  9803              LDR      r0,[sp,#0xc]
000190  fb09f000          MUL      r0,r9,r0
000194  9001              STR      r0,[sp,#4]
000196  e015              B        |L1.452|
                  |L1.408|
;;;316    	/* fill in blksize entries beginning at ptr */
;;;317    	for (k = 0; k < blksize; k++)
000198  2000              MOVS     r0,#0
00019a  9004              STR      r0,[sp,#0x10]
00019c  e00a              B        |L1.436|
                  |L1.414|
;;;318    	  colormap[i][ptr+k] = (JSAMPLE) val;
00019e  9800              LDR      r0,[sp,#0]
0001a0  b2c2              UXTB     r2,r0
0001a2  f8583027          LDR      r3,[r8,r7,LSL #2]
0001a6  9904              LDR      r1,[sp,#0x10]
0001a8  9801              LDR      r0,[sp,#4]
0001aa  4408              ADD      r0,r0,r1
0001ac  541a              STRB     r2,[r3,r0]
0001ae  9804              LDR      r0,[sp,#0x10]         ;317
0001b0  1c40              ADDS     r0,r0,#1              ;317
0001b2  9004              STR      r0,[sp,#0x10]         ;317
                  |L1.436|
0001b4  e9dd1003          LDRD     r1,r0,[sp,#0xc]       ;317
0001b8  4288              CMP      r0,r1                 ;317
0001ba  dbf0              BLT      |L1.414|
0001bc  e9dd0101          LDRD     r0,r1,[sp,#4]         ;315
0001c0  4408              ADD      r0,r0,r1              ;315
0001c2  9001              STR      r0,[sp,#4]            ;315
                  |L1.452|
0001c4  9801              LDR      r0,[sp,#4]            ;315
0001c6  42b0              CMP      r0,r6                 ;315
0001c8  dbe6              BLT      |L1.408|
0001ca  f1090901          ADD      r9,r9,#1              ;311
                  |L1.462|
0001ce  45d1              CMP      r9,r10                ;311
0001d0  dbd5              BLT      |L1.382|
;;;319          }
;;;320        }
;;;321        blkdist = blksize;		/* blksize of this color is blkdist of next */
0001d2  9803              LDR      r0,[sp,#0xc]
0001d4  9002              STR      r0,[sp,#8]
0001d6  1c7f              ADDS     r7,r7,#1              ;307
                  |L1.472|
0001d8  6fa0              LDR      r0,[r4,#0x78]         ;307
0001da  42b8              CMP      r0,r7                 ;307
0001dc  dcc4              BGT      |L1.360|
;;;322      }
;;;323    
;;;324      /* Save the colormap in private storage,
;;;325       * where it will survive color quantization mode changes.
;;;326       */
;;;327      cquantize->sv_colormap = colormap;
0001de  f8c58010          STR      r8,[r5,#0x10]
;;;328      cquantize->sv_actual = total_colors;
0001e2  616e              STR      r6,[r5,#0x14]
;;;329    }
0001e4  b005              ADD      sp,sp,#0x14
0001e6  e8bd8ff0          POP      {r4-r11,pc}
;;;330    
                          ENDP

                  create_colorindex PROC
;;;336    LOCAL(void)
;;;337    create_colorindex (j_decompress_ptr cinfo)
0001ea  e92d5ffc          PUSH     {r2-r12,lr}
;;;338    {
0001ee  4607              MOV      r7,r0
;;;339      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0001f0  f8d741cc          LDR      r4,[r7,#0x1cc]
;;;340      JSAMPROW indexptr;
;;;341      int i,j,k, nci, blksize, val, pad;
;;;342    
;;;343      /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
;;;344       * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
;;;345       * This is not necessary in the other dithering modes.  However, we
;;;346       * flag whether it was done in case user changes dithering mode.
;;;347       */
;;;348      if (cinfo->dither_mode == JDITHER_ORDERED) {
0001f4  f8970058          LDRB     r0,[r7,#0x58]
0001f8  2801              CMP      r0,#1
0001fa  d103              BNE      |L1.516|
;;;349        pad = MAXJSAMPLE*2;
0001fc  f44f79ff          MOV      r9,#0x1fe
;;;350        cquantize->is_padded = TRUE;
000200  61e0              STR      r0,[r4,#0x1c]
000202  e003              B        |L1.524|
                  |L1.516|
;;;351      } else {
;;;352        pad = 0;
000204  f04f0900          MOV      r9,#0
;;;353        cquantize->is_padded = FALSE;
000208  2000              MOVS     r0,#0
00020a  61e0              STR      r0,[r4,#0x1c]
                  |L1.524|
;;;354      }
;;;355    
;;;356      cquantize->colorindex = (*cinfo->mem->alloc_sarray)
00020c  f5097280          ADD      r2,r9,#0x100
000210  6fbb              LDR      r3,[r7,#0x78]
000212  6878              LDR      r0,[r7,#4]
000214  2101              MOVS     r1,#1
000216  f8d0c008          LDR      r12,[r0,#8]
00021a  4638              MOV      r0,r7
00021c  47e0              BLX      r12
00021e  61a0              STR      r0,[r4,#0x18]
;;;357        ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;358         (JDIMENSION) (MAXJSAMPLE+1 + pad),
;;;359         (JDIMENSION) cinfo->out_color_components);
;;;360    
;;;361      /* blksize is number of adjacent repeated entries for a component */
;;;362      blksize = cquantize->sv_actual;
000220  f8d4b014          LDR      r11,[r4,#0x14]
;;;363    
;;;364      for (i = 0; i < cinfo->out_color_components; i++) {
000224  2500              MOVS     r5,#0
000226  e049              B        |L1.700|
                  |L1.552|
;;;365        /* fill in colorindex entries for i'th color component */
;;;366        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
000228  f1040020          ADD      r0,r4,#0x20
00022c  f850a025          LDR      r10,[r0,r5,LSL #2]
;;;367        blksize = blksize / nci;
000230  fb9bfbfa          SDIV     r11,r11,r10
;;;368    
;;;369        /* adjust colorindex pointers to provide padding at negative indexes. */
;;;370        if (pad)
000234  f1b90f00          CMP      r9,#0
000238  d006              BEQ      |L1.584|
;;;371          cquantize->colorindex[i] += MAXJSAMPLE;
00023a  69a0              LDR      r0,[r4,#0x18]
00023c  f8500025          LDR      r0,[r0,r5,LSL #2]
000240  30ff              ADDS     r0,r0,#0xff
000242  69a1              LDR      r1,[r4,#0x18]
000244  f8410025          STR      r0,[r1,r5,LSL #2]
                  |L1.584|
;;;372    
;;;373        /* in loop, val = index of current output value, */
;;;374        /* and k = largest j that maps to current val */
;;;375        indexptr = cquantize->colorindex[i];
000248  69a0              LDR      r0,[r4,#0x18]
00024a  f8508025          LDR      r8,[r0,r5,LSL #2]
;;;376        val = 0;
00024e  2000              MOVS     r0,#0
000250  9000              STR      r0,[sp,#0]
;;;377        k = largest_input_value(cinfo, i, 0, nci-1);
000252  f1aa0301          SUB      r3,r10,#1
000256  2200              MOVS     r2,#0
000258  4629              MOV      r1,r5
00025a  4638              MOV      r0,r7
00025c  f7fffffe          BL       largest_input_value
000260  9001              STR      r0,[sp,#4]
;;;378        for (j = 0; j <= MAXJSAMPLE; j++) {
000262  2600              MOVS     r6,#0
000264  e014              B        |L1.656|
                  |L1.614|
;;;379          while (j > k)		/* advance val if past boundary */
000266  e00a              B        |L1.638|
                  |L1.616|
;;;380    	k = largest_input_value(cinfo, i, ++val, nci-1);
000268  f1aa0301          SUB      r3,r10,#1
00026c  9800              LDR      r0,[sp,#0]
00026e  1c40              ADDS     r0,r0,#1
000270  4602              MOV      r2,r0
000272  4629              MOV      r1,r5
000274  9000              STR      r0,[sp,#0]
000276  4638              MOV      r0,r7
000278  f7fffffe          BL       largest_input_value
00027c  9001              STR      r0,[sp,#4]
                  |L1.638|
00027e  9801              LDR      r0,[sp,#4]            ;379
000280  4286              CMP      r6,r0                 ;379
000282  dcf1              BGT      |L1.616|
;;;381          /* premultiply so that no multiplication needed in main processing */
;;;382          indexptr[j] = (JSAMPLE) (val * blksize);
000284  9800              LDR      r0,[sp,#0]
000286  fb00f00b          MUL      r0,r0,r11
00028a  f8080006          STRB     r0,[r8,r6]
00028e  1c76              ADDS     r6,r6,#1              ;378
                  |L1.656|
000290  2eff              CMP      r6,#0xff              ;378
000292  dde8              BLE      |L1.614|
;;;383        }
;;;384        /* Pad at both ends if necessary */
;;;385        if (pad)
000294  f1b90f00          CMP      r9,#0
000298  d00f              BEQ      |L1.698|
;;;386          for (j = 1; j <= MAXJSAMPLE; j++) {
00029a  2601              MOVS     r6,#1
00029c  e00b              B        |L1.694|
                  |L1.670|
;;;387    	indexptr[-j] = indexptr[0];
00029e  f8980000          LDRB     r0,[r8,#0]
0002a2  4271              RSBS     r1,r6,#0
0002a4  f8080001          STRB     r0,[r8,r1]
;;;388    	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
0002a8  f89810ff          LDRB     r1,[r8,#0xff]
0002ac  f10600ff          ADD      r0,r6,#0xff
0002b0  f8081000          STRB     r1,[r8,r0]
0002b4  1c76              ADDS     r6,r6,#1              ;386
                  |L1.694|
0002b6  2eff              CMP      r6,#0xff              ;386
0002b8  ddf1              BLE      |L1.670|
                  |L1.698|
0002ba  1c6d              ADDS     r5,r5,#1              ;364
                  |L1.700|
0002bc  6fb8              LDR      r0,[r7,#0x78]         ;364
0002be  42a8              CMP      r0,r5                 ;364
0002c0  dcb2              BGT      |L1.552|
;;;389          }
;;;390      }
;;;391    }
0002c2  e8bd9ffc          POP      {r2-r12,pc}
;;;392    
                          ENDP

                  make_odither_array PROC
;;;399    LOCAL(ODITHER_MATRIX_PTR)
;;;400    make_odither_array (j_decompress_ptr cinfo, int ncolors)
0002c6  e92d47f0          PUSH     {r4-r10,lr}
;;;401    {
0002ca  4607              MOV      r7,r0
0002cc  4688              MOV      r8,r1
;;;402      ODITHER_MATRIX_PTR odither;
;;;403      int j,k;
;;;404      INT32 num,den;
;;;405    
;;;406      odither = (ODITHER_MATRIX_PTR)
0002ce  6878              LDR      r0,[r7,#4]
0002d0  f44f6280          MOV      r2,#0x400
0002d4  2101              MOVS     r1,#1
0002d6  6803              LDR      r3,[r0,#0]
0002d8  4638              MOV      r0,r7
0002da  4798              BLX      r3
0002dc  4681              MOV      r9,r0
;;;407        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;408    				SIZEOF(ODITHER_MATRIX));
;;;409      /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
;;;410       * Hence the dither value for the matrix cell with fill order f
;;;411       * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
;;;412       * On 16-bit-int machine, be careful to avoid overflow.
;;;413       */
;;;414      den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
0002de  f1a80001          SUB      r0,r8,#1
0002e2  ea4f2a40          LSL      r10,r0,#9
;;;415      for (j = 0; j < ODITHER_SIZE; j++) {
0002e6  2400              MOVS     r4,#0
0002e8  e01b              B        |L1.802|
                  |L1.746|
;;;416        for (k = 0; k < ODITHER_SIZE; k++) {
0002ea  2500              MOVS     r5,#0
0002ec  e016              B        |L1.796|
                  |L1.750|
;;;417          num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
0002ee  485f              LDR      r0,|L1.1132|
0002f0  eb001004          ADD      r0,r0,r4,LSL #4
0002f4  5d40              LDRB     r0,[r0,r5]
0002f6  0040              LSLS     r0,r0,#1
0002f8  f1c000ff          RSB      r0,r0,#0xff
0002fc  ebc02600          RSB      r6,r0,r0,LSL #8
;;;418    	    * MAXJSAMPLE;
;;;419          /* Ensure round towards zero despite C's lack of consistency
;;;420           * about rounding negative values in integer division...
;;;421           */
;;;422          odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
000300  2e00              CMP      r6,#0
000302  da04              BGE      |L1.782|
000304  4270              RSBS     r0,r6,#0
000306  fb90f0fa          SDIV     r0,r0,r10
00030a  4240              RSBS     r0,r0,#0
00030c  e001              B        |L1.786|
                  |L1.782|
00030e  fb96f0fa          SDIV     r0,r6,r10
                  |L1.786|
000312  eb091184          ADD      r1,r9,r4,LSL #6
000316  f8410025          STR      r0,[r1,r5,LSL #2]
00031a  1c6d              ADDS     r5,r5,#1              ;416
                  |L1.796|
00031c  2d10              CMP      r5,#0x10              ;416
00031e  dbe6              BLT      |L1.750|
000320  1c64              ADDS     r4,r4,#1              ;415
                  |L1.802|
000322  2c10              CMP      r4,#0x10              ;415
000324  dbe1              BLT      |L1.746|
;;;423        }
;;;424      }
;;;425      return odither;
000326  4648              MOV      r0,r9
;;;426    }
000328  e8bd87f0          POP      {r4-r10,pc}
;;;427    
                          ENDP

                  create_odither_tables PROC
;;;435    LOCAL(void)
;;;436    create_odither_tables (j_decompress_ptr cinfo)
00032c  e92d47f0          PUSH     {r4-r10,lr}
;;;437    {
000330  4607              MOV      r7,r0
;;;438      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000332  f8d751cc          LDR      r5,[r7,#0x1cc]
;;;439      ODITHER_MATRIX_PTR odither;
;;;440      int i, j, nci;
;;;441    
;;;442      for (i = 0; i < cinfo->out_color_components; i++) {
000336  2400              MOVS     r4,#0
000338  e023              B        |L1.898|
                  |L1.826|
;;;443        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
00033a  f1050020          ADD      r0,r5,#0x20
00033e  f8508024          LDR      r8,[r0,r4,LSL #2]
;;;444        odither = NULL;		/* search for matching prior component */
000342  f04f0900          MOV      r9,#0
;;;445        for (j = 0; j < i; j++) {
000346  2600              MOVS     r6,#0
000348  e00b              B        |L1.866|
                  |L1.842|
;;;446          if (nci == cquantize->Ncolors[j]) {
00034a  f1050020          ADD      r0,r5,#0x20
00034e  f8500026          LDR      r0,[r0,r6,LSL #2]
000352  4540              CMP      r0,r8
000354  d104              BNE      |L1.864|
;;;447    	odither = cquantize->odither[j];
000356  f1050034          ADD      r0,r5,#0x34
00035a  f8509026          LDR      r9,[r0,r6,LSL #2]
;;;448    	break;
00035e  e002              B        |L1.870|
                  |L1.864|
000360  1c76              ADDS     r6,r6,#1              ;445
                  |L1.866|
000362  42a6              CMP      r6,r4                 ;445
000364  dbf1              BLT      |L1.842|
                  |L1.870|
000366  bf00              NOP      
;;;449          }
;;;450        }
;;;451        if (odither == NULL)	/* need a new table? */
000368  f1b90f00          CMP      r9,#0
00036c  d104              BNE      |L1.888|
;;;452          odither = make_odither_array(cinfo, nci);
00036e  4641              MOV      r1,r8
000370  4638              MOV      r0,r7
000372  f7fffffe          BL       make_odither_array
000376  4681              MOV      r9,r0
                  |L1.888|
;;;453        cquantize->odither[i] = odither;
000378  f1050034          ADD      r0,r5,#0x34
00037c  f8409024          STR      r9,[r0,r4,LSL #2]
000380  1c64              ADDS     r4,r4,#1              ;442
                  |L1.898|
000382  6fb8              LDR      r0,[r7,#0x78]         ;442
000384  42a0              CMP      r0,r4                 ;442
000386  dcd8              BGT      |L1.826|
;;;454      }
;;;455    }
000388  e8bd87f0          POP      {r4-r10,pc}
;;;456    
                          ENDP

                  color_quantize PROC
;;;462    METHODDEF(void)
;;;463    color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
00038c  e92d4ffc          PUSH     {r2-r11,lr}
;;;464    		JSAMPARRAY output_buf, int num_rows)
;;;465    /* General case, no dithering */
;;;466    {
000390  460c              MOV      r4,r1
000392  4615              MOV      r5,r2
;;;467      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000394  f8d091cc          LDR      r9,[r0,#0x1cc]
;;;468      JSAMPARRAY colorindex = cquantize->colorindex;
000398  f8d9a018          LDR      r10,[r9,#0x18]
;;;469      register int pixcode, ci;
;;;470      register JSAMPROW ptrin, ptrout;
;;;471      int row;
;;;472      JDIMENSION col;
;;;473      JDIMENSION width = cinfo->output_width;
00039c  f8d0b070          LDR      r11,[r0,#0x70]
0003a0  f8cdb004          STR      r11,[sp,#4]
;;;474      register int nc = cinfo->out_color_components;
0003a4  f8d0b078          LDR      r11,[r0,#0x78]
0003a8  f8cdb000          STR      r11,[sp,#0]
;;;475    
;;;476      for (row = 0; row < num_rows; row++) {
0003ac  2100              MOVS     r1,#0
0003ae  e01a              B        |L1.998|
                  |L1.944|
;;;477        ptrin = input_buf[row];
0003b0  f854c021          LDR      r12,[r4,r1,LSL #2]
;;;478        ptrout = output_buf[row];
0003b4  f8558021          LDR      r8,[r5,r1,LSL #2]
;;;479        for (col = width; col > 0; col--) {
0003b8  9f01              LDR      r7,[sp,#4]
0003ba  e011              B        |L1.992|
                  |L1.956|
;;;480          pixcode = 0;
0003bc  2600              MOVS     r6,#0
;;;481          for (ci = 0; ci < nc; ci++) {
0003be  2200              MOVS     r2,#0
0003c0  e007              B        |L1.978|
                  |L1.962|
;;;482    	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
0003c2  f81cbb01          LDRB     r11,[r12],#1
0003c6  f85ae022          LDR      lr,[r10,r2,LSL #2]
0003ca  f81eb00b          LDRB     r11,[lr,r11]
0003ce  445e              ADD      r6,r6,r11
0003d0  1c52              ADDS     r2,r2,#1              ;481
                  |L1.978|
0003d2  f8ddb000          LDR      r11,[sp,#0]           ;481
0003d6  455a              CMP      r2,r11                ;481
0003d8  dbf3              BLT      |L1.962|
;;;483          }
;;;484          *ptrout++ = (JSAMPLE) pixcode;
0003da  f8086b01          STRB     r6,[r8],#1
0003de  1e7f              SUBS     r7,r7,#1              ;479
                  |L1.992|
0003e0  2f00              CMP      r7,#0                 ;479
0003e2  d1eb              BNE      |L1.956|
0003e4  1c49              ADDS     r1,r1,#1              ;476
                  |L1.998|
0003e6  4299              CMP      r1,r3                 ;476
0003e8  dbe2              BLT      |L1.944|
;;;485        }
;;;486      }
;;;487    }
0003ea  e8bd8ffc          POP      {r2-r11,pc}
;;;488    
                          ENDP

                  color_quantize3 PROC
;;;490    METHODDEF(void)
;;;491    color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
0003ee  e92d4ffc          PUSH     {r2-r11,lr}
;;;492    		 JSAMPARRAY output_buf, int num_rows)
;;;493    /* Fast path for out_color_components==3, no dithering */
;;;494    {
0003f2  4604              MOV      r4,r0
0003f4  460d              MOV      r5,r1
0003f6  4616              MOV      r6,r2
0003f8  461f              MOV      r7,r3
;;;495      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0003fa  f8d421cc          LDR      r2,[r4,#0x1cc]
;;;496      register int pixcode;
;;;497      register JSAMPROW ptrin, ptrout;
;;;498      JSAMPROW colorindex0 = cquantize->colorindex[0];
0003fe  f8d2b018          LDR      r11,[r2,#0x18]
000402  f8db9000          LDR      r9,[r11,#0]
;;;499      JSAMPROW colorindex1 = cquantize->colorindex[1];
000406  f8d2b018          LDR      r11,[r2,#0x18]
00040a  f8dba004          LDR      r10,[r11,#4]
;;;500      JSAMPROW colorindex2 = cquantize->colorindex[2];
00040e  f8d2b018          LDR      r11,[r2,#0x18]
000412  f8dbb008          LDR      r11,[r11,#8]
000416  f8cdb004          STR      r11,[sp,#4]
;;;501      int row;
;;;502      JDIMENSION col;
;;;503      JDIMENSION width = cinfo->output_width;
00041a  f8d4b070          LDR      r11,[r4,#0x70]
00041e  f8cdb000          STR      r11,[sp,#0]
;;;504    
;;;505      for (row = 0; row < num_rows; row++) {
000422  2100              MOVS     r1,#0
000424  e01e              B        |L1.1124|
                  |L1.1062|
;;;506        ptrin = input_buf[row];
000426  f8550021          LDR      r0,[r5,r1,LSL #2]
;;;507        ptrout = output_buf[row];
00042a  f856c021          LDR      r12,[r6,r1,LSL #2]
;;;508        for (col = width; col > 0; col--) {
00042e  f8dd8000          LDR      r8,[sp,#0]
000432  e013              B        |L1.1116|
                  |L1.1076|
;;;509          pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
000434  f810bb01          LDRB     r11,[r0],#1
000438  f819300b          LDRB     r3,[r9,r11]
;;;510          pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
00043c  f810bb01          LDRB     r11,[r0],#1
000440  f81ab00b          LDRB     r11,[r10,r11]
000444  445b              ADD      r3,r3,r11
;;;511          pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
000446  f810bb01          LDRB     r11,[r0],#1
00044a  f8dde004          LDR      lr,[sp,#4]
00044e  f81eb00b          LDRB     r11,[lr,r11]
000452  445b              ADD      r3,r3,r11
;;;512          *ptrout++ = (JSAMPLE) pixcode;
000454  f80c3b01          STRB     r3,[r12],#1
000458  f1a80801          SUB      r8,r8,#1              ;508
                  |L1.1116|
00045c  f1b80f00          CMP      r8,#0                 ;508
000460  d1e8              BNE      |L1.1076|
000462  1c49              ADDS     r1,r1,#1              ;505
                  |L1.1124|
000464  42b9              CMP      r1,r7                 ;505
000466  e003              B        |L1.1136|
                  |L1.1128|
                          DCD      RGB_order
                  |L1.1132|
                          DCD      base_dither_matrix
                  |L1.1136|
000470  dbd9              BLT      |L1.1062|
;;;513        }
;;;514      }
;;;515    }
000472  e8bd8ffc          POP      {r2-r11,pc}
;;;516    
                          ENDP

                  quantize_ord_dither PROC
;;;518    METHODDEF(void)
;;;519    quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000476  e92d4fff          PUSH     {r0-r11,lr}
;;;520    		     JSAMPARRAY output_buf, int num_rows)
;;;521    /* General case, with ordered dithering */
;;;522    {
00047a  b087              SUB      sp,sp,#0x1c
00047c  4606              MOV      r6,r0
00047e  4690              MOV      r8,r2
;;;523      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000480  f8d671cc          LDR      r7,[r6,#0x1cc]
;;;524      register JSAMPROW input_ptr;
;;;525      register JSAMPROW output_ptr;
;;;526      JSAMPROW colorindex_ci;
;;;527      int * dither;			/* points to active row of dither matrix */
;;;528      int row_index, col_index;	/* current indexes into dither matrix */
;;;529      int nc = cinfo->out_color_components;
000484  6fb0              LDR      r0,[r6,#0x78]
000486  9002              STR      r0,[sp,#8]
;;;530      int ci;
;;;531      int row;
;;;532      JDIMENSION col;
;;;533      JDIMENSION width = cinfo->output_width;
000488  f8d6b070          LDR      r11,[r6,#0x70]
;;;534    
;;;535      for (row = 0; row < num_rows; row++) {
00048c  2500              MOVS     r5,#0
00048e  e049              B        |L1.1316|
                  |L1.1168|
;;;536        /* Initialize output values to 0 so can process components separately */
;;;537        jzero_far((void FAR *) output_buf[row],
000490  4659              MOV      r1,r11
000492  f8580025          LDR      r0,[r8,r5,LSL #2]
000496  f7fffffe          BL       jzero_far
;;;538    	      (size_t) (width * SIZEOF(JSAMPLE)));
;;;539        row_index = cquantize->row_index;
00049a  f8d7a030          LDR      r10,[r7,#0x30]
;;;540        for (ci = 0; ci < nc; ci++) {
00049e  2400              MOVS     r4,#0
0004a0  e036              B        |L1.1296|
                  |L1.1186|
;;;541          input_ptr = input_buf[row] + ci;
0004a2  9808              LDR      r0,[sp,#0x20]
0004a4  f8500025          LDR      r0,[r0,r5,LSL #2]
0004a8  4420              ADD      r0,r0,r4
0004aa  9006              STR      r0,[sp,#0x18]
;;;542          output_ptr = output_buf[row];
0004ac  f8589025          LDR      r9,[r8,r5,LSL #2]
;;;543          colorindex_ci = cquantize->colorindex[ci];
0004b0  69b8              LDR      r0,[r7,#0x18]
0004b2  f8500024          LDR      r0,[r0,r4,LSL #2]
0004b6  9005              STR      r0,[sp,#0x14]
;;;544          dither = cquantize->odither[ci][row_index];
0004b8  f1070034          ADD      r0,r7,#0x34
0004bc  f8500024          LDR      r0,[r0,r4,LSL #2]
0004c0  eb00108a          ADD      r0,r0,r10,LSL #6
0004c4  9004              STR      r0,[sp,#0x10]
;;;545          col_index = 0;
0004c6  2000              MOVS     r0,#0
0004c8  9003              STR      r0,[sp,#0xc]
;;;546    
;;;547          for (col = width; col > 0; col--) {
0004ca  f8cdb004          STR      r11,[sp,#4]
0004ce  e01b              B        |L1.1288|
                  |L1.1232|
;;;548    	/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
;;;549    	 * select output value, accumulate into output code for this pixel.
;;;550    	 * Range-limiting need not be done explicitly, as we have extended
;;;551    	 * the colorindex table to produce the right answers for out-of-range
;;;552    	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
;;;553    	 * required amount of padding.
;;;554    	 */
;;;555    	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
0004d0  9806              LDR      r0,[sp,#0x18]
0004d2  7802              LDRB     r2,[r0,#0]
0004d4  e9dd1003          LDRD     r1,r0,[sp,#0xc]
0004d8  f8500021          LDR      r0,[r0,r1,LSL #2]
0004dc  1811              ADDS     r1,r2,r0
0004de  9805              LDR      r0,[sp,#0x14]
0004e0  5c40              LDRB     r0,[r0,r1]
0004e2  f8991000          LDRB     r1,[r9,#0]
0004e6  4408              ADD      r0,r0,r1
0004e8  f8890000          STRB     r0,[r9,#0]
;;;556    	input_ptr += nc;
0004ec  9902              LDR      r1,[sp,#8]
0004ee  9806              LDR      r0,[sp,#0x18]
0004f0  4408              ADD      r0,r0,r1
0004f2  9006              STR      r0,[sp,#0x18]
;;;557    	output_ptr++;
0004f4  f1090901          ADD      r9,r9,#1
;;;558    	col_index = (col_index + 1) & ODITHER_MASK;
0004f8  9803              LDR      r0,[sp,#0xc]
0004fa  1c40              ADDS     r0,r0,#1
0004fc  f000000f          AND      r0,r0,#0xf
000500  9003              STR      r0,[sp,#0xc]
000502  9801              LDR      r0,[sp,#4]            ;547
000504  1e40              SUBS     r0,r0,#1              ;547
000506  9001              STR      r0,[sp,#4]            ;547
                  |L1.1288|
000508  9801              LDR      r0,[sp,#4]            ;547
00050a  2800              CMP      r0,#0                 ;547
00050c  d1e0              BNE      |L1.1232|
00050e  1c64              ADDS     r4,r4,#1              ;540
                  |L1.1296|
000510  9802              LDR      r0,[sp,#8]            ;540
000512  4284              CMP      r4,r0                 ;540
000514  dbc5              BLT      |L1.1186|
;;;559          }
;;;560        }
;;;561        /* Advance row index for next row */
;;;562        row_index = (row_index + 1) & ODITHER_MASK;
000516  f10a0001          ADD      r0,r10,#1
00051a  f0000a0f          AND      r10,r0,#0xf
;;;563        cquantize->row_index = row_index;
00051e  f8c7a030          STR      r10,[r7,#0x30]
000522  1c6d              ADDS     r5,r5,#1              ;535
                  |L1.1316|
000524  980a              LDR      r0,[sp,#0x28]         ;535
000526  4285              CMP      r5,r0                 ;535
000528  dbb2              BLT      |L1.1168|
;;;564      }
;;;565    }
00052a  b00b              ADD      sp,sp,#0x2c
00052c  e8bd8ff0          POP      {r4-r11,pc}
;;;566    
                          ENDP

                  quantize3_ord_dither PROC
;;;568    METHODDEF(void)
;;;569    quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000530  e92d4fff          PUSH     {r0-r11,lr}
;;;570    		      JSAMPARRAY output_buf, int num_rows)
;;;571    /* Fast path for out_color_components==3, with ordered dithering */
;;;572    {
000534  b084              SUB      sp,sp,#0x10
000536  4605              MOV      r5,r0
;;;573      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000538  f8d501cc          LDR      r0,[r5,#0x1cc]
;;;574      register int pixcode;
;;;575      register JSAMPROW input_ptr;
;;;576      register JSAMPROW output_ptr;
;;;577      JSAMPROW colorindex0 = cquantize->colorindex[0];
00053c  f8d0b018          LDR      r11,[r0,#0x18]
000540  f8dbb000          LDR      r11,[r11,#0]
000544  f8cdb00c          STR      r11,[sp,#0xc]
;;;578      JSAMPROW colorindex1 = cquantize->colorindex[1];
000548  f8d0b018          LDR      r11,[r0,#0x18]
00054c  f8dbb004          LDR      r11,[r11,#4]
000550  f8cdb008          STR      r11,[sp,#8]
;;;579      JSAMPROW colorindex2 = cquantize->colorindex[2];
000554  f8d0b018          LDR      r11,[r0,#0x18]
000558  f8dbb008          LDR      r11,[r11,#8]
00055c  f8cdb004          STR      r11,[sp,#4]
;;;580      int * dither0;		/* points to active row of dither matrix */
;;;581      int * dither1;
;;;582      int * dither2;
;;;583      int row_index, col_index;	/* current indexes into dither matrix */
;;;584      int row;
;;;585      JDIMENSION col;
;;;586      JDIMENSION width = cinfo->output_width;
000560  f8d5b070          LDR      r11,[r5,#0x70]
000564  f8cdb000          STR      r11,[sp,#0]
;;;587    
;;;588      for (row = 0; row < num_rows; row++) {
000568  2400              MOVS     r4,#0
00056a  e046              B        |L1.1530|
                  |L1.1388|
;;;589        row_index = cquantize->row_index;
00056c  6b02              LDR      r2,[r0,#0x30]
;;;590        input_ptr = input_buf[row];
00056e  f8ddb014          LDR      r11,[sp,#0x14]
000572  f85b1024          LDR      r1,[r11,r4,LSL #2]
;;;591        output_ptr = output_buf[row];
000576  f8ddb018          LDR      r11,[sp,#0x18]
00057a  f85b7024          LDR      r7,[r11,r4,LSL #2]
;;;592        dither0 = cquantize->odither[0][row_index];
00057e  f8d0b034          LDR      r11,[r0,#0x34]
000582  eb0b1c82          ADD      r12,r11,r2,LSL #6
;;;593        dither1 = cquantize->odither[1][row_index];
000586  f8d0b038          LDR      r11,[r0,#0x38]
00058a  eb0b1882          ADD      r8,r11,r2,LSL #6
;;;594        dither2 = cquantize->odither[2][row_index];
00058e  f8d0b03c          LDR      r11,[r0,#0x3c]
000592  eb0b1982          ADD      r9,r11,r2,LSL #6
;;;595        col_index = 0;
000596  2300              MOVS     r3,#0
;;;596    
;;;597        for (col = width; col > 0; col--) {
000598  f8dda000          LDR      r10,[sp,#0]
00059c  e024              B        |L1.1512|
                  |L1.1438|
;;;598          pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
00059e  f811bb01          LDRB     r11,[r1],#1
0005a2  f85ce023          LDR      lr,[r12,r3,LSL #2]
0005a6  44de              ADD      lr,lr,r11
0005a8  f8ddb00c          LDR      r11,[sp,#0xc]
0005ac  f81b600e          LDRB     r6,[r11,lr]
;;;599    					dither0[col_index]]);
;;;600          pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
0005b0  f811bb01          LDRB     r11,[r1],#1
0005b4  f858e023          LDR      lr,[r8,r3,LSL #2]
0005b8  44de              ADD      lr,lr,r11
0005ba  f8ddb008          LDR      r11,[sp,#8]
0005be  f81bb00e          LDRB     r11,[r11,lr]
0005c2  445e              ADD      r6,r6,r11
;;;601    					dither1[col_index]]);
;;;602          pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
0005c4  f811bb01          LDRB     r11,[r1],#1
0005c8  f859e023          LDR      lr,[r9,r3,LSL #2]
0005cc  44de              ADD      lr,lr,r11
0005ce  f8ddb004          LDR      r11,[sp,#4]
0005d2  f81bb00e          LDRB     r11,[r11,lr]
0005d6  445e              ADD      r6,r6,r11
;;;603    					dither2[col_index]]);
;;;604          *output_ptr++ = (JSAMPLE) pixcode;
0005d8  f8076b01          STRB     r6,[r7],#1
;;;605          col_index = (col_index + 1) & ODITHER_MASK;
0005dc  f1030b01          ADD      r11,r3,#1
0005e0  f00b030f          AND      r3,r11,#0xf
0005e4  f1aa0a01          SUB      r10,r10,#1            ;597
                  |L1.1512|
0005e8  f1ba0f00          CMP      r10,#0                ;597
0005ec  d1d7              BNE      |L1.1438|
;;;606        }
;;;607        row_index = (row_index + 1) & ODITHER_MASK;
0005ee  f1020b01          ADD      r11,r2,#1
0005f2  f00b020f          AND      r2,r11,#0xf
;;;608        cquantize->row_index = row_index;
0005f6  6302              STR      r2,[r0,#0x30]
0005f8  1c64              ADDS     r4,r4,#1              ;588
                  |L1.1530|
0005fa  f8ddb01c          LDR      r11,[sp,#0x1c]        ;588
0005fe  455c              CMP      r4,r11                ;588
000600  dbb4              BLT      |L1.1388|
;;;609      }
;;;610    }
000602  b008              ADD      sp,sp,#0x20
000604  e8bd8ff0          POP      {r4-r11,pc}
;;;611    
                          ENDP

                  quantize_fs_dither PROC
;;;613    METHODDEF(void)
;;;614    quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000608  e92d4fff          PUSH     {r0-r11,lr}
;;;615    		    JSAMPARRAY output_buf, int num_rows)
;;;616    /* General case, with Floyd-Steinberg dithering */
;;;617    {
00060c  b08d              SUB      sp,sp,#0x34
00060e  4680              MOV      r8,r0
;;;618      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000610  f8d851cc          LDR      r5,[r8,#0x1cc]
;;;619      register LOCFSERROR cur;	/* current error or pixel value */
;;;620      LOCFSERROR belowerr;		/* error for pixel below cur */
;;;621      LOCFSERROR bpreverr;		/* error for below/prev col */
;;;622      LOCFSERROR bnexterr;		/* error for below/next col */
;;;623      LOCFSERROR delta;
;;;624      register FSERRPTR errorptr;	/* => fserrors[] at column before current */
;;;625      register JSAMPROW input_ptr;
;;;626      register JSAMPROW output_ptr;
;;;627      JSAMPROW colorindex_ci;
;;;628      JSAMPROW colormap_ci;
;;;629      int pixcode;
;;;630      int nc = cinfo->out_color_components;
000614  f8d80078          LDR      r0,[r8,#0x78]
000618  9004              STR      r0,[sp,#0x10]
;;;631      int dir;			/* 1 for left-to-right, -1 for right-to-left */
;;;632      int dirnc;			/* dir * nc */
;;;633      int ci;
;;;634      int row;
;;;635      JDIMENSION col;
;;;636      JDIMENSION width = cinfo->output_width;
00061a  f8d87070          LDR      r7,[r8,#0x70]
;;;637      JSAMPLE *range_limit = cinfo->sample_range_limit;
00061e  f8d80144          LDR      r0,[r8,#0x144]
000622  9000              STR      r0,[sp,#0]
;;;638      SHIFT_TEMPS
;;;639    
;;;640      for (row = 0; row < num_rows; row++) {
000624  f04f0a00          MOV      r10,#0
000628  e08e              B        |L1.1864|
                  |L1.1578|
;;;641        /* Initialize output values to 0 so can process components separately */
;;;642        jzero_far((void FAR *) output_buf[row],
00062a  4639              MOV      r1,r7
00062c  9a0f              LDR      r2,[sp,#0x3c]
00062e  f852002a          LDR      r0,[r2,r10,LSL #2]
000632  f7fffffe          BL       jzero_far
;;;643    	      (size_t) (width * SIZEOF(JSAMPLE)));
;;;644        for (ci = 0; ci < nc; ci++) {
000636  2600              MOVS     r6,#0
000638  e07b              B        |L1.1842|
                  |L1.1594|
;;;645          input_ptr = input_buf[row] + ci;
00063a  980e              LDR      r0,[sp,#0x38]
00063c  f850002a          LDR      r0,[r0,r10,LSL #2]
000640  4430              ADD      r0,r0,r6
000642  9009              STR      r0,[sp,#0x24]
;;;646          output_ptr = output_buf[row];
000644  980f              LDR      r0,[sp,#0x3c]
000646  f850002a          LDR      r0,[r0,r10,LSL #2]
00064a  9008              STR      r0,[sp,#0x20]
;;;647          if (cquantize->on_odd_row) {
00064c  6d68              LDR      r0,[r5,#0x54]
00064e  b1b8              CBZ      r0,|L1.1664|
;;;648    	/* work right to left in this row */
;;;649    	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
000650  1e79              SUBS     r1,r7,#1
000652  9a04              LDR      r2,[sp,#0x10]
000654  9809              LDR      r0,[sp,#0x24]
000656  fb010002          MLA      r0,r1,r2,r0
00065a  9009              STR      r0,[sp,#0x24]
;;;650    	output_ptr += width-1;
00065c  9808              LDR      r0,[sp,#0x20]
00065e  4408              ADD      r0,r0,r1
000660  9008              STR      r0,[sp,#0x20]
;;;651    	dir = -1;
000662  f04f30ff          MOV      r0,#0xffffffff
000666  9003              STR      r0,[sp,#0xc]
;;;652    	dirnc = -nc;
000668  9804              LDR      r0,[sp,#0x10]
00066a  4240              RSBS     r0,r0,#0
00066c  9002              STR      r0,[sp,#8]
;;;653    	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
00066e  f1050044          ADD      r0,r5,#0x44
000672  f8501026          LDR      r1,[r0,r6,LSL #2]
000676  1c78              ADDS     r0,r7,#1
000678  eb010040          ADD      r0,r1,r0,LSL #1
00067c  900a              STR      r0,[sp,#0x28]
00067e  e008              B        |L1.1682|
                  |L1.1664|
;;;654          } else {
;;;655    	/* work left to right in this row */
;;;656    	dir = 1;
000680  2001              MOVS     r0,#1
000682  9003              STR      r0,[sp,#0xc]
;;;657    	dirnc = nc;
000684  9804              LDR      r0,[sp,#0x10]
000686  9002              STR      r0,[sp,#8]
;;;658    	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
000688  f1050044          ADD      r0,r5,#0x44
00068c  f8500026          LDR      r0,[r0,r6,LSL #2]
000690  900a              STR      r0,[sp,#0x28]
                  |L1.1682|
;;;659          }
;;;660          colorindex_ci = cquantize->colorindex[ci];
000692  69a8              LDR      r0,[r5,#0x18]
000694  f8500026          LDR      r0,[r0,r6,LSL #2]
000698  9007              STR      r0,[sp,#0x1c]
;;;661          colormap_ci = cquantize->sv_colormap[ci];
00069a  6928              LDR      r0,[r5,#0x10]
00069c  f8500026          LDR      r0,[r0,r6,LSL #2]
0006a0  9006              STR      r0,[sp,#0x18]
;;;662          /* Preset error values: no error propagated to first pixel from left */
;;;663          cur = 0;
0006a2  2400              MOVS     r4,#0
;;;664          /* and no error propagated to row below yet */
;;;665          belowerr = bpreverr = 0;
0006a4  2000              MOVS     r0,#0
0006a6  900b              STR      r0,[sp,#0x2c]
0006a8  900c              STR      r0,[sp,#0x30]
;;;666    
;;;667          for (col = width; col > 0; col--) {
0006aa  9701              STR      r7,[sp,#4]
0006ac  e039              B        |L1.1826|
                  |L1.1710|
;;;668    	/* cur holds the error propagated from the previous pixel on the
;;;669    	 * current line.  Add the error propagated from the previous line
;;;670    	 * to form the complete error correction term for this pixel, and
;;;671    	 * round the error term (which is expressed * 16) to an integer.
;;;672    	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
;;;673    	 * for either sign of the error value.
;;;674    	 * Note: errorptr points to *previous* column's array entry.
;;;675    	 */
;;;676    	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
0006ae  9903              LDR      r1,[sp,#0xc]
0006b0  980a              LDR      r0,[sp,#0x28]
0006b2  f9300011          LDRSH    r0,[r0,r1,LSL #1]
0006b6  4420              ADD      r0,r0,r4
0006b8  3008              ADDS     r0,r0,#8
0006ba  1104              ASRS     r4,r0,#4
;;;677    	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
;;;678    	 * The maximum error is +- MAXJSAMPLE; this sets the required size
;;;679    	 * of the range_limit array.
;;;680    	 */
;;;681    	cur += GETJSAMPLE(*input_ptr);
0006bc  9809              LDR      r0,[sp,#0x24]
0006be  7800              LDRB     r0,[r0,#0]
0006c0  4404              ADD      r4,r4,r0
;;;682    	cur = GETJSAMPLE(range_limit[cur]);
0006c2  9800              LDR      r0,[sp,#0]
0006c4  5d04              LDRB     r4,[r0,r4]
;;;683    	/* Select output value, accumulate into output code for this pixel */
;;;684    	pixcode = GETJSAMPLE(colorindex_ci[cur]);
0006c6  9807              LDR      r0,[sp,#0x1c]
0006c8  5d00              LDRB     r0,[r0,r4]
0006ca  9005              STR      r0,[sp,#0x14]
;;;685    	*output_ptr += (JSAMPLE) pixcode;
0006cc  9808              LDR      r0,[sp,#0x20]
0006ce  7801              LDRB     r1,[r0,#0]
0006d0  9805              LDR      r0,[sp,#0x14]
0006d2  4408              ADD      r0,r0,r1
0006d4  b2c1              UXTB     r1,r0
0006d6  9808              LDR      r0,[sp,#0x20]
0006d8  7001              STRB     r1,[r0,#0]
;;;686    	/* Compute actual representation error at this pixel */
;;;687    	/* Note: we can do this even though we don't have the final */
;;;688    	/* pixel code, because the colormap is orthogonal. */
;;;689    	cur -= GETJSAMPLE(colormap_ci[pixcode]);
0006da  e9dd0105          LDRD     r0,r1,[sp,#0x14]
0006de  5c08              LDRB     r0,[r1,r0]
0006e0  1a24              SUBS     r4,r4,r0
;;;690    	/* Compute error fractions to be propagated to adjacent pixels.
;;;691    	 * Add these into the running sums, and simultaneously shift the
;;;692    	 * next-line error sums left by 1 column.
;;;693    	 */
;;;694    	bnexterr = cur;
0006e2  46a1              MOV      r9,r4
;;;695    	delta = cur * 2;
0006e4  ea4f0b44          LSL      r11,r4,#1
;;;696    	cur += delta;		/* form error * 3 */
0006e8  445c              ADD      r4,r4,r11
;;;697    	errorptr[0] = (FSERROR) (bpreverr + cur);
0006ea  980b              LDR      r0,[sp,#0x2c]
0006ec  4420              ADD      r0,r0,r4
0006ee  b201              SXTH     r1,r0
0006f0  980a              LDR      r0,[sp,#0x28]
0006f2  8001              STRH     r1,[r0,#0]
;;;698    	cur += delta;		/* form error * 5 */
0006f4  445c              ADD      r4,r4,r11
;;;699    	bpreverr = belowerr + cur;
0006f6  980c              LDR      r0,[sp,#0x30]
0006f8  4420              ADD      r0,r0,r4
0006fa  900b              STR      r0,[sp,#0x2c]
;;;700    	belowerr = bnexterr;
0006fc  f8cd9030          STR      r9,[sp,#0x30]
;;;701    	cur += delta;		/* form error * 7 */
000700  445c              ADD      r4,r4,r11
;;;702    	/* At this point cur contains the 7/16 error value to be propagated
;;;703    	 * to the next pixel on the current line, and all the errors for the
;;;704    	 * next line have been shifted over. We are therefore ready to move on.
;;;705    	 */
;;;706    	input_ptr += dirnc;	/* advance input ptr to next column */
000702  9902              LDR      r1,[sp,#8]
000704  9809              LDR      r0,[sp,#0x24]
000706  4408              ADD      r0,r0,r1
000708  9009              STR      r0,[sp,#0x24]
;;;707    	output_ptr += dir;	/* advance output ptr to next column */
00070a  9903              LDR      r1,[sp,#0xc]
00070c  9808              LDR      r0,[sp,#0x20]
00070e  4408              ADD      r0,r0,r1
000710  9008              STR      r0,[sp,#0x20]
;;;708    	errorptr += dir;	/* advance errorptr to current column */
000712  9903              LDR      r1,[sp,#0xc]
000714  980a              LDR      r0,[sp,#0x28]
000716  eb000041          ADD      r0,r0,r1,LSL #1
00071a  900a              STR      r0,[sp,#0x28]
00071c  9801              LDR      r0,[sp,#4]            ;667
00071e  1e40              SUBS     r0,r0,#1              ;667
000720  9001              STR      r0,[sp,#4]            ;667
                  |L1.1826|
000722  9801              LDR      r0,[sp,#4]            ;667
000724  2800              CMP      r0,#0                 ;667
000726  d1c2              BNE      |L1.1710|
;;;709          }
;;;710          /* Post-loop cleanup: we must unload the final error value into the
;;;711           * final fserrors[] entry.  Note we need not unload belowerr because
;;;712           * it is for the dummy column before or after the actual array.
;;;713           */
;;;714          errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
000728  980b              LDR      r0,[sp,#0x2c]
00072a  b201              SXTH     r1,r0
00072c  980a              LDR      r0,[sp,#0x28]
00072e  8001              STRH     r1,[r0,#0]
000730  1c76              ADDS     r6,r6,#1              ;644
                  |L1.1842|
000732  9804              LDR      r0,[sp,#0x10]         ;644
000734  4286              CMP      r6,r0                 ;644
000736  db80              BLT      |L1.1594|
;;;715        }
;;;716        cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
000738  6d68              LDR      r0,[r5,#0x54]
00073a  b908              CBNZ     r0,|L1.1856|
00073c  2001              MOVS     r0,#1
00073e  e000              B        |L1.1858|
                  |L1.1856|
000740  2000              MOVS     r0,#0
                  |L1.1858|
000742  6568              STR      r0,[r5,#0x54]
000744  f10a0a01          ADD      r10,r10,#1            ;640
                  |L1.1864|
000748  9810              LDR      r0,[sp,#0x40]         ;640
00074a  4582              CMP      r10,r0                ;640
00074c  f6ffaf6d          BLT      |L1.1578|
;;;717      }
;;;718    }
000750  b011              ADD      sp,sp,#0x44
000752  e8bd8ff0          POP      {r4-r11,pc}
;;;719    
                          ENDP

                  alloc_fs_workspace PROC
;;;725    LOCAL(void)
;;;726    alloc_fs_workspace (j_decompress_ptr cinfo)
000756  e92d41f0          PUSH     {r4-r8,lr}
;;;727    {
00075a  4604              MOV      r4,r0
;;;728      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00075c  f8d471cc          LDR      r7,[r4,#0x1cc]
;;;729      size_t arraysize;
;;;730      int i;
;;;731    
;;;732      arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
000760  6f20              LDR      r0,[r4,#0x70]
000762  1c80              ADDS     r0,r0,#2
000764  0046              LSLS     r6,r0,#1
;;;733      for (i = 0; i < cinfo->out_color_components; i++) {
000766  2500              MOVS     r5,#0
000768  e00a              B        |L1.1920|
                  |L1.1898|
;;;734        cquantize->fserrors[i] = (FSERRPTR)
00076a  6860              LDR      r0,[r4,#4]
00076c  4632              MOV      r2,r6
00076e  2101              MOVS     r1,#1
000770  6843              LDR      r3,[r0,#4]
000772  4620              MOV      r0,r4
000774  4798              BLX      r3
000776  f1070144          ADD      r1,r7,#0x44
00077a  f8410025          STR      r0,[r1,r5,LSL #2]
00077e  1c6d              ADDS     r5,r5,#1              ;733
                  |L1.1920|
000780  6fa0              LDR      r0,[r4,#0x78]         ;733
000782  42a8              CMP      r0,r5                 ;733
000784  dcf1              BGT      |L1.1898|
;;;735          (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
;;;736      }
;;;737    }
000786  e8bd81f0          POP      {r4-r8,pc}
;;;738    
                          ENDP

                  start_pass_1_quant PROC
;;;744    METHODDEF(void)
;;;745    start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
00078a  e92d41f0          PUSH     {r4-r8,lr}
;;;746    {
00078e  4605              MOV      r5,r0
000790  460f              MOV      r7,r1
;;;747      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000792  3558              ADDS     r5,r5,#0x58
000794  f8d54174          LDR      r4,[r5,#0x174]
;;;748      size_t arraysize;
;;;749      int i;
;;;750    
;;;751      GUI_USE_PARA(is_pre_scan);
000798  bf00              NOP      
;;;752      /* Install my colormap. */
;;;753      cinfo->colormap = cquantize->sv_colormap;
00079a  6920              LDR      r0,[r4,#0x10]
00079c  6328              STR      r0,[r5,#0x30]
;;;754      cinfo->actual_number_of_colors = cquantize->sv_actual;
00079e  6960              LDR      r0,[r4,#0x14]
0007a0  62e8              STR      r0,[r5,#0x2c]
;;;755    
;;;756      /* Initialize for desired dithering mode. */
;;;757      switch (cinfo->dither_mode) {
0007a2  f8150958          LDRB     r0,[r5],#-0x58
0007a6  b120              CBZ      r0,|L1.1970|
0007a8  2801              CMP      r0,#1
0007aa  d00b              BEQ      |L1.1988|
0007ac  2802              CMP      r0,#2
0007ae  d139              BNE      |L1.2084|
0007b0  e01d              B        |L1.2030|
                  |L1.1970|
;;;758      case JDITHER_NONE:
;;;759        if (cinfo->out_color_components == 3)
0007b2  6fa8              LDR      r0,[r5,#0x78]
0007b4  2803              CMP      r0,#3
0007b6  d102              BNE      |L1.1982|
;;;760          cquantize->pub.color_quantize = color_quantize3;
0007b8  4845              LDR      r0,|L1.2256|
0007ba  6060              STR      r0,[r4,#4]
0007bc  e001              B        |L1.1986|
                  |L1.1982|
;;;761        else
;;;762          cquantize->pub.color_quantize = color_quantize;
0007be  4845              LDR      r0,|L1.2260|
0007c0  6060              STR      r0,[r4,#4]
                  |L1.1986|
;;;763        break;
0007c2  e037              B        |L1.2100|
                  |L1.1988|
;;;764      case JDITHER_ORDERED:
;;;765        if (cinfo->out_color_components == 3)
0007c4  6fa8              LDR      r0,[r5,#0x78]
0007c6  2803              CMP      r0,#3
0007c8  d102              BNE      |L1.2000|
;;;766          cquantize->pub.color_quantize = quantize3_ord_dither;
0007ca  4843              LDR      r0,|L1.2264|
0007cc  6060              STR      r0,[r4,#4]
0007ce  e001              B        |L1.2004|
                  |L1.2000|
;;;767        else
;;;768          cquantize->pub.color_quantize = quantize_ord_dither;
0007d0  4842              LDR      r0,|L1.2268|
0007d2  6060              STR      r0,[r4,#4]
                  |L1.2004|
;;;769        cquantize->row_index = 0;	/* initialize state for ordered dither */
0007d4  2000              MOVS     r0,#0
0007d6  6320              STR      r0,[r4,#0x30]
;;;770        /* If user changed to ordered dither from another mode,
;;;771         * we must recreate the color index table with padding.
;;;772         * This will cost extra space, but probably isn't very likely.
;;;773         */
;;;774        if (! cquantize->is_padded)
0007d8  69e0              LDR      r0,[r4,#0x1c]
0007da  b910              CBNZ     r0,|L1.2018|
;;;775          create_colorindex(cinfo);
0007dc  4628              MOV      r0,r5
0007de  f7fffffe          BL       create_colorindex
                  |L1.2018|
;;;776        /* Create ordered-dither tables if we didn't already. */
;;;777        if (cquantize->odither[0] == NULL)
0007e2  6b60              LDR      r0,[r4,#0x34]
0007e4  b910              CBNZ     r0,|L1.2028|
;;;778          create_odither_tables(cinfo);
0007e6  4628              MOV      r0,r5
0007e8  f7fffffe          BL       create_odither_tables
                  |L1.2028|
;;;779        break;
0007ec  e022              B        |L1.2100|
                  |L1.2030|
;;;780      case JDITHER_FS:
;;;781        cquantize->pub.color_quantize = quantize_fs_dither;
0007ee  483c              LDR      r0,|L1.2272|
0007f0  6060              STR      r0,[r4,#4]
;;;782        cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
0007f2  2000              MOVS     r0,#0
0007f4  6560              STR      r0,[r4,#0x54]
;;;783        /* Allocate Floyd-Steinberg workspace if didn't already. */
;;;784        if (cquantize->fserrors[0] == NULL)
0007f6  6c60              LDR      r0,[r4,#0x44]
0007f8  b910              CBNZ     r0,|L1.2048|
;;;785          alloc_fs_workspace(cinfo);
0007fa  4628              MOV      r0,r5
0007fc  f7fffffe          BL       alloc_fs_workspace
                  |L1.2048|
;;;786        /* Initialize the propagated errors to zero. */
;;;787        arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
000800  6f28              LDR      r0,[r5,#0x70]
000802  1c80              ADDS     r0,r0,#2
000804  ea4f0840          LSL      r8,r0,#1
;;;788        for (i = 0; i < cinfo->out_color_components; i++)
000808  2600              MOVS     r6,#0
00080a  e007              B        |L1.2076|
                  |L1.2060|
;;;789          jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
00080c  f1040144          ADD      r1,r4,#0x44
000810  f8510026          LDR      r0,[r1,r6,LSL #2]
000814  4641              MOV      r1,r8
000816  f7fffffe          BL       jzero_far
00081a  1c76              ADDS     r6,r6,#1              ;788
                  |L1.2076|
00081c  6fa8              LDR      r0,[r5,#0x78]         ;788
00081e  42b0              CMP      r0,r6                 ;788
000820  dcf4              BGT      |L1.2060|
;;;790        break;
000822  e007              B        |L1.2100|
                  |L1.2084|
;;;791      default:
;;;792        ERREXIT(cinfo, JERR_NOT_COMPILED);
000824  2030              MOVS     r0,#0x30
000826  6829              LDR      r1,[r5,#0]
000828  6148              STR      r0,[r1,#0x14]
00082a  6828              LDR      r0,[r5,#0]
00082c  6801              LDR      r1,[r0,#0]
00082e  4628              MOV      r0,r5
000830  4788              BLX      r1
;;;793        break;
000832  bf00              NOP      
                  |L1.2100|
000834  bf00              NOP                            ;763
;;;794      }
;;;795    }
000836  e8bd81f0          POP      {r4-r8,pc}
;;;796    
                          ENDP

                  finish_pass_1_quant PROC
;;;802    METHODDEF(void)
;;;803    finish_pass_1_quant (j_decompress_ptr cinfo)
00083a  bf00              NOP      
;;;804    {
;;;805      GUI_USE_PARA(cinfo);
;;;806      /* no work in 1-pass case */
;;;807    }
00083c  4770              BX       lr
;;;808    
                          ENDP

                  new_color_map_1_quant PROC
;;;815    METHODDEF(void)
;;;816    new_color_map_1_quant (j_decompress_ptr cinfo)
00083e  b510              PUSH     {r4,lr}
;;;817    {
000840  4604              MOV      r4,r0
;;;818      ERREXIT(cinfo, JERR_MODE_CHANGE);
000842  202e              MOVS     r0,#0x2e
000844  6821              LDR      r1,[r4,#0]
000846  6148              STR      r0,[r1,#0x14]
000848  6820              LDR      r0,[r4,#0]
00084a  6801              LDR      r1,[r0,#0]
00084c  4620              MOV      r0,r4
00084e  4788              BLX      r1
;;;819    }
000850  bd10              POP      {r4,pc}
;;;820    
                          ENDP

                  jinit_1pass_quantizer PROC
;;;826    GLOBAL(void)
;;;827    jinit_1pass_quantizer (j_decompress_ptr cinfo)
000852  b570              PUSH     {r4-r6,lr}
;;;828    {
000854  4604              MOV      r4,r0
;;;829      my_cquantize_ptr cquantize;
;;;830    
;;;831      cquantize = (my_cquantize_ptr)
000856  6860              LDR      r0,[r4,#4]
000858  2258              MOVS     r2,#0x58
00085a  2101              MOVS     r1,#1
00085c  6803              LDR      r3,[r0,#0]
00085e  4620              MOV      r0,r4
000860  4798              BLX      r3
000862  4605              MOV      r5,r0
;;;832        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;833    				SIZEOF(my_cquantizer));
;;;834      cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
000864  f8c451cc          STR      r5,[r4,#0x1cc]
;;;835      cquantize->pub.start_pass = start_pass_1_quant;
000868  481e              LDR      r0,|L1.2276|
00086a  6028              STR      r0,[r5,#0]
;;;836      cquantize->pub.finish_pass = finish_pass_1_quant;
00086c  481e              LDR      r0,|L1.2280|
00086e  60a8              STR      r0,[r5,#8]
;;;837      cquantize->pub.new_color_map = new_color_map_1_quant;
000870  481e              LDR      r0,|L1.2284|
000872  60e8              STR      r0,[r5,#0xc]
;;;838      cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
000874  2000              MOVS     r0,#0
000876  6468              STR      r0,[r5,#0x44]
;;;839      cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
000878  6368              STR      r0,[r5,#0x34]
;;;840    
;;;841      /* Make sure my internal arrays won't overflow */
;;;842      if (cinfo->out_color_components > MAX_Q_COMPS)
00087a  6fa0              LDR      r0,[r4,#0x78]
00087c  2804              CMP      r0,#4
00087e  dd09              BLE      |L1.2196|
;;;843        ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
000880  2037              MOVS     r0,#0x37
000882  6821              LDR      r1,[r4,#0]
000884  6148              STR      r0,[r1,#0x14]
000886  2004              MOVS     r0,#4
000888  6821              LDR      r1,[r4,#0]
00088a  6188              STR      r0,[r1,#0x18]
00088c  6820              LDR      r0,[r4,#0]
00088e  6801              LDR      r1,[r0,#0]
000890  4620              MOV      r0,r4
000892  4788              BLX      r1
                  |L1.2196|
;;;844      /* Make sure colormap indexes can be represented by JSAMPLEs */
;;;845      if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
000894  6e20              LDR      r0,[r4,#0x60]
000896  f5b07f80          CMP      r0,#0x100
00089a  dd0a              BLE      |L1.2226|
;;;846        ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);
00089c  2039              MOVS     r0,#0x39
00089e  6821              LDR      r1,[r4,#0]
0008a0  6148              STR      r0,[r1,#0x14]
0008a2  f44f7080          MOV      r0,#0x100
0008a6  6821              LDR      r1,[r4,#0]
0008a8  6188              STR      r0,[r1,#0x18]
0008aa  6820              LDR      r0,[r4,#0]
0008ac  6801              LDR      r1,[r0,#0]
0008ae  4620              MOV      r0,r4
0008b0  4788              BLX      r1
                  |L1.2226|
;;;847    
;;;848      /* Create the colormap and color index table. */
;;;849      create_colormap(cinfo);
0008b2  4620              MOV      r0,r4
0008b4  f7fffffe          BL       create_colormap
;;;850      create_colorindex(cinfo);
0008b8  4620              MOV      r0,r4
0008ba  f7fffffe          BL       create_colorindex
;;;851    
;;;852      /* Allocate Floyd-Steinberg workspace now if requested.
;;;853       * We do this now since it is FAR storage and may affect the memory
;;;854       * manager's space calculations.  If the user changes to FS dither
;;;855       * mode in a later pass, we will allocate the space then, and will
;;;856       * possibly overrun the max_memory_to_use setting.
;;;857       */
;;;858      if (cinfo->dither_mode == JDITHER_FS)
0008be  f8940058          LDRB     r0,[r4,#0x58]
0008c2  2802              CMP      r0,#2
0008c4  d102              BNE      |L1.2252|
;;;859        alloc_fs_workspace(cinfo);
0008c6  4620              MOV      r0,r4
0008c8  f7fffffe          BL       alloc_fs_workspace
                  |L1.2252|
;;;860    }
0008cc  bd70              POP      {r4-r6,pc}
;;;861    
                          ENDP

0008ce  0000              DCW      0x0000
                  |L1.2256|
                          DCD      color_quantize3
                  |L1.2260|
                          DCD      color_quantize
                  |L1.2264|
                          DCD      quantize3_ord_dither
                  |L1.2268|
                          DCD      quantize_ord_dither
                  |L1.2272|
                          DCD      quantize_fs_dither
                  |L1.2276|
                          DCD      start_pass_1_quant
                  |L1.2280|
                          DCD      finish_pass_1_quant
                  |L1.2284|
                          DCD      new_color_map_1_quant

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  base_dither_matrix
000000  00c030f0          DCB      0x00,0xc0,0x30,0xf0
000004  0ccc3cfc          DCB      0x0c,0xcc,0x3c,0xfc
000008  03c333f3          DCB      0x03,0xc3,0x33,0xf3
00000c  0fcf3fff          DCB      0x0f,0xcf,0x3f,0xff
000010  8040b070          DCB      0x80,0x40,0xb0,0x70
000014  8c4cbc7c          DCB      0x8c,0x4c,0xbc,0x7c
000018  8343b373          DCB      0x83,0x43,0xb3,0x73
00001c  8f4fbf7f          DCB      0x8f,0x4f,0xbf,0x7f
000020  20e010d0          DCB      0x20,0xe0,0x10,0xd0
000024  2cec1cdc          DCB      0x2c,0xec,0x1c,0xdc
000028  23e313d3          DCB      0x23,0xe3,0x13,0xd3
00002c  2fef1fdf          DCB      0x2f,0xef,0x1f,0xdf
000030  a0609050          DCB      0xa0,0x60,0x90,0x50
000034  ac6c9c5c          DCB      0xac,0x6c,0x9c,0x5c
000038  a3639353          DCB      0xa3,0x63,0x93,0x53
00003c  af6f9f5f          DCB      0xaf,0x6f,0x9f,0x5f
000040  08c838f8          DCB      0x08,0xc8,0x38,0xf8
000044  04c434f4          DCB      0x04,0xc4,0x34,0xf4
000048  0bcb3bfb          DCB      0x0b,0xcb,0x3b,0xfb
00004c  07c737f7          DCB      0x07,0xc7,0x37,0xf7
000050  8848b878          DCB      0x88,0x48,0xb8,0x78
000054  8444b474          DCB      0x84,0x44,0xb4,0x74
000058  8b4bbb7b          DCB      0x8b,0x4b,0xbb,0x7b
00005c  8747b777          DCB      0x87,0x47,0xb7,0x77
000060  28e818d8          DCB      0x28,0xe8,0x18,0xd8
000064  24e414d4          DCB      0x24,0xe4,0x14,0xd4
000068  2beb1bdb          DCB      0x2b,0xeb,0x1b,0xdb
00006c  27e717d7          DCB      0x27,0xe7,0x17,0xd7
000070  a8689858          DCB      0xa8,0x68,0x98,0x58
000074  a4649454          DCB      0xa4,0x64,0x94,0x54
000078  ab6b9b5b          DCB      0xab,0x6b,0x9b,0x5b
00007c  a7679757          DCB      0xa7,0x67,0x97,0x57
000080  02c232f2          DCB      0x02,0xc2,0x32,0xf2
000084  0ece3efe          DCB      0x0e,0xce,0x3e,0xfe
000088  01c131f1          DCB      0x01,0xc1,0x31,0xf1
00008c  0dcd3dfd          DCB      0x0d,0xcd,0x3d,0xfd
000090  8242b272          DCB      0x82,0x42,0xb2,0x72
000094  8e4ebe7e          DCB      0x8e,0x4e,0xbe,0x7e
000098  8141b171          DCB      0x81,0x41,0xb1,0x71
00009c  8d4dbd7d          DCB      0x8d,0x4d,0xbd,0x7d
0000a0  22e212d2          DCB      0x22,0xe2,0x12,0xd2
0000a4  2eee1ede          DCB      0x2e,0xee,0x1e,0xde
0000a8  21e111d1          DCB      0x21,0xe1,0x11,0xd1
0000ac  2ded1ddd          DCB      0x2d,0xed,0x1d,0xdd
0000b0  a2629252          DCB      0xa2,0x62,0x92,0x52
0000b4  ae6e9e5e          DCB      0xae,0x6e,0x9e,0x5e
0000b8  a1619151          DCB      0xa1,0x61,0x91,0x51
0000bc  ad6d9d5d          DCB      0xad,0x6d,0x9d,0x5d
0000c0  0aca3afa          DCB      0x0a,0xca,0x3a,0xfa
0000c4  06c636f6          DCB      0x06,0xc6,0x36,0xf6
0000c8  09c939f9          DCB      0x09,0xc9,0x39,0xf9
0000cc  05c535f5          DCB      0x05,0xc5,0x35,0xf5
0000d0  8a4aba7a          DCB      0x8a,0x4a,0xba,0x7a
0000d4  8646b676          DCB      0x86,0x46,0xb6,0x76
0000d8  8949b979          DCB      0x89,0x49,0xb9,0x79
0000dc  8545b575          DCB      0x85,0x45,0xb5,0x75
0000e0  2aea1ada          DCB      0x2a,0xea,0x1a,0xda
0000e4  26e616d6          DCB      0x26,0xe6,0x16,0xd6
0000e8  29e919d9          DCB      0x29,0xe9,0x19,0xd9
0000ec  25e515d5          DCB      0x25,0xe5,0x15,0xd5
0000f0  aa6a9a5a          DCB      0xaa,0x6a,0x9a,0x5a
0000f4  a6669656          DCB      0xa6,0x66,0x96,0x56
0000f8  a9699959          DCB      0xa9,0x69,0x99,0x59
0000fc  a5659555          DCB      0xa5,0x65,0x95,0x55
                  RGB_order
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000002
