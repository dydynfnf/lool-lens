; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\gui_jpeg.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\gui_jpeg.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\gui_jpeg.crf GUI\JPEG\GUI_JPEG.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _InitSource PROC
;;;61     
;;;62     static void _InitSource (j_decompress_ptr cinfo) {
000000  6981              LDR      r1,[r0,#0x18]
;;;63       SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
;;;64     
;;;65       /* We reset the empty-input-file flag for each image,
;;;66        * but we don't clear the input buffer.
;;;67        * This is correct behavior for reading a series of images from one source.
;;;68        */
;;;69       pSrc->start_of_file = TRUE;
000002  2201              MOVS     r2,#1
000004  628a              STR      r2,[r1,#0x28]
;;;70     }
000006  4770              BX       lr
;;;71     
                          ENDP

                  _FillInputBuffer PROC
;;;104    
;;;105    static boolean _FillInputBuffer(j_decompress_ptr cinfo) {
000008  e92d41f0          PUSH     {r4-r8,lr}
00000c  4605              MOV      r5,r0
;;;106      SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
00000e  69ac              LDR      r4,[r5,#0x18]
;;;107      size_t nbytes;
;;;108      int RemBytes = pSrc->FileSize - pSrc->Off;
000010  e9d40108          LDRD     r0,r1,[r4,#0x20]
000014  1a47              SUBS     r7,r0,r1
;;;109      if (RemBytes > 0) {
000016  2f00              CMP      r7,#0
000018  dd0f              BLE      |L1.58|
;;;110        nbytes = (RemBytes > INPUT_BUF_SIZE) ? INPUT_BUF_SIZE : RemBytes;
00001a  f5b75f80          CMP      r7,#0x1000
00001e  dd02              BLE      |L1.38|
000020  f44f5080          MOV      r0,#0x1000
000024  e000              B        |L1.40|
                  |L1.38|
000026  4638              MOV      r0,r7
                  |L1.40|
000028  4606              MOV      r6,r0
;;;111        pSrc->pub.next_input_byte = pSrc->pFileData + pSrc->Off;
00002a  6a61              LDR      r1,[r4,#0x24]
00002c  69e0              LDR      r0,[r4,#0x1c]
00002e  4408              ADD      r0,r0,r1
000030  6020              STR      r0,[r4,#0]
;;;112        pSrc->Off += nbytes;
000032  6a60              LDR      r0,[r4,#0x24]
000034  4430              ADD      r0,r0,r6
000036  6260              STR      r0,[r4,#0x24]
000038  e014              B        |L1.100|
                  |L1.58|
;;;113      } else {
;;;114        if (pSrc->start_of_file)	/* Treat empty input file as fatal error */
00003a  6aa0              LDR      r0,[r4,#0x28]
00003c  b130              CBZ      r0,|L1.76|
;;;115          ERREXIT(cinfo, JERR_INPUT_EMPTY);
00003e  202a              MOVS     r0,#0x2a
000040  6829              LDR      r1,[r5,#0]
000042  6148              STR      r0,[r1,#0x14]
000044  6828              LDR      r0,[r5,#0]
000046  6801              LDR      r1,[r0,#0]
000048  4628              MOV      r0,r5
00004a  4788              BLX      r1
                  |L1.76|
;;;116        WARNMS(cinfo, JWRN_JPEG_EOF);
00004c  2078              MOVS     r0,#0x78
00004e  6829              LDR      r1,[r5,#0]
000050  6148              STR      r0,[r1,#0x14]
000052  6828              LDR      r0,[r5,#0]
000054  f04f31ff          MOV      r1,#0xffffffff
000058  6842              LDR      r2,[r0,#4]
00005a  4628              MOV      r0,r5
00005c  4790              BLX      r2
;;;117        /* Insert a fake EOI marker */
;;;118        nbytes = 2;
00005e  2602              MOVS     r6,#2
;;;119        pSrc->pub.next_input_byte = _abEnd;
000060  48a8              LDR      r0,|L1.772|
000062  6020              STR      r0,[r4,#0]
                  |L1.100|
;;;120      }
;;;121    
;;;122      pSrc->pub.bytes_in_buffer = nbytes;
000064  6066              STR      r6,[r4,#4]
;;;123      pSrc->start_of_file = FALSE;
000066  2000              MOVS     r0,#0
000068  62a0              STR      r0,[r4,#0x28]
;;;124      return TRUE;
00006a  2001              MOVS     r0,#1
;;;125    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;126    
                          ENDP

                  _SkipInputData PROC
;;;138    
;;;139    static void _SkipInputData (j_decompress_ptr cinfo, long num_bytes) {
000070  b570              PUSH     {r4-r6,lr}
000072  4606              MOV      r6,r0
000074  460c              MOV      r4,r1
;;;140      SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
000076  69b5              LDR      r5,[r6,#0x18]
;;;141      /* Just a dumb implementation for now.  Could use fseek() except
;;;142       * it doesn't work on pipes.  Not clear that being smart is worth
;;;143       * any trouble anyway --- large skips are infrequent.
;;;144       */
;;;145      if (num_bytes > 0) {
000078  2c00              CMP      r4,#0
00007a  dd0e              BLE      |L1.154|
;;;146        while (num_bytes > (long) pSrc->pub.bytes_in_buffer) {
00007c  e004              B        |L1.136|
                  |L1.126|
;;;147          num_bytes -= (long) pSrc->pub.bytes_in_buffer;
00007e  6868              LDR      r0,[r5,#4]
000080  1a24              SUBS     r4,r4,r0
;;;148          (void) _FillInputBuffer(cinfo);
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       _FillInputBuffer
                  |L1.136|
000088  6868              LDR      r0,[r5,#4]            ;146
00008a  42a0              CMP      r0,r4                 ;146
00008c  dbf7              BLT      |L1.126|
;;;149          /* note we assume that fill_input_buffer will never return FALSE,
;;;150           * so suspension need not be handled.
;;;151           */
;;;152        }
;;;153        pSrc->pub.next_input_byte += (size_t) num_bytes;
00008e  6828              LDR      r0,[r5,#0]
000090  4420              ADD      r0,r0,r4
000092  6028              STR      r0,[r5,#0]
;;;154        pSrc->pub.bytes_in_buffer -= (size_t) num_bytes;
000094  6868              LDR      r0,[r5,#4]
000096  1b00              SUBS     r0,r0,r4
000098  6068              STR      r0,[r5,#4]
                  |L1.154|
;;;155      }
;;;156    }
00009a  bd70              POP      {r4-r6,pc}
;;;157    /*
                          ENDP

                  _TermSource PROC
;;;174    
;;;175    static void _TermSource(j_decompress_ptr cinfo) {
00009c  bf00              NOP      
;;;176      /* no work necessary here */
;;;177      GUI_USE_PARA(cinfo);
;;;178    }
00009e  4770              BX       lr
;;;179    
                          ENDP

                  _InitSrc PROC
;;;180    
;;;181    static void _InitSrc(j_decompress_ptr cinfo, const U8* pFileData, I32 FileSize) {
0000a0  e92d41f0          PUSH     {r4-r8,lr}
0000a4  4605              MOV      r5,r0
0000a6  460e              MOV      r6,r1
0000a8  4617              MOV      r7,r2
;;;182      SOURCE_MANAGER* pSrc;
;;;183      /* The source object and input buffer are made permanent so that a series
;;;184       * of JPEG images can be read from the same file by calling jpeg_stdio_src
;;;185       * only before the first one.  (If we discarded the buffer at the end of
;;;186       * one image, we'd likely lose the start of the next one.)
;;;187       * This makes it unsafe to use this manager and a different source
;;;188       * manager serially with the same JPEG object.  Caveat programmer.
;;;189       */
;;;190      if (cinfo->src == NULL) {	/* first time for this JPEG object? */
0000aa  69a8              LDR      r0,[r5,#0x18]
0000ac  b930              CBNZ     r0,|L1.188|
;;;191        cinfo->src = (jpeg_source_mgr *) (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT, sizeof(SOURCE_MANAGER));
0000ae  6868              LDR      r0,[r5,#4]
0000b0  222c              MOVS     r2,#0x2c
0000b2  2100              MOVS     r1,#0
0000b4  6803              LDR      r3,[r0,#0]
0000b6  4628              MOV      r0,r5
0000b8  4798              BLX      r3
0000ba  61a8              STR      r0,[r5,#0x18]
                  |L1.188|
;;;192      }
;;;193      pSrc = (SOURCE_MANAGER*) cinfo->src;
0000bc  69ac              LDR      r4,[r5,#0x18]
;;;194      pSrc->pub.init_source       = _InitSource;
0000be  4892              LDR      r0,|L1.776|
0000c0  60a0              STR      r0,[r4,#8]
;;;195      pSrc->pub.fill_input_buffer = _FillInputBuffer;
0000c2  4892              LDR      r0,|L1.780|
0000c4  60e0              STR      r0,[r4,#0xc]
;;;196      pSrc->pub.skip_input_data   = _SkipInputData;
0000c6  4892              LDR      r0,|L1.784|
0000c8  6120              STR      r0,[r4,#0x10]
;;;197      pSrc->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
0000ca  4892              LDR      r0,|L1.788|
0000cc  6160              STR      r0,[r4,#0x14]
;;;198      pSrc->pub.term_source       = _TermSource;
0000ce  4892              LDR      r0,|L1.792|
0000d0  61a0              STR      r0,[r4,#0x18]
;;;199      pSrc->pub.bytes_in_buffer   = 0;    /* forces fill_input_buffer on first read */
0000d2  2000              MOVS     r0,#0
0000d4  6060              STR      r0,[r4,#4]
;;;200      pSrc->pub.next_input_byte   = NULL; /* until buffer loaded */
0000d6  6020              STR      r0,[r4,#0]
;;;201      /*
;;;202       *  Init private part of Source manager
;;;203       */
;;;204      pSrc->FileSize  = FileSize;
0000d8  6227              STR      r7,[r4,#0x20]
;;;205      pSrc->pFileData = pFileData;
0000da  61e6              STR      r6,[r4,#0x1c]
;;;206      pSrc->Off       = 0;
0000dc  6260              STR      r0,[r4,#0x24]
;;;207    }
0000de  e8bd81f0          POP      {r4-r8,pc}
;;;208    
                          ENDP

                  jpeg_get_small PROC
;;;223    
;;;224    GLOBAL(void *) jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject) {
0000e2  b570              PUSH     {r4-r6,lr}
0000e4  4605              MOV      r5,r0
0000e6  460c              MOV      r4,r1
;;;225      GUI_USE_PARA(cinfo);
0000e8  bf00              NOP      
;;;226      AllocCnt++;
0000ea  488c              LDR      r0,|L1.796|
0000ec  6800              LDR      r0,[r0,#0]  ; AllocCnt
0000ee  1c40              ADDS     r0,r0,#1
0000f0  498a              LDR      r1,|L1.796|
0000f2  6008              STR      r0,[r1,#0]  ; AllocCnt
;;;227      TotalSize += sizeofobject;
0000f4  488a              LDR      r0,|L1.800|
0000f6  6800              LDR      r0,[r0,#0]  ; TotalSize
0000f8  4420              ADD      r0,r0,r4
0000fa  4989              LDR      r1,|L1.800|
0000fc  6008              STR      r0,[r1,#0]  ; TotalSize
;;;228      return (void *) malloc(sizeofobject);
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       malloc
;;;229    }
000104  bd70              POP      {r4-r6,pc}
;;;230    
                          ENDP

                  jpeg_free_small PROC
;;;231    GLOBAL(void) jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject) {
000106  b570              PUSH     {r4-r6,lr}
000108  4604              MOV      r4,r0
00010a  460d              MOV      r5,r1
00010c  4616              MOV      r6,r2
;;;232      GUI_USE_PARA(cinfo);
00010e  bf00              NOP      
;;;233      GUI_USE_PARA(sizeofobject);
000110  bf00              NOP      
;;;234      if (--AllocCnt) {
000112  4882              LDR      r0,|L1.796|
000114  6800              LDR      r0,[r0,#0]  ; AllocCnt
000116  1e40              SUBS     r0,r0,#1
000118  4980              LDR      r1,|L1.796|
00011a  6008              STR      r0,[r1,#0]  ; AllocCnt
00011c  b110              CBZ      r0,|L1.292|
;;;235        TotalSize = 0;
00011e  2000              MOVS     r0,#0
000120  497f              LDR      r1,|L1.800|
000122  6008              STR      r0,[r1,#0]  ; TotalSize
                  |L1.292|
;;;236      }
;;;237      free(object);
000124  4628              MOV      r0,r5
000126  f7fffffe          BL       free
;;;238    }
00012a  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP

                  jpeg_mem_available PROC
;;;244    
;;;245    GLOBAL(long) jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed, long max_bytes_needed, long already_allocated) {
00012c  b510              PUSH     {r4,lr}
00012e  4604              MOV      r4,r0
;;;246      GUI_USE_PARA(cinfo);
000130  bf00              NOP      
;;;247      GUI_USE_PARA(min_bytes_needed);
000132  bf00              NOP      
;;;248      GUI_USE_PARA(already_allocated);
000134  bf00              NOP      
;;;249      return max_bytes_needed;
000136  4610              MOV      r0,r2
;;;250    }
000138  bd10              POP      {r4,pc}
;;;251    
                          ENDP

                  jpeg_mem_init PROC
;;;258    
;;;259    GLOBAL(long) jpeg_mem_init (j_common_ptr cinfo) { 
00013a  4601              MOV      r1,r0
;;;260      GUI_USE_PARA(cinfo);
00013c  bf00              NOP      
;;;261      return 0;
00013e  2000              MOVS     r0,#0
;;;262    }
000140  4770              BX       lr
;;;263    
                          ENDP

                  jpeg_mem_term PROC
;;;264    GLOBAL(void) jpeg_mem_term (j_common_ptr cinfo) {
000142  bf00              NOP      
;;;265      GUI_USE_PARA(cinfo);
;;;266    }
000144  4770              BX       lr
;;;267    
                          ENDP

                  _Init PROC
;;;285    */
;;;286    static void _Init(struct jpeg_error_mgr* pjerr, struct jpeg_decompress_struct *pcinfo, const void * pFileData, int DataSize) {
000146  e92d41f0          PUSH     {r4-r8,lr}
00014a  4607              MOV      r7,r0
00014c  460c              MOV      r4,r1
00014e  4615              MOV      r5,r2
000150  461e              MOV      r6,r3
;;;287      /* 1. Allocate and initialize a JPEG decompression object. */
;;;288      pcinfo->err = jpeg_std_error(pjerr);
000152  4638              MOV      r0,r7
000154  f7fffffe          BL       jpeg_std_error
000158  6020              STR      r0,[r4,#0]
;;;289    	jpeg_create_decompress(pcinfo);
00015a  f44f72e8          MOV      r2,#0x1d0
00015e  213e              MOVS     r1,#0x3e
000160  4620              MOV      r0,r4
000162  f7fffffe          BL       jpeg_CreateDecompress
;;;290      /* 2. Init the source manager so the library can retrieve data via methods */
;;;291      _InitSrc(pcinfo, (const U8*)pFileData, DataSize);
000166  4632              MOV      r2,r6
000168  4629              MOV      r1,r5
00016a  4620              MOV      r0,r4
00016c  f7fffffe          BL       _InitSrc
;;;292      /* 3. Call jpeg_read_header() to obtain image info. */
;;;293    	jpeg_read_header(pcinfo, TRUE);
000170  2101              MOVS     r1,#1
000172  4620              MOV      r0,r4
000174  f7fffffe          BL       jpeg_read_header
;;;294    }
000178  e8bd81f0          POP      {r4-r8,pc}
;;;295    
                          ENDP

                  _WritePixelsRGB PROC
;;;299    */
;;;300    static void _WritePixelsRGB(const U8*p, int x0, int y0, int xSize) {
00017c  e92d47f0          PUSH     {r4-r10,lr}
000180  4604              MOV      r4,r0
000182  460e              MOV      r6,r1
000184  4617              MOV      r7,r2
000186  461d              MOV      r5,r3
;;;301      U8 r,g,b;
;;;302      while (xSize) {
000188  e011              B        |L1.430|
                  |L1.394|
;;;303        r = *p++;
00018a  f8148b01          LDRB     r8,[r4],#1
;;;304        g = *p++;
00018e  f8149b01          LDRB     r9,[r4],#1
;;;305        b = *p++;
000192  f814ab01          LDRB     r10,[r4],#1
;;;306        LCD_SetColor(r | (g << 8) | (U32)((U32)b << 16));
000196  ea482109          ORR      r1,r8,r9,LSL #8
00019a  ea41400a          ORR      r0,r1,r10,LSL #16
00019e  f7fffffe          BL       LCD_SetColor
;;;307        LCD_DrawPixel(x0++, y0);
0001a2  4630              MOV      r0,r6
0001a4  1c76              ADDS     r6,r6,#1
0001a6  4639              MOV      r1,r7
0001a8  f7fffffe          BL       LCD_DrawPixel
;;;308        xSize--;
0001ac  1e6d              SUBS     r5,r5,#1
                  |L1.430|
0001ae  2d00              CMP      r5,#0                 ;302
0001b0  d1eb              BNE      |L1.394|
;;;309      }
;;;310    }
0001b2  e8bd87f0          POP      {r4-r10,pc}
;;;311    
                          ENDP

                  _WritePixelsGray PROC
;;;315    */
;;;316    static void _WritePixelsGray(const U8*p, int x0, int y0, int xSize) {
0001b6  e92d41f0          PUSH     {r4-r8,lr}
0001ba  4604              MOV      r4,r0
0001bc  460e              MOV      r6,r1
0001be  4617              MOV      r7,r2
0001c0  461d              MOV      r5,r3
;;;317      U8 u;
;;;318      while (xSize) {
0001c2  e00d              B        |L1.480|
                  |L1.452|
;;;319        u = *p++;
0001c4  f8148b01          LDRB     r8,[r4],#1
;;;320        LCD_SetColor(u * (U32)0x10101);
0001c8  eb082108          ADD      r1,r8,r8,LSL #8
0001cc  eb014008          ADD      r0,r1,r8,LSL #16
0001d0  f7fffffe          BL       LCD_SetColor
;;;321        LCD_DrawPixel(x0++, y0);
0001d4  4630              MOV      r0,r6
0001d6  1c76              ADDS     r6,r6,#1
0001d8  4639              MOV      r1,r7
0001da  f7fffffe          BL       LCD_DrawPixel
;;;322        xSize--;
0001de  1e6d              SUBS     r5,r5,#1
                  |L1.480|
0001e0  2d00              CMP      r5,#0                 ;318
0001e2  d1ef              BNE      |L1.452|
;;;323      }
;;;324    }
0001e4  e8bd81f0          POP      {r4-r8,pc}
;;;325    
                          ENDP

                  GUI_JPEG_GetInfo PROC
;;;335    */
;;;336    int GUI_JPEG_GetInfo(const void * pFileData, int DataSize, GUI_JPEG_INFO* pInfo) {
0001e8  b570              PUSH     {r4-r6,lr}
0001ea  f5ad7d16          SUB      sp,sp,#0x258
0001ee  4605              MOV      r5,r0
0001f0  460e              MOV      r6,r1
0001f2  4614              MOV      r4,r2
;;;337    	struct jpeg_decompress_struct cinfo;
;;;338    	struct jpeg_error_mgr jerr;
;;;339      _Init(&jerr, &cinfo, pFileData, DataSize);
0001f4  4633              MOV      r3,r6
0001f6  462a              MOV      r2,r5
0001f8  a922              ADD      r1,sp,#0x88
0001fa  a801              ADD      r0,sp,#4
0001fc  f7fffffe          BL       _Init
;;;340      /*
;;;341       * Release the JPEG decompression object.
;;;342       */
;;;343      jpeg_destroy_decompress(&cinfo);
000200  a822              ADD      r0,sp,#0x88
000202  f7fffffe          BL       jpeg_destroy_decompress
;;;344      if (pInfo) {
000206  b11c              CBZ      r4,|L1.528|
;;;345        pInfo->XSize = cinfo.image_width;
000208  9829              LDR      r0,[sp,#0xa4]
00020a  6020              STR      r0,[r4,#0]
;;;346        pInfo->YSize = cinfo.image_height;
00020c  982a              LDR      r0,[sp,#0xa8]
00020e  6060              STR      r0,[r4,#4]
                  |L1.528|
;;;347      }
;;;348      return 0;
000210  2000              MOVS     r0,#0
;;;349    }
000212  f50d7d16          ADD      sp,sp,#0x258
000216  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP

                  GUI_JPEG_Draw PROC
;;;355    */
;;;356    int GUI_JPEG_Draw(const void * pFileData, int DataSize, int x0, int y0) {
000218  e92d43f0          PUSH     {r4-r9,lr}
00021c  f5ad7d19          SUB      sp,sp,#0x264
000220  4607              MOV      r7,r0
000222  4688              MOV      r8,r1
000224  4615              MOV      r5,r2
000226  461c              MOV      r4,r3
;;;357      #if (GUI_WINSUPPORT)
;;;358        GUI_RECT r;
;;;359      #endif
;;;360      int Ret = 0;
000228  f04f0900          MOV      r9,#0
;;;361      GUI_HMEM hBuffer = 0;
00022c  2600              MOVS     r6,#0
;;;362    	struct jpeg_decompress_struct cinfo;
;;;363    	struct jpeg_error_mgr jerr;
;;;364      GUI_LOCK();
;;;365      _Init(&jerr, &cinfo, pFileData, DataSize);
00022e  4643              MOV      r3,r8
000230  463a              MOV      r2,r7
000232  a922              ADD      r1,sp,#0x88
000234  a801              ADD      r0,sp,#4
000236  f7fffffe          BL       _Init
;;;366      #if (GUI_WINSUPPORT)
;;;367        WM_ADDORG(x0,y0);
00023a  483a              LDR      r0,|L1.804|
00023c  6c00              LDR      r0,[r0,#0x40]  ; GUI_Context
00023e  4405              ADD      r5,r5,r0
000240  4838              LDR      r0,|L1.804|
000242  6c40              LDR      r0,[r0,#0x44]  ; GUI_Context
000244  4404              ADD      r4,r4,r0
;;;368        r.x1 = (r.x0 = x0) + cinfo.image_width - 1;
000246  b228              SXTH     r0,r5
000248  f8ad0258          STRH     r0,[sp,#0x258]
00024c  9929              LDR      r1,[sp,#0xa4]
00024e  4408              ADD      r0,r0,r1
000250  1e40              SUBS     r0,r0,#1
000252  b200              SXTH     r0,r0
000254  f8ad025c          STRH     r0,[sp,#0x25c]
;;;369        r.y1 = (r.y0 = y0) + cinfo.image_height - 1;
000258  b220              SXTH     r0,r4
00025a  f8ad025a          STRH     r0,[sp,#0x25a]
00025e  992a              LDR      r1,[sp,#0xa8]
000260  4408              ADD      r0,r0,r1
000262  1e40              SUBS     r0,r0,#1
000264  b200              SXTH     r0,r0
000266  f8ad025e          STRH     r0,[sp,#0x25e]
;;;370        WM_ITERATE_START(&r) {
00026a  a896              ADD      r0,sp,#0x258
00026c  f7fffffe          BL       WM__InitIVRSearch
000270  2800              CMP      r0,#0
000272  d03e              BEQ      |L1.754|
000274  bf00              NOP      
                  |L1.630|
;;;371      #endif
;;;372        if (hBuffer) {
000276  b12e              CBZ      r6,|L1.644|
;;;373          _Init(&jerr, &cinfo, pFileData, DataSize);
000278  4643              MOV      r3,r8
00027a  463a              MOV      r2,r7
00027c  a922              ADD      r1,sp,#0x88
00027e  a801              ADD      r0,sp,#4
000280  f7fffffe          BL       _Init
                  |L1.644|
;;;374        }
;;;375        /* 4. Set up parameters for decompression (optional ...) */
;;;376        /* 5. jpeg_start_decompress(...); Should normally return quickly */
;;;377    	  jpeg_start_decompress(&cinfo);
000284  a822              ADD      r0,sp,#0x88
000286  f7fffffe          BL       jpeg_start_decompress
;;;378        /* 6. while (scan lines remain to be read) */
;;;379    	  /*     jpeg_read_scanlines(...); */
;;;380        if (!hBuffer) {
00028a  b936              CBNZ     r6,|L1.666|
;;;381          hBuffer = GUI_ALLOC_AllocNoInit(cinfo.image_width * 3);
00028c  9929              LDR      r1,[sp,#0xa4]
00028e  eb010141          ADD      r1,r1,r1,LSL #1
000292  b208              SXTH     r0,r1
000294  f7fffffe          BL       GUI_ALLOC_AllocNoInit
000298  4606              MOV      r6,r0
                  |L1.666|
;;;382        }
;;;383        while (cinfo.output_scanline < cinfo.output_height) {
00029a  e01c              B        |L1.726|
                  |L1.668|
;;;384          U8* p;
;;;385          p = (U8*)GUI_ALLOC_h2p(hBuffer);
00029c  4630              MOV      r0,r6
00029e  f7fffffe          BL       GUI_ALLOC_h2p
0002a2  9000              STR      r0,[sp,#0]
;;;386          jpeg_read_scanlines(&cinfo, &p, 1);
0002a4  2201              MOVS     r2,#1
0002a6  4669              MOV      r1,sp
0002a8  a822              ADD      r0,sp,#0x88
0002aa  f7fffffe          BL       jpeg_read_scanlines
;;;387          if (cinfo.jpeg_color_space == JCS_GRAYSCALE) {
0002ae  f89d00b0          LDRB     r0,[sp,#0xb0]
0002b2  2801              CMP      r0,#1
0002b4  d107              BNE      |L1.710|
;;;388            _WritePixelsGray(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
0002b6  9845              LDR      r0,[sp,#0x114]
0002b8  1902              ADDS     r2,r0,r4
0002ba  4629              MOV      r1,r5
0002bc  9b29              LDR      r3,[sp,#0xa4]
0002be  9800              LDR      r0,[sp,#0]
0002c0  f7fffffe          BL       _WritePixelsGray
0002c4  e006              B        |L1.724|
                  |L1.710|
;;;389          } else {
;;;390            _WritePixelsRGB(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
0002c6  9845              LDR      r0,[sp,#0x114]
0002c8  1902              ADDS     r2,r0,r4
0002ca  4629              MOV      r1,r5
0002cc  9b29              LDR      r3,[sp,#0xa4]
0002ce  9800              LDR      r0,[sp,#0]
0002d0  f7fffffe          BL       _WritePixelsRGB
                  |L1.724|
;;;391          }
;;;392        }
0002d4  bf00              NOP      
                  |L1.726|
0002d6  993f              LDR      r1,[sp,#0xfc]         ;383
0002d8  9845              LDR      r0,[sp,#0x114]        ;383
0002da  4288              CMP      r0,r1                 ;383
0002dc  d3de              BCC      |L1.668|
;;;393        /* 7. jpeg_finish_decompress(...); */
;;;394        /*    Complete the decompression cycle.  This causes working memory associated */
;;;395        /*    with the JPEG object to be released. */
;;;396    	  jpeg_finish_decompress(&cinfo);
0002de  a822              ADD      r0,sp,#0x88
0002e0  f7fffffe          BL       jpeg_finish_decompress
;;;397        /* 8. Release the JPEG decompression object. */
;;;398        jpeg_destroy_decompress(&cinfo);
0002e4  a822              ADD      r0,sp,#0x88
0002e6  f7fffffe          BL       jpeg_destroy_decompress
;;;399      #if (GUI_WINSUPPORT)
;;;400        } WM_ITERATE_END();
0002ea  f7fffffe          BL       WM__GetNextIVR
0002ee  2800              CMP      r0,#0
0002f0  d1c1              BNE      |L1.630|
                  |L1.754|
;;;401      #endif
;;;402      GUI_ALLOC_Free(hBuffer);
0002f2  4630              MOV      r0,r6
0002f4  f7fffffe          BL       GUI_ALLOC_Free
;;;403      GUI_UNLOCK();
;;;404      return Ret;
0002f8  4648              MOV      r0,r9
;;;405    }
0002fa  f50d7d19          ADD      sp,sp,#0x264
0002fe  e8bd83f0          POP      {r4-r9,pc}
;;;406    
                          ENDP

000302  0000              DCW      0x0000
                  |L1.772|
                          DCD      _abEnd
                  |L1.776|
                          DCD      _InitSource
                  |L1.780|
                          DCD      _FillInputBuffer
                  |L1.784|
                          DCD      _SkipInputData
                  |L1.788|
                          DCD      jpeg_resync_to_restart
                  |L1.792|
                          DCD      _TermSource
                  |L1.796|
                          DCD      AllocCnt
                  |L1.800|
                          DCD      TotalSize
                  |L1.804|
                          DCD      GUI_Context

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _abEnd
000000  ffd9              DCB      0xff,0xd9

                          AREA ||.data||, DATA, ALIGN=2

                  AllocCnt
                          DCD      0x00000000
                  TotalSize
                          DCD      0x00000000
