; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdmaster.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdmaster.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdmaster.crf GUI\JPEG\jdmaster.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  use_merged_upsample PROC
;;;43     LOCAL(boolean)
;;;44     use_merged_upsample (j_decompress_ptr cinfo)
000000  4601              MOV      r1,r0
;;;45     {
;;;46     #ifdef UPSAMPLE_MERGING_SUPPORTED
;;;47       /* Merging is the equivalent of plain box-filter upsampling */
;;;48       if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
000002  6cc8              LDR      r0,[r1,#0x4c]
000004  b910              CBNZ     r0,|L1.12|
000006  f8d1012c          LDR      r0,[r1,#0x12c]
00000a  b108              CBZ      r0,|L1.16|
                  |L1.12|
;;;49         return FALSE;
00000c  2000              MOVS     r0,#0
                  |L1.14|
;;;50       /* jdmerge.c only supports YCC=>RGB color conversion */
;;;51       if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
;;;52           cinfo->out_color_space != JCS_RGB ||
;;;53           cinfo->out_color_components != RGB_PIXELSIZE)
;;;54         return FALSE;
;;;55       /* and it only handles 2h1v or 2h2v sampling ratios */
;;;56       if (cinfo->comp_info[0].h_samp_factor != 2 ||
;;;57           cinfo->comp_info[1].h_samp_factor != 1 ||
;;;58           cinfo->comp_info[2].h_samp_factor != 1 ||
;;;59           cinfo->comp_info[0].v_samp_factor >  2 ||
;;;60           cinfo->comp_info[1].v_samp_factor != 1 ||
;;;61           cinfo->comp_info[2].v_samp_factor != 1)
;;;62         return FALSE;
;;;63       /* furthermore, it doesn't work if we've scaled the IDCTs differently */
;;;64       if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
;;;65           cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
;;;66           cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)
;;;67         return FALSE;
;;;68       /* ??? also need to test for upsample-time rescaling, when & if supported */
;;;69       return TRUE;			/* by golly, it'll work... */
;;;70     #else
;;;71       return FALSE;
;;;72     #endif
;;;73     }
00000e  4770              BX       lr
                  |L1.16|
000010  f8910028          LDRB     r0,[r1,#0x28]         ;51
000014  2803              CMP      r0,#3                 ;51
000016  d109              BNE      |L1.44|
000018  6a48              LDR      r0,[r1,#0x24]         ;51
00001a  2803              CMP      r0,#3                 ;51
00001c  d106              BNE      |L1.44|
00001e  f8910029          LDRB     r0,[r1,#0x29]         ;52
000022  2802              CMP      r0,#2                 ;52
000024  d102              BNE      |L1.44|
000026  6f88              LDR      r0,[r1,#0x78]         ;53
000028  2803              CMP      r0,#3                 ;53
00002a  d001              BEQ      |L1.48|
                  |L1.44|
00002c  2000              MOVS     r0,#0                 ;54
00002e  e7ee              B        |L1.14|
                  |L1.48|
000030  f8d100d8          LDR      r0,[r1,#0xd8]         ;56
000034  6880              LDR      r0,[r0,#8]            ;56
000036  2802              CMP      r0,#2                 ;56
000038  d11a              BNE      |L1.112|
00003a  f8d100d8          LDR      r0,[r1,#0xd8]         ;57
00003e  6dc0              LDR      r0,[r0,#0x5c]         ;57
000040  2801              CMP      r0,#1                 ;57
000042  d115              BNE      |L1.112|
000044  f8d100d8          LDR      r0,[r1,#0xd8]         ;58
000048  f8d000b0          LDR      r0,[r0,#0xb0]         ;58
00004c  2801              CMP      r0,#1                 ;58
00004e  d10f              BNE      |L1.112|
000050  f8d100d8          LDR      r0,[r1,#0xd8]         ;59
000054  68c0              LDR      r0,[r0,#0xc]          ;59
000056  2802              CMP      r0,#2                 ;59
000058  dc0a              BGT      |L1.112|
00005a  f8d100d8          LDR      r0,[r1,#0xd8]         ;60
00005e  6e00              LDR      r0,[r0,#0x60]         ;60
000060  2801              CMP      r0,#1                 ;60
000062  d105              BNE      |L1.112|
000064  f8d100d8          LDR      r0,[r1,#0xd8]         ;61
000068  f8d000b4          LDR      r0,[r0,#0xb4]         ;61
00006c  2801              CMP      r0,#1                 ;61
00006e  d001              BEQ      |L1.116|
                  |L1.112|
000070  2000              MOVS     r0,#0                 ;62
000072  e7cc              B        |L1.14|
                  |L1.116|
000074  f8d100d8          LDR      r0,[r1,#0xd8]         ;64
000078  6a40              LDR      r0,[r0,#0x24]         ;64
00007a  f8d1213c          LDR      r2,[r1,#0x13c]        ;64
00007e  4290              CMP      r0,r2                 ;64
000080  d10e              BNE      |L1.160|
000082  f8d100d8          LDR      r0,[r1,#0xd8]         ;65
000086  6f80              LDR      r0,[r0,#0x78]         ;65
000088  f8d1213c          LDR      r2,[r1,#0x13c]        ;65
00008c  4290              CMP      r0,r2                 ;65
00008e  d107              BNE      |L1.160|
000090  f8d100d8          LDR      r0,[r1,#0xd8]         ;66
000094  f8d000cc          LDR      r0,[r0,#0xcc]         ;66
000098  f8d1213c          LDR      r2,[r1,#0x13c]        ;66
00009c  4290              CMP      r0,r2                 ;66
00009e  d001              BEQ      |L1.164|
                  |L1.160|
0000a0  2000              MOVS     r0,#0                 ;67
0000a2  e7b4              B        |L1.14|
                  |L1.164|
0000a4  2001              MOVS     r0,#1                 ;69
0000a6  e7b2              B        |L1.14|
;;;74     
                          ENDP

                  jpeg_calc_output_dimensions PROC
;;;83     GLOBAL(void)
;;;84     jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
0000a8  b510              PUSH     {r4,lr}
;;;85     /* Do computations that are needed before master selection phase */
;;;86     {
0000aa  4604              MOV      r4,r0
;;;87     #ifdef IDCT_SCALING_SUPPORTED
;;;88       int ci;
;;;89       jpeg_component_info *compptr;
;;;90     #endif
;;;91     
;;;92       /* Prevent application from calling me at wrong times */
;;;93       if (cinfo->global_state != DSTATE_READY)
0000ac  6960              LDR      r0,[r4,#0x14]
0000ae  28ca              CMP      r0,#0xca
0000b0  d009              BEQ      |L1.198|
;;;94         ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
0000b2  2014              MOVS     r0,#0x14
0000b4  6821              LDR      r1,[r4,#0]
0000b6  6148              STR      r0,[r1,#0x14]
0000b8  6821              LDR      r1,[r4,#0]
0000ba  6960              LDR      r0,[r4,#0x14]
0000bc  6188              STR      r0,[r1,#0x18]
0000be  6820              LDR      r0,[r4,#0]
0000c0  6801              LDR      r1,[r0,#0]
0000c2  4620              MOV      r0,r4
0000c4  4788              BLX      r1
                  |L1.198|
;;;95     
;;;96     #ifdef IDCT_SCALING_SUPPORTED
;;;97     
;;;98       /* Compute actual output image dimensions and DCT scaling choices. */
;;;99       if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
;;;100        /* Provide 1/8 scaling */
;;;101        cinfo->output_width = (JDIMENSION)
;;;102          jdiv_round_up((long) cinfo->image_width, 8L);
;;;103        cinfo->output_height = (JDIMENSION)
;;;104          jdiv_round_up((long) cinfo->image_height, 8L);
;;;105        cinfo->min_DCT_scaled_size = 1;
;;;106      } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
;;;107        /* Provide 1/4 scaling */
;;;108        cinfo->output_width = (JDIMENSION)
;;;109          jdiv_round_up((long) cinfo->image_width, 4L);
;;;110        cinfo->output_height = (JDIMENSION)
;;;111          jdiv_round_up((long) cinfo->image_height, 4L);
;;;112        cinfo->min_DCT_scaled_size = 2;
;;;113      } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
;;;114        /* Provide 1/2 scaling */
;;;115        cinfo->output_width = (JDIMENSION)
;;;116          jdiv_round_up((long) cinfo->image_width, 2L);
;;;117        cinfo->output_height = (JDIMENSION)
;;;118          jdiv_round_up((long) cinfo->image_height, 2L);
;;;119        cinfo->min_DCT_scaled_size = 4;
;;;120      } else {
;;;121        /* Provide 1/1 scaling */
;;;122        cinfo->output_width = cinfo->image_width;
;;;123        cinfo->output_height = cinfo->image_height;
;;;124        cinfo->min_DCT_scaled_size = DCTSIZE;
;;;125      }
;;;126      /* In selecting the actual DCT scaling for each component, we try to
;;;127       * scale up the chroma components via IDCT scaling rather than upsampling.
;;;128       * This saves time if the upsampler gets to use 1:1 scaling.
;;;129       * Note this code assumes that the supported DCT scalings are powers of 2.
;;;130       */
;;;131      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;132           ci++, compptr++) {
;;;133        int ssize = cinfo->min_DCT_scaled_size;
;;;134        while (ssize < DCTSIZE &&
;;;135    	   (compptr->h_samp_factor * ssize * 2 <=
;;;136    	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
;;;137    	   (compptr->v_samp_factor * ssize * 2 <=
;;;138    	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
;;;139          ssize = ssize * 2;
;;;140        }
;;;141        compptr->DCT_scaled_size = ssize;
;;;142      }
;;;143    
;;;144      /* Recompute downsampled dimensions of components;
;;;145       * application needs to know these if using raw downsampled data.
;;;146       */
;;;147      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;148           ci++, compptr++) {
;;;149        /* Size in samples, after IDCT scaling */
;;;150        compptr->downsampled_width = (JDIMENSION)
;;;151          jdiv_round_up((long) cinfo->image_width *
;;;152    		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
;;;153    		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
;;;154        compptr->downsampled_height = (JDIMENSION)
;;;155          jdiv_round_up((long) cinfo->image_height *
;;;156    		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
;;;157    		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
;;;158      }
;;;159    
;;;160    #else /* !IDCT_SCALING_SUPPORTED */
;;;161    
;;;162      /* Hardwire it to "no scaling" */
;;;163      cinfo->output_width = cinfo->image_width;
0000c6  69e0              LDR      r0,[r4,#0x1c]
0000c8  6720              STR      r0,[r4,#0x70]
;;;164      cinfo->output_height = cinfo->image_height;
0000ca  6a20              LDR      r0,[r4,#0x20]
0000cc  6760              STR      r0,[r4,#0x74]
;;;165      /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,
;;;166       * and has computed unscaled downsampled_width and downsampled_height.
;;;167       */
;;;168    
;;;169    #endif /* IDCT_SCALING_SUPPORTED */
;;;170    
;;;171      /* Report number of components in selected colorspace. */
;;;172      /* Probably this should be in the color conversion module... */
;;;173      switch (cinfo->out_color_space) {
0000ce  f8940029          LDRB     r0,[r4,#0x29]
0000d2  2806              CMP      r0,#6
0000d4  d20f              BCS      |L1.246|
0000d6  e8dff000          TBB      [pc,r0]
0000da  0e03              DCB      0x0e,0x03
0000dc  06070a0b          DCB      0x06,0x07,0x0a,0x0b
;;;174      case JCS_GRAYSCALE:
;;;175        cinfo->out_color_components = 1;
0000e0  2001              MOVS     r0,#1
0000e2  67a0              STR      r0,[r4,#0x78]
;;;176        break;
0000e4  e00a              B        |L1.252|
;;;177      case JCS_RGB:
;;;178    #if RGB_PIXELSIZE != 3
;;;179        cinfo->out_color_components = RGB_PIXELSIZE;
;;;180        break;
;;;181    #endif /* else share code with YCbCr */
;;;182      case JCS_YCbCr:
0000e6  bf00              NOP      
;;;183        cinfo->out_color_components = 3;
0000e8  2003              MOVS     r0,#3
0000ea  67a0              STR      r0,[r4,#0x78]
;;;184        break;
0000ec  e006              B        |L1.252|
;;;185      case JCS_CMYK:
;;;186      case JCS_YCCK:
0000ee  bf00              NOP      
;;;187        cinfo->out_color_components = 4;
0000f0  2004              MOVS     r0,#4
0000f2  67a0              STR      r0,[r4,#0x78]
;;;188        break;
0000f4  e002              B        |L1.252|
                  |L1.246|
;;;189      default:			/* else must be same colorspace as in file */
;;;190        cinfo->out_color_components = cinfo->num_components;
0000f6  6a60              LDR      r0,[r4,#0x24]
0000f8  67a0              STR      r0,[r4,#0x78]
;;;191        break;
0000fa  bf00              NOP      
                  |L1.252|
0000fc  bf00              NOP                            ;176
;;;192      }
;;;193      cinfo->output_components = (cinfo->quantize_colors ? 1 :
0000fe  6d60              LDR      r0,[r4,#0x54]
000100  b108              CBZ      r0,|L1.262|
000102  2001              MOVS     r0,#1
000104  e000              B        |L1.264|
                  |L1.262|
;;;194    			      cinfo->out_color_components);
000106  6fa0              LDR      r0,[r4,#0x78]
                  |L1.264|
000108  67e0              STR      r0,[r4,#0x7c]
;;;195    
;;;196      /* See if upsampler will want to emit more than one row at a time */
;;;197      if (use_merged_upsample(cinfo))
00010a  4620              MOV      r0,r4
00010c  f7fffffe          BL       use_merged_upsample
000110  b120              CBZ      r0,|L1.284|
;;;198        cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
000112  f8d40138          LDR      r0,[r4,#0x138]
000116  f8c40080          STR      r0,[r4,#0x80]
00011a  e002              B        |L1.290|
                  |L1.284|
;;;199      else
;;;200        cinfo->rec_outbuf_height = 1;
00011c  2001              MOVS     r0,#1
00011e  f8c40080          STR      r0,[r4,#0x80]
                  |L1.290|
;;;201    }
000122  bd10              POP      {r4,pc}
;;;202    
                          ENDP

                  prepare_range_limit_table PROC
;;;247    LOCAL(void)
;;;248    prepare_range_limit_table (j_decompress_ptr cinfo)
000124  b570              PUSH     {r4-r6,lr}
;;;249    /* Allocate and fill in the sample_range_limit table */
;;;250    {
000126  4606              MOV      r6,r0
;;;251      JSAMPLE * table;
;;;252      int i;
;;;253    
;;;254      table = (JSAMPLE *)
000128  6870              LDR      r0,[r6,#4]
00012a  f44f62b0          MOV      r2,#0x580
00012e  2101              MOVS     r1,#1
000130  6803              LDR      r3,[r0,#0]
000132  4630              MOV      r0,r6
000134  4798              BLX      r3
000136  4604              MOV      r4,r0
;;;255        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;256    		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
;;;257      table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
000138  f5047480          ADD      r4,r4,#0x100
;;;258      cinfo->sample_range_limit = table;
00013c  f8c64144          STR      r4,[r6,#0x144]
;;;259      /* First segment of "simple" table: limit[x] = 0 for x < 0 */
;;;260      MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
000140  f5a47080          SUB      r0,r4,#0x100
000144  f44f7180          MOV      r1,#0x100
000148  f7fffffe          BL       __aeabi_memclr
;;;261      /* Main part of "simple" table: limit[x] = x */
;;;262      for (i = 0; i <= MAXJSAMPLE; i++)
00014c  2500              MOVS     r5,#0
00014e  e001              B        |L1.340|
                  |L1.336|
;;;263        table[i] = (JSAMPLE) i;
000150  5565              STRB     r5,[r4,r5]
000152  1c6d              ADDS     r5,r5,#1              ;262
                  |L1.340|
000154  2dff              CMP      r5,#0xff              ;262
000156  ddfb              BLE      |L1.336|
;;;264      table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
000158  3480              ADDS     r4,r4,#0x80
;;;265      /* End of simple table, rest of first half of post-IDCT table */
;;;266      for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
00015a  2580              MOVS     r5,#0x80
00015c  e002              B        |L1.356|
                  |L1.350|
;;;267        table[i] = MAXJSAMPLE;
00015e  20ff              MOVS     r0,#0xff
000160  5560              STRB     r0,[r4,r5]
000162  1c6d              ADDS     r5,r5,#1              ;266
                  |L1.356|
000164  f5b57f00          CMP      r5,#0x200             ;266
000168  dbf9              BLT      |L1.350|
;;;268      /* Second half of post-IDCT table */
;;;269      MEMZERO(table + (2 * (MAXJSAMPLE+1)),
00016a  f44f71c0          MOV      r1,#0x180
00016e  f5047000          ADD      r0,r4,#0x200
000172  f7fffffe          BL       __aeabi_memclr
;;;270    	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
;;;271      MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
000176  2280              MOVS     r2,#0x80
000178  f5047060          ADD      r0,r4,#0x380
00017c  f8d61144          LDR      r1,[r6,#0x144]
000180  f7fffffe          BL       __aeabi_memcpy
;;;272    	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
;;;273    }
000184  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP

                  master_selection PROC
;;;287    LOCAL(void)
;;;288    master_selection (j_decompress_ptr cinfo)
000186  e92d41f0          PUSH     {r4-r8,lr}
;;;289    {
00018a  4604              MOV      r4,r0
;;;290      my_master_ptr master = (my_master_ptr) cinfo->master;
00018c  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;291      boolean use_c_buffer;
;;;292      long samplesperrow;
;;;293      JDIMENSION jd_samplesperrow;
;;;294    
;;;295      /* Initialize dimensions and other stuff */
;;;296      jpeg_calc_output_dimensions(cinfo);
000190  4620              MOV      r0,r4
000192  f7fffffe          BL       jpeg_calc_output_dimensions
;;;297      prepare_range_limit_table(cinfo);
000196  4620              MOV      r0,r4
000198  f7fffffe          BL       prepare_range_limit_table
;;;298    
;;;299      /* Width of an output scanline must be representable as JDIMENSION. */
;;;300      samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
00019c  6fa1              LDR      r1,[r4,#0x78]
00019e  6f20              LDR      r0,[r4,#0x70]
0001a0  fb00f601          MUL      r6,r0,r1
;;;301      jd_samplesperrow = (JDIMENSION) samplesperrow;
0001a4  4637              MOV      r7,r6
;;;302      if ((long) jd_samplesperrow != samplesperrow)
0001a6  42b7              CMP      r7,r6
0001a8  d006              BEQ      |L1.440|
;;;303        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
0001aa  2046              MOVS     r0,#0x46
0001ac  6821              LDR      r1,[r4,#0]
0001ae  6148              STR      r0,[r1,#0x14]
0001b0  6820              LDR      r0,[r4,#0]
0001b2  6801              LDR      r1,[r0,#0]
0001b4  4620              MOV      r0,r4
0001b6  4788              BLX      r1
                  |L1.440|
;;;304    
;;;305      /* Initialize my private state */
;;;306      master->pass_number = 0;
0001b8  2000              MOVS     r0,#0
0001ba  60e8              STR      r0,[r5,#0xc]
;;;307      master->using_merged_upsample = use_merged_upsample(cinfo);
0001bc  4620              MOV      r0,r4
0001be  f7fffffe          BL       use_merged_upsample
0001c2  6128              STR      r0,[r5,#0x10]
;;;308    
;;;309      /* Color quantizer selection */
;;;310      master->quantizer_1pass = NULL;
0001c4  2000              MOVS     r0,#0
0001c6  6168              STR      r0,[r5,#0x14]
;;;311      master->quantizer_2pass = NULL;
0001c8  61a8              STR      r0,[r5,#0x18]
;;;312      /* No mode changes if not using buffered-image mode. */
;;;313      if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
0001ca  6d60              LDR      r0,[r4,#0x54]
0001cc  b108              CBZ      r0,|L1.466|
0001ce  6c20              LDR      r0,[r4,#0x40]
0001d0  b918              CBNZ     r0,|L1.474|
                  |L1.466|
;;;314        cinfo->enable_1pass_quant = FALSE;
0001d2  2000              MOVS     r0,#0
0001d4  6660              STR      r0,[r4,#0x64]
;;;315        cinfo->enable_external_quant = FALSE;
0001d6  66a0              STR      r0,[r4,#0x68]
;;;316        cinfo->enable_2pass_quant = FALSE;
0001d8  66e0              STR      r0,[r4,#0x6c]
                  |L1.474|
;;;317      }
;;;318      if (cinfo->quantize_colors) {
0001da  6d60              LDR      r0,[r4,#0x54]
0001dc  2800              CMP      r0,#0
0001de  d032              BEQ      |L1.582|
;;;319        if (cinfo->raw_data_out)
0001e0  6c60              LDR      r0,[r4,#0x44]
0001e2  b130              CBZ      r0,|L1.498|
;;;320          ERREXIT(cinfo, JERR_NOTIMPL);
0001e4  202f              MOVS     r0,#0x2f
0001e6  6821              LDR      r1,[r4,#0]
0001e8  6148              STR      r0,[r1,#0x14]
0001ea  6820              LDR      r0,[r4,#0]
0001ec  6801              LDR      r1,[r0,#0]
0001ee  4620              MOV      r0,r4
0001f0  4788              BLX      r1
                  |L1.498|
;;;321        /* 2-pass quantizer only works in 3-component color space. */
;;;322        if (cinfo->out_color_components != 3) {
0001f2  6fa0              LDR      r0,[r4,#0x78]
0001f4  2803              CMP      r0,#3
0001f6  d007              BEQ      |L1.520|
;;;323          cinfo->enable_1pass_quant = TRUE;
0001f8  2001              MOVS     r0,#1
0001fa  6660              STR      r0,[r4,#0x64]
;;;324          cinfo->enable_external_quant = FALSE;
0001fc  2000              MOVS     r0,#0
0001fe  66a0              STR      r0,[r4,#0x68]
;;;325          cinfo->enable_2pass_quant = FALSE;
000200  66e0              STR      r0,[r4,#0x6c]
;;;326          cinfo->colormap = NULL;
000202  f8c40088          STR      r0,[r4,#0x88]
000206  e00c              B        |L1.546|
                  |L1.520|
;;;327        } else if (cinfo->colormap != NULL) {
000208  f8d40088          LDR      r0,[r4,#0x88]
00020c  b110              CBZ      r0,|L1.532|
;;;328          cinfo->enable_external_quant = TRUE;
00020e  2001              MOVS     r0,#1
000210  66a0              STR      r0,[r4,#0x68]
000212  e006              B        |L1.546|
                  |L1.532|
;;;329        } else if (cinfo->two_pass_quantize) {
000214  6de0              LDR      r0,[r4,#0x5c]
000216  b110              CBZ      r0,|L1.542|
;;;330          cinfo->enable_2pass_quant = TRUE;
000218  2001              MOVS     r0,#1
00021a  66e0              STR      r0,[r4,#0x6c]
00021c  e001              B        |L1.546|
                  |L1.542|
;;;331        } else {
;;;332          cinfo->enable_1pass_quant = TRUE;
00021e  2001              MOVS     r0,#1
000220  6660              STR      r0,[r4,#0x64]
                  |L1.546|
;;;333        }
;;;334    
;;;335        if (cinfo->enable_1pass_quant) {
000222  6e60              LDR      r0,[r4,#0x64]
000224  b128              CBZ      r0,|L1.562|
;;;336    #ifdef QUANT_1PASS_SUPPORTED
;;;337          jinit_1pass_quantizer(cinfo);
000226  4620              MOV      r0,r4
000228  f7fffffe          BL       jinit_1pass_quantizer
;;;338          master->quantizer_1pass = cinfo->cquantize;
00022c  f8d401cc          LDR      r0,[r4,#0x1cc]
000230  6168              STR      r0,[r5,#0x14]
                  |L1.562|
;;;339    #else
;;;340          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;341    #endif
;;;342        }
;;;343    
;;;344        /* We use the 2-pass code to map to external colormaps. */
;;;345        if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
000232  6ee0              LDR      r0,[r4,#0x6c]
000234  b908              CBNZ     r0,|L1.570|
000236  6ea0              LDR      r0,[r4,#0x68]
000238  b128              CBZ      r0,|L1.582|
                  |L1.570|
;;;346    #ifdef QUANT_2PASS_SUPPORTED
;;;347          jinit_2pass_quantizer(cinfo);
00023a  4620              MOV      r0,r4
00023c  f7fffffe          BL       jinit_2pass_quantizer
;;;348          master->quantizer_2pass = cinfo->cquantize;
000240  f8d401cc          LDR      r0,[r4,#0x1cc]
000244  61a8              STR      r0,[r5,#0x18]
                  |L1.582|
;;;349    #else
;;;350          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;351    #endif
;;;352        }
;;;353        /* If both quantizers are initialized, the 2-pass one is left active;
;;;354         * this is necessary for starting with quantization to an external map.
;;;355         */
;;;356      }
;;;357    
;;;358      /* Post-processing: in particular, color conversion first */
;;;359      if (! cinfo->raw_data_out) {
000246  6c60              LDR      r0,[r4,#0x44]
000248  b978              CBNZ     r0,|L1.618|
;;;360        if (master->using_merged_upsample) {
00024a  6928              LDR      r0,[r5,#0x10]
00024c  b118              CBZ      r0,|L1.598|
;;;361    #ifdef UPSAMPLE_MERGING_SUPPORTED
;;;362          jinit_merged_upsampler(cinfo); /* does color conversion too */
00024e  4620              MOV      r0,r4
000250  f7fffffe          BL       jinit_merged_upsampler
000254  e005              B        |L1.610|
                  |L1.598|
;;;363    #else
;;;364          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;365    #endif
;;;366        } else {
;;;367          jinit_color_deconverter(cinfo);
000256  4620              MOV      r0,r4
000258  f7fffffe          BL       jinit_color_deconverter
;;;368          jinit_upsampler(cinfo);
00025c  4620              MOV      r0,r4
00025e  f7fffffe          BL       jinit_upsampler
                  |L1.610|
;;;369        }
;;;370        jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
000262  4620              MOV      r0,r4
000264  6ee1              LDR      r1,[r4,#0x6c]
000266  f7fffffe          BL       jinit_d_post_controller
                  |L1.618|
;;;371      }
;;;372      /* Inverse DCT */
;;;373      jinit_inverse_dct(cinfo);
00026a  4620              MOV      r0,r4
00026c  f7fffffe          BL       jinit_inverse_dct
;;;374      /* Entropy decoding: either Huffman or arithmetic coding. */
;;;375      if (cinfo->arith_code) {
000270  f8d400e0          LDR      r0,[r4,#0xe0]
000274  b138              CBZ      r0,|L1.646|
;;;376        ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
000276  2001              MOVS     r0,#1
000278  6821              LDR      r1,[r4,#0]
00027a  6148              STR      r0,[r1,#0x14]
00027c  6820              LDR      r0,[r4,#0]
00027e  6801              LDR      r1,[r0,#0]
000280  4620              MOV      r0,r4
000282  4788              BLX      r1
000284  e009              B        |L1.666|
                  |L1.646|
;;;377      } else {
;;;378        if (cinfo->progressive_mode) {
000286  f8d400dc          LDR      r0,[r4,#0xdc]
00028a  b118              CBZ      r0,|L1.660|
;;;379    #ifdef D_PROGRESSIVE_SUPPORTED
;;;380          jinit_phuff_decoder(cinfo);
00028c  4620              MOV      r0,r4
00028e  f7fffffe          BL       jinit_phuff_decoder
000292  e002              B        |L1.666|
                  |L1.660|
;;;381    #else
;;;382          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;383    #endif
;;;384        } else
;;;385          jinit_huff_decoder(cinfo);
000294  4620              MOV      r0,r4
000296  f7fffffe          BL       jinit_huff_decoder
                  |L1.666|
;;;386      }
;;;387    
;;;388      /* Initialize principal buffer controllers. */
;;;389      use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
00029a  f8d401b4          LDR      r0,[r4,#0x1b4]
00029e  6900              LDR      r0,[r0,#0x10]
0002a0  b908              CBNZ     r0,|L1.678|
0002a2  6c20              LDR      r0,[r4,#0x40]
0002a4  b108              CBZ      r0,|L1.682|
                  |L1.678|
0002a6  2001              MOVS     r0,#1
0002a8  e000              B        |L1.684|
                  |L1.682|
0002aa  2000              MOVS     r0,#0
                  |L1.684|
0002ac  4680              MOV      r8,r0
;;;390      jinit_d_coef_controller(cinfo, use_c_buffer);
0002ae  4641              MOV      r1,r8
0002b0  4620              MOV      r0,r4
0002b2  f7fffffe          BL       jinit_d_coef_controller
;;;391    
;;;392      if (! cinfo->raw_data_out)
0002b6  6c60              LDR      r0,[r4,#0x44]
0002b8  b918              CBNZ     r0,|L1.706|
;;;393        jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
0002ba  2100              MOVS     r1,#0
0002bc  4620              MOV      r0,r4
0002be  f7fffffe          BL       jinit_d_main_controller
                  |L1.706|
;;;394    
;;;395      /* We can now tell the memory manager to allocate virtual arrays. */
;;;396      (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
0002c2  6860              LDR      r0,[r4,#4]
0002c4  6981              LDR      r1,[r0,#0x18]
0002c6  4620              MOV      r0,r4
0002c8  4788              BLX      r1
;;;397    
;;;398      /* Initialize input side of decompressor to consume first scan. */
;;;399      (*cinfo->inputctl->start_input_pass) (cinfo);
0002ca  f8d401b4          LDR      r0,[r4,#0x1b4]
0002ce  6881              LDR      r1,[r0,#8]
0002d0  4620              MOV      r0,r4
0002d2  4788              BLX      r1
;;;400    
;;;401    #ifdef D_MULTISCAN_FILES_SUPPORTED
;;;402      /* If jpeg_start_decompress will read the whole file, initialize
;;;403       * progress monitoring appropriately.  The input step is counted
;;;404       * as one pass.
;;;405       */
;;;406      if (cinfo->progress != NULL && ! cinfo->buffered_image &&
0002d4  68a0              LDR      r0,[r4,#8]
0002d6  b320              CBZ      r0,|L1.802|
0002d8  6c20              LDR      r0,[r4,#0x40]
0002da  bb10              CBNZ     r0,|L1.802|
;;;407          cinfo->inputctl->has_multiple_scans) {
0002dc  f8d401b4          LDR      r0,[r4,#0x1b4]
0002e0  6900              LDR      r0,[r0,#0x10]
0002e2  b1f0              CBZ      r0,|L1.802|
;;;408        int nscans;
;;;409        /* Estimate number of scans to set pass_limit. */
;;;410        if (cinfo->progressive_mode) {
0002e4  f8d410dc          LDR      r1,[r4,#0xdc]
0002e8  b121              CBZ      r1,|L1.756|
;;;411          /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
;;;412          nscans = 2 + 3 * cinfo->num_components;
0002ea  6a61              LDR      r1,[r4,#0x24]
0002ec  eb010141          ADD      r1,r1,r1,LSL #1
0002f0  1c88              ADDS     r0,r1,#2
0002f2  e000              B        |L1.758|
                  |L1.756|
;;;413        } else {
;;;414          /* For a nonprogressive multiscan file, estimate 1 scan per component. */
;;;415          nscans = cinfo->num_components;
0002f4  6a60              LDR      r0,[r4,#0x24]
                  |L1.758|
;;;416        }
;;;417        cinfo->progress->pass_counter = 0L;
0002f6  2100              MOVS     r1,#0
0002f8  68a2              LDR      r2,[r4,#8]
0002fa  6051              STR      r1,[r2,#4]
;;;418        cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
0002fc  f8d41140          LDR      r1,[r4,#0x140]
000300  4341              MULS     r1,r0,r1
000302  68a2              LDR      r2,[r4,#8]
000304  6091              STR      r1,[r2,#8]
;;;419        cinfo->progress->completed_passes = 0;
000306  2100              MOVS     r1,#0
000308  68a2              LDR      r2,[r4,#8]
00030a  60d1              STR      r1,[r2,#0xc]
;;;420        cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
00030c  6ee1              LDR      r1,[r4,#0x6c]
00030e  b109              CBZ      r1,|L1.788|
000310  2103              MOVS     r1,#3
000312  e000              B        |L1.790|
                  |L1.788|
000314  2102              MOVS     r1,#2
                  |L1.790|
000316  68a2              LDR      r2,[r4,#8]
000318  6111              STR      r1,[r2,#0x10]
;;;421        /* Count the input pass as done */
;;;422        master->pass_number++;
00031a  68e9              LDR      r1,[r5,#0xc]
00031c  1c49              ADDS     r1,r1,#1
00031e  60e9              STR      r1,[r5,#0xc]
;;;423      }
000320  bf00              NOP      
                  |L1.802|
;;;424    #endif /* D_MULTISCAN_FILES_SUPPORTED */
;;;425    }
000322  e8bd81f0          POP      {r4-r8,pc}
;;;426    
                          ENDP

                  prepare_for_output_pass PROC
;;;437    METHODDEF(void)
;;;438    prepare_for_output_pass (j_decompress_ptr cinfo)
000326  b570              PUSH     {r4-r6,lr}
;;;439    {
000328  4604              MOV      r4,r0
;;;440      my_master_ptr master = (my_master_ptr) cinfo->master;
00032a  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;441    
;;;442      if (master->pub.is_dummy_pass) {
00032e  68a8              LDR      r0,[r5,#8]
000330  b1a0              CBZ      r0,|L1.860|
;;;443    #ifdef QUANT_2PASS_SUPPORTED
;;;444        /* Final pass of 2-pass quantization */
;;;445        master->pub.is_dummy_pass = FALSE;
000332  2000              MOVS     r0,#0
000334  60a8              STR      r0,[r5,#8]
;;;446        (*cinfo->cquantize->start_pass) (cinfo, FALSE);
000336  f8d401cc          LDR      r0,[r4,#0x1cc]
00033a  2100              MOVS     r1,#0
00033c  6802              LDR      r2,[r0,#0]
00033e  4620              MOV      r0,r4
000340  4790              BLX      r2
;;;447        (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
000342  f8d401b0          LDR      r0,[r4,#0x1b0]
000346  2102              MOVS     r1,#2
000348  6802              LDR      r2,[r0,#0]
00034a  4620              MOV      r0,r4
00034c  4790              BLX      r2
;;;448        (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
00034e  f8d401a8          LDR      r0,[r4,#0x1a8]
000352  2102              MOVS     r1,#2
000354  6802              LDR      r2,[r0,#0]
000356  4620              MOV      r0,r4
000358  4790              BLX      r2
00035a  e04c              B        |L1.1014|
                  |L1.860|
;;;449    #else
;;;450        ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;451    #endif /* QUANT_2PASS_SUPPORTED */
;;;452      } else {
;;;453        if (cinfo->quantize_colors && cinfo->colormap == NULL) {
00035c  6d60              LDR      r0,[r4,#0x54]
00035e  b1c8              CBZ      r0,|L1.916|
000360  f8d40088          LDR      r0,[r4,#0x88]
000364  b9b0              CBNZ     r0,|L1.916|
;;;454          /* Select new quantization method */
;;;455          if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
000366  6de0              LDR      r0,[r4,#0x5c]
000368  b138              CBZ      r0,|L1.890|
00036a  6ee0              LDR      r0,[r4,#0x6c]
00036c  b128              CBZ      r0,|L1.890|
;;;456    	cinfo->cquantize = master->quantizer_2pass;
00036e  69a8              LDR      r0,[r5,#0x18]
000370  f8c401cc          STR      r0,[r4,#0x1cc]
;;;457    	master->pub.is_dummy_pass = TRUE;
000374  2001              MOVS     r0,#1
000376  60a8              STR      r0,[r5,#8]
000378  e00c              B        |L1.916|
                  |L1.890|
;;;458          } else if (cinfo->enable_1pass_quant) {
00037a  6e60              LDR      r0,[r4,#0x64]
00037c  b118              CBZ      r0,|L1.902|
;;;459    	cinfo->cquantize = master->quantizer_1pass;
00037e  6968              LDR      r0,[r5,#0x14]
000380  f8c401cc          STR      r0,[r4,#0x1cc]
000384  e006              B        |L1.916|
                  |L1.902|
;;;460          } else {
;;;461    	ERREXIT(cinfo, JERR_MODE_CHANGE);
000386  202e              MOVS     r0,#0x2e
000388  6821              LDR      r1,[r4,#0]
00038a  6148              STR      r0,[r1,#0x14]
00038c  6820              LDR      r0,[r4,#0]
00038e  6801              LDR      r1,[r0,#0]
000390  4620              MOV      r0,r4
000392  4788              BLX      r1
                  |L1.916|
;;;462          }
;;;463        }
;;;464        (*cinfo->idct->start_pass) (cinfo);
000394  f8d401c0          LDR      r0,[r4,#0x1c0]
000398  6801              LDR      r1,[r0,#0]
00039a  4620              MOV      r0,r4
00039c  4788              BLX      r1
;;;465        (*cinfo->coef->start_output_pass) (cinfo);
00039e  f8d401ac          LDR      r0,[r4,#0x1ac]
0003a2  6881              LDR      r1,[r0,#8]
0003a4  4620              MOV      r0,r4
0003a6  4788              BLX      r1
;;;466        if (! cinfo->raw_data_out) {
0003a8  6c60              LDR      r0,[r4,#0x44]
0003aa  bb20              CBNZ     r0,|L1.1014|
;;;467          if (! master->using_merged_upsample)
0003ac  6928              LDR      r0,[r5,#0x10]
0003ae  b920              CBNZ     r0,|L1.954|
;;;468    	(*cinfo->cconvert->start_pass) (cinfo);
0003b0  f8d401c8          LDR      r0,[r4,#0x1c8]
0003b4  6801              LDR      r1,[r0,#0]
0003b6  4620              MOV      r0,r4
0003b8  4788              BLX      r1
                  |L1.954|
;;;469          (*cinfo->upsample->start_pass) (cinfo);
0003ba  f8d401c4          LDR      r0,[r4,#0x1c4]
0003be  6801              LDR      r1,[r0,#0]
0003c0  4620              MOV      r0,r4
0003c2  4788              BLX      r1
;;;470          if (cinfo->quantize_colors)
0003c4  6d60              LDR      r0,[r4,#0x54]
0003c6  b128              CBZ      r0,|L1.980|
;;;471    	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
0003c8  68a9              LDR      r1,[r5,#8]
0003ca  f8d401cc          LDR      r0,[r4,#0x1cc]
0003ce  6802              LDR      r2,[r0,#0]
0003d0  4620              MOV      r0,r4
0003d2  4790              BLX      r2
                  |L1.980|
;;;472          (*cinfo->post->start_pass) (cinfo,
0003d4  68a8              LDR      r0,[r5,#8]
0003d6  b108              CBZ      r0,|L1.988|
;;;473    	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
0003d8  2003              MOVS     r0,#3
0003da  e000              B        |L1.990|
                  |L1.988|
0003dc  2000              MOVS     r0,#0
                  |L1.990|
0003de  4601              MOV      r1,r0
0003e0  f8d401b0          LDR      r0,[r4,#0x1b0]
0003e4  6802              LDR      r2,[r0,#0]
0003e6  4620              MOV      r0,r4
0003e8  4790              BLX      r2
;;;474          (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
0003ea  f8d401a8          LDR      r0,[r4,#0x1a8]
0003ee  2100              MOVS     r1,#0
0003f0  6802              LDR      r2,[r0,#0]
0003f2  4620              MOV      r0,r4
0003f4  4790              BLX      r2
                  |L1.1014|
;;;475        }
;;;476      }
;;;477    
;;;478      /* Set up progress monitor's pass info if present */
;;;479      if (cinfo->progress != NULL) {
0003f6  68a0              LDR      r0,[r4,#8]
0003f8  b1d8              CBZ      r0,|L1.1074|
;;;480        cinfo->progress->completed_passes = master->pass_number;
0003fa  68e8              LDR      r0,[r5,#0xc]
0003fc  68a1              LDR      r1,[r4,#8]
0003fe  60c8              STR      r0,[r1,#0xc]
;;;481        cinfo->progress->total_passes = master->pass_number +
000400  e9d51002          LDRD     r1,r0,[r5,#8]
000404  b109              CBZ      r1,|L1.1034|
;;;482    				    (master->pub.is_dummy_pass ? 2 : 1);
000406  2102              MOVS     r1,#2
000408  e000              B        |L1.1036|
                  |L1.1034|
00040a  2101              MOVS     r1,#1
                  |L1.1036|
00040c  4408              ADD      r0,r0,r1
00040e  68a1              LDR      r1,[r4,#8]
000410  6108              STR      r0,[r1,#0x10]
;;;483        /* In buffered-image mode, we assume one more output pass if EOI not
;;;484         * yet reached, but no more passes if EOI has been reached.
;;;485         */
;;;486        if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
000412  6c20              LDR      r0,[r4,#0x40]
000414  b168              CBZ      r0,|L1.1074|
000416  f8d401b4          LDR      r0,[r4,#0x1b4]
00041a  6940              LDR      r0,[r0,#0x14]
00041c  b948              CBNZ     r0,|L1.1074|
;;;487          cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
00041e  68a0              LDR      r0,[r4,#8]
000420  6900              LDR      r0,[r0,#0x10]
000422  6ee1              LDR      r1,[r4,#0x6c]
000424  b109              CBZ      r1,|L1.1066|
000426  2102              MOVS     r1,#2
000428  e000              B        |L1.1068|
                  |L1.1066|
00042a  2101              MOVS     r1,#1
                  |L1.1068|
00042c  4408              ADD      r0,r0,r1
00042e  68a1              LDR      r1,[r4,#8]
000430  6108              STR      r0,[r1,#0x10]
                  |L1.1074|
;;;488        }
;;;489      }
;;;490    }
000432  bd70              POP      {r4-r6,pc}
;;;491    
                          ENDP

                  finish_output_pass PROC
;;;497    METHODDEF(void)
;;;498    finish_output_pass (j_decompress_ptr cinfo)
000434  b570              PUSH     {r4-r6,lr}
;;;499    {
000436  4604              MOV      r4,r0
;;;500      my_master_ptr master = (my_master_ptr) cinfo->master;
000438  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;501    
;;;502      if (cinfo->quantize_colors)
00043c  6d60              LDR      r0,[r4,#0x54]
00043e  b120              CBZ      r0,|L1.1098|
;;;503        (*cinfo->cquantize->finish_pass) (cinfo);
000440  f8d401cc          LDR      r0,[r4,#0x1cc]
000444  6881              LDR      r1,[r0,#8]
000446  4620              MOV      r0,r4
000448  4788              BLX      r1
                  |L1.1098|
;;;504      master->pass_number++;
00044a  68e8              LDR      r0,[r5,#0xc]
00044c  1c40              ADDS     r0,r0,#1
00044e  60e8              STR      r0,[r5,#0xc]
;;;505    }
000450  bd70              POP      {r4-r6,pc}
;;;506    
                          ENDP

                  jpeg_new_colormap PROC
;;;514    GLOBAL(void)
;;;515    jpeg_new_colormap (j_decompress_ptr cinfo)
000452  b570              PUSH     {r4-r6,lr}
;;;516    {
000454  4604              MOV      r4,r0
;;;517      my_master_ptr master = (my_master_ptr) cinfo->master;
000456  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;518    
;;;519      /* Prevent application from calling me at wrong times */
;;;520      if (cinfo->global_state != DSTATE_BUFIMAGE)
00045a  6960              LDR      r0,[r4,#0x14]
00045c  28cf              CMP      r0,#0xcf
00045e  d009              BEQ      |L1.1140|
;;;521        ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
000460  2014              MOVS     r0,#0x14
000462  6821              LDR      r1,[r4,#0]
000464  6148              STR      r0,[r1,#0x14]
000466  6821              LDR      r1,[r4,#0]
000468  6960              LDR      r0,[r4,#0x14]
00046a  6188              STR      r0,[r1,#0x18]
00046c  6820              LDR      r0,[r4,#0]
00046e  6801              LDR      r1,[r0,#0]
000470  4620              MOV      r0,r4
000472  4788              BLX      r1
                  |L1.1140|
;;;522    
;;;523      if (cinfo->quantize_colors && cinfo->enable_external_quant &&
000474  6d60              LDR      r0,[r4,#0x54]
000476  b178              CBZ      r0,|L1.1176|
000478  6ea0              LDR      r0,[r4,#0x68]
00047a  b168              CBZ      r0,|L1.1176|
;;;524          cinfo->colormap != NULL) {
00047c  f8d40088          LDR      r0,[r4,#0x88]
000480  b150              CBZ      r0,|L1.1176|
;;;525        /* Select 2-pass quantizer for external colormap use */
;;;526        cinfo->cquantize = master->quantizer_2pass;
000482  69a8              LDR      r0,[r5,#0x18]
000484  f8c401cc          STR      r0,[r4,#0x1cc]
;;;527        /* Notify quantizer of colormap change */
;;;528        (*cinfo->cquantize->new_color_map) (cinfo);
000488  f8d401cc          LDR      r0,[r4,#0x1cc]
00048c  68c1              LDR      r1,[r0,#0xc]
00048e  4620              MOV      r0,r4
000490  4788              BLX      r1
;;;529        master->pub.is_dummy_pass = FALSE; /* just in case */
000492  2000              MOVS     r0,#0
000494  60a8              STR      r0,[r5,#8]
000496  e006              B        |L1.1190|
                  |L1.1176|
;;;530      } else
;;;531        ERREXIT(cinfo, JERR_MODE_CHANGE);
000498  202e              MOVS     r0,#0x2e
00049a  6821              LDR      r1,[r4,#0]
00049c  6148              STR      r0,[r1,#0x14]
00049e  6820              LDR      r0,[r4,#0]
0004a0  6801              LDR      r1,[r0,#0]
0004a2  4620              MOV      r0,r4
0004a4  4788              BLX      r1
                  |L1.1190|
;;;532    }
0004a6  bd70              POP      {r4-r6,pc}
;;;533    
                          ENDP

                  jinit_master_decompress PROC
;;;542    GLOBAL(void)
;;;543    jinit_master_decompress (j_decompress_ptr cinfo)
0004a8  b570              PUSH     {r4-r6,lr}
;;;544    {
0004aa  4605              MOV      r5,r0
;;;545      my_master_ptr master;
;;;546    
;;;547      master = (my_master_ptr)
0004ac  6868              LDR      r0,[r5,#4]
0004ae  221c              MOVS     r2,#0x1c
0004b0  2101              MOVS     r1,#1
0004b2  6803              LDR      r3,[r0,#0]
0004b4  4628              MOV      r0,r5
0004b6  4798              BLX      r3
0004b8  4604              MOV      r4,r0
;;;548          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;549    				  SIZEOF(my_decomp_master));
;;;550      cinfo->master = (struct jpeg_decomp_master *) master;
0004ba  f8c541a4          STR      r4,[r5,#0x1a4]
;;;551      master->pub.prepare_for_output_pass = prepare_for_output_pass;
0004be  4805              LDR      r0,|L1.1236|
0004c0  6020              STR      r0,[r4,#0]
;;;552      master->pub.finish_output_pass = finish_output_pass;
0004c2  4805              LDR      r0,|L1.1240|
0004c4  6060              STR      r0,[r4,#4]
;;;553    
;;;554      master->pub.is_dummy_pass = FALSE;
0004c6  2000              MOVS     r0,#0
0004c8  60a0              STR      r0,[r4,#8]
;;;555    
;;;556      master_selection(cinfo);
0004ca  4628              MOV      r0,r5
0004cc  f7fffffe          BL       master_selection
;;;557    }
0004d0  bd70              POP      {r4-r6,pc}
                          ENDP

0004d2  0000              DCW      0x0000
                  |L1.1236|
                          DCD      prepare_for_output_pass
                  |L1.1240|
                          DCD      finish_output_pass
