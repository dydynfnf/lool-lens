; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdpostct.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdpostct.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdpostct.crf GUI\JPEG\jdpostct.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  post_process_2pass PROC
;;;203    METHODDEF(void)
;;;204    post_process_2pass (j_decompress_ptr cinfo,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;205    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;206    		    JDIMENSION in_row_groups_avail,
;;;207    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;208    		    JDIMENSION out_rows_avail)
;;;209    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  469b              MOV      r11,r3
00000c  f8dd802c          LDR      r8,[sp,#0x2c]
;;;210      my_post_ptr post = (my_post_ptr) cinfo->post;
000010  f8d641b0          LDR      r4,[r6,#0x1b0]
;;;211      JDIMENSION num_rows, max_rows;
;;;212    
;;;213      GUI_USE_PARA(in_row_groups_avail);
000014  bf00              NOP      
;;;214      GUI_USE_PARA(in_row_group_ctr);
000016  bf00              NOP      
;;;215      GUI_USE_PARA(input_buf);
000018  bf00              NOP      
;;;216      /* Reposition virtual buffer if at start of strip. */
;;;217      if (post->next_row == 0) {
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  b950              CBNZ     r0,|L1.52|
;;;218        post->buffer = (*cinfo->mem->access_virt_sarray)
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
000022  e9d43204          LDRD     r3,r2,[r4,#0x10]
000026  68a1              LDR      r1,[r4,#8]
000028  6870              LDR      r0,[r6,#4]
00002a  f8d0c01c          LDR      r12,[r0,#0x1c]
00002e  4630              MOV      r0,r6
000030  47e0              BLX      r12
000032  60e0              STR      r0,[r4,#0xc]
                  |L1.52|
;;;219    	((j_common_ptr) cinfo, post->whole_image,
;;;220    	 post->starting_row, post->strip_height, FALSE);
;;;221      }
;;;222    
;;;223      /* Determine number of rows to emit. */
;;;224      num_rows = post->strip_height - post->next_row; /* available in strip */
000034  69a1              LDR      r1,[r4,#0x18]
000036  6920              LDR      r0,[r4,#0x10]
000038  1a45              SUBS     r5,r0,r1
;;;225      max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
00003a  f8d81000          LDR      r1,[r8,#0]
00003e  980c              LDR      r0,[sp,#0x30]
000040  1a47              SUBS     r7,r0,r1
;;;226      if (num_rows > max_rows)
000042  42bd              CMP      r5,r7
000044  d900              BLS      |L1.72|
;;;227        num_rows = max_rows;
000046  463d              MOV      r5,r7
                  |L1.72|
;;;228      /* We have to check bottom of image here, can't depend on upsampler. */
;;;229      max_rows = cinfo->output_height - post->starting_row;
000048  6f70              LDR      r0,[r6,#0x74]
00004a  6961              LDR      r1,[r4,#0x14]
00004c  1a47              SUBS     r7,r0,r1
;;;230      if (num_rows > max_rows)
00004e  42bd              CMP      r5,r7
000050  d900              BLS      |L1.84|
;;;231        num_rows = max_rows;
000052  463d              MOV      r5,r7
                  |L1.84|
;;;232    
;;;233      /* Quantize and emit data. */
;;;234      (*cinfo->cquantize->color_quantize) (cinfo,
000054  69a3              LDR      r3,[r4,#0x18]
000056  68e0              LDR      r0,[r4,#0xc]
000058  eb000183          ADD      r1,r0,r3,LSL #2
00005c  f8d83000          LDR      r3,[r8,#0]
000060  980a              LDR      r0,[sp,#0x28]
000062  eb000283          ADD      r2,r0,r3,LSL #2
000066  f8d601cc          LDR      r0,[r6,#0x1cc]
00006a  462b              MOV      r3,r5
00006c  f8d0c004          LDR      r12,[r0,#4]
000070  4630              MOV      r0,r6
000072  47e0              BLX      r12
;;;235    		post->buffer + post->next_row, output_buf + *out_row_ctr,
;;;236    		(int) num_rows);
;;;237      *out_row_ctr += num_rows;
000074  f8d80000          LDR      r0,[r8,#0]
000078  4428              ADD      r0,r0,r5
00007a  f8c80000          STR      r0,[r8,#0]
;;;238    
;;;239      /* Advance if we filled the strip. */
;;;240      post->next_row += num_rows;
00007e  69a0              LDR      r0,[r4,#0x18]
000080  4428              ADD      r0,r0,r5
000082  61a0              STR      r0,[r4,#0x18]
;;;241      if (post->next_row >= post->strip_height) {
000084  6921              LDR      r1,[r4,#0x10]
000086  69a0              LDR      r0,[r4,#0x18]
000088  4288              CMP      r0,r1
00008a  d305              BCC      |L1.152|
;;;242        post->starting_row += post->strip_height;
00008c  e9d41004          LDRD     r1,r0,[r4,#0x10]
000090  4408              ADD      r0,r0,r1
000092  6160              STR      r0,[r4,#0x14]
;;;243        post->next_row = 0;
000094  2000              MOVS     r0,#0
000096  61a0              STR      r0,[r4,#0x18]
                  |L1.152|
;;;244      }
;;;245    }
000098  e8bd8ff8          POP      {r3-r11,pc}
;;;246    
                          ENDP

                  post_process_prepass PROC
;;;157    METHODDEF(void)
;;;158    post_process_prepass (j_decompress_ptr cinfo,
00009c  e92d4fff          PUSH     {r0-r11,lr}
;;;159    		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;160    		      JDIMENSION in_row_groups_avail,
;;;161    		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;162    		      JDIMENSION out_rows_avail)
;;;163    {
0000a0  b083              SUB      sp,sp,#0xc
0000a2  4605              MOV      r5,r0
0000a4  468b              MOV      r11,r1
0000a6  e9dd8a11          LDRD     r8,r10,[sp,#0x44]
0000aa  f8dd9040          LDR      r9,[sp,#0x40]
;;;164      my_post_ptr post = (my_post_ptr) cinfo->post;
0000ae  f8d541b0          LDR      r4,[r5,#0x1b0]
;;;165      JDIMENSION old_next_row, num_rows;
;;;166    
;;;167      GUI_USE_PARA(out_rows_avail);
0000b2  bf00              NOP      
;;;168      GUI_USE_PARA(output_buf);
0000b4  bf00              NOP      
;;;169      /* Reposition virtual buffer if at start of strip. */
;;;170      if (post->next_row == 0) {
0000b6  69a0              LDR      r0,[r4,#0x18]
0000b8  b950              CBNZ     r0,|L1.208|
;;;171        post->buffer = (*cinfo->mem->access_virt_sarray)
0000ba  2001              MOVS     r0,#1
0000bc  9000              STR      r0,[sp,#0]
0000be  e9d43204          LDRD     r3,r2,[r4,#0x10]
0000c2  68a1              LDR      r1,[r4,#8]
0000c4  6868              LDR      r0,[r5,#4]
0000c6  f8d0c01c          LDR      r12,[r0,#0x1c]
0000ca  4628              MOV      r0,r5
0000cc  47e0              BLX      r12
0000ce  60e0              STR      r0,[r4,#0xc]
                  |L1.208|
;;;172    	((j_common_ptr) cinfo, post->whole_image,
;;;173    	 post->starting_row, post->strip_height, TRUE);
;;;174      }
;;;175    
;;;176      /* Upsample some data (up to a strip height's worth). */
;;;177      old_next_row = post->next_row;
0000d0  69a6              LDR      r6,[r4,#0x18]
;;;178      (*cinfo->upsample->upsample) (cinfo,
0000d2  f1040118          ADD      r1,r4,#0x18
0000d6  e9d42003          LDRD     r2,r0,[r4,#0xc]
0000da  e9cd2100          STRD     r2,r1,[sp,#0]
0000de  9002              STR      r0,[sp,#8]
0000e0  f8d501c4          LDR      r0,[r5,#0x1c4]
0000e4  f8d0c004          LDR      r12,[r0,#4]
0000e8  4659              MOV      r1,r11
0000ea  4628              MOV      r0,r5
0000ec  e9dd2305          LDRD     r2,r3,[sp,#0x14]
0000f0  47e0              BLX      r12
;;;179    		input_buf, in_row_group_ctr, in_row_groups_avail,
;;;180    		post->buffer, &post->next_row, post->strip_height);
;;;181    
;;;182      /* Allow quantizer to scan new data.  No data is emitted, */
;;;183      /* but we advance out_row_ctr so outer loop can tell when we're done. */
;;;184      if (post->next_row > old_next_row) {
0000f2  69a0              LDR      r0,[r4,#0x18]
0000f4  42b0              CMP      r0,r6
0000f6  d911              BLS      |L1.284|
;;;185        num_rows = post->next_row - old_next_row;
0000f8  69a0              LDR      r0,[r4,#0x18]
0000fa  1b87              SUBS     r7,r0,r6
;;;186        (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
0000fc  68e0              LDR      r0,[r4,#0xc]
0000fe  eb000186          ADD      r1,r0,r6,LSL #2
000102  f8d501cc          LDR      r0,[r5,#0x1cc]
000106  463b              MOV      r3,r7
000108  2200              MOVS     r2,#0
00010a  f8d0c004          LDR      r12,[r0,#4]
00010e  4628              MOV      r0,r5
000110  47e0              BLX      r12
;;;187    					 (JSAMPARRAY) NULL, (int) num_rows);
;;;188        *out_row_ctr += num_rows;
000112  f8d80000          LDR      r0,[r8,#0]
000116  4438              ADD      r0,r0,r7
000118  f8c80000          STR      r0,[r8,#0]
                  |L1.284|
;;;189      }
;;;190    
;;;191      /* Advance if we filled the strip. */
;;;192      if (post->next_row >= post->strip_height) {
00011c  6921              LDR      r1,[r4,#0x10]
00011e  69a0              LDR      r0,[r4,#0x18]
000120  4288              CMP      r0,r1
000122  d305              BCC      |L1.304|
;;;193        post->starting_row += post->strip_height;
000124  e9d41004          LDRD     r1,r0,[r4,#0x10]
000128  4408              ADD      r0,r0,r1
00012a  6160              STR      r0,[r4,#0x14]
;;;194        post->next_row = 0;
00012c  2000              MOVS     r0,#0
00012e  61a0              STR      r0,[r4,#0x18]
                  |L1.304|
;;;195      }
;;;196    }
000130  b007              ADD      sp,sp,#0x1c
000132  e8bd8ff0          POP      {r4-r11,pc}
;;;197    
                          ENDP

                  post_process_1pass PROC
;;;125    METHODDEF(void)
;;;126    post_process_1pass (j_decompress_ptr cinfo,
000136  e92d4fff          PUSH     {r0-r11,lr}
;;;127    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;128    		    JDIMENSION in_row_groups_avail,
;;;129    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;130    		    JDIMENSION out_rows_avail)
;;;131    {
00013a  b085              SUB      sp,sp,#0x14
00013c  4604              MOV      r4,r0
00013e  4688              MOV      r8,r1
000140  4693              MOV      r11,r2
000142  e9dd5a13          LDRD     r5,r10,[sp,#0x4c]
000146  f8dd9048          LDR      r9,[sp,#0x48]
;;;132      my_post_ptr post = (my_post_ptr) cinfo->post;
00014a  f8d461b0          LDR      r6,[r4,#0x1b0]
;;;133      JDIMENSION num_rows, max_rows;
;;;134    
;;;135      /* Fill the buffer, but not more than what we can dump out in one go. */
;;;136      /* Note we rely on the upsampler to detect bottom of image. */
;;;137      max_rows = out_rows_avail - *out_row_ctr;
00014e  6828              LDR      r0,[r5,#0]
000150  ebaa0700          SUB      r7,r10,r0
;;;138      if (max_rows > post->strip_height)
000154  6930              LDR      r0,[r6,#0x10]
000156  42b8              CMP      r0,r7
000158  d200              BCS      |L1.348|
;;;139        max_rows = post->strip_height;
00015a  6937              LDR      r7,[r6,#0x10]
                  |L1.348|
;;;140      num_rows = 0;
00015c  2000              MOVS     r0,#0
00015e  9004              STR      r0,[sp,#0x10]
;;;141      (*cinfo->upsample->upsample) (cinfo,
000160  a904              ADD      r1,sp,#0x10
000162  68f0              LDR      r0,[r6,#0xc]
000164  e88d0083          STM      sp,{r0,r1,r7}
000168  f8d401c4          LDR      r0,[r4,#0x1c4]
00016c  f8d0c004          LDR      r12,[r0,#4]
000170  465a              MOV      r2,r11
000172  4641              MOV      r1,r8
000174  4620              MOV      r0,r4
000176  9b08              LDR      r3,[sp,#0x20]
000178  47e0              BLX      r12
;;;142    		input_buf, in_row_group_ctr, in_row_groups_avail,
;;;143    		post->buffer, &num_rows, max_rows);
;;;144      /* Quantize and emit data. */
;;;145      (*cinfo->cquantize->color_quantize) (cinfo,
00017a  6828              LDR      r0,[r5,#0]
00017c  eb090280          ADD      r2,r9,r0,LSL #2
000180  68f1              LDR      r1,[r6,#0xc]
000182  f8d401cc          LDR      r0,[r4,#0x1cc]
000186  f8d0c004          LDR      r12,[r0,#4]
00018a  4620              MOV      r0,r4
00018c  9b04              LDR      r3,[sp,#0x10]
00018e  47e0              BLX      r12
;;;146    		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
;;;147      *out_row_ctr += num_rows;
000190  6828              LDR      r0,[r5,#0]
000192  9904              LDR      r1,[sp,#0x10]
000194  4408              ADD      r0,r0,r1
000196  6028              STR      r0,[r5,#0]
;;;148    }
000198  b009              ADD      sp,sp,#0x24
00019a  e8bd8ff0          POP      {r4-r11,pc}
;;;149    
                          ENDP

                  start_pass_dpost PROC
;;;72     METHODDEF(void)
;;;73     start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
00019e  b5f8              PUSH     {r3-r7,lr}
;;;74     {
0001a0  4605              MOV      r5,r0
0001a2  460e              MOV      r6,r1
;;;75       my_post_ptr post = (my_post_ptr) cinfo->post;
0001a4  f8d541b0          LDR      r4,[r5,#0x1b0]
;;;76     
;;;77       switch (pass_mode) {
0001a8  b126              CBZ      r6,|L1.436|
0001aa  2e02              CMP      r6,#2
0001ac  d024              BEQ      |L1.504|
0001ae  2e03              CMP      r6,#3
0001b0  d12e              BNE      |L1.528|
0001b2  e015              B        |L1.480|
                  |L1.436|
;;;78       case JBUF_PASS_THRU:
;;;79         if (cinfo->quantize_colors) {
0001b4  6d68              LDR      r0,[r5,#0x54]
0001b6  b170              CBZ      r0,|L1.470|
;;;80           /* Single-pass processing with color quantization. */
;;;81           post->pub.post_process_data = post_process_1pass;
0001b8  4839              LDR      r0,|L1.672|
0001ba  6060              STR      r0,[r4,#4]
;;;82           /* We could be doing buffered-image output before starting a 2-pass
;;;83            * color quantization; in that case, jinit_d_post_controller did not
;;;84            * allocate a strip buffer.  Use the virtual-array buffer as workspace.
;;;85            */
;;;86           if (post->buffer == NULL) {
0001bc  68e0              LDR      r0,[r4,#0xc]
0001be  b970              CBNZ     r0,|L1.478|
;;;87     	post->buffer = (*cinfo->mem->access_virt_sarray)
0001c0  2001              MOVS     r0,#1
0001c2  9000              STR      r0,[sp,#0]
0001c4  6923              LDR      r3,[r4,#0x10]
0001c6  68a1              LDR      r1,[r4,#8]
0001c8  6868              LDR      r0,[r5,#4]
0001ca  2200              MOVS     r2,#0
0001cc  69c7              LDR      r7,[r0,#0x1c]
0001ce  4628              MOV      r0,r5
0001d0  47b8              BLX      r7
0001d2  60e0              STR      r0,[r4,#0xc]
0001d4  e003              B        |L1.478|
                  |L1.470|
;;;88     	  ((j_common_ptr) cinfo, post->whole_image,
;;;89     	   (JDIMENSION) 0, post->strip_height, TRUE);
;;;90           }
;;;91         } else {
;;;92           /* For single-pass processing without color quantization,
;;;93            * I have no work to do; just call the upsampler directly.
;;;94            */
;;;95           post->pub.post_process_data = cinfo->upsample->upsample;
0001d6  f8d501c4          LDR      r0,[r5,#0x1c4]
0001da  6840              LDR      r0,[r0,#4]
0001dc  6060              STR      r0,[r4,#4]
                  |L1.478|
;;;96         }
;;;97         break;
0001de  e01f              B        |L1.544|
                  |L1.480|
;;;98     #ifdef QUANT_2PASS_SUPPORTED
;;;99       case JBUF_SAVE_AND_PASS:
;;;100        /* First pass of 2-pass quantization */
;;;101        if (post->whole_image == NULL)
0001e0  68a0              LDR      r0,[r4,#8]
0001e2  b930              CBNZ     r0,|L1.498|
;;;102          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
0001e4  2004              MOVS     r0,#4
0001e6  6829              LDR      r1,[r5,#0]
0001e8  6148              STR      r0,[r1,#0x14]
0001ea  6828              LDR      r0,[r5,#0]
0001ec  6801              LDR      r1,[r0,#0]
0001ee  4628              MOV      r0,r5
0001f0  4788              BLX      r1
                  |L1.498|
;;;103        post->pub.post_process_data = post_process_prepass;
0001f2  482c              LDR      r0,|L1.676|
0001f4  6060              STR      r0,[r4,#4]
;;;104        break;
0001f6  e013              B        |L1.544|
                  |L1.504|
;;;105      case JBUF_CRANK_DEST:
;;;106        /* Second pass of 2-pass quantization */
;;;107        if (post->whole_image == NULL)
0001f8  68a0              LDR      r0,[r4,#8]
0001fa  b930              CBNZ     r0,|L1.522|
;;;108          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
0001fc  2004              MOVS     r0,#4
0001fe  6829              LDR      r1,[r5,#0]
000200  6148              STR      r0,[r1,#0x14]
000202  6828              LDR      r0,[r5,#0]
000204  6801              LDR      r1,[r0,#0]
000206  4628              MOV      r0,r5
000208  4788              BLX      r1
                  |L1.522|
;;;109        post->pub.post_process_data = post_process_2pass;
00020a  4827              LDR      r0,|L1.680|
00020c  6060              STR      r0,[r4,#4]
;;;110        break;
00020e  e007              B        |L1.544|
                  |L1.528|
;;;111    #endif /* QUANT_2PASS_SUPPORTED */
;;;112      default:
;;;113        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000210  2004              MOVS     r0,#4
000212  6829              LDR      r1,[r5,#0]
000214  6148              STR      r0,[r1,#0x14]
000216  6828              LDR      r0,[r5,#0]
000218  6801              LDR      r1,[r0,#0]
00021a  4628              MOV      r0,r5
00021c  4788              BLX      r1
;;;114        break;
00021e  bf00              NOP      
                  |L1.544|
000220  bf00              NOP                            ;97
;;;115      }
;;;116      post->starting_row = post->next_row = 0;
000222  2000              MOVS     r0,#0
000224  61a0              STR      r0,[r4,#0x18]
000226  6160              STR      r0,[r4,#0x14]
;;;117    }
000228  bdf8              POP      {r3-r7,pc}
;;;118    
                          ENDP

                  jinit_d_post_controller PROC
;;;254    GLOBAL(void)
;;;255    jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
00022a  e92d41fc          PUSH     {r2-r8,lr}
;;;256    {
00022e  4604              MOV      r4,r0
000230  460e              MOV      r6,r1
;;;257      my_post_ptr post;
;;;258    
;;;259      post = (my_post_ptr)
000232  6860              LDR      r0,[r4,#4]
000234  221c              MOVS     r2,#0x1c
000236  2101              MOVS     r1,#1
000238  6803              LDR      r3,[r0,#0]
00023a  4620              MOV      r0,r4
00023c  4798              BLX      r3
00023e  4605              MOV      r5,r0
;;;260        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;261    				SIZEOF(my_post_controller));
;;;262      cinfo->post = (struct jpeg_d_post_controller *) post;
000240  f8c451b0          STR      r5,[r4,#0x1b0]
;;;263      post->pub.start_pass = start_pass_dpost;
000244  4819              LDR      r0,|L1.684|
000246  6028              STR      r0,[r5,#0]
;;;264      post->whole_image = NULL;	/* flag for no virtual arrays */
000248  2000              MOVS     r0,#0
00024a  60a8              STR      r0,[r5,#8]
;;;265      post->buffer = NULL;		/* flag for no strip buffer */
00024c  60e8              STR      r0,[r5,#0xc]
;;;266    
;;;267      /* Create the quantization buffer, if needed */
;;;268      if (cinfo->quantize_colors) {
00024e  6d60              LDR      r0,[r4,#0x54]
000250  b318              CBZ      r0,|L1.666|
;;;269        /* The buffer strip height is max_v_samp_factor, which is typically
;;;270         * an efficient number of rows for upsampling to return.
;;;271         * (In the presence of output rescaling, we might want to be smarter?)
;;;272         */
;;;273        post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
000252  f8d40138          LDR      r0,[r4,#0x138]
000256  6128              STR      r0,[r5,#0x10]
;;;274        if (need_full_buffer) {
000258  b1a6              CBZ      r6,|L1.644|
;;;275          /* Two-pass color quantization: need full-image storage. */
;;;276          /* We round up the number of rows to a multiple of the strip height. */
;;;277    #ifdef QUANT_2PASS_SUPPORTED
;;;278          post->whole_image = (*cinfo->mem->request_virt_sarray)
00025a  6929              LDR      r1,[r5,#0x10]
00025c  6f60              LDR      r0,[r4,#0x74]
00025e  f7fffffe          BL       jround_up
000262  4607              MOV      r7,r0
000264  6928              LDR      r0,[r5,#0x10]
000266  e9cd7000          STRD     r7,r0,[sp,#0]
00026a  6fa1              LDR      r1,[r4,#0x78]
00026c  6f20              LDR      r0,[r4,#0x70]
00026e  fb00f301          MUL      r3,r0,r1
000272  6860              LDR      r0,[r4,#4]
000274  2200              MOVS     r2,#0
000276  2101              MOVS     r1,#1
000278  f8d0c010          LDR      r12,[r0,#0x10]
00027c  4620              MOV      r0,r4
00027e  47e0              BLX      r12
000280  60a8              STR      r0,[r5,#8]
000282  e00a              B        |L1.666|
                  |L1.644|
;;;279    	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
;;;280    	 cinfo->output_width * cinfo->out_color_components,
;;;281    	 (JDIMENSION) jround_up((long) cinfo->output_height,
;;;282    				(long) post->strip_height),
;;;283    	 post->strip_height);
;;;284    #else
;;;285          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
;;;286    #endif /* QUANT_2PASS_SUPPORTED */
;;;287        } else {
;;;288          /* One-pass color quantization: just make a strip buffer. */
;;;289          post->buffer = (*cinfo->mem->alloc_sarray)
000284  6fa1              LDR      r1,[r4,#0x78]
000286  6f20              LDR      r0,[r4,#0x70]
000288  fb00f201          MUL      r2,r0,r1
00028c  692b              LDR      r3,[r5,#0x10]
00028e  6860              LDR      r0,[r4,#4]
000290  2101              MOVS     r1,#1
000292  6887              LDR      r7,[r0,#8]
000294  4620              MOV      r0,r4
000296  47b8              BLX      r7
000298  60e8              STR      r0,[r5,#0xc]
                  |L1.666|
;;;290    	((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;291    	 cinfo->output_width * cinfo->out_color_components,
;;;292    	 post->strip_height);
;;;293        }
;;;294      }
;;;295    }
00029a  e8bd81fc          POP      {r2-r8,pc}
                          ENDP

00029e  0000              DCW      0x0000
                  |L1.672|
                          DCD      post_process_1pass
                  |L1.676|
                          DCD      post_process_prepass
                  |L1.680|
                          DCD      post_process_2pass
                  |L1.684|
                          DCD      start_pass_dpost
