; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdhuff.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdhuff.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdhuff.crf GUI\JPEG\jdhuff.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  jpeg_make_d_derived_tbl PROC
;;;148    GLOBAL(void)
;;;149    jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;150    			 d_derived_tbl ** pdtbl)
;;;151    {
000004  f2ad5d1c          SUB      sp,sp,#0x51c
000008  4605              MOV      r5,r0
00000a  4692              MOV      r10,r2
;;;152      JHUFF_TBL *htbl;
;;;153      d_derived_tbl *dtbl;
;;;154      int p, i, l, si, numsymbols;
;;;155      int lookbits, ctr;
;;;156      char huffsize[257];
;;;157      unsigned int huffcode[257];
;;;158      unsigned int code;
;;;159    
;;;160      /* Note that huffsize[] and huffcode[] are filled in code-length order,
;;;161       * paralleling the order of the symbols themselves in htbl->huffval[].
;;;162       */
;;;163    
;;;164      /* Find the input Huffman table */
;;;165      if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
00000c  f1ba0f00          CMP      r10,#0
000010  db02              BLT      |L1.24|
000012  f1ba0f04          CMP      r10,#4
000016  db09              BLT      |L1.44|
                  |L1.24|
;;;166        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
000018  2032              MOVS     r0,#0x32
00001a  6829              LDR      r1,[r5,#0]
00001c  6148              STR      r0,[r1,#0x14]
00001e  6828              LDR      r0,[r5,#0]
000020  f8c0a018          STR      r10,[r0,#0x18]
000024  6828              LDR      r0,[r5,#0]
000026  6801              LDR      r1,[r0,#0]
000028  4628              MOV      r0,r5
00002a  4788              BLX      r1
                  |L1.44|
;;;167      htbl =
00002c  f8dd0520          LDR      r0,[sp,#0x520]
000030  b120              CBZ      r0,|L1.60|
;;;168        isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
000032  f10500b4          ADD      r0,r5,#0xb4
000036  f850002a          LDR      r0,[r0,r10,LSL #2]
00003a  e003              B        |L1.68|
                  |L1.60|
00003c  f10500c4          ADD      r0,r5,#0xc4
000040  f850002a          LDR      r0,[r0,r10,LSL #2]
                  |L1.68|
000044  4680              MOV      r8,r0
;;;169      if (htbl == NULL)
000046  f1b80f00          CMP      r8,#0
00004a  d109              BNE      |L1.96|
;;;170        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
00004c  2032              MOVS     r0,#0x32
00004e  6829              LDR      r1,[r5,#0]
000050  6148              STR      r0,[r1,#0x14]
000052  6828              LDR      r0,[r5,#0]
000054  f8c0a018          STR      r10,[r0,#0x18]
000058  6828              LDR      r0,[r5,#0]
00005a  6801              LDR      r1,[r0,#0]
00005c  4628              MOV      r0,r5
00005e  4788              BLX      r1
                  |L1.96|
;;;171    
;;;172      /* Allocate a workspace if we haven't already done so. */
;;;173      if (*pdtbl == NULL)
000060  f8dd0528          LDR      r0,[sp,#0x528]
000064  6800              LDR      r0,[r0,#0]
000066  b948              CBNZ     r0,|L1.124|
;;;174        *pdtbl = (d_derived_tbl *)
000068  6868              LDR      r0,[r5,#4]
00006a  f44f62b2          MOV      r2,#0x590
00006e  2101              MOVS     r1,#1
000070  6803              LDR      r3,[r0,#0]
000072  4628              MOV      r0,r5
000074  4798              BLX      r3
000076  f8dd1528          LDR      r1,[sp,#0x528]
00007a  6008              STR      r0,[r1,#0]
                  |L1.124|
;;;175          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;176    				  SIZEOF(d_derived_tbl));
;;;177      dtbl = *pdtbl;
00007c  f8dd0528          LDR      r0,[sp,#0x528]
000080  6807              LDR      r7,[r0,#0]
;;;178      dtbl->pub = htbl;		/* fill in back link */
000082  f8c7808c          STR      r8,[r7,#0x8c]
;;;179      
;;;180      /* Figure C.1: make table of Huffman code length for each symbol */
;;;181    
;;;182      p = 0;
000086  2600              MOVS     r6,#0
;;;183      for (l = 1; l <= 16; l++) {
000088  2401              MOVS     r4,#1
00008a  e01c              B        |L1.198|
                  |L1.140|
;;;184        i = (int) htbl->bits[l];
00008c  f8189004          LDRB     r9,[r8,r4]
;;;185        if (i < 0 || p + i > 256)	/* protect against table overrun */
000090  f1b90f00          CMP      r9,#0
000094  db04              BLT      |L1.160|
000096  eb060009          ADD      r0,r6,r9
00009a  f5b07f80          CMP      r0,#0x100
00009e  dd06              BLE      |L1.174|
                  |L1.160|
;;;186          ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
0000a0  2008              MOVS     r0,#8
0000a2  6829              LDR      r1,[r5,#0]
0000a4  6148              STR      r0,[r1,#0x14]
0000a6  6828              LDR      r0,[r5,#0]
0000a8  6801              LDR      r1,[r0,#0]
0000aa  4628              MOV      r0,r5
0000ac  4788              BLX      r1
                  |L1.174|
;;;187        while (i--)
0000ae  e004              B        |L1.186|
                  |L1.176|
;;;188          huffsize[p++] = (char) l;
0000b0  4630              MOV      r0,r6
0000b2  1c76              ADDS     r6,r6,#1
0000b4  f50d6181          ADD      r1,sp,#0x408
0000b8  540c              STRB     r4,[r1,r0]
                  |L1.186|
0000ba  ea5f0009          MOVS     r0,r9                 ;187
0000be  f1a90901          SUB      r9,r9,#1              ;187
0000c2  d1f5              BNE      |L1.176|
0000c4  1c64              ADDS     r4,r4,#1              ;183
                  |L1.198|
0000c6  2c10              CMP      r4,#0x10              ;183
0000c8  dde0              BLE      |L1.140|
;;;189      }
;;;190      huffsize[p] = 0;
0000ca  2000              MOVS     r0,#0
0000cc  f50d6181          ADD      r1,sp,#0x408
0000d0  5588              STRB     r0,[r1,r6]
;;;191      numsymbols = p;
0000d2  f8cd6514          STR      r6,[sp,#0x514]
;;;192      
;;;193      /* Figure C.2: generate the codes themselves */
;;;194      /* We also validate that the counts represent a legal Huffman code tree. */
;;;195      
;;;196      code = 0;
0000d6  4683              MOV      r11,r0
;;;197      si = huffsize[0];
0000d8  f89d0408          LDRB     r0,[sp,#0x408]
0000dc  f8cd0518          STR      r0,[sp,#0x518]
;;;198      p = 0;
0000e0  2600              MOVS     r6,#0
;;;199      while (huffsize[p]) {
0000e2  e022              B        |L1.298|
                  |L1.228|
;;;200        while (((int) huffsize[p]) == si) {
0000e4  e006              B        |L1.244|
                  |L1.230|
;;;201          huffcode[p++] = code;
0000e6  4630              MOV      r0,r6
0000e8  1c76              ADDS     r6,r6,#1
0000ea  a901              ADD      r1,sp,#4
0000ec  f841b020          STR      r11,[r1,r0,LSL #2]
;;;202          code++;
0000f0  f10b0b01          ADD      r11,r11,#1
                  |L1.244|
0000f4  f50d6081          ADD      r0,sp,#0x408          ;200
0000f8  5d81              LDRB     r1,[r0,r6]            ;200
0000fa  f8dd0518          LDR      r0,[sp,#0x518]        ;200
0000fe  4281              CMP      r1,r0                 ;200
000100  d0f1              BEQ      |L1.230|
;;;203        }
;;;204        /* code is now 1 more than the last code used for codelength si; but
;;;205         * it must still fit in si bits, since no code is allowed to be all ones.
;;;206         */
;;;207        if (((INT32) code) >= (((INT32) 1) << si))
000102  2101              MOVS     r1,#1
000104  f8dd0518          LDR      r0,[sp,#0x518]
000108  4081              LSLS     r1,r1,r0
00010a  4559              CMP      r1,r11
00010c  dc06              BGT      |L1.284|
;;;208          ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
00010e  2008              MOVS     r0,#8
000110  6829              LDR      r1,[r5,#0]
000112  6148              STR      r0,[r1,#0x14]
000114  6828              LDR      r0,[r5,#0]
000116  6801              LDR      r1,[r0,#0]
000118  4628              MOV      r0,r5
00011a  4788              BLX      r1
                  |L1.284|
;;;209        code <<= 1;
00011c  ea4f0b4b          LSL      r11,r11,#1
;;;210        si++;
000120  f8dd0518          LDR      r0,[sp,#0x518]
000124  1c40              ADDS     r0,r0,#1
000126  f8cd0518          STR      r0,[sp,#0x518]
                  |L1.298|
00012a  f50d6081          ADD      r0,sp,#0x408          ;199
00012e  5d80              LDRB     r0,[r0,r6]            ;199
000130  2800              CMP      r0,#0                 ;199
000132  d1d7              BNE      |L1.228|
;;;211      }
;;;212    
;;;213      /* Figure F.15: generate decoding tables for bit-sequential decoding */
;;;214    
;;;215      p = 0;
000134  2600              MOVS     r6,#0
;;;216      for (l = 1; l <= 16; l++) {
000136  2401              MOVS     r4,#1
000138  e019              B        |L1.366|
                  |L1.314|
;;;217        if (htbl->bits[l]) {
00013a  f8180004          LDRB     r0,[r8,r4]
00013e  b188              CBZ      r0,|L1.356|
;;;218          /* valoffset[l] = huffval[] index of 1st symbol of code length l,
;;;219           * minus the minimum code of length l
;;;220           */
;;;221          dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
000140  a801              ADD      r0,sp,#4
000142  f8500026          LDR      r0,[r0,r6,LSL #2]
000146  1a31              SUBS     r1,r6,r0
000148  f1070048          ADD      r0,r7,#0x48
00014c  f8401024          STR      r1,[r0,r4,LSL #2]
;;;222          p += htbl->bits[l];
000150  f8180004          LDRB     r0,[r8,r4]
000154  4406              ADD      r6,r6,r0
;;;223          dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
000156  1e70              SUBS     r0,r6,#1
000158  a901              ADD      r1,sp,#4
00015a  f8510020          LDR      r0,[r1,r0,LSL #2]
00015e  f8470024          STR      r0,[r7,r4,LSL #2]
000162  e003              B        |L1.364|
                  |L1.356|
;;;224        } else {
;;;225          dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
000164  f04f30ff          MOV      r0,#0xffffffff
000168  f8470024          STR      r0,[r7,r4,LSL #2]
                  |L1.364|
00016c  1c64              ADDS     r4,r4,#1              ;216
                  |L1.366|
00016e  2c10              CMP      r4,#0x10              ;216
000170  dde3              BLE      |L1.314|
;;;226        }
;;;227      }
;;;228      dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
000172  48f9              LDR      r0,|L1.1368|
000174  6478              STR      r0,[r7,#0x44]
;;;229    
;;;230      /* Compute lookahead tables to speed up decoding.
;;;231       * First we set all the table entries to 0, indicating "too long";
;;;232       * then we iterate through the Huffman codes that are short enough and
;;;233       * fill in all the entries that correspond to bit sequences starting
;;;234       * with that code.
;;;235       */
;;;236    
;;;237      MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
000176  f44f6180          MOV      r1,#0x400
00017a  f1070090          ADD      r0,r7,#0x90
00017e  f7fffffe          BL       __aeabi_memclr4
;;;238    
;;;239      p = 0;
000182  2600              MOVS     r6,#0
;;;240      for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
000184  2401              MOVS     r4,#1
000186  e035              B        |L1.500|
                  |L1.392|
;;;241        for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
000188  f04f0901          MOV      r9,#1
00018c  e02d              B        |L1.490|
                  |L1.398|
;;;242          /* l = current code's length, p = its index in huffcode[] & huffval[]. */
;;;243          /* Generate left-justified code followed by all possible bit sequences */
;;;244          lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
00018e  a801              ADD      r0,sp,#4
000190  f8500026          LDR      r0,[r0,r6,LSL #2]
000194  f1c40108          RSB      r1,r4,#8
000198  4088              LSLS     r0,r0,r1
00019a  f8cd0510          STR      r0,[sp,#0x510]
;;;245          for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
00019e  f1c40108          RSB      r1,r4,#8
0001a2  2001              MOVS     r0,#1
0001a4  4088              LSLS     r0,r0,r1
0001a6  f8cd050c          STR      r0,[sp,#0x50c]
0001aa  e017              B        |L1.476|
                  |L1.428|
;;;246    	dtbl->look_nbits[lookbits] = l;
0001ac  f1070090          ADD      r0,r7,#0x90
0001b0  f8dd1510          LDR      r1,[sp,#0x510]
0001b4  f8404021          STR      r4,[r0,r1,LSL #2]
;;;247    	dtbl->look_sym[lookbits] = htbl->huffval[p];
0001b8  f1080011          ADD      r0,r8,#0x11
0001bc  5d82              LDRB     r2,[r0,r6]
0001be  f5076092          ADD      r0,r7,#0x490
0001c2  f8dd1510          LDR      r1,[sp,#0x510]
0001c6  5442              STRB     r2,[r0,r1]
;;;248    	lookbits++;
0001c8  f8dd0510          LDR      r0,[sp,#0x510]
0001cc  1c40              ADDS     r0,r0,#1
0001ce  f8cd0510          STR      r0,[sp,#0x510]
0001d2  f8dd050c          LDR      r0,[sp,#0x50c]        ;245
0001d6  1e40              SUBS     r0,r0,#1              ;245
0001d8  f8cd050c          STR      r0,[sp,#0x50c]        ;245
                  |L1.476|
0001dc  f8dd050c          LDR      r0,[sp,#0x50c]        ;245
0001e0  2800              CMP      r0,#0                 ;245
0001e2  dce3              BGT      |L1.428|
0001e4  f1090901          ADD      r9,r9,#1              ;241
0001e8  1c76              ADDS     r6,r6,#1              ;241
                  |L1.490|
0001ea  f8180004          LDRB     r0,[r8,r4]            ;241
0001ee  4548              CMP      r0,r9                 ;241
0001f0  dacd              BGE      |L1.398|
0001f2  1c64              ADDS     r4,r4,#1              ;240
                  |L1.500|
0001f4  2c08              CMP      r4,#8                 ;240
0001f6  ddc7              BLE      |L1.392|
;;;249          }
;;;250        }
;;;251      }
;;;252    
;;;253      /* Validate symbols as being reasonable.
;;;254       * For AC tables, we make no check, but accept all byte values 0..255.
;;;255       * For DC tables, we require the symbols to be in range 0..15.
;;;256       * (Tighter bounds could be applied depending on the data depth and mode,
;;;257       * but this is sufficient to ensure safe decoding.)
;;;258       */
;;;259      if (isDC) {
0001f8  f8dd0520          LDR      r0,[sp,#0x520]
0001fc  b1d0              CBZ      r0,|L1.564|
;;;260        for (i = 0; i < numsymbols; i++) {
0001fe  f04f0900          MOV      r9,#0
000202  e013              B        |L1.556|
                  |L1.516|
;;;261          int sym = htbl->huffval[i];
000204  f1080011          ADD      r0,r8,#0x11
000208  f8100009          LDRB     r0,[r0,r9]
00020c  9000              STR      r0,[sp,#0]
;;;262          if (sym < 0 || sym > 15)
00020e  9800              LDR      r0,[sp,#0]
000210  2800              CMP      r0,#0
000212  db02              BLT      |L1.538|
000214  9800              LDR      r0,[sp,#0]
000216  280f              CMP      r0,#0xf
000218  dd06              BLE      |L1.552|
                  |L1.538|
;;;263    	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
00021a  2008              MOVS     r0,#8
00021c  6829              LDR      r1,[r5,#0]
00021e  6148              STR      r0,[r1,#0x14]
000220  6828              LDR      r0,[r5,#0]
000222  6801              LDR      r1,[r0,#0]
000224  4628              MOV      r0,r5
000226  4788              BLX      r1
                  |L1.552|
000228  f1090901          ADD      r9,r9,#1              ;260
                  |L1.556|
00022c  f8dd0514          LDR      r0,[sp,#0x514]        ;260
000230  4581              CMP      r9,r0                 ;260
000232  dbe7              BLT      |L1.516|
                  |L1.564|
;;;264        }
;;;265      }
;;;266    }
000234  f20d5d2c          ADD      sp,sp,#0x52c
000238  e8bd8ff0          POP      {r4-r11,pc}
;;;267    
                          ENDP

                  start_pass_huff_decoder PROC
;;;85     METHODDEF(void)
;;;86     start_pass_huff_decoder (j_decompress_ptr cinfo)
00023c  e92d47f0          PUSH     {r4-r10,lr}
;;;87     {
000240  4605              MOV      r5,r0
;;;88       huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
000242  f8d541bc          LDR      r4,[r5,#0x1bc]
;;;89       int ci, blkn, dctbl, actbl;
;;;90       jpeg_component_info * compptr;
;;;91     
;;;92       /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
;;;93        * This ought to be an error condition, but we make it a warning because
;;;94        * there are some baseline files out there with all zeroes in these bytes.
;;;95        */
;;;96       if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
000246  f8d50190          LDR      r0,[r5,#0x190]
00024a  b948              CBNZ     r0,|L1.608|
00024c  f8d50194          LDR      r0,[r5,#0x194]
000250  283f              CMP      r0,#0x3f
000252  d105              BNE      |L1.608|
;;;97           cinfo->Ah != 0 || cinfo->Al != 0)
000254  f8d50198          LDR      r0,[r5,#0x198]
000258  b910              CBNZ     r0,|L1.608|
00025a  f8d5019c          LDR      r0,[r5,#0x19c]
00025e  b140              CBZ      r0,|L1.626|
                  |L1.608|
;;;98         WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
000260  207a              MOVS     r0,#0x7a
000262  6829              LDR      r1,[r5,#0]
000264  6148              STR      r0,[r1,#0x14]
000266  6828              LDR      r0,[r5,#0]
000268  f04f31ff          MOV      r1,#0xffffffff
00026c  6842              LDR      r2,[r0,#4]
00026e  4628              MOV      r0,r5
000270  4790              BLX      r2
                  |L1.626|
;;;99     
;;;100      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000272  f04f0800          MOV      r8,#0
000276  e020              B        |L1.698|
                  |L1.632|
;;;101        compptr = cinfo->cur_comp_info[ci];
000278  f50570a6          ADD      r0,r5,#0x14c
00027c  f8507028          LDR      r7,[r0,r8,LSL #2]
;;;102        dctbl = compptr->dc_tbl_no;
000280  f8d79014          LDR      r9,[r7,#0x14]
;;;103        actbl = compptr->ac_tbl_no;
000284  f8d7a018          LDR      r10,[r7,#0x18]
;;;104        /* Compute derived values for Huffman tables */
;;;105        /* We may do this more than once for a table, but it's not expensive */
;;;106        jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
000288  f1040028          ADD      r0,r4,#0x28
00028c  eb000389          ADD      r3,r0,r9,LSL #2
000290  464a              MOV      r2,r9
000292  2101              MOVS     r1,#1
000294  4628              MOV      r0,r5
000296  f7fffffe          BL       jpeg_make_d_derived_tbl
;;;107    			    & entropy->dc_derived_tbls[dctbl]);
;;;108        jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
00029a  f1040038          ADD      r0,r4,#0x38
00029e  eb00038a          ADD      r3,r0,r10,LSL #2
0002a2  4652              MOV      r2,r10
0002a4  2100              MOVS     r1,#0
0002a6  4628              MOV      r0,r5
0002a8  f7fffffe          BL       jpeg_make_d_derived_tbl
;;;109    			    & entropy->ac_derived_tbls[actbl]);
;;;110        /* Initialize DC predictions to 0 */
;;;111        entropy->saved.last_dc_val[ci] = 0;
0002ac  2100              MOVS     r1,#0
0002ae  f1040014          ADD      r0,r4,#0x14
0002b2  f8401028          STR      r1,[r0,r8,LSL #2]
0002b6  f1080801          ADD      r8,r8,#1              ;100
                  |L1.698|
0002ba  f8d50148          LDR      r0,[r5,#0x148]        ;100
0002be  4540              CMP      r0,r8                 ;100
0002c0  dcda              BGT      |L1.632|
;;;112      }
;;;113    
;;;114      /* Precalculate decoding info for each block in an MCU of this scan */
;;;115      for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
0002c2  2600              MOVS     r6,#0
0002c4  e02f              B        |L1.806|
                  |L1.710|
;;;116        ci = cinfo->MCU_membership[blkn];
0002c6  f50570b4          ADD      r0,r5,#0x168
0002ca  f8508026          LDR      r8,[r0,r6,LSL #2]
;;;117        compptr = cinfo->cur_comp_info[ci];
0002ce  381c              SUBS     r0,r0,#0x1c
0002d0  f8507028          LDR      r7,[r0,r8,LSL #2]
;;;118        /* Precalculate which table to use for each block */
;;;119        entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
0002d4  f1040028          ADD      r0,r4,#0x28
0002d8  6979              LDR      r1,[r7,#0x14]
0002da  f8501021          LDR      r1,[r0,r1,LSL #2]
0002de  3020              ADDS     r0,r0,#0x20
0002e0  f8401026          STR      r1,[r0,r6,LSL #2]
;;;120        entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
0002e4  3810              SUBS     r0,r0,#0x10
0002e6  69b9              LDR      r1,[r7,#0x18]
0002e8  f8501021          LDR      r1,[r0,r1,LSL #2]
0002ec  3038              ADDS     r0,r0,#0x38
0002ee  f8401026          STR      r1,[r0,r6,LSL #2]
;;;121        /* Decide whether we really care about the coefficient values */
;;;122        if (compptr->component_needed) {
0002f2  6b38              LDR      r0,[r7,#0x30]
0002f4  b170              CBZ      r0,|L1.788|
;;;123          entropy->dc_needed[blkn] = TRUE;
0002f6  2101              MOVS     r1,#1
0002f8  f1040098          ADD      r0,r4,#0x98
0002fc  f8401026          STR      r1,[r0,r6,LSL #2]
;;;124          /* we don't need the ACs if producing a 1/8th-size image */
;;;125          entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
000300  6a78              LDR      r0,[r7,#0x24]
000302  2801              CMP      r0,#1
000304  dd00              BLE      |L1.776|
000306  e000              B        |L1.778|
                  |L1.776|
000308  2100              MOVS     r1,#0
                  |L1.778|
00030a  f10400c0          ADD      r0,r4,#0xc0
00030e  f8401026          STR      r1,[r0,r6,LSL #2]
000312  e007              B        |L1.804|
                  |L1.788|
;;;126        } else {
;;;127          entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
000314  2100              MOVS     r1,#0
000316  f10400c0          ADD      r0,r4,#0xc0
00031a  f8401026          STR      r1,[r0,r6,LSL #2]
00031e  3828              SUBS     r0,r0,#0x28
000320  f8401026          STR      r1,[r0,r6,LSL #2]
                  |L1.804|
000324  1c76              ADDS     r6,r6,#1              ;115
                  |L1.806|
000326  f8d50164          LDR      r0,[r5,#0x164]        ;115
00032a  42b0              CMP      r0,r6                 ;115
00032c  dccb              BGT      |L1.710|
;;;128        }
;;;129      }
;;;130    
;;;131      /* Initialize bitread state variables */
;;;132      entropy->bitstate.bits_left = 0;
00032e  2100              MOVS     r1,#0
000330  6121              STR      r1,[r4,#0x10]
;;;133      entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
000332  2000              MOVS     r0,#0
000334  60e0              STR      r0,[r4,#0xc]
;;;134      entropy->pub.insufficient_data = FALSE;
000336  60a0              STR      r0,[r4,#8]
;;;135    
;;;136      /* Initialize restart counter */
;;;137      entropy->restarts_to_go = cinfo->restart_interval;
000338  f8d50114          LDR      r0,[r5,#0x114]
00033c  6260              STR      r0,[r4,#0x24]
;;;138    }
00033e  e8bd87f0          POP      {r4-r10,pc}
;;;139    
                          ENDP

                  jpeg_fill_bit_buffer PROC
;;;291    GLOBAL(boolean)
;;;292    jpeg_fill_bit_buffer (bitread_working_state * state,
000342  e92d5ff0          PUSH     {r4-r12,lr}
;;;293    		      register bit_buf_type get_buffer, register int bits_left,
;;;294    		      int nbits)
;;;295    /* Load up the bit buffer to a depth of at least nbits */
;;;296    {
000346  4605              MOV      r5,r0
000348  468a              MOV      r10,r1
00034a  4616              MOV      r6,r2
00034c  469b              MOV      r11,r3
;;;297      /* Copy heavily used state fields into locals (hopefully registers) */
;;;298      register const JOCTET * next_input_byte = state->next_input_byte;
00034e  f8d58000          LDR      r8,[r5,#0]
;;;299      register size_t bytes_in_buffer = state->bytes_in_buffer;
000352  f8d59004          LDR      r9,[r5,#4]
;;;300      j_decompress_ptr cinfo = state->cinfo;
000356  692c              LDR      r4,[r5,#0x10]
;;;301    
;;;302      /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
;;;303      /* (It is assumed that no request will be for more than that many bits.) */
;;;304      /* We fail to do so only if we hit a marker or are forced to suspend. */
;;;305    
;;;306      if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
000358  f8d401a0          LDR      r0,[r4,#0x1a0]
00035c  2800              CMP      r0,#0
00035e  d13b              BNE      |L1.984|
;;;307        while (bits_left < MIN_GET_BITS) {
000360  e037              B        |L1.978|
                  |L1.866|
;;;308          register int c;
;;;309    
;;;310          /* Attempt to read a byte */
;;;311          if (bytes_in_buffer == 0) {
000362  f1b90f00          CMP      r9,#0
000366  d10d              BNE      |L1.900|
;;;312    	if (! (*cinfo->src->fill_input_buffer) (cinfo))
000368  69a0              LDR      r0,[r4,#0x18]
00036a  68c1              LDR      r1,[r0,#0xc]
00036c  4620              MOV      r0,r4
00036e  4788              BLX      r1
000370  b910              CBNZ     r0,|L1.888|
;;;313    	  return FALSE;
000372  2000              MOVS     r0,#0
                  |L1.884|
;;;314    	next_input_byte = cinfo->src->next_input_byte;
;;;315    	bytes_in_buffer = cinfo->src->bytes_in_buffer;
;;;316          }
;;;317          bytes_in_buffer--;
;;;318          c = GETJOCTET(*next_input_byte++);
;;;319    
;;;320          /* If it's 0xFF, check and discard stuffed zero byte */
;;;321          if (c == 0xFF) {
;;;322    	/* Loop here to discard any padding FF's on terminating marker,
;;;323    	 * so that we can save a valid unread_marker value.  NOTE: we will
;;;324    	 * accept multiple FF's followed by a 0 as meaning a single FF data
;;;325    	 * byte.  This data pattern is not valid according to the standard.
;;;326    	 */
;;;327    	do {
;;;328    	  if (bytes_in_buffer == 0) {
;;;329    	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
;;;330    	      return FALSE;
;;;331    	    next_input_byte = cinfo->src->next_input_byte;
;;;332    	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
;;;333    	  }
;;;334    	  bytes_in_buffer--;
;;;335    	  c = GETJOCTET(*next_input_byte++);
;;;336    	} while (c == 0xFF);
;;;337    
;;;338    	if (c == 0) {
;;;339    	  /* Found FF/00, which represents an FF data byte */
;;;340    	  c = 0xFF;
;;;341    	} else {
;;;342    	  /* Oops, it's actually a marker indicating end of compressed data.
;;;343    	   * Save the marker code for later use.
;;;344    	   * Fine point: it might appear that we should save the marker into
;;;345    	   * bitread working state, not straight into permanent state.  But
;;;346    	   * once we have hit a marker, we cannot need to suspend within the
;;;347    	   * current MCU, because we will read no more bytes from the data
;;;348    	   * source.  So it is OK to update permanent state right away.
;;;349    	   */
;;;350    	  cinfo->unread_marker = c;
;;;351    	  /* See if we need to insert some fake zero bits. */
;;;352    	  goto no_more_bytes;
;;;353    	}
;;;354          }
;;;355    
;;;356          /* OK, load c into get_buffer */
;;;357          get_buffer = (get_buffer << 8) | c;
;;;358          bits_left += 8;
;;;359        } /* end while */
;;;360      } else {
;;;361      no_more_bytes:
;;;362        /* We get here if we've read the marker that terminates the compressed
;;;363         * data segment.  There should be enough bits in the buffer register
;;;364         * to satisfy the request; if so, no problem.
;;;365         */
;;;366        if (nbits > bits_left) {
;;;367          /* Uh-oh.  Report corrupted data to user and stuff zeroes into
;;;368           * the data stream, so that we can produce some kind of image.
;;;369           * We use a nonvolatile flag to ensure that only one warning message
;;;370           * appears per data segment.
;;;371           */
;;;372          if (! cinfo->entropy->insufficient_data) {
;;;373    	WARNMS(cinfo, JWRN_HIT_MARKER);
;;;374    	cinfo->entropy->insufficient_data = TRUE;
;;;375          }
;;;376          /* Fill the buffer with zero bits */
;;;377          get_buffer <<= MIN_GET_BITS - bits_left;
;;;378          bits_left = MIN_GET_BITS;
;;;379        }
;;;380      }
;;;381    
;;;382      /* Unload the local registers */
;;;383      state->next_input_byte = next_input_byte;
;;;384      state->bytes_in_buffer = bytes_in_buffer;
;;;385      state->get_buffer = get_buffer;
;;;386      state->bits_left = bits_left;
;;;387    
;;;388      return TRUE;
;;;389    }
000374  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.888|
000378  69a0              LDR      r0,[r4,#0x18]         ;314
00037a  f8d08000          LDR      r8,[r0,#0]            ;314
00037e  69a0              LDR      r0,[r4,#0x18]         ;315
000380  f8d09004          LDR      r9,[r0,#4]            ;315
                  |L1.900|
000384  f1a90901          SUB      r9,r9,#1              ;317
000388  f8187b01          LDRB     r7,[r8],#1            ;318
00038c  2fff              CMP      r7,#0xff              ;321
00038e  d11c              BNE      |L1.970|
000390  bf00              NOP                            ;327
                  |L1.914|
000392  f1b90f00          CMP      r9,#0                 ;328
000396  d10c              BNE      |L1.946|
000398  69a0              LDR      r0,[r4,#0x18]         ;329
00039a  68c1              LDR      r1,[r0,#0xc]          ;329
00039c  4620              MOV      r0,r4                 ;329
00039e  4788              BLX      r1                    ;329
0003a0  b908              CBNZ     r0,|L1.934|
0003a2  2000              MOVS     r0,#0                 ;330
0003a4  e7e6              B        |L1.884|
                  |L1.934|
0003a6  69a0              LDR      r0,[r4,#0x18]         ;331
0003a8  f8d08000          LDR      r8,[r0,#0]            ;331
0003ac  69a0              LDR      r0,[r4,#0x18]         ;332
0003ae  f8d09004          LDR      r9,[r0,#4]            ;332
                  |L1.946|
0003b2  f1a90901          SUB      r9,r9,#1              ;334
0003b6  f8187b01          LDRB     r7,[r8],#1            ;335
0003ba  2fff              CMP      r7,#0xff              ;336
0003bc  d0e9              BEQ      |L1.914|
0003be  b90f              CBNZ     r7,|L1.964|
0003c0  27ff              MOVS     r7,#0xff              ;340
0003c2  e002              B        |L1.970|
                  |L1.964|
0003c4  f8c471a0          STR      r7,[r4,#0x1a0]        ;350
0003c8  e007              B        |L1.986|
                  |L1.970|
0003ca  ea472a0a          ORR      r10,r7,r10,LSL #8     ;357
0003ce  3608              ADDS     r6,r6,#8              ;358
0003d0  bf00              NOP                            ;359
                  |L1.978|
0003d2  2e19              CMP      r6,#0x19              ;307
0003d4  dbc5              BLT      |L1.866|
0003d6  e018              B        |L1.1034|
                  |L1.984|
0003d8  bf00              NOP                            ;361
                  |L1.986|
0003da  45b3              CMP      r11,r6                ;366
0003dc  dd15              BLE      |L1.1034|
0003de  f8d401bc          LDR      r0,[r4,#0x1bc]        ;372
0003e2  6880              LDR      r0,[r0,#8]            ;372
0003e4  b960              CBNZ     r0,|L1.1024|
0003e6  2075              MOVS     r0,#0x75              ;373
0003e8  6821              LDR      r1,[r4,#0]            ;373
0003ea  6148              STR      r0,[r1,#0x14]         ;373
0003ec  6820              LDR      r0,[r4,#0]            ;373
0003ee  f04f31ff          MOV      r1,#0xffffffff        ;373
0003f2  6842              LDR      r2,[r0,#4]            ;373
0003f4  4620              MOV      r0,r4                 ;373
0003f6  4790              BLX      r2                    ;373
0003f8  2001              MOVS     r0,#1                 ;374
0003fa  f8d411bc          LDR      r1,[r4,#0x1bc]        ;374
0003fe  6088              STR      r0,[r1,#8]            ;374
                  |L1.1024|
000400  f1c60019          RSB      r0,r6,#0x19           ;377
000404  fa0afa00          LSL      r10,r10,r0            ;377
000408  2619              MOVS     r6,#0x19              ;378
                  |L1.1034|
00040a  f8c58000          STR      r8,[r5,#0]            ;383
00040e  f8c59004          STR      r9,[r5,#4]            ;384
000412  f8c5a008          STR      r10,[r5,#8]           ;385
000416  60ee              STR      r6,[r5,#0xc]          ;386
000418  2001              MOVS     r0,#1                 ;388
00041a  e7ab              B        |L1.884|
;;;390    
                          ENDP

                  jpeg_huff_decode PROC
;;;397    GLOBAL(int)
;;;398    jpeg_huff_decode (bitread_working_state * state,
00041c  e92d47f0          PUSH     {r4-r10,lr}
;;;399    		  register bit_buf_type get_buffer, register int bits_left,
;;;400    		  d_derived_tbl * htbl, int min_bits)
;;;401    {
000420  4604              MOV      r4,r0
000422  4688              MOV      r8,r1
000424  4616              MOV      r6,r2
000426  4699              MOV      r9,r3
000428  f8dda020          LDR      r10,[sp,#0x20]
;;;402      register int l = min_bits;
00042c  4655              MOV      r5,r10
;;;403      register INT32 code;
;;;404    
;;;405      /* HUFF_DECODE has determined that the code is at least min_bits */
;;;406      /* bits long, so fetch that many bits in one swoop. */
;;;407    
;;;408      CHECK_BIT_BUFFER(*state, l, return -1);
00042e  42ae              CMP      r6,r5
000430  da0d              BGE      |L1.1102|
000432  462b              MOV      r3,r5
000434  4632              MOV      r2,r6
000436  4641              MOV      r1,r8
000438  4620              MOV      r0,r4
00043a  f7fffffe          BL       jpeg_fill_bit_buffer
00043e  b918              CBNZ     r0,|L1.1096|
000440  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1092|
;;;409      code = GET_BITS(l);
;;;410    
;;;411      /* Collect the rest of the Huffman code one bit at a time. */
;;;412      /* This is per Figure F.16 in the JPEG spec. */
;;;413    
;;;414      while (code > htbl->maxcode[l]) {
;;;415        code <<= 1;
;;;416        CHECK_BIT_BUFFER(*state, 1, return -1);
;;;417        code |= GET_BITS(1);
;;;418        l++;
;;;419      }
;;;420    
;;;421      /* Unload the local registers */
;;;422      state->get_buffer = get_buffer;
;;;423      state->bits_left = bits_left;
;;;424    
;;;425      /* With garbage input we may reach the sentinel value l = 17. */
;;;426    
;;;427      if (l > 16) {
;;;428        WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
;;;429        return 0;			/* fake a zero as the safest result */
;;;430      }
;;;431    
;;;432      return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
;;;433    }
000444  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1096|
000448  f8d48008          LDR      r8,[r4,#8]            ;408
00044c  68e6              LDR      r6,[r4,#0xc]          ;408
                  |L1.1102|
00044e  1b71              SUBS     r1,r6,r5              ;409
000450  460e              MOV      r6,r1                 ;409
000452  fa48f001          ASR      r0,r8,r1              ;409
000456  2101              MOVS     r1,#1                 ;409
000458  40a9              LSLS     r1,r1,r5              ;409
00045a  1e49              SUBS     r1,r1,#1              ;409
00045c  ea000701          AND      r7,r0,r1              ;409
000460  e017              B        |L1.1170|
                  |L1.1122|
000462  007f              LSLS     r7,r7,#1              ;415
000464  2e01              CMP      r6,#1                 ;416
000466  da0c              BGE      |L1.1154|
000468  2301              MOVS     r3,#1                 ;416
00046a  4632              MOV      r2,r6                 ;416
00046c  4641              MOV      r1,r8                 ;416
00046e  4620              MOV      r0,r4                 ;416
000470  f7fffffe          BL       jpeg_fill_bit_buffer
000474  b910              CBNZ     r0,|L1.1148|
000476  f04f30ff          MOV      r0,#0xffffffff        ;416
00047a  e7e3              B        |L1.1092|
                  |L1.1148|
00047c  f8d48008          LDR      r8,[r4,#8]            ;416
000480  68e6              LDR      r6,[r4,#0xc]          ;416
                  |L1.1154|
000482  1e70              SUBS     r0,r6,#1              ;417
000484  4606              MOV      r6,r0                 ;417
000486  fa48f000          ASR      r0,r8,r0              ;417
00048a  f0000001          AND      r0,r0,#1              ;417
00048e  4307              ORRS     r7,r7,r0              ;417
000490  1c6d              ADDS     r5,r5,#1              ;418
                  |L1.1170|
000492  f8590025          LDR      r0,[r9,r5,LSL #2]     ;414
000496  42b8              CMP      r0,r7                 ;414
000498  dbe3              BLT      |L1.1122|
00049a  f8c48008          STR      r8,[r4,#8]            ;422
00049e  60e6              STR      r6,[r4,#0xc]          ;423
0004a0  2d10              CMP      r5,#0x10              ;427
0004a2  dd0b              BLE      |L1.1212|
0004a4  2076              MOVS     r0,#0x76              ;428
0004a6  6921              LDR      r1,[r4,#0x10]         ;428
0004a8  6809              LDR      r1,[r1,#0]            ;428
0004aa  6148              STR      r0,[r1,#0x14]         ;428
0004ac  6920              LDR      r0,[r4,#0x10]         ;428
0004ae  6801              LDR      r1,[r0,#0]            ;428
0004b0  684a              LDR      r2,[r1,#4]            ;428
0004b2  f04f31ff          MOV      r1,#0xffffffff        ;428
0004b6  4790              BLX      r2                    ;428
0004b8  2000              MOVS     r0,#0                 ;429
0004ba  e7c3              B        |L1.1092|
                  |L1.1212|
0004bc  f8d9008c          LDR      r0,[r9,#0x8c]         ;432
0004c0  3011              ADDS     r0,r0,#0x11           ;432
0004c2  f1090148          ADD      r1,r9,#0x48           ;432
0004c6  f8511025          LDR      r1,[r1,r5,LSL #2]     ;432
0004ca  4439              ADD      r1,r1,r7              ;432
0004cc  5c40              LDRB     r0,[r0,r1]            ;432
0004ce  e7b9              B        |L1.1092|
;;;434    
                          ENDP

                  process_restart PROC
;;;467    LOCAL(boolean)
;;;468    process_restart (j_decompress_ptr cinfo)
0004d0  b570              PUSH     {r4-r6,lr}
;;;469    {
0004d2  4604              MOV      r4,r0
;;;470      huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
0004d4  f8d451bc          LDR      r5,[r4,#0x1bc]
;;;471      int ci;
;;;472    
;;;473      /* Throw away any unused bits remaining in bit buffer; */
;;;474      /* include any full bytes in next_marker's count of discarded bytes */
;;;475      cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
0004d8  6928              LDR      r0,[r5,#0x10]
0004da  17c1              ASRS     r1,r0,#31
0004dc  eb007151          ADD      r1,r0,r1,LSR #29
0004e0  f8d421b8          LDR      r2,[r4,#0x1b8]
0004e4  6992              LDR      r2,[r2,#0x18]
0004e6  eb0201e1          ADD      r1,r2,r1,ASR #3
0004ea  f8d421b8          LDR      r2,[r4,#0x1b8]
0004ee  6191              STR      r1,[r2,#0x18]
;;;476      entropy->bitstate.bits_left = 0;
0004f0  2100              MOVS     r1,#0
0004f2  6129              STR      r1,[r5,#0x10]
;;;477    
;;;478      /* Advance past the RSTn marker */
;;;479      if (! (*cinfo->marker->read_restart_marker) (cinfo))
0004f4  f8d401b8          LDR      r0,[r4,#0x1b8]
0004f8  6881              LDR      r1,[r0,#8]
0004fa  4620              MOV      r0,r4
0004fc  4788              BLX      r1
0004fe  b908              CBNZ     r0,|L1.1284|
;;;480        return FALSE;
000500  2000              MOVS     r0,#0
                  |L1.1282|
;;;481    
;;;482      /* Re-initialize DC predictions to 0 */
;;;483      for (ci = 0; ci < cinfo->comps_in_scan; ci++)
;;;484        entropy->saved.last_dc_val[ci] = 0;
;;;485    
;;;486      /* Reset restart counter */
;;;487      entropy->restarts_to_go = cinfo->restart_interval;
;;;488    
;;;489      /* Reset out-of-data flag, unless read_restart_marker left us smack up
;;;490       * against a marker.  In that case we will end up treating the next data
;;;491       * segment as empty, and we can avoid producing bogus output pixels by
;;;492       * leaving the flag set.
;;;493       */
;;;494      if (cinfo->unread_marker == 0)
;;;495        entropy->pub.insufficient_data = FALSE;
;;;496    
;;;497      return TRUE;
;;;498    }
000502  bd70              POP      {r4-r6,pc}
                  |L1.1284|
000504  2600              MOVS     r6,#0                 ;483
000506  e005              B        |L1.1300|
                  |L1.1288|
000508  2100              MOVS     r1,#0                 ;484
00050a  f1050014          ADD      r0,r5,#0x14           ;484
00050e  f8401026          STR      r1,[r0,r6,LSL #2]     ;484
000512  1c76              ADDS     r6,r6,#1              ;483
                  |L1.1300|
000514  f8d40148          LDR      r0,[r4,#0x148]        ;483
000518  42b0              CMP      r0,r6                 ;483
00051a  dcf5              BGT      |L1.1288|
00051c  f8d40114          LDR      r0,[r4,#0x114]        ;487
000520  6268              STR      r0,[r5,#0x24]         ;487
000522  f8d401a0          LDR      r0,[r4,#0x1a0]        ;494
000526  b908              CBNZ     r0,|L1.1324|
000528  2000              MOVS     r0,#0                 ;495
00052a  60a8              STR      r0,[r5,#8]            ;495
                  |L1.1324|
00052c  2001              MOVS     r0,#1                 ;497
00052e  e7e8              B        |L1.1282|
;;;499    
                          ENDP

                  decode_mcu PROC
;;;516    METHODDEF(boolean)
;;;517    decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
000530  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;518    {
000534  b08f              SUB      sp,sp,#0x3c
000536  4680              MOV      r8,r0
;;;519      huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
000538  f8d861bc          LDR      r6,[r8,#0x1bc]
;;;520      int blkn;
;;;521      BITREAD_STATE_VARS;
;;;522      savable_state state;
;;;523    
;;;524      /* Process restart marker if needed; may have to suspend */
;;;525      if (cinfo->restart_interval) {
00053c  f8d80114          LDR      r0,[r8,#0x114]
000540  b160              CBZ      r0,|L1.1372|
;;;526        if (entropy->restarts_to_go == 0)
000542  6a70              LDR      r0,[r6,#0x24]
000544  b950              CBNZ     r0,|L1.1372|
;;;527          if (! process_restart(cinfo))
000546  4640              MOV      r0,r8
000548  f7fffffe          BL       process_restart
00054c  b930              CBNZ     r0,|L1.1372|
;;;528    	return FALSE;
00054e  2000              MOVS     r0,#0
                  |L1.1360|
;;;529      }
;;;530    
;;;531      /* If we've run out of data, just leave the MCU set to zeroes.
;;;532       * This way, we return uniform gray for the remainder of the segment.
;;;533       */
;;;534      if (! entropy->pub.insufficient_data) {
;;;535    
;;;536        /* Load up working state */
;;;537        BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
;;;538        ASSIGN_STATE(state, entropy->saved);
;;;539    
;;;540        /* Outer loop handles each block in the MCU */
;;;541    
;;;542        for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
;;;543          JBLOCKROW block = MCU_data[blkn];
;;;544          d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
;;;545          d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
;;;546          register int s, k, r;
;;;547    
;;;548          /* Decode a single block's worth of coefficients */
;;;549    
;;;550          /* Section F.2.2.1: decode the DC coefficient difference */
;;;551          HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
;;;552          if (s) {
;;;553    	CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;554    	r = GET_BITS(s);
;;;555    	s = HUFF_EXTEND(r, s);
;;;556          }
;;;557    
;;;558          if (entropy->dc_needed[blkn]) {
;;;559    	/* Convert DC difference to actual value, update last_dc_val */
;;;560    	int ci = cinfo->MCU_membership[blkn];
;;;561    	s += state.last_dc_val[ci];
;;;562    	state.last_dc_val[ci] = s;
;;;563    	/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
;;;564    	(*block)[0] = (JCOEF) s;
;;;565          }
;;;566    
;;;567          if (entropy->ac_needed[blkn]) {
;;;568    
;;;569    	/* Section F.2.2.2: decode the AC coefficients */
;;;570    	/* Since zeroes are skipped, output area must be cleared beforehand */
;;;571    	for (k = 1; k < DCTSIZE2; k++) {
;;;572    	  HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
;;;573          
;;;574    	  r = s >> 4;
;;;575    	  s &= 15;
;;;576          
;;;577    	  if (s) {
;;;578    	    k += r;
;;;579    	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;580    	    r = GET_BITS(s);
;;;581    	    s = HUFF_EXTEND(r, s);
;;;582    	    /* Output coefficient in natural (dezigzagged) order.
;;;583    	     * Note: the extra entries in jpeg_natural_order[] will save us
;;;584    	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
;;;585    	     */
;;;586    	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
;;;587    	  } else {
;;;588    	    if (r != 15)
;;;589    	      break;
;;;590    	    k += 15;
;;;591    	  }
;;;592    	}
;;;593    
;;;594          } else {
;;;595    
;;;596    	/* Section F.2.2.2: decode the AC coefficients */
;;;597    	/* In this path we just discard the values */
;;;598    	for (k = 1; k < DCTSIZE2; k++) {
;;;599    	  HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
;;;600          
;;;601    	  r = s >> 4;
;;;602    	  s &= 15;
;;;603          
;;;604    	  if (s) {
;;;605    	    k += r;
;;;606    	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;607    	    DROP_BITS(s);
;;;608    	  } else {
;;;609    	    if (r != 15)
;;;610    	      break;
;;;611    	    k += 15;
;;;612    	  }
;;;613    	}
;;;614    
;;;615          }
;;;616        }
;;;617    
;;;618        /* Completed MCU, so update state */
;;;619        BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
;;;620        ASSIGN_STATE(entropy->saved, state);
;;;621      }
;;;622    
;;;623      /* Account for restart interval (no-op if not using restarts) */
;;;624      entropy->restarts_to_go--;
;;;625    
;;;626      return TRUE;
;;;627    }
000550  b011              ADD      sp,sp,#0x44
000552  e8bd8ff0          POP      {r4-r11,pc}
000556  0000              DCW      0x0000
                  |L1.1368|
                          DCD      0x000fffff
                  |L1.1372|
00055c  68b0              LDR      r0,[r6,#8]            ;534
00055e  2800              CMP      r0,#0                 ;534
000560  d17e              BNE      |L1.1632|
000562  f8cd8038          STR      r8,[sp,#0x38]         ;537
000566  f8d80018          LDR      r0,[r8,#0x18]         ;537
00056a  6800              LDR      r0,[r0,#0]            ;537
00056c  900a              STR      r0,[sp,#0x28]         ;537
00056e  f8d80018          LDR      r0,[r8,#0x18]         ;537
000572  6840              LDR      r0,[r0,#4]            ;537
000574  900b              STR      r0,[sp,#0x2c]         ;537
000576  f8d6b00c          LDR      r11,[r6,#0xc]         ;537
00057a  6935              LDR      r5,[r6,#0x10]         ;537
00057c  e9d62307          LDRD     r2,r3,[r6,#0x1c]      ;538
000580  e9d61005          LDRD     r1,r0,[r6,#0x14]      ;538
000584  ac07              ADD      r4,sp,#0x1c           ;538
000586  c40d              STM      r4!,{r0,r2,r3}        ;538
000588  9106              STR      r1,[sp,#0x18]         ;538
00058a  f04f0900          MOV      r9,#0                 ;542
00058e  e15e              B        |L1.2126|
                  |L1.1424|
000590  9810              LDR      r0,[sp,#0x40]         ;543
000592  f8500029          LDR      r0,[r0,r9,LSL #2]     ;543
000596  9005              STR      r0,[sp,#0x14]         ;543
000598  f1060048          ADD      r0,r6,#0x48           ;544
00059c  f8500029          LDR      r0,[r0,r9,LSL #2]     ;544
0005a0  9004              STR      r0,[sp,#0x10]         ;544
0005a2  f1060070          ADD      r0,r6,#0x70           ;545
0005a6  f8500029          LDR      r0,[r0,r9,LSL #2]     ;545
0005aa  9003              STR      r0,[sp,#0xc]          ;545
0005ac  2d08              CMP      r5,#8                 ;551
0005ae  da10              BGE      |L1.1490|
0005b0  2300              MOVS     r3,#0                 ;551
0005b2  462a              MOV      r2,r5                 ;551
0005b4  4659              MOV      r1,r11                ;551
0005b6  a80a              ADD      r0,sp,#0x28           ;551
0005b8  f7fffffe          BL       jpeg_fill_bit_buffer
0005bc  b908              CBNZ     r0,|L1.1474|
0005be  2000              MOVS     r0,#0                 ;551
0005c0  e7c6              B        |L1.1360|
                  |L1.1474|
0005c2  f8ddb030          LDR      r11,[sp,#0x30]        ;551
0005c6  9d0d              LDR      r5,[sp,#0x34]         ;551
0005c8  2d08              CMP      r5,#8                 ;551
0005ca  da02              BGE      |L1.1490|
0005cc  2001              MOVS     r0,#1                 ;551
0005ce  9002              STR      r0,[sp,#8]            ;551
0005d0  e018              B        |L1.1540|
                  |L1.1490|
0005d2  f1a50008          SUB      r0,r5,#8              ;551
0005d6  fa4bf000          ASR      r0,r11,r0             ;551
0005da  b2c0              UXTB     r0,r0                 ;551
0005dc  9001              STR      r0,[sp,#4]            ;551
0005de  9804              LDR      r0,[sp,#0x10]         ;551
0005e0  f1000190          ADD      r1,r0,#0x90           ;551
0005e4  9801              LDR      r0,[sp,#4]            ;551
0005e6  f8510020          LDR      r0,[r1,r0,LSL #2]     ;551
0005ea  9002              STR      r0,[sp,#8]            ;551
0005ec  b138              CBZ      r0,|L1.1534|
0005ee  9802              LDR      r0,[sp,#8]            ;551
0005f0  1a2d              SUBS     r5,r5,r0              ;551
0005f2  9804              LDR      r0,[sp,#0x10]         ;551
0005f4  f5006092          ADD      r0,r0,#0x490          ;551
0005f8  9901              LDR      r1,[sp,#4]            ;551
0005fa  5c44              LDRB     r4,[r0,r1]            ;551
0005fc  e011              B        |L1.1570|
                  |L1.1534|
0005fe  2009              MOVS     r0,#9                 ;551
000600  9002              STR      r0,[sp,#8]            ;551
000602  bf00              NOP                            ;551
                  |L1.1540|
000604  9802              LDR      r0,[sp,#8]            ;551
000606  9000              STR      r0,[sp,#0]            ;551
000608  462a              MOV      r2,r5                 ;551
00060a  4659              MOV      r1,r11                ;551
00060c  a80a              ADD      r0,sp,#0x28           ;551
00060e  9b04              LDR      r3,[sp,#0x10]         ;551
000610  f7fffffe          BL       jpeg_huff_decode
000614  1e04              SUBS     r4,r0,#0              ;551
000616  da01              BGE      |L1.1564|
000618  2000              MOVS     r0,#0                 ;551
00061a  e799              B        |L1.1360|
                  |L1.1564|
00061c  f8ddb030          LDR      r11,[sp,#0x30]        ;551
000620  9d0d              LDR      r5,[sp,#0x34]         ;551
                  |L1.1570|
000622  b324              CBZ      r4,|L1.1646|
000624  42a5              CMP      r5,r4                 ;553
000626  da0b              BGE      |L1.1600|
000628  4623              MOV      r3,r4                 ;553
00062a  462a              MOV      r2,r5                 ;553
00062c  4659              MOV      r1,r11                ;553
00062e  a80a              ADD      r0,sp,#0x28           ;553
000630  f7fffffe          BL       jpeg_fill_bit_buffer
000634  b908              CBNZ     r0,|L1.1594|
000636  2000              MOVS     r0,#0                 ;553
000638  e78a              B        |L1.1360|
                  |L1.1594|
00063a  f8ddb030          LDR      r11,[sp,#0x30]        ;553
00063e  9d0d              LDR      r5,[sp,#0x34]         ;553
                  |L1.1600|
000640  1b29              SUBS     r1,r5,r4              ;554
000642  460d              MOV      r5,r1                 ;554
000644  fa4bf001          ASR      r0,r11,r1             ;554
000648  2101              MOVS     r1,#1                 ;554
00064a  40a1              LSLS     r1,r1,r4              ;554
00064c  1e49              SUBS     r1,r1,#1              ;554
00064e  ea000a01          AND      r10,r0,r1             ;554
000652  489a              LDR      r0,|L1.2236|
000654  f8500024          LDR      r0,[r0,r4,LSL #2]     ;555
000658  4550              CMP      r0,r10                ;555
00065a  dd06              BLE      |L1.1642|
00065c  4898              LDR      r0,|L1.2240|
00065e  e000              B        |L1.1634|
                  |L1.1632|
000660  e10a              B        |L1.2168|
                  |L1.1634|
000662  f8500024          LDR      r0,[r0,r4,LSL #2]     ;555
000666  4450              ADD      r0,r0,r10             ;555
000668  e000              B        |L1.1644|
                  |L1.1642|
00066a  4650              MOV      r0,r10                ;555
                  |L1.1644|
00066c  4604              MOV      r4,r0                 ;555
                  |L1.1646|
00066e  f1060098          ADD      r0,r6,#0x98           ;558
000672  f8500029          LDR      r0,[r0,r9,LSL #2]     ;558
000676  b170              CBZ      r0,|L1.1686|
000678  f50871b4          ADD      r1,r8,#0x168          ;560
00067c  f8510029          LDR      r0,[r1,r9,LSL #2]     ;560
000680  a906              ADD      r1,sp,#0x18           ;561
000682  f8511020          LDR      r1,[r1,r0,LSL #2]     ;561
000686  440c              ADD      r4,r4,r1              ;561
000688  a906              ADD      r1,sp,#0x18           ;562
00068a  f8414020          STR      r4,[r1,r0,LSL #2]     ;562
00068e  b222              SXTH     r2,r4                 ;564
000690  9905              LDR      r1,[sp,#0x14]         ;564
000692  800a              STRH     r2,[r1,#0]            ;564
000694  bf00              NOP                            ;565
                  |L1.1686|
000696  f10600c0          ADD      r0,r6,#0xc0           ;567
00069a  f8500029          LDR      r0,[r0,r9,LSL #2]     ;567
00069e  2800              CMP      r0,#0                 ;567
0006a0  d077              BEQ      |L1.1938|
0006a2  2701              MOVS     r7,#1                 ;571
0006a4  e072              B        |L1.1932|
                  |L1.1702|
0006a6  2d08              CMP      r5,#8                 ;572
0006a8  da10              BGE      |L1.1740|
0006aa  2300              MOVS     r3,#0                 ;572
0006ac  462a              MOV      r2,r5                 ;572
0006ae  4659              MOV      r1,r11                ;572
0006b0  a80a              ADD      r0,sp,#0x28           ;572
0006b2  f7fffffe          BL       jpeg_fill_bit_buffer
0006b6  b908              CBNZ     r0,|L1.1724|
0006b8  2000              MOVS     r0,#0                 ;572
0006ba  e749              B        |L1.1360|
                  |L1.1724|
0006bc  f8ddb030          LDR      r11,[sp,#0x30]        ;572
0006c0  9d0d              LDR      r5,[sp,#0x34]         ;572
0006c2  2d08              CMP      r5,#8                 ;572
0006c4  da02              BGE      |L1.1740|
0006c6  2001              MOVS     r0,#1                 ;572
0006c8  9002              STR      r0,[sp,#8]            ;572
0006ca  e018              B        |L1.1790|
                  |L1.1740|
0006cc  f1a50008          SUB      r0,r5,#8              ;572
0006d0  fa4bf000          ASR      r0,r11,r0             ;572
0006d4  b2c0              UXTB     r0,r0                 ;572
0006d6  9001              STR      r0,[sp,#4]            ;572
0006d8  9803              LDR      r0,[sp,#0xc]          ;572
0006da  f1000190          ADD      r1,r0,#0x90           ;572
0006de  9801              LDR      r0,[sp,#4]            ;572
0006e0  f8510020          LDR      r0,[r1,r0,LSL #2]     ;572
0006e4  9002              STR      r0,[sp,#8]            ;572
0006e6  b138              CBZ      r0,|L1.1784|
0006e8  9802              LDR      r0,[sp,#8]            ;572
0006ea  1a2d              SUBS     r5,r5,r0              ;572
0006ec  9803              LDR      r0,[sp,#0xc]          ;572
0006ee  f5006092          ADD      r0,r0,#0x490          ;572
0006f2  9901              LDR      r1,[sp,#4]            ;572
0006f4  5c44              LDRB     r4,[r0,r1]            ;572
0006f6  e011              B        |L1.1820|
                  |L1.1784|
0006f8  2009              MOVS     r0,#9                 ;572
0006fa  9002              STR      r0,[sp,#8]            ;572
0006fc  bf00              NOP                            ;572
                  |L1.1790|
0006fe  9802              LDR      r0,[sp,#8]            ;572
000700  9000              STR      r0,[sp,#0]            ;572
000702  462a              MOV      r2,r5                 ;572
000704  4659              MOV      r1,r11                ;572
000706  a80a              ADD      r0,sp,#0x28           ;572
000708  9b03              LDR      r3,[sp,#0xc]          ;572
00070a  f7fffffe          BL       jpeg_huff_decode
00070e  1e04              SUBS     r4,r0,#0              ;572
000710  da01              BGE      |L1.1814|
000712  2000              MOVS     r0,#0                 ;572
000714  e71c              B        |L1.1360|
                  |L1.1814|
000716  f8ddb030          LDR      r11,[sp,#0x30]        ;572
00071a  9d0d              LDR      r5,[sp,#0x34]         ;572
                  |L1.1820|
00071c  ea4f1a24          ASR      r10,r4,#4             ;574
000720  f004040f          AND      r4,r4,#0xf            ;575
000724  b35c              CBZ      r4,|L1.1918|
000726  4457              ADD      r7,r7,r10             ;578
000728  42a5              CMP      r5,r4                 ;579
00072a  da0b              BGE      |L1.1860|
00072c  4623              MOV      r3,r4                 ;579
00072e  462a              MOV      r2,r5                 ;579
000730  4659              MOV      r1,r11                ;579
000732  a80a              ADD      r0,sp,#0x28           ;579
000734  f7fffffe          BL       jpeg_fill_bit_buffer
000738  b908              CBNZ     r0,|L1.1854|
00073a  2000              MOVS     r0,#0                 ;579
00073c  e708              B        |L1.1360|
                  |L1.1854|
00073e  f8ddb030          LDR      r11,[sp,#0x30]        ;579
000742  9d0d              LDR      r5,[sp,#0x34]         ;579
                  |L1.1860|
000744  1b29              SUBS     r1,r5,r4              ;580
000746  460d              MOV      r5,r1                 ;580
000748  fa4bf001          ASR      r0,r11,r1             ;580
00074c  2101              MOVS     r1,#1                 ;580
00074e  40a1              LSLS     r1,r1,r4              ;580
000750  1e49              SUBS     r1,r1,#1              ;580
000752  ea000a01          AND      r10,r0,r1             ;580
000756  4859              LDR      r0,|L1.2236|
000758  f8500024          LDR      r0,[r0,r4,LSL #2]     ;581
00075c  4550              CMP      r0,r10                ;581
00075e  dd04              BLE      |L1.1898|
000760  4857              LDR      r0,|L1.2240|
000762  f8500024          LDR      r0,[r0,r4,LSL #2]     ;581
000766  4450              ADD      r0,r0,r10             ;581
000768  e000              B        |L1.1900|
                  |L1.1898|
00076a  4650              MOV      r0,r10                ;581
                  |L1.1900|
00076c  4604              MOV      r4,r0                 ;581
00076e  b221              SXTH     r1,r4                 ;586
000770  4854              LDR      r0,|L1.2244|
000772  f8502027          LDR      r2,[r0,r7,LSL #2]     ;586
000776  9805              LDR      r0,[sp,#0x14]         ;586
000778  f8201012          STRH     r1,[r0,r2,LSL #1]     ;586
00077c  e005              B        |L1.1930|
                  |L1.1918|
00077e  f1ba0f0f          CMP      r10,#0xf              ;588
000782  d001              BEQ      |L1.1928|
000784  e004              B        |L1.1936|
000786  e004              B        |L1.1938|
                  |L1.1928|
000788  370f              ADDS     r7,r7,#0xf            ;590
                  |L1.1930|
00078a  1c7f              ADDS     r7,r7,#1              ;571
                  |L1.1932|
00078c  2f40              CMP      r7,#0x40              ;571
00078e  db8a              BLT      |L1.1702|
                  |L1.1936|
000790  e05b              B        |L1.2122|
                  |L1.1938|
000792  2701              MOVS     r7,#1                 ;598
000794  e056              B        |L1.2116|
                  |L1.1942|
000796  2d08              CMP      r5,#8                 ;599
000798  da10              BGE      |L1.1980|
00079a  2300              MOVS     r3,#0                 ;599
00079c  462a              MOV      r2,r5                 ;599
00079e  4659              MOV      r1,r11                ;599
0007a0  a80a              ADD      r0,sp,#0x28           ;599
0007a2  f7fffffe          BL       jpeg_fill_bit_buffer
0007a6  b908              CBNZ     r0,|L1.1964|
0007a8  2000              MOVS     r0,#0                 ;599
0007aa  e6d1              B        |L1.1360|
                  |L1.1964|
0007ac  f8ddb030          LDR      r11,[sp,#0x30]        ;599
0007b0  9d0d              LDR      r5,[sp,#0x34]         ;599
0007b2  2d08              CMP      r5,#8                 ;599
0007b4  da02              BGE      |L1.1980|
0007b6  2001              MOVS     r0,#1                 ;599
0007b8  9002              STR      r0,[sp,#8]            ;599
0007ba  e018              B        |L1.2030|
                  |L1.1980|
0007bc  f1a50008          SUB      r0,r5,#8              ;599
0007c0  fa4bf000          ASR      r0,r11,r0             ;599
0007c4  b2c0              UXTB     r0,r0                 ;599
0007c6  9001              STR      r0,[sp,#4]            ;599
0007c8  9803              LDR      r0,[sp,#0xc]          ;599
0007ca  f1000190          ADD      r1,r0,#0x90           ;599
0007ce  9801              LDR      r0,[sp,#4]            ;599
0007d0  f8510020          LDR      r0,[r1,r0,LSL #2]     ;599
0007d4  9002              STR      r0,[sp,#8]            ;599
0007d6  b138              CBZ      r0,|L1.2024|
0007d8  9802              LDR      r0,[sp,#8]            ;599
0007da  1a2d              SUBS     r5,r5,r0              ;599
0007dc  9803              LDR      r0,[sp,#0xc]          ;599
0007de  f5006092          ADD      r0,r0,#0x490          ;599
0007e2  9901              LDR      r1,[sp,#4]            ;599
0007e4  5c44              LDRB     r4,[r0,r1]            ;599
0007e6  e011              B        |L1.2060|
                  |L1.2024|
0007e8  2009              MOVS     r0,#9                 ;599
0007ea  9002              STR      r0,[sp,#8]            ;599
0007ec  bf00              NOP                            ;599
                  |L1.2030|
0007ee  9802              LDR      r0,[sp,#8]            ;599
0007f0  9000              STR      r0,[sp,#0]            ;599
0007f2  462a              MOV      r2,r5                 ;599
0007f4  4659              MOV      r1,r11                ;599
0007f6  a80a              ADD      r0,sp,#0x28           ;599
0007f8  9b03              LDR      r3,[sp,#0xc]          ;599
0007fa  f7fffffe          BL       jpeg_huff_decode
0007fe  1e04              SUBS     r4,r0,#0              ;599
000800  da01              BGE      |L1.2054|
000802  2000              MOVS     r0,#0                 ;599
000804  e6a4              B        |L1.1360|
                  |L1.2054|
000806  f8ddb030          LDR      r11,[sp,#0x30]        ;599
00080a  9d0d              LDR      r5,[sp,#0x34]         ;599
                  |L1.2060|
00080c  ea4f1a24          ASR      r10,r4,#4             ;601
000810  f004040f          AND      r4,r4,#0xf            ;602
000814  b184              CBZ      r4,|L1.2104|
000816  4457              ADD      r7,r7,r10             ;605
000818  42a5              CMP      r5,r4                 ;606
00081a  da0b              BGE      |L1.2100|
00081c  4623              MOV      r3,r4                 ;606
00081e  462a              MOV      r2,r5                 ;606
000820  4659              MOV      r1,r11                ;606
000822  a80a              ADD      r0,sp,#0x28           ;606
000824  f7fffffe          BL       jpeg_fill_bit_buffer
000828  b908              CBNZ     r0,|L1.2094|
00082a  2000              MOVS     r0,#0                 ;606
00082c  e690              B        |L1.1360|
                  |L1.2094|
00082e  f8ddb030          LDR      r11,[sp,#0x30]        ;606
000832  9d0d              LDR      r5,[sp,#0x34]         ;606
                  |L1.2100|
000834  1b2d              SUBS     r5,r5,r4              ;607
000836  e004              B        |L1.2114|
                  |L1.2104|
000838  f1ba0f0f          CMP      r10,#0xf              ;609
00083c  d000              BEQ      |L1.2112|
00083e  e003              B        |L1.2120|
                  |L1.2112|
000840  370f              ADDS     r7,r7,#0xf            ;611
                  |L1.2114|
000842  1c7f              ADDS     r7,r7,#1              ;598
                  |L1.2116|
000844  2f40              CMP      r7,#0x40              ;598
000846  dba6              BLT      |L1.1942|
                  |L1.2120|
000848  bf00              NOP                            ;610
                  |L1.2122|
00084a  f1090901          ADD      r9,r9,#1              ;542
                  |L1.2126|
00084e  f8d80164          LDR      r0,[r8,#0x164]        ;542
000852  4548              CMP      r0,r9                 ;542
000854  f73fae9c          BGT      |L1.1424|
000858  980a              LDR      r0,[sp,#0x28]         ;619
00085a  f8d81018          LDR      r1,[r8,#0x18]         ;619
00085e  6008              STR      r0,[r1,#0]            ;619
000860  980b              LDR      r0,[sp,#0x2c]         ;619
000862  f8d81018          LDR      r1,[r8,#0x18]         ;619
000866  6048              STR      r0,[r1,#4]            ;619
000868  f8c6b00c          STR      r11,[r6,#0xc]         ;619
00086c  6135              STR      r5,[r6,#0x10]         ;619
00086e  a806              ADD      r0,sp,#0x18           ;620
000870  c80f              LDM      r0,{r0-r3}            ;620
000872  f1060414          ADD      r4,r6,#0x14           ;620
000876  c40f              STM      r4!,{r0-r3}           ;620
                  |L1.2168|
000878  6a70              LDR      r0,[r6,#0x24]         ;624
00087a  1e40              SUBS     r0,r0,#1              ;624
00087c  6270              STR      r0,[r6,#0x24]         ;624
00087e  2001              MOVS     r0,#1                 ;626
000880  e666              B        |L1.1360|
;;;628    
                          ENDP

                  jinit_huff_decoder PROC
;;;634    GLOBAL(void)
;;;635    jinit_huff_decoder (j_decompress_ptr cinfo)
000882  b570              PUSH     {r4-r6,lr}
;;;636    {
000884  4606              MOV      r6,r0
;;;637      huff_entropy_ptr entropy;
;;;638      int i;
;;;639    
;;;640      entropy = (huff_entropy_ptr)
000886  6870              LDR      r0,[r6,#4]
000888  22e8              MOVS     r2,#0xe8
00088a  2101              MOVS     r1,#1
00088c  6803              LDR      r3,[r0,#0]
00088e  4630              MOV      r0,r6
000890  4798              BLX      r3
000892  4604              MOV      r4,r0
;;;641        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;642    				SIZEOF(huff_entropy_decoder));
;;;643      cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
000894  f8c641bc          STR      r4,[r6,#0x1bc]
;;;644      entropy->pub.start_pass = start_pass_huff_decoder;
000898  480b              LDR      r0,|L1.2248|
00089a  6020              STR      r0,[r4,#0]
;;;645      entropy->pub.decode_mcu = decode_mcu;
00089c  480b              LDR      r0,|L1.2252|
00089e  6060              STR      r0,[r4,#4]
;;;646    
;;;647      /* Mark tables unallocated */
;;;648      for (i = 0; i < NUM_HUFF_TBLS; i++) {
0008a0  2500              MOVS     r5,#0
0008a2  e008              B        |L1.2230|
                  |L1.2212|
;;;649        entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
0008a4  2100              MOVS     r1,#0
0008a6  f1040038          ADD      r0,r4,#0x38
0008aa  f8401025          STR      r1,[r0,r5,LSL #2]
0008ae  3810              SUBS     r0,r0,#0x10
0008b0  f8401025          STR      r1,[r0,r5,LSL #2]
0008b4  1c6d              ADDS     r5,r5,#1              ;648
                  |L1.2230|
0008b6  2d04              CMP      r5,#4                 ;648
0008b8  dbf4              BLT      |L1.2212|
;;;650      }
;;;651    }
0008ba  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L1.2236|
                          DCD      extend_test
                  |L1.2240|
                          DCD      extend_offset
                  |L1.2244|
                          DCD      jpeg_natural_order
                  |L1.2248|
                          DCD      start_pass_huff_decoder
                  |L1.2252|
                          DCD      decode_mcu

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  extend_test
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000020
                          DCD      0x00000040
                          DCD      0x00000080
                          DCD      0x00000100
                          DCD      0x00000200
                          DCD      0x00000400
                          DCD      0x00000800
                          DCD      0x00001000
                          DCD      0x00002000
                          DCD      0x00004000
                  extend_offset
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0xfffffffd
                          DCD      0xfffffff9
                          DCD      0xfffffff1
                          DCD      0xffffffe1
                          DCD      0xffffffc1
                          DCD      0xffffff81
                          DCD      0xffffff01
                          DCD      0xfffffe01
                          DCD      0xfffffc01
                          DCD      0xfffff801
                          DCD      0xfffff001
                          DCD      0xffffe001
                          DCD      0xffffc001
                          DCD      0xffff8001
