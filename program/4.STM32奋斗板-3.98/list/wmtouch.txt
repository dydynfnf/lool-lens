; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\wmtouch.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\wmtouch.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\wmtouch.crf GUI\WM\WMTouch.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  WM__IsInModalArea PROC
;;;48     */
;;;49     int WM__IsInModalArea(WM_HWIN hWin) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;50       if ((WM__CHWinModal.hWin == 0) || WM__IsAncestor(hWin, WM__CHWinModal.hWin) || (hWin == WM__CHWinModal.hWin)) {
000004  489e              LDR      r0,|L1.640|
000006  8880              LDRH     r0,[r0,#4]  ; WM__CHWinModal
000008  b158              CBZ      r0,|L1.34|
00000a  489d              LDR      r0,|L1.640|
00000c  f9b01004          LDRSH    r1,[r0,#4]  ; WM__CHWinModal
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       WM__IsAncestor
000016  b920              CBNZ     r0,|L1.34|
000018  4899              LDR      r0,|L1.640|
00001a  f9b00004          LDRSH    r0,[r0,#4]  ; WM__CHWinModal
00001e  42a0              CMP      r0,r4
000020  d101              BNE      |L1.38|
                  |L1.34|
;;;51         return 1;
000022  2001              MOVS     r0,#1
                  |L1.36|
;;;52       }
;;;53       return 0;
;;;54     }
000024  bd10              POP      {r4,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;53
000028  e7fc              B        |L1.36|
;;;55     
                          ENDP

                  WM__SendPIDMessage PROC
;;;65     */
;;;66     void WM__SendPIDMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00002a  b5fe              PUSH     {r1-r7,lr}
00002c  4604              MOV      r4,r0
00002e  460d              MOV      r5,r1
;;;67       #if 1
;;;68       WM_HWIN iWin;
;;;69       WM_MESSAGE Msg;
;;;70       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
000030  e8950007          LDM      r5,{r0-r2}
000034  e88d0007          STM      sp,{r0-r2}
;;;71       /* Send notification to all ancestors.
;;;72          We need to check if the window which has received the last message still exists,
;;;73          since it may have deleted itself and its parent as result of the message.
;;;74       */
;;;75       Msg.hWinSrc = hWin;
000038  f8ad4006          STRH     r4,[sp,#6]
;;;76       Msg.MsgId   = WM_TOUCH_CHILD;
00003c  200d              MOVS     r0,#0xd
00003e  9000              STR      r0,[sp,#0]
;;;77       iWin = hWin;
000040  4626              MOV      r6,r4
;;;78       while (WM_IsWindow(iWin)) {
000042  e009              B        |L1.88|
                  |L1.68|
;;;79         iWin = WM_GetParent(iWin);
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       WM_GetParent
00004a  4606              MOV      r6,r0
;;;80         if (iWin) {
00004c  b126              CBZ      r6,|L1.88|
;;;81           Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
00004e  9502              STR      r5,[sp,#8]
;;;82           WM__SendMessageIfEnabled(iWin, &Msg);    /* Send message to the ancestors */
000050  4669              MOV      r1,sp
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       WM__SendMessageIfEnabled
                  |L1.88|
000058  4630              MOV      r0,r6                 ;78
00005a  f7fffffe          BL       WM_IsWindow
00005e  2800              CMP      r0,#0                 ;78
000060  d1f0              BNE      |L1.68|
;;;83         }
;;;84       }
;;;85       /* Send message to the affected window */
;;;86       WM__SendMessageIfEnabled(hWin, pMsg);
000062  4629              MOV      r1,r5
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       WM__SendMessageIfEnabled
;;;87       #else
;;;88       WM_MESSAGE Msg;
;;;89       /* Send message to the affected window */
;;;90       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
;;;91       WM__SendMessageIfEnabled(hWin, &Msg);
;;;92       /* Send notification to all ancestors.
;;;93          We need to check if the window which has received the last message still exists,
;;;94          since it may have deleted itself and its parent as result of the message.
;;;95       */
;;;96       Msg.hWinSrc = hWin;
;;;97       Msg.MsgId   = WM_TOUCH_CHILD;
;;;98       while (WM_IsWindow(hWin)) {
;;;99         hWin = WM_GetParent(hWin);
;;;100        if (hWin) {
;;;101          Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
;;;102          WM__SendMessageIfEnabled(hWin, &Msg);    /* Send message to the ancestors */
;;;103        }
;;;104      }
;;;105      #endif
;;;106    }
00006a  bdfe              POP      {r1-r7,pc}
;;;107    
                          ENDP

                  WM__SendTouchMessage PROC
;;;111    */
;;;112    void WM__SendTouchMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00006c  e92d41f0          PUSH     {r4-r8,lr}
000070  4607              MOV      r7,r0
000072  460d              MOV      r5,r1
;;;113      GUI_PID_STATE* pState;
;;;114      pState     = (GUI_PID_STATE*)pMsg->Data.p;
000074  68ac              LDR      r4,[r5,#8]
;;;115      if (pState) {
000076  b174              CBZ      r4,|L1.150|
;;;116        WM_Obj* pWin;
;;;117        pWin       = WM_H2P(hWin);
000078  4638              MOV      r0,r7
00007a  f7fffffe          BL       GUI_ALLOC_h2p
00007e  4606              MOV      r6,r0
;;;118        pState->x -= pWin->Rect.x0;
000080  f9b61000          LDRSH    r1,[r6,#0]
000084  6820              LDR      r0,[r4,#0]
000086  1a40              SUBS     r0,r0,r1
000088  6020              STR      r0,[r4,#0]
;;;119        pState->y -= pWin->Rect.y0;
00008a  f9b61002          LDRSH    r1,[r6,#2]
00008e  6860              LDR      r0,[r4,#4]
000090  1a40              SUBS     r0,r0,r1
000092  6060              STR      r0,[r4,#4]
;;;120      }
000094  bf00              NOP      
                  |L1.150|
;;;121      WM__SendPIDMessage(hWin, pMsg);
000096  4629              MOV      r1,r5
000098  4638              MOV      r0,r7
00009a  f7fffffe          BL       WM__SendPIDMessage
;;;122    }
00009e  e8bd81f0          POP      {r4-r8,pc}
;;;123    
                          ENDP

                  _Screen2Win PROC
;;;133    */
;;;134    static WM_HWIN _Screen2Win(GUI_PID_STATE* pState) {
0000a2  b510              PUSH     {r4,lr}
0000a4  4604              MOV      r4,r0
;;;135      if (WM__hCapture == 0) {
0000a6  4877              LDR      r0,|L1.644|
0000a8  8800              LDRH     r0,[r0,#0]  ; WM__hCapture
0000aa  b920              CBNZ     r0,|L1.182|
;;;136        return WM_Screen2hWin(pState->x, pState->y);
0000ac  e9d40100          LDRD     r0,r1,[r4,#0]
0000b0  f7fffffe          BL       WM_Screen2hWin
                  |L1.180|
;;;137      } 
;;;138      return WM__hCapture;
;;;139    }
0000b4  bd10              POP      {r4,pc}
                  |L1.182|
0000b6  4873              LDR      r0,|L1.644|
0000b8  f9b00000          LDRSH    r0,[r0,#0]            ;138  ; WM__hCapture
0000bc  e7fa              B        |L1.180|
;;;140    
                          ENDP

                  WM_HandlePID PROC
;;;157    */
;;;158    int WM_HandlePID(void) {
0000be  b570              PUSH     {r4-r6,lr}
0000c0  b092              SUB      sp,sp,#0x48
;;;159      int r = 0;
0000c2  2600              MOVS     r6,#0
;;;160      WM_MESSAGE Msg;
;;;161      WM_CRITICAL_HANDLE CHWin;
;;;162      GUI_PID_STATE State = {0}, StateNew;
0000c4  2000              MOVS     r0,#0
0000c6  900a              STR      r0,[sp,#0x28]
0000c8  900b              STR      r0,[sp,#0x2c]
0000ca  900c              STR      r0,[sp,#0x30]
;;;163      GUI_PID_GetState(&StateNew);
0000cc  a807              ADD      r0,sp,#0x1c
0000ce  f7fffffe          BL       GUI_PID_GetState
;;;164      WM_LOCK();
;;;165      StateNew.x += GUI_OrgX;
0000d2  496d              LDR      r1,|L1.648|
0000d4  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgX
0000d8  9807              LDR      r0,[sp,#0x1c]
0000da  4408              ADD      r0,r0,r1
0000dc  9007              STR      r0,[sp,#0x1c]
;;;166      StateNew.y += GUI_OrgY;
0000de  496b              LDR      r1,|L1.652|
0000e0  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgY
0000e4  9808              LDR      r0,[sp,#0x20]
0000e6  4408              ADD      r0,r0,r1
0000e8  9008              STR      r0,[sp,#0x20]
;;;167      WM__AddCriticalHandle(&CHWin);
0000ea  a80d              ADD      r0,sp,#0x34
0000ec  f7fffffe          BL       WM__AddCriticalHandle
;;;168      if ((WM_PID__StateLast.x != StateNew.x) || (WM_PID__StateLast.y != StateNew.y) || (WM_PID__StateLast.Pressed != StateNew.Pressed)) {
0000f0  4867              LDR      r0,|L1.656|
0000f2  6800              LDR      r0,[r0,#0]  ; WM_PID__StateLast
0000f4  9907              LDR      r1,[sp,#0x1c]
0000f6  4288              CMP      r0,r1
0000f8  d10a              BNE      |L1.272|
0000fa  4865              LDR      r0,|L1.656|
0000fc  6840              LDR      r0,[r0,#4]  ; WM_PID__StateLast
0000fe  9908              LDR      r1,[sp,#0x20]
000100  4288              CMP      r0,r1
000102  d105              BNE      |L1.272|
000104  4862              LDR      r0,|L1.656|
000106  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
000108  f89d1024          LDRB     r1,[sp,#0x24]
00010c  4288              CMP      r0,r1
00010e  d071              BEQ      |L1.500|
                  |L1.272|
;;;169        #if GUI_SUPPORT_CURSOR
;;;170          GUI_CURSOR_SetPosition(StateNew.x, StateNew.y);
;;;171        #endif
;;;172        CHWin.hWin = _Screen2Win(&StateNew);
000110  a807              ADD      r0,sp,#0x1c
000112  f7fffffe          BL       _Screen2Win
000116  f8ad0038          STRH     r0,[sp,#0x38]
;;;173        #if GUI_SUPPORT_MOUSE
;;;174        /* Send WM_MOUSEOVER_END Message */
;;;175        if (WM__CHWinMouseOver.hWin && (WM__CHWinMouseOver.hWin != CHWin.hWin)) {
;;;176          if (WM__IsInModalArea(WM__CHWinMouseOver.hWin)) {
;;;177            /* Do not send messages to disabled windows */
;;;178            if (WM__IsEnabled(WM__CHWinMouseOver.hWin)) {
;;;179              State      = StateNew;
;;;180              Msg.MsgId  = WM_MOUSEOVER_END;
;;;181              Msg.Data.p = (void*)&State;
;;;182              WM__SendTouchMessage(WM__CHWinMouseOver.hWin, &Msg);
;;;183              WM__CHWinMouseOver.hWin = 0;
;;;184            }
;;;185          }
;;;186        }
;;;187        #endif
;;;188        if (WM__IsInModalArea(CHWin.hWin)) {
00011a  f9bd0038          LDRSH    r0,[sp,#0x38]
00011e  f7fffffe          BL       WM__IsInModalArea
000122  2800              CMP      r0,#0
000124  d067              BEQ      |L1.502|
;;;189          #if GUI_SUPPORT_MOUSE
;;;190            WM__CHWinMouseOver.hWin = CHWin.hWin;
;;;191          #endif
;;;192          /*
;;;193           * Send WM_PID_STATE_CHANGED message if state has changed (just pressed or just released)
;;;194           */
;;;195          if ((WM_PID__StateLast.Pressed != StateNew.Pressed) && CHWin.hWin) {
000126  485a              LDR      r0,|L1.656|
000128  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
00012a  f89d1024          LDRB     r1,[sp,#0x24]
00012e  4288              CMP      r0,r1
000130  d046              BEQ      |L1.448|
000132  f8bd0038          LDRH     r0,[sp,#0x38]
000136  2800              CMP      r0,#0
000138  d042              BEQ      |L1.448|
;;;196            GUI_PID_STATE PID_StateOld;
;;;197            WM_HWIN hWinOld;
;;;198            WM_PID_STATE_CHANGED_INFO Info;
;;;199            WM_Obj* pWin;
;;;200            pWin = WM_H2P(CHWin.hWin);
00013a  f9bd0038          LDRSH    r0,[sp,#0x38]
00013e  f7fffffe          BL       GUI_ALLOC_h2p
000142  4605              MOV      r5,r0
;;;201            Info.State     = StateNew.Pressed;
000144  f89d0024          LDRB     r0,[sp,#0x24]
000148  f88d000c          STRB     r0,[sp,#0xc]
;;;202            Info.StatePrev = WM_PID__StateLast.Pressed;
00014c  4850              LDR      r0,|L1.656|
00014e  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
000150  f88d000d          STRB     r0,[sp,#0xd]
;;;203            Info.x         = StateNew.x - pWin->Rect.x0;
000154  f9b51000          LDRSH    r1,[r5,#0]
000158  9807              LDR      r0,[sp,#0x1c]
00015a  1a40              SUBS     r0,r0,r1
00015c  9001              STR      r0,[sp,#4]
;;;204            Info.y         = StateNew.y - pWin->Rect.y0;
00015e  f9b51002          LDRSH    r1,[r5,#2]
000162  9808              LDR      r0,[sp,#0x20]
000164  1a40              SUBS     r0,r0,r1
000166  9002              STR      r0,[sp,#8]
;;;205            Msg.Data.p = &Info;
000168  a801              ADD      r0,sp,#4
00016a  9011              STR      r0,[sp,#0x44]
;;;206            Msg.MsgId  = WM_PID_STATE_CHANGED;
00016c  2011              MOVS     r0,#0x11
00016e  900f              STR      r0,[sp,#0x3c]
;;;207            /* Make sure that this routine does not react a second time on the same press event.
;;;208             * This could happen if for example a dialog is executed during the WM_PID_STATE_CHANGED message processing
;;;209             */
;;;210            PID_StateOld = WM_PID__StateLast;
000170  4a47              LDR      r2,|L1.656|
000172  e9d21000          LDRD     r1,r0,[r2,#0]
000176  6892              LDR      r2,[r2,#8]  ; WM_PID__StateLast
000178  e9cd0205          STRD     r0,r2,[sp,#0x14]
00017c  9104              STR      r1,[sp,#0x10]
;;;211            /* Make sure that in case of creating a new window over the current PID position
;;;212             * during the WM_PID_STATE_CHANGED message processing the old window
;;;213             * will be informed that it is no longer pressed.
;;;214             */
;;;215            WM_PID__StateLast.Pressed = StateNew.Pressed;
00017e  f89d0024          LDRB     r0,[sp,#0x24]
000182  4943              LDR      r1,|L1.656|
000184  7208              STRB     r0,[r1,#8]
;;;216            if (State.Pressed) {
000186  f89d0030          LDRB     r0,[sp,#0x30]
00018a  b138              CBZ      r0,|L1.412|
;;;217              hWinOld            = WM__CHWinLast.hWin;
00018c  4841              LDR      r0,|L1.660|
00018e  f9b04004          LDRSH    r4,[r0,#4]  ; WM__CHWinLast
;;;218              WM__CHWinLast.hWin = CHWin.hWin;
000192  f8bd0038          LDRH     r0,[sp,#0x38]
000196  493f              LDR      r1,|L1.660|
000198  8088              STRH     r0,[r1,#4]
00019a  e000              B        |L1.414|
                  |L1.412|
;;;219            } else {
;;;220              hWinOld            = 0;
00019c  2400              MOVS     r4,#0
                  |L1.414|
;;;221            }
;;;222            WM__SendMessageIfEnabled(CHWin.hWin, &Msg);
00019e  f9bd0038          LDRSH    r0,[sp,#0x38]
0001a2  a90f              ADD      r1,sp,#0x3c
0001a4  f7fffffe          BL       WM__SendMessageIfEnabled
;;;223            /* Restore state for further processing */
;;;224            WM_PID__StateLast = PID_StateOld;
0001a8  4839              LDR      r0,|L1.656|
0001aa  a904              ADD      r1,sp,#0x10
0001ac  c90e              LDM      r1,{r1-r3}
0001ae  c00e              STM      r0!,{r1-r3}
;;;225            if (hWinOld) {
0001b0  b12c              CBZ      r4,|L1.446|
;;;226              /* hWinOld could be deleted during message processing. So check if it is a Window
;;;227               * before using it.
;;;228               */
;;;229              if (WM_IsWindow(hWinOld)) {
0001b2  4620              MOV      r0,r4
0001b4  f7fffffe          BL       WM_IsWindow
0001b8  b108              CBZ      r0,|L1.446|
;;;230                WM__CHWinLast.hWin        = hWinOld;
0001ba  4836              LDR      r0,|L1.660|
0001bc  8084              STRH     r4,[r0,#4]
                  |L1.446|
;;;231              }
;;;232            }
;;;233          }
0001be  bf00              NOP      
                  |L1.448|
;;;234          /*
;;;235           * Send WM_TOUCH message(s)
;;;236           * Note that we may have to send 2 touch messages.
;;;237           */
;;;238          if (WM_PID__StateLast.Pressed | StateNew.Pressed) {    /* Only if pressed or just released */
0001c0  4833              LDR      r0,|L1.656|
0001c2  7a00              LDRB     r0,[r0,#8]  ; WM_PID__StateLast
0001c4  f89d1024          LDRB     r1,[sp,#0x24]
0001c8  4308              ORRS     r0,r0,r1
0001ca  2800              CMP      r0,#0
0001cc  d04a              BEQ      |L1.612|
;;;239            Msg.MsgId = WM_TOUCH;
0001ce  200c              MOVS     r0,#0xc
0001d0  900f              STR      r0,[sp,#0x3c]
;;;240            r = 1;
0001d2  2601              MOVS     r6,#1
;;;241            /*
;;;242             * Tell window if it is no longer pressed
;;;243             * This happens for 2 possible reasons:
;;;244             * a) PID is released
;;;245             * b) PID is moved out
;;;246             */
;;;247            if (WM__CHWinLast.hWin != CHWin.hWin) {
0001d4  482f              LDR      r0,|L1.660|
0001d6  f9b00004          LDRSH    r0,[r0,#4]  ; WM__CHWinLast
0001da  f9bd1038          LDRSH    r1,[sp,#0x38]
0001de  4288              CMP      r0,r1
0001e0  d01e              BEQ      |L1.544|
;;;248              if (WM__CHWinLast.hWin != 0) {
0001e2  482c              LDR      r0,|L1.660|
0001e4  8880              LDRH     r0,[r0,#4]  ; WM__CHWinLast
0001e6  b1d8              CBZ      r0,|L1.544|
;;;249                if (StateNew.Pressed) {
0001e8  f89d0024          LDRB     r0,[sp,#0x24]
0001ec  b120              CBZ      r0,|L1.504|
;;;250                  /* Moved out -> no longer in this window
;;;251                   * Send a NULL pointer as data
;;;252                   */
;;;253                  Msg.Data.p = NULL;
0001ee  2000              MOVS     r0,#0
0001f0  9011              STR      r0,[sp,#0x44]
0001f2  e00c              B        |L1.526|
                  |L1.500|
0001f4  e03d              B        |L1.626|
                  |L1.502|
0001f6  e035              B        |L1.612|
                  |L1.504|
;;;254                } else {
;;;255                  /* Last window needs to know that it has been "Released"
;;;256                   * Send last coordinates 
;;;257                   */
;;;258                  State.x       = WM_PID__StateLast.x;
0001f8  4825              LDR      r0,|L1.656|
0001fa  6800              LDR      r0,[r0,#0]  ; WM_PID__StateLast
0001fc  900a              STR      r0,[sp,#0x28]
;;;259                  State.y       = WM_PID__StateLast.y;
0001fe  4824              LDR      r0,|L1.656|
000200  6840              LDR      r0,[r0,#4]  ; WM_PID__StateLast
000202  900b              STR      r0,[sp,#0x2c]
;;;260                  State.Pressed = 0;
000204  2000              MOVS     r0,#0
000206  f88d0030          STRB     r0,[sp,#0x30]
;;;261                  Msg.Data.p = (void*)&State;
00020a  a80a              ADD      r0,sp,#0x28
00020c  9011              STR      r0,[sp,#0x44]
                  |L1.526|
;;;262                }
;;;263                GUI_DEBUG_LOG1 ("\nSending WM_Touch to LastWindow %d (out of area)", WM__CHWinLast.hWin);
;;;264                WM__SendTouchMessage(WM__CHWinLast.hWin, &Msg);
00020e  4921              LDR      r1,|L1.660|
000210  f9b10004          LDRSH    r0,[r1,#4]  ; WM__CHWinLast
000214  a90f              ADD      r1,sp,#0x3c
000216  f7fffffe          BL       WM__SendTouchMessage
;;;265                WM__CHWinLast.hWin = 0;
00021a  2000              MOVS     r0,#0
00021c  491d              LDR      r1,|L1.660|
00021e  8088              STRH     r0,[r1,#4]
                  |L1.544|
;;;266              }
;;;267            }
;;;268            /* Make sure that this routine does not react a second time on the same event.
;;;269             * This could happen if for example a dialog is executed during the WM_TOUCH message processing
;;;270             */
;;;271            WM_PID__StateLast.Pressed = StateNew.Pressed;
000220  f89d0024          LDRB     r0,[sp,#0x24]
000224  491a              LDR      r1,|L1.656|
000226  7208              STRB     r0,[r1,#8]
;;;272            /* Sending WM_Touch to current window */
;;;273            if (CHWin.hWin) {
000228  f8bd0038          LDRH     r0,[sp,#0x38]
00022c  b1d0              CBZ      r0,|L1.612|
;;;274              /* convert screen into window coordinates */
;;;275              State = StateNew;
00022e  a807              ADD      r0,sp,#0x1c
000230  c807              LDM      r0,{r0-r2}
000232  ab0a              ADD      r3,sp,#0x28
000234  c307              STM      r3!,{r0-r2}
;;;276              /* Remember window */
;;;277              if (State.Pressed) {
000236  f89d0030          LDRB     r0,[sp,#0x30]
00023a  b120              CBZ      r0,|L1.582|
;;;278                WM__CHWinLast.hWin = CHWin.hWin;
00023c  f8bd0038          LDRH     r0,[sp,#0x38]
000240  4914              LDR      r1,|L1.660|
000242  8088              STRH     r0,[r1,#4]
000244  e007              B        |L1.598|
                  |L1.582|
;;;279              } else {
;;;280                /* Handle automatic capture release */
;;;281                if (WM__CaptureReleaseAuto) {
000246  4814              LDR      r0,|L1.664|
000248  7800              LDRB     r0,[r0,#0]  ; WM__CaptureReleaseAuto
00024a  b108              CBZ      r0,|L1.592|
;;;282                  WM_ReleaseCapture();
00024c  f7fffffe          BL       WM_ReleaseCapture
                  |L1.592|
;;;283                }
;;;284                WM__CHWinLast.hWin = 0;
000250  2000              MOVS     r0,#0
000252  4910              LDR      r1,|L1.660|
000254  8088              STRH     r0,[r1,#4]
                  |L1.598|
;;;285              }
;;;286              Msg.Data.p = (void*)&State;
000256  a80a              ADD      r0,sp,#0x28
000258  9011              STR      r0,[sp,#0x44]
;;;287              WM__SendTouchMessage(CHWin.hWin, &Msg);
00025a  f9bd0038          LDRSH    r0,[sp,#0x38]
00025e  a90f              ADD      r1,sp,#0x3c
000260  f7fffffe          BL       WM__SendTouchMessage
                  |L1.612|
;;;288            }
;;;289          }
;;;290          /*
;;;291           * Send WM_MOUSEOVER message
;;;292           */
;;;293          #if GUI_SUPPORT_MOUSE
;;;294          else {
;;;295            /* Send WM_MOUSEOVER Message */
;;;296            if (CHWin.hWin) {
;;;297              /* Do not send messages to disabled windows */
;;;298              if (WM__IsEnabled(CHWin.hWin)) {
;;;299                State      = StateNew;
;;;300                Msg.MsgId  = WM_MOUSEOVER;
;;;301                Msg.Data.p = (void*)&State;
;;;302                WM__SendTouchMessage(CHWin.hWin, &Msg);
;;;303              }
;;;304            }
;;;305          }
;;;306          #endif
;;;307        }
;;;308        /* Store the new state */
;;;309        WM_PID__StateLast = StateNew;
000264  480a              LDR      r0,|L1.656|
000266  a907              ADD      r1,sp,#0x1c
000268  c90e              LDM      r1,{r1-r3}
00026a  c00e              STM      r0!,{r1-r3}
;;;310        WM_PID__SetPrevState(&StateNew);
00026c  a807              ADD      r0,sp,#0x1c
00026e  f7fffffe          BL       WM_PID__SetPrevState
                  |L1.626|
;;;311      }
;;;312      WM__RemoveCriticalHandle(&CHWin);
000272  a80d              ADD      r0,sp,#0x34
000274  f7fffffe          BL       WM__RemoveCriticalHandle
;;;313      WM_UNLOCK();
;;;314      return r;
000278  4630              MOV      r0,r6
;;;315    }
00027a  b012              ADD      sp,sp,#0x48
00027c  bd70              POP      {r4-r6,pc}
;;;316    
                          ENDP

00027e  0000              DCW      0x0000
                  |L1.640|
                          DCD      WM__CHWinModal
                  |L1.644|
                          DCD      WM__hCapture
                  |L1.648|
                          DCD      GUI_OrgX
                  |L1.652|
                          DCD      GUI_OrgY
                  |L1.656|
                          DCD      WM_PID__StateLast
                  |L1.660|
                          DCD      WM__CHWinLast
                  |L1.664|
                          DCD      WM__CaptureReleaseAuto

                          AREA ||.data||, DATA, ALIGN=2

                  WM__CHWinModal
                          %        8
                  WM__CHWinLast
                          %        8
