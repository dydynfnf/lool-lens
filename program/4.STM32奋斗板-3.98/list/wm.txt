; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\wm.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\wm.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\wm.crf GUI\WM\WM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _CheckCriticalHandles PROC
;;;99     */
;;;100    static void _CheckCriticalHandles(WM_HWIN hWin) {
000000  4601              MOV      r1,r0
;;;101      WM_CRITICAL_HANDLE * pCH;
;;;102      for (pCH = WM__pFirstCriticalHandle; pCH; pCH = pCH->pNext) {
000002  4afd              LDR      r2,|L1.1016|
000004  6810              LDR      r0,[r2,#0]  ; WM__pFirstCriticalHandle
000006  e006              B        |L1.22|
                  |L1.8|
;;;103        if (pCH->hWin == hWin) {
000008  f9b02004          LDRSH    r2,[r0,#4]
00000c  428a              CMP      r2,r1
00000e  d101              BNE      |L1.20|
;;;104          pCH->hWin = 0;
000010  2200              MOVS     r2,#0
000012  8082              STRH     r2,[r0,#4]
                  |L1.20|
000014  6800              LDR      r0,[r0,#0]            ;102
                  |L1.22|
000016  2800              CMP      r0,#0                 ;102
000018  d1f6              BNE      |L1.8|
;;;105        }
;;;106      }
;;;107    }
00001a  4770              BX       lr
;;;108    
                          ENDP

                  _DesktopHandle2Index PROC
;;;119    */
;;;120    static int _DesktopHandle2Index(WM_HWIN hDesktop) {
00001c  4601              MOV      r1,r0
;;;121    #if GUI_NUM_LAYERS > 1
;;;122      int i;
;;;123      for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;124        if (hDesktop == WM__ahDesktopWin[i]) {
;;;125          return i;
;;;126        }
;;;127      }
;;;128    #else
;;;129      if (hDesktop == WM__ahDesktopWin[0]) {
00001e  48f7              LDR      r0,|L1.1020|
000020  f9b00000          LDRSH    r0,[r0,#0]  ; WM__ahDesktopWin
000024  4288              CMP      r0,r1
000026  d101              BNE      |L1.44|
;;;130        return 0;
000028  2000              MOVS     r0,#0
                  |L1.42|
;;;131      }
;;;132    #endif
;;;133      return -1;
;;;134    }
00002a  4770              BX       lr
                  |L1.44|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;133
000030  e7fb              B        |L1.42|
;;;135    
                          ENDP

                  ResetNextDrawWin PROC
;;;155    */
;;;156    static void ResetNextDrawWin(void) {
000032  2000              MOVS     r0,#0
;;;157      NextDrawWin = WM_HWIN_NULL;
000034  49f2              LDR      r1,|L1.1024|
000036  8008              STRH     r0,[r1,#0]
;;;158    }
000038  4770              BX       lr
;;;159    
                          ENDP

                  _GethDrawWin PROC
;;;167    */
;;;168    static WM_HWIN _GethDrawWin(void) {
00003a  49f2              LDR      r1,|L1.1028|
;;;169      WM_HWIN h;
;;;170      #if WM_SUPPORT_TRANSPARENCY
;;;171        if (WM__hATransWindow) {
00003c  8809              LDRH     r1,[r1,#0]  ; WM__hATransWindow
00003e  b119              CBZ      r1,|L1.72|
;;;172          h = WM__hATransWindow;
000040  49f0              LDR      r1,|L1.1028|
000042  f9b10000          LDRSH    r0,[r1,#0]  ; WM__hATransWindow
000046  e002              B        |L1.78|
                  |L1.72|
;;;173        } else
;;;174      #endif
;;;175      {
;;;176        h = GUI_Context.hAWin;
000048  49ef              LDR      r1,|L1.1032|
00004a  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
                  |L1.78|
;;;177      }
;;;178      return h;
;;;179    }
00004e  4770              BX       lr
;;;180    
                          ENDP

                  WM__Client2Screen PROC
;;;462    */
;;;463    void WM__Client2Screen(const WM_Obj* pWin, GUI_RECT *pRect) {
000050  b570              PUSH     {r4-r6,lr}
000052  4604              MOV      r4,r0
000054  460d              MOV      r5,r1
;;;464      GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
000056  f9b42002          LDRSH    r2,[r4,#2]
00005a  f9b41000          LDRSH    r1,[r4,#0]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       GUI_MoveRect
;;;465    }
000064  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP

                  _SetClipRectUserIntersect PROC
;;;184    */
;;;185    static void _SetClipRectUserIntersect(const GUI_RECT* prSrc) {
000066  b57c              PUSH     {r2-r6,lr}
000068  4604              MOV      r4,r0
;;;186      if (GUI_Context.WM__pUserClipRect == NULL) {
00006a  48e7              LDR      r0,|L1.1032|
00006c  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
00006e  b918              CBNZ     r0,|L1.120|
;;;187        LCD_SetClipRectEx(prSrc);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       LCD_SetClipRectEx
000076  e016              B        |L1.166|
                  |L1.120|
;;;188      } else {
;;;189        GUI_RECT r;
;;;190        r = *GUI_Context.WM__pUserClipRect;             
000078  48e3              LDR      r0,|L1.1032|
00007a  6b80              LDR      r0,[r0,#0x38]  ; GUI_Context
00007c  6801              LDR      r1,[r0,#0]
00007e  9100              STR      r1,[sp,#0]
000080  6840              LDR      r0,[r0,#4]
000082  9001              STR      r0,[sp,#4]
;;;191        WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
000084  f7fffffe          BL       _GethDrawWin
000088  4606              MOV      r6,r0
00008a  f7fffffe          BL       GUI_ALLOC_h2p
00008e  4605              MOV      r5,r0
000090  4669              MOV      r1,sp
000092  f7fffffe          BL       WM__Client2Screen
;;;192        /* Set intersection as clip rect */    
;;;193        GUI__IntersectRect(&r, prSrc);
000096  4621              MOV      r1,r4
000098  4668              MOV      r0,sp
00009a  f7fffffe          BL       GUI__IntersectRect
;;;194        LCD_SetClipRectEx(&r);
00009e  4668              MOV      r0,sp
0000a0  f7fffffe          BL       LCD_SetClipRectEx
;;;195      }
0000a4  bf00              NOP      
                  |L1.166|
;;;196    }
0000a6  bd7c              POP      {r2-r6,pc}
;;;197    
                          ENDP

                  WM__RectIsNZ PROC
;;;613    */
;;;614    int WM__RectIsNZ(const GUI_RECT* pr) {
0000a8  4601              MOV      r1,r0
;;;615      if (pr->x0 > pr->x1)
0000aa  f9b10000          LDRSH    r0,[r1,#0]
0000ae  f9b12004          LDRSH    r2,[r1,#4]
0000b2  4290              CMP      r0,r2
0000b4  dd01              BLE      |L1.186|
;;;616        return 0;
0000b6  2000              MOVS     r0,#0
                  |L1.184|
;;;617      if (pr->y0 > pr->y1)
;;;618        return 0;
;;;619      return 1;
;;;620    }
0000b8  4770              BX       lr
                  |L1.186|
0000ba  f9b10002          LDRSH    r0,[r1,#2]            ;617
0000be  f9b12006          LDRSH    r2,[r1,#6]            ;617
0000c2  4290              CMP      r0,r2                 ;617
0000c4  dd01              BLE      |L1.202|
0000c6  2000              MOVS     r0,#0                 ;618
0000c8  e7f6              B        |L1.184|
                  |L1.202|
0000ca  2001              MOVS     r0,#1                 ;619
0000cc  e7f4              B        |L1.184|
;;;621    
                          ENDP

                  WM__Invalidate1Abs PROC
;;;209    */
;;;210    void WM__Invalidate1Abs(WM_HWIN hWin, const GUI_RECT * pRect) {
0000ce  e92d41fc          PUSH     {r2-r8,lr}
0000d2  4607              MOV      r7,r0
0000d4  460d              MOV      r5,r1
;;;211      GUI_RECT r;
;;;212      WM_Obj* pWin;
;;;213      int Status;
;;;214      pWin = WM_H2P(hWin);
0000d6  4638              MOV      r0,r7
0000d8  f7fffffe          BL       GUI_ALLOC_h2p
0000dc  4604              MOV      r4,r0
;;;215      Status = pWin->Status;
0000de  8ba6              LDRH     r6,[r4,#0x1c]
;;;216      if ((Status & WM_SF_ISVIS) == 0) {
0000e0  f0060002          AND      r0,r6,#2
0000e4  b908              CBNZ     r0,|L1.234|
                  |L1.230|
;;;217        return;   /* Window is not visible... we are done */
;;;218      }
;;;219      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
;;;220        return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
;;;221      }
;;;222      if (WM__RectIsNZ(pRect) == 0) {
;;;223        return;   /* Nothing to do ... */
;;;224      }
;;;225      /* Calc affected area */
;;;226      GUI__IntersectRects(&r, pRect, &pWin->Rect);
;;;227      if (WM__RectIsNZ(&r)) {
;;;228        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;229          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;230        #endif
;;;231    
;;;232        if (pWin->Status & WM_SF_INVALID) {
;;;233          GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
;;;234        } else {
;;;235          pWin->InvalidRect = r;
;;;236          pWin->Status |= WM_SF_INVALID;
;;;237          WM__NumInvalidWindows++;
;;;238          /* Optional code: Call external routine to notify that drawing is required */
;;;239          #ifdef GUI_X_REDRAW
;;;240          if (_IsInited) {
;;;241            GUI_RECT r;
;;;242            r = pWin->Rect;
;;;243            if (WM__ClipAtParentBorders(&r,  hWin)) {
;;;244              GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
;;;245            }
;;;246          }
;;;247          #endif
;;;248          GUI_X_SIGNAL_EVENT();
;;;249        }
;;;250        /* Debug code: shows invalid areas */
;;;251        #if (WM_SUPPORT_DIAG)
;;;252          if (WM__pfShowInvalid) {
;;;253            (WM__pfShowInvalid)(hWin);
;;;254          }
;;;255        #endif
;;;256      }
;;;257    }
0000e6  e8bd81fc          POP      {r2-r8,pc}
                  |L1.234|
0000ea  f6400001          MOV      r0,#0x801             ;219
0000ee  4030              ANDS     r0,r0,r6              ;219
0000f0  2801              CMP      r0,#1                 ;219
0000f2  d100              BNE      |L1.246|
0000f4  e7f7              B        |L1.230|
                  |L1.246|
0000f6  4628              MOV      r0,r5                 ;222
0000f8  f7fffffe          BL       WM__RectIsNZ
0000fc  b900              CBNZ     r0,|L1.256|
0000fe  e7f2              B        |L1.230|
                  |L1.256|
000100  4622              MOV      r2,r4                 ;226
000102  4629              MOV      r1,r5                 ;226
000104  4668              MOV      r0,sp                 ;226
000106  f7fffffe          BL       GUI__IntersectRects
00010a  4668              MOV      r0,sp                 ;227
00010c  f7fffffe          BL       WM__RectIsNZ
000110  b1b8              CBZ      r0,|L1.322|
000112  7f20              LDRB     r0,[r4,#0x1c]         ;232
000114  f0000020          AND      r0,r0,#0x20           ;232
000118  b130              CBZ      r0,|L1.296|
00011a  466a              MOV      r2,sp                 ;233
00011c  f1040108          ADD      r1,r4,#8              ;233
000120  4608              MOV      r0,r1                 ;233
000122  f7fffffe          BL       GUI_MergeRect
000126  e00c              B        |L1.322|
                  |L1.296|
000128  9800              LDR      r0,[sp,#0]            ;235
00012a  60a0              STR      r0,[r4,#8]            ;235
00012c  9801              LDR      r0,[sp,#4]            ;235
00012e  60e0              STR      r0,[r4,#0xc]          ;235
000130  8ba0              LDRH     r0,[r4,#0x1c]         ;236
000132  f0400020          ORR      r0,r0,#0x20           ;236
000136  83a0              STRH     r0,[r4,#0x1c]         ;236
000138  48b4              LDR      r0,|L1.1036|
00013a  8800              LDRH     r0,[r0,#0]            ;237  ; WM__NumInvalidWindows
00013c  1c40              ADDS     r0,r0,#1              ;237
00013e  49b3              LDR      r1,|L1.1036|
000140  8008              STRH     r0,[r1,#0]            ;237
                  |L1.322|
000142  bf00              NOP      
000144  e7cf              B        |L1.230|
;;;258    
                          ENDP

                  WM__ClipAtParentBorders PROC
;;;281    */
;;;282    int WM__ClipAtParentBorders(GUI_RECT* pRect, WM_HWIN hWin) {
000146  b570              PUSH     {r4-r6,lr}
000148  4606              MOV      r6,r0
00014a  460d              MOV      r5,r1
;;;283      WM_Obj* pWin;
;;;284    
;;;285      /* Iterate up the window hierarchy.
;;;286         If the window is invisible, we are done.
;;;287         Clip at parent boarders.
;;;288         We are done with iterating if hWin has no parent.
;;;289      */
;;;290      do {
00014c  bf00              NOP      
                  |L1.334|
;;;291        pWin = WM_H2P(hWin);
00014e  4628              MOV      r0,r5
000150  f7fffffe          BL       GUI_ALLOC_h2p
000154  4604              MOV      r4,r0
;;;292        if ((pWin->Status & WM_SF_ISVIS) == 0) {
000156  7f20              LDRB     r0,[r4,#0x1c]
000158  f0000002          AND      r0,r0,#2
00015c  b908              CBNZ     r0,|L1.354|
;;;293          return 0;                     /* Invisible */
00015e  2000              MOVS     r0,#0
                  |L1.352|
;;;294        }
;;;295        GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
;;;296        if (pWin->hParent == 0) {
;;;297          break;   /* hWin is now the top level window which has no parent */
;;;298        }
;;;299        hWin = pWin->hParent;                    /* Go one level up (parent)*/
;;;300      } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
;;;301      
;;;302      /* Now check if the top level window is a desktop window. If it is not,
;;;303        then the window is not visible.
;;;304      */
;;;305      if (_DesktopHandle2Index(hWin) < 0) {
;;;306        return 0;           /* No desktop - (unattached) - Nothing to draw */
;;;307      }
;;;308      return 1;               /* Something may be visible */
;;;309    }
000160  bd70              POP      {r4-r6,pc}
                  |L1.354|
000162  4621              MOV      r1,r4                 ;295
000164  4630              MOV      r0,r6                 ;295
000166  f7fffffe          BL       GUI__IntersectRect
00016a  8ae0              LDRH     r0,[r4,#0x16]         ;296
00016c  b900              CBNZ     r0,|L1.368|
00016e  e002              B        |L1.374|
                  |L1.368|
000170  f9b45016          LDRSH    r5,[r4,#0x16]         ;299
000174  e7eb              B        |L1.334|
                  |L1.374|
000176  bf00              NOP                            ;297
000178  4628              MOV      r0,r5                 ;305
00017a  f7fffffe          BL       _DesktopHandle2Index
00017e  2800              CMP      r0,#0                 ;305
000180  da01              BGE      |L1.390|
000182  2000              MOVS     r0,#0                 ;306
000184  e7ec              B        |L1.352|
                  |L1.390|
000186  2001              MOVS     r0,#1                 ;308
000188  e7ea              B        |L1.352|
;;;310    
                          ENDP

                  WM__ActivateClipRect PROC
;;;314    */
;;;315    void  WM__ActivateClipRect(void) {
00018a  b51c              PUSH     {r2-r4,lr}
;;;316      if (WM_IsActive) {
00018c  48a0              LDR      r0,|L1.1040|
00018e  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000190  b118              CBZ      r0,|L1.410|
;;;317        _SetClipRectUserIntersect(&_ClipContext.CurRect);
000192  48a0              LDR      r0,|L1.1044|
000194  f7fffffe          BL       _SetClipRectUserIntersect
000198  e016              B        |L1.456|
                  |L1.410|
;;;318      } else {    /* Window manager disabled, typically because meory device is active */
;;;319        GUI_RECT r;
;;;320        WM_Obj *pAWin;
;;;321        pAWin = WM_H2P(GUI_Context.hAWin);
00019a  499b              LDR      r1,|L1.1032|
00019c  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
0001a0  f7fffffe          BL       GUI_ALLOC_h2p
0001a4  4604              MOV      r4,r0
;;;322        r = pAWin->Rect;
0001a6  e9d40100          LDRD     r0,r1,[r4,#0]
0001aa  e9cd0100          STRD     r0,r1,[sp,#0]
;;;323        #if WM_SUPPORT_TRANSPARENCY
;;;324          if (WM__hATransWindow) {
0001ae  4895              LDR      r0,|L1.1028|
0001b0  8800              LDRH     r0,[r0,#0]  ; WM__hATransWindow
0001b2  b128              CBZ      r0,|L1.448|
;;;325            WM__ClipAtParentBorders(&r, WM__hATransWindow);
0001b4  4893              LDR      r0,|L1.1028|
0001b6  f9b01000          LDRSH    r1,[r0,#0]  ; WM__hATransWindow
0001ba  4668              MOV      r0,sp
0001bc  f7fffffe          BL       WM__ClipAtParentBorders
                  |L1.448|
;;;326          }
;;;327        #endif
;;;328        /* Take UserClipRect into account */
;;;329        _SetClipRectUserIntersect(&r);
0001c0  4668              MOV      r0,sp
0001c2  f7fffffe          BL       _SetClipRectUserIntersect
;;;330      }
0001c6  bf00              NOP      
                  |L1.456|
;;;331    }
0001c8  bd1c              POP      {r2-r4,pc}
;;;332    
                          ENDP

                  WM__InsertWindowIntoList PROC
;;;341    */
;;;342    void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
0001ca  e92d4ff8          PUSH     {r3-r11,lr}
0001ce  4606              MOV      r6,r0
0001d0  4688              MOV      r8,r1
;;;343      int OnTop;
;;;344      WM_HWIN hi;
;;;345      WM_Obj * pWin;
;;;346      WM_Obj * pParent;
;;;347      WM_Obj * pi;
;;;348    
;;;349      if (hParent) {
0001d2  f1b80f00          CMP      r8,#0
0001d6  d03f              BEQ      |L1.600|
;;;350        pWin = WM_H2P(hWin);
0001d8  4630              MOV      r0,r6
0001da  f7fffffe          BL       GUI_ALLOC_h2p
0001de  4604              MOV      r4,r0
;;;351        pWin->hNext = 0;
0001e0  2000              MOVS     r0,#0
0001e2  8360              STRH     r0,[r4,#0x1a]
;;;352        pWin->hParent = hParent;
0001e4  f8a48016          STRH     r8,[r4,#0x16]
;;;353        pParent = WM_H2P(hParent);
0001e8  4640              MOV      r0,r8
0001ea  f7fffffe          BL       GUI_ALLOC_h2p
0001ee  4607              MOV      r7,r0
;;;354        OnTop   = pWin->Status & WM_CF_STAYONTOP;
0001f0  7f20              LDRB     r0,[r4,#0x1c]
0001f2  f0000b08          AND      r11,r0,#8
;;;355        hi = pParent->hFirstChild;
0001f6  f9b79018          LDRSH    r9,[r7,#0x18]
;;;356        /* Put it at beginning of the list if there is no child */
;;;357        if (hi == 0) {   /* No child yet ... Makes things easy ! */
0001fa  f1b90f00          CMP      r9,#0
0001fe  d102              BNE      |L1.518|
;;;358          pParent->hFirstChild = hWin;
000200  833e              STRH     r6,[r7,#0x18]
                  |L1.514|
;;;359          return;                         /* Early out ... We are done */
;;;360        }
;;;361        /* Put it at beginning of the list if first child is a TOP window and new one is not */
;;;362        pi = WM_H2P(hi);
;;;363        if (!OnTop) {
;;;364          if (pi->Status & WM_SF_STAYONTOP) {
;;;365            pWin->hNext = hi;
;;;366            pParent->hFirstChild = hWin;
;;;367            return;                         /* Early out ... We are done */
;;;368          }
;;;369        }
;;;370        /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
;;;371        do {
;;;372          WM_Obj* pNext;
;;;373          WM_HWIN hNext;
;;;374          if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
;;;375            pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
;;;376            break;
;;;377          }
;;;378          pNext = WM_H2P(hNext);
;;;379          if (!OnTop) {
;;;380            if (pNext->Status & WM_SF_STAYONTOP) {
;;;381              pi->hNext = hWin;
;;;382              pWin->hNext = hNext;
;;;383              break;
;;;384            }
;;;385          }
;;;386          pi = pNext;
;;;387        }  while (1);
;;;388        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;389          WM__NotifyVisChanged(hWin, &pWin->Rect);
;;;390        #endif
;;;391      }
;;;392    }
000202  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.518|
000206  4648              MOV      r0,r9                 ;362
000208  f7fffffe          BL       GUI_ALLOC_h2p
00020c  4605              MOV      r5,r0                 ;362
00020e  f1bb0f00          CMP      r11,#0                ;363
000212  d107              BNE      |L1.548|
000214  7f28              LDRB     r0,[r5,#0x1c]         ;364
000216  f0000008          AND      r0,r0,#8              ;364
00021a  b118              CBZ      r0,|L1.548|
00021c  f8a4901a          STRH     r9,[r4,#0x1a]         ;365
000220  833e              STRH     r6,[r7,#0x18]         ;366
000222  e7ee              B        |L1.514|
                  |L1.548|
000224  bf00              NOP                            ;371
                  |L1.550|
000226  f9b5001a          LDRSH    r0,[r5,#0x1a]         ;374
00022a  9000              STR      r0,[sp,#0]            ;374
00022c  b908              CBNZ     r0,|L1.562|
00022e  836e              STRH     r6,[r5,#0x1a]         ;375
000230  e011              B        |L1.598|
                  |L1.562|
000232  9800              LDR      r0,[sp,#0]            ;378
000234  f7fffffe          BL       GUI_ALLOC_h2p
000238  4682              MOV      r10,r0                ;378
00023a  f1bb0f00          CMP      r11,#0                ;379
00023e  d108              BNE      |L1.594|
000240  f89a001c          LDRB     r0,[r10,#0x1c]        ;380
000244  f0000008          AND      r0,r0,#8              ;380
000248  b118              CBZ      r0,|L1.594|
00024a  836e              STRH     r6,[r5,#0x1a]         ;381
00024c  9800              LDR      r0,[sp,#0]            ;382
00024e  8360              STRH     r0,[r4,#0x1a]         ;382
000250  e001              B        |L1.598|
                  |L1.594|
000252  4655              MOV      r5,r10                ;386
000254  e7e7              B        |L1.550|
                  |L1.598|
000256  bf00              NOP                            ;376
                  |L1.600|
000258  bf00              NOP      
00025a  e7d2              B        |L1.514|
;;;393    
                          ENDP

                  WM__RemoveWindowFromList PROC
;;;397    */
;;;398    void WM__RemoveWindowFromList(WM_HWIN hWin) {
00025c  e92d47f0          PUSH     {r4-r10,lr}
000260  4607              MOV      r7,r0
;;;399      WM_HWIN hi, hParent;
;;;400      WM_Obj * pWin, * pParent, * pi;
;;;401      
;;;402      pWin = WM_H2P(hWin);
000262  4638              MOV      r0,r7
000264  f7fffffe          BL       GUI_ALLOC_h2p
000268  4681              MOV      r9,r0
;;;403      hParent = pWin->hParent;
00026a  f9b98016          LDRSH    r8,[r9,#0x16]
;;;404      if (hParent) {
00026e  f1b80f00          CMP      r8,#0
000272  d020              BEQ      |L1.694|
;;;405        pParent = WM_H2P(hParent);
000274  4640              MOV      r0,r8
000276  f7fffffe          BL       GUI_ALLOC_h2p
00027a  4606              MOV      r6,r0
;;;406        hi = pParent->hFirstChild;
00027c  f9b65018          LDRSH    r5,[r6,#0x18]
;;;407        if (hi == hWin) {
000280  42bd              CMP      r5,r7
000282  d106              BNE      |L1.658|
;;;408          pi = WM_H2P(hi);
000284  4628              MOV      r0,r5
000286  f7fffffe          BL       GUI_ALLOC_h2p
00028a  4604              MOV      r4,r0
;;;409          pParent->hFirstChild = pi->hNext;
00028c  8b60              LDRH     r0,[r4,#0x1a]
00028e  8330              STRH     r0,[r6,#0x18]
000290  e011              B        |L1.694|
                  |L1.658|
;;;410        } else {
;;;411          while (hi) {
000292  e00d              B        |L1.688|
                  |L1.660|
;;;412            pi = WM_H2P(hi);
000294  4628              MOV      r0,r5
000296  f7fffffe          BL       GUI_ALLOC_h2p
00029a  4604              MOV      r4,r0
;;;413            if (pi->hNext == hWin) {
00029c  f9b4001a          LDRSH    r0,[r4,#0x1a]
0002a0  42b8              CMP      r0,r7
0002a2  d103              BNE      |L1.684|
;;;414              pi->hNext = pWin->hNext;
0002a4  f8b9001a          LDRH     r0,[r9,#0x1a]
0002a8  8360              STRH     r0,[r4,#0x1a]
;;;415              break;
0002aa  e003              B        |L1.692|
                  |L1.684|
;;;416            }
;;;417            hi = pi->hNext;
0002ac  f9b4501a          LDRSH    r5,[r4,#0x1a]
                  |L1.688|
0002b0  2d00              CMP      r5,#0                 ;411
0002b2  d1ef              BNE      |L1.660|
                  |L1.692|
0002b4  bf00              NOP                            ;415
                  |L1.694|
;;;418          }
;;;419        }
;;;420      }
;;;421    }
0002b6  e8bd87f0          POP      {r4-r10,pc}
;;;422    
                          ENDP

                  WM_InvalidateWindowAndDescsEx PROC
;;;490    */
;;;491    void WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect) {
0002ba  e92d47fc          PUSH     {r2-r10,lr}
0002be  4607              MOV      r7,r0
0002c0  4689              MOV      r9,r1
;;;492      GUI_RECT Rect;
;;;493      WM_Obj*  pWin;
;;;494      WM_Obj* pChild;
;;;495      WM_HWIN hChild;
;;;496      int Status;
;;;497    
;;;498      if (hWin) {
0002c2  b337              CBZ      r7,|L1.786|
;;;499        pWin = WM_H2P(hWin);
0002c4  4638              MOV      r0,r7
0002c6  f7fffffe          BL       GUI_ALLOC_h2p
0002ca  4604              MOV      r4,r0
;;;500        Status  = pWin->Status;
0002cc  f8b4801c          LDRH     r8,[r4,#0x1c]
;;;501        if ((Status & WM_SF_ISVIS) == 0) {
0002d0  f0080002          AND      r0,r8,#2
0002d4  b908              CBNZ     r0,|L1.730|
                  |L1.726|
;;;502          return;                                                            /* Window is not visible... we are done */
;;;503        }
;;;504        if (GUI__IntersectRects(&Rect, pInvalidRect, &pWin->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
;;;505          return;                                                            /* No intersection, nothing to do */
;;;506        }
;;;507        WM__Invalidate1Abs(hWin, &Rect);    /* Invalidate window itself */
;;;508        for (hChild = WM_GetFirstChild(hWin); hChild; hChild = pChild->hNext) {
;;;509          WM_InvalidateWindowAndDescsEx(hChild, &Rect);
;;;510          pChild = WM_H2P(hChild);
;;;511        }
;;;512      }
;;;513    }
0002d6  e8bd87fc          POP      {r2-r10,pc}
                  |L1.730|
0002da  4622              MOV      r2,r4                 ;504
0002dc  4649              MOV      r1,r9                 ;504
0002de  4668              MOV      r0,sp                 ;504
0002e0  f7fffffe          BL       GUI__IntersectRects
0002e4  b900              CBNZ     r0,|L1.744|
0002e6  e7f6              B        |L1.726|
                  |L1.744|
0002e8  4669              MOV      r1,sp                 ;507
0002ea  4638              MOV      r0,r7                 ;507
0002ec  f7fffffe          BL       WM__Invalidate1Abs
0002f0  4638              MOV      r0,r7                 ;508
0002f2  f7fffffe          BL       WM_GetFirstChild
0002f6  4606              MOV      r6,r0                 ;508
0002f8  e009              B        |L1.782|
                  |L1.762|
0002fa  4669              MOV      r1,sp                 ;509
0002fc  4630              MOV      r0,r6                 ;509
0002fe  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
000302  4630              MOV      r0,r6                 ;510
000304  f7fffffe          BL       GUI_ALLOC_h2p
000308  4605              MOV      r5,r0                 ;510
00030a  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;508
                  |L1.782|
00030e  2e00              CMP      r6,#0                 ;508
000310  d1f3              BNE      |L1.762|
                  |L1.786|
000312  bf00              NOP      
000314  e7df              B        |L1.726|
;;;514    
                          ENDP

                  WM__InvalidateRectEx PROC
;;;534    */
;;;535    void WM__InvalidateRectEx(const GUI_RECT* pInvalidRect, WM_HWIN hParent, WM_HWIN hStop) {
000316  e92d47fc          PUSH     {r2-r10,lr}
00031a  4681              MOV      r9,r0
00031c  460e              MOV      r6,r1
00031e  4692              MOV      r10,r2
;;;536      GUI_RECT Rect;
;;;537      WM_Obj*  pParent;
;;;538      WM_Obj*  pi;
;;;539      WM_HWIN  hi;
;;;540      int Status;
;;;541    
;;;542      /* Perform some parameter checks and check for "early out" conditions. */
;;;543      if (hParent == 0) {
000320  b90e              CBNZ     r6,|L1.806|
                  |L1.802|
;;;544        return;                                                            /* Desktop window or unattached wind. Nothing to do. */
;;;545      }
;;;546      pParent = WM_H2P(hParent);
;;;547      Status  = pParent->Status;
;;;548      if ((Status & WM_SF_ISVIS) == 0) {
;;;549        return;                                                            /* Window is not visible... we are done */
;;;550      }
;;;551      if (GUI__IntersectRects(&Rect, pInvalidRect, &pParent->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
;;;552        return;                                                            /* No intersection, nothing to do */
;;;553      }
;;;554      /* Invalidate the rectangle in the parent */
;;;555      /* If the parent is (partially) transparent, we need to move up in the hierarchy */
;;;556      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
;;;557        WM__InvalidateRectEx(&Rect, pParent->hParent, pParent->hNext);
;;;558      } else {
;;;559        WM__Invalidate1Abs(hParent, &Rect);
;;;560      }
;;;561      /* Invalidate siblings up to hStop */
;;;562      for (hi = pParent->hFirstChild; hi; hi = pi->hNext) {
;;;563        if (hi == hStop) {
;;;564          break;
;;;565        }
;;;566        WM_InvalidateWindowAndDescsEx(hi, &Rect);
;;;567        pi = WM_H2P(hi);
;;;568      }
;;;569    }
000322  e8bd87fc          POP      {r2-r10,pc}
                  |L1.806|
000326  4630              MOV      r0,r6                 ;546
000328  f7fffffe          BL       GUI_ALLOC_h2p
00032c  4604              MOV      r4,r0                 ;546
00032e  f8b4801c          LDRH     r8,[r4,#0x1c]         ;547
000332  f0080002          AND      r0,r8,#2              ;548
000336  b900              CBNZ     r0,|L1.826|
000338  e7f3              B        |L1.802|
                  |L1.826|
00033a  4622              MOV      r2,r4                 ;551
00033c  4649              MOV      r1,r9                 ;551
00033e  4668              MOV      r0,sp                 ;551
000340  f7fffffe          BL       GUI__IntersectRects
000344  b900              CBNZ     r0,|L1.840|
000346  e7ec              B        |L1.802|
                  |L1.840|
000348  f6400001          MOV      r0,#0x801             ;556
00034c  ea080000          AND      r0,r8,r0              ;556
000350  2801              CMP      r0,#1                 ;556
000352  d107              BNE      |L1.868|
000354  f9b4201a          LDRSH    r2,[r4,#0x1a]         ;557
000358  f9b41016          LDRSH    r1,[r4,#0x16]         ;557
00035c  4668              MOV      r0,sp                 ;557
00035e  f7fffffe          BL       WM__InvalidateRectEx
000362  e003              B        |L1.876|
                  |L1.868|
000364  4669              MOV      r1,sp                 ;559
000366  4630              MOV      r0,r6                 ;559
000368  f7fffffe          BL       WM__Invalidate1Abs
                  |L1.876|
00036c  f9b45018          LDRSH    r5,[r4,#0x18]         ;562
000370  e00c              B        |L1.908|
                  |L1.882|
000372  4555              CMP      r5,r10                ;563
000374  d100              BNE      |L1.888|
000376  e00b              B        |L1.912|
                  |L1.888|
000378  4669              MOV      r1,sp                 ;566
00037a  4628              MOV      r0,r5                 ;566
00037c  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
000380  4628              MOV      r0,r5                 ;567
000382  f7fffffe          BL       GUI_ALLOC_h2p
000386  4607              MOV      r7,r0                 ;567
000388  f9b7501a          LDRSH    r5,[r7,#0x1a]         ;562
                  |L1.908|
00038c  2d00              CMP      r5,#0                 ;562
00038e  d1f0              BNE      |L1.882|
                  |L1.912|
000390  bf00              NOP                            ;564
000392  bf00              NOP      
000394  e7c5              B        |L1.802|
;;;570    
                          ENDP

                  WM__DetachWindow PROC
;;;430    */
;;;431    void WM__DetachWindow(WM_HWIN hWin) {
000396  b570              PUSH     {r4-r6,lr}
000398  4605              MOV      r5,r0
;;;432      WM_Obj* pWin;
;;;433      WM_HWIN hParent;
;;;434      pWin = WM_H2P(hWin);
00039a  4628              MOV      r0,r5
00039c  f7fffffe          BL       GUI_ALLOC_h2p
0003a0  4604              MOV      r4,r0
;;;435      hParent = pWin->hParent;
0003a2  f9b46016          LDRSH    r6,[r4,#0x16]
;;;436      if (hParent) {
0003a6  b15e              CBZ      r6,|L1.960|
;;;437        WM__InvalidateRectEx(&pWin->Rect, pWin->hParent, pWin->hNext);
0003a8  f9b4201a          LDRSH    r2,[r4,#0x1a]
0003ac  f9b41016          LDRSH    r1,[r4,#0x16]
0003b0  4620              MOV      r0,r4
0003b2  f7fffffe          BL       WM__InvalidateRectEx
;;;438        WM__RemoveWindowFromList(hWin);
0003b6  4628              MOV      r0,r5
0003b8  f7fffffe          BL       WM__RemoveWindowFromList
;;;439        pWin->hParent = 0;
0003bc  2000              MOVS     r0,#0
0003be  82e0              STRH     r0,[r4,#0x16]
                  |L1.960|
;;;440      }
;;;441    }
0003c0  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP

                  WM_SelectWindow PROC
;;;1001   */
;;;1002   WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
0003c2  b570              PUSH     {r4-r6,lr}
0003c4  4604              MOV      r4,r0
;;;1003     WM_HWIN hWinPrev;
;;;1004     WM_Obj* pObj;
;;;1005   
;;;1006     WM_ASSERT_NOT_IN_PAINT();
;;;1007     WM_LOCK();
;;;1008     hWinPrev = GUI_Context.hAWin;
0003c6  4810              LDR      r0,|L1.1032|
0003c8  f9b0603c          LDRSH    r6,[r0,#0x3c]  ; GUI_Context
;;;1009     if (hWin == 0) {
0003cc  b914              CBNZ     r4,|L1.980|
;;;1010       hWin = WM__FirstWin;
0003ce  4812              LDR      r0,|L1.1048|
0003d0  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
                  |L1.980|
;;;1011     }
;;;1012     /* Select new window */
;;;1013     GUI_Context.hAWin = hWin;
0003d4  480c              LDR      r0,|L1.1032|
0003d6  8784              STRH     r4,[r0,#0x3c]
;;;1014     #if GUI_NUM_LAYERS > 1
;;;1015     {
;;;1016       WM_HWIN hTop;
;;;1017       int LayerIndex;
;;;1018       hTop = _GetTopLevelWindow(hWin);
;;;1019       LayerIndex = _DesktopHandle2Index(hTop);
;;;1020       if (LayerIndex >= 0) {
;;;1021         GUI_SelectLayer(LayerIndex);
;;;1022       }
;;;1023     }
;;;1024     #endif
;;;1025     pObj = WM_H2P(hWin);
0003d8  4620              MOV      r0,r4
0003da  f7fffffe          BL       GUI_ALLOC_h2p
0003de  4605              MOV      r5,r0
;;;1026     LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
0003e0  f7fffffe          BL       LCD_SetClipRectMax
;;;1027     GUI_Context.xOff = pObj->Rect.x0;
0003e4  f9b50000          LDRSH    r0,[r5,#0]
0003e8  4907              LDR      r1,|L1.1032|
0003ea  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;1028     GUI_Context.yOff = pObj->Rect.y0;
0003ec  f9b50002          LDRSH    r0,[r5,#2]
0003f0  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;1029     WM_UNLOCK();
;;;1030     return hWinPrev;
0003f2  4630              MOV      r0,r6
;;;1031   }
0003f4  bd70              POP      {r4-r6,pc}
0003f6  0000              DCW      0x0000
                  |L1.1016|
                          DCD      WM__pFirstCriticalHandle
                  |L1.1020|
                          DCD      WM__ahDesktopWin
                  |L1.1024|
                          DCD      NextDrawWin
                  |L1.1028|
                          DCD      WM__hATransWindow
                  |L1.1032|
                          DCD      GUI_Context
                  |L1.1036|
                          DCD      WM__NumInvalidWindows
                  |L1.1040|
                          DCD      WM_IsActive
                  |L1.1044|
                          DCD      _ClipContext+0x8
                  |L1.1048|
                          DCD      WM__FirstWin
                          ENDP

                  WM__RemoveFromLinList PROC
;;;574    */
;;;575    void WM__RemoveFromLinList(WM_HWIN hWin) {
00041c  e92d41f0          PUSH     {r4-r8,lr}
000420  4606              MOV      r6,r0
;;;576      WM_Obj* piWin;
;;;577      WM_HWIN hiWin;
;;;578      WM_HWIN hNext;
;;;579      for (hiWin = WM__FirstWin; hiWin; ) {
000422  48fe              LDR      r0,|L1.2076|
000424  f9b07000          LDRSH    r7,[r0,#0]  ; WM__FirstWin
000428  e00e              B        |L1.1096|
                  |L1.1066|
;;;580        piWin = WM_H2P(hiWin);
00042a  4638              MOV      r0,r7
00042c  f7fffffe          BL       GUI_ALLOC_h2p
000430  4604              MOV      r4,r0
;;;581        hNext = piWin->hNextLin;
000432  f9b45014          LDRSH    r5,[r4,#0x14]
;;;582        if (hNext == hWin) {
000436  42b5              CMP      r5,r6
000438  d105              BNE      |L1.1094|
;;;583          piWin->hNextLin = WM_H2P(hWin)->hNextLin;
00043a  4630              MOV      r0,r6
00043c  f7fffffe          BL       GUI_ALLOC_h2p
000440  8a80              LDRH     r0,[r0,#0x14]
000442  82a0              STRH     r0,[r4,#0x14]
;;;584          break;
000444  e002              B        |L1.1100|
                  |L1.1094|
;;;585        }
;;;586        hiWin = hNext;
000446  462f              MOV      r7,r5
                  |L1.1096|
000448  2f00              CMP      r7,#0                 ;579
00044a  d1ee              BNE      |L1.1066|
                  |L1.1100|
00044c  bf00              NOP                            ;584
;;;587      }
;;;588    }
00044e  e8bd81f0          POP      {r4-r8,pc}
;;;589    
                          ENDP

                  WM__SendMsgNoData PROC
;;;753    */
;;;754    void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
000452  b53e              PUSH     {r1-r5,lr}
000454  4605              MOV      r5,r0
000456  460c              MOV      r4,r1
;;;755      WM_MESSAGE Msg;
;;;756      Msg.hWin  = hWin;
000458  f8ad5004          STRH     r5,[sp,#4]
;;;757      Msg.MsgId = MsgId;
00045c  9400              STR      r4,[sp,#0]
;;;758      WM__SendMessage(hWin, &Msg);
00045e  4669              MOV      r1,sp
000460  4628              MOV      r0,r5
000462  f7fffffe          BL       WM__SendMessage
;;;759    }
000466  bd3e              POP      {r1-r5,pc}
;;;760    
                          ENDP

                  WM__IsWindow PROC
;;;470    */
;;;471    int WM__IsWindow(WM_HWIN hWin) {
000468  b570              PUSH     {r4-r6,lr}
00046a  4605              MOV      r5,r0
;;;472      WM_HWIN iWin;
;;;473      for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
00046c  48eb              LDR      r0,|L1.2076|
00046e  f9b04000          LDRSH    r4,[r0,#0]  ; WM__FirstWin
000472  e008              B        |L1.1158|
                  |L1.1140|
;;;474        if (iWin == hWin) {
000474  42ac              CMP      r4,r5
000476  d101              BNE      |L1.1148|
;;;475          return 1;
000478  2001              MOVS     r0,#1
                  |L1.1146|
;;;476        }
;;;477      }
;;;478      return 0;
;;;479    }
00047a  bd70              POP      {r4-r6,pc}
                  |L1.1148|
00047c  4620              MOV      r0,r4                 ;473
00047e  f7fffffe          BL       GUI_ALLOC_h2p
000482  f9b04014          LDRSH    r4,[r0,#0x14]         ;473
                  |L1.1158|
000486  2c00              CMP      r4,#0                 ;473
000488  d1f4              BNE      |L1.1140|
00048a  2000              MOVS     r0,#0                 ;478
00048c  e7f5              B        |L1.1146|
;;;480    
                          ENDP

                  WM_DeleteWindow PROC
;;;942    */
;;;943    void WM_DeleteWindow (WM_HWIN hWin) {
00048e  b570              PUSH     {r4-r6,lr}
000490  4604              MOV      r4,r0
;;;944      WM_Obj* pWin;
;;;945      if (!hWin) {
000492  b904              CBNZ     r4,|L1.1174|
                  |L1.1172|
;;;946        return;
;;;947      }
;;;948      WM_ASSERT_NOT_IN_PAINT();
;;;949      WM_LOCK();
;;;950      if (WM__IsWindow(hWin)) {
;;;951        pWin = WM_H2P(hWin);
;;;952        ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
;;;953      /* Make sure that focus is set to an existing window */
;;;954        if (WM__hWinFocus == hWin) {
;;;955          WM__hWinFocus = 0;
;;;956        }
;;;957        if (WM__hCapture == hWin) {
;;;958          WM__hCapture = 0;
;;;959        }
;;;960        /* check if critical handles are affected. If so, reset the window handle to 0 */
;;;961        _CheckCriticalHandles(hWin);
;;;962        /* Inform parent */
;;;963        WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
;;;964        /* Delete all children */
;;;965        _DeleteAllChildren(pWin);
;;;966        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;967          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;968        #endif
;;;969        /* Send WM_DELETE message to window in order to inform window itself */
;;;970        WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
;;;971        WM__DetachWindow(hWin);
;;;972        /* Remove window from window stack */
;;;973        WM__RemoveFromLinList(hWin);
;;;974        /* Handle transparency counter if necessary */
;;;975        #if WM_SUPPORT_TRANSPARENCY
;;;976          if (pWin->Status & WM_SF_HASTRANS) {
;;;977            WM__TransWindowCnt--;
;;;978          }
;;;979        #endif
;;;980        /* Make sure window is no longer counted as invalid */
;;;981        if (pWin->Status & WM_SF_INVALID) {
;;;982          WM__NumInvalidWindows--;
;;;983        }
;;;984      /* Free window memory */
;;;985        WM__NumWindows--;
;;;986        GUI_ALLOC_Free(hWin);
;;;987      /* Select a valid window */
;;;988        WM_SelectWindow(WM__FirstWin);
;;;989      } else {
;;;990        GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
;;;991      }
;;;992      WM_UNLOCK();
;;;993    }
000494  bd70              POP      {r4-r6,pc}
                  |L1.1174|
000496  4620              MOV      r0,r4                 ;950
000498  f7fffffe          BL       WM__IsWindow
00049c  2800              CMP      r0,#0                 ;950
00049e  d048              BEQ      |L1.1330|
0004a0  4620              MOV      r0,r4                 ;951
0004a2  f7fffffe          BL       GUI_ALLOC_h2p
0004a6  4605              MOV      r5,r0                 ;951
0004a8  f7fffffe          BL       ResetNextDrawWin
0004ac  48dc              LDR      r0,|L1.2080|
0004ae  f9b00000          LDRSH    r0,[r0,#0]            ;954  ; WM__hWinFocus
0004b2  42a0              CMP      r0,r4                 ;954
0004b4  d102              BNE      |L1.1212|
0004b6  2000              MOVS     r0,#0                 ;955
0004b8  49d9              LDR      r1,|L1.2080|
0004ba  8008              STRH     r0,[r1,#0]            ;955
                  |L1.1212|
0004bc  48d9              LDR      r0,|L1.2084|
0004be  f9b00000          LDRSH    r0,[r0,#0]            ;957  ; WM__hCapture
0004c2  42a0              CMP      r0,r4                 ;957
0004c4  d102              BNE      |L1.1228|
0004c6  2000              MOVS     r0,#0                 ;958
0004c8  49d6              LDR      r1,|L1.2084|
0004ca  8008              STRH     r0,[r1,#0]            ;958
                  |L1.1228|
0004cc  4620              MOV      r0,r4                 ;961
0004ce  f7fffffe          BL       _CheckCriticalHandles
0004d2  2107              MOVS     r1,#7                 ;963
0004d4  4620              MOV      r0,r4                 ;963
0004d6  f7fffffe          BL       WM_NotifyParent
0004da  4628              MOV      r0,r5                 ;965
0004dc  f7fffffe          BL       _DeleteAllChildren
0004e0  210b              MOVS     r1,#0xb               ;970
0004e2  4620              MOV      r0,r4                 ;970
0004e4  f7fffffe          BL       WM__SendMsgNoData
0004e8  4620              MOV      r0,r4                 ;971
0004ea  f7fffffe          BL       WM__DetachWindow
0004ee  4620              MOV      r0,r4                 ;973
0004f0  f7fffffe          BL       WM__RemoveFromLinList
0004f4  7f28              LDRB     r0,[r5,#0x1c]         ;976
0004f6  f0000001          AND      r0,r0,#1              ;976
0004fa  b120              CBZ      r0,|L1.1286|
0004fc  48ca              LDR      r0,|L1.2088|
0004fe  6800              LDR      r0,[r0,#0]            ;977  ; WM__TransWindowCnt
000500  1e40              SUBS     r0,r0,#1              ;977
000502  49c9              LDR      r1,|L1.2088|
000504  6008              STR      r0,[r1,#0]            ;977  ; WM__TransWindowCnt
                  |L1.1286|
000506  7f28              LDRB     r0,[r5,#0x1c]         ;981
000508  f0000020          AND      r0,r0,#0x20           ;981
00050c  b120              CBZ      r0,|L1.1304|
00050e  48c7              LDR      r0,|L1.2092|
000510  8800              LDRH     r0,[r0,#0]            ;982  ; WM__NumInvalidWindows
000512  1e40              SUBS     r0,r0,#1              ;982
000514  49c5              LDR      r1,|L1.2092|
000516  8008              STRH     r0,[r1,#0]            ;982
                  |L1.1304|
000518  48c5              LDR      r0,|L1.2096|
00051a  8800              LDRH     r0,[r0,#0]            ;985  ; WM__NumWindows
00051c  1e40              SUBS     r0,r0,#1              ;985
00051e  49c4              LDR      r1,|L1.2096|
000520  8008              STRH     r0,[r1,#0]            ;985
000522  4620              MOV      r0,r4                 ;986
000524  f7fffffe          BL       GUI_ALLOC_Free
000528  48bc              LDR      r0,|L1.2076|
00052a  f9b00000          LDRSH    r0,[r0,#0]            ;988  ; WM__FirstWin
00052e  f7fffffe          BL       WM_SelectWindow
                  |L1.1330|
000532  bf00              NOP      
000534  e7ae              B        |L1.1172|
;;;994    
                          ENDP

                  _DeleteAllChildren PROC
;;;446    */
;;;447    static void _DeleteAllChildren(WM_Obj * pParent) {
000536  b510              PUSH     {r4,lr}
000538  4604              MOV      r4,r0
;;;448      do {
00053a  bf00              NOP      
                  |L1.1340|
;;;449        WM_DeleteWindow(pParent->hFirstChild);
00053c  f9b40018          LDRSH    r0,[r4,#0x18]
000540  f7fffffe          BL       WM_DeleteWindow
;;;450      } while (pParent->hFirstChild);
000544  8b20              LDRH     r0,[r4,#0x18]
000546  2800              CMP      r0,#0
000548  d1f8              BNE      |L1.1340|
;;;451    }
00054a  bd10              POP      {r4,pc}
;;;452    
                          ENDP

                  _AddToLinList PROC
;;;593    */
;;;594    static void _AddToLinList(WM_HWIN hNew) {
00054c  b570              PUSH     {r4-r6,lr}
00054e  4604              MOV      r4,r0
;;;595      WM_Obj* pFirst;
;;;596      WM_Obj* pNew;
;;;597      if (WM__FirstWin) {
000550  48b2              LDR      r0,|L1.2076|
000552  8800              LDRH     r0,[r0,#0]  ; WM__FirstWin
000554  b168              CBZ      r0,|L1.1394|
;;;598        pFirst = WM_H2P(WM__FirstWin);
000556  48b1              LDR      r0,|L1.2076|
000558  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
00055c  f7fffffe          BL       GUI_ALLOC_h2p
000560  4606              MOV      r6,r0
;;;599        pNew   = WM_H2P(hNew);
000562  4620              MOV      r0,r4
000564  f7fffffe          BL       GUI_ALLOC_h2p
000568  4605              MOV      r5,r0
;;;600        pNew->hNextLin = pFirst->hNextLin;
00056a  8ab0              LDRH     r0,[r6,#0x14]
00056c  82a8              STRH     r0,[r5,#0x14]
;;;601        pFirst->hNextLin = hNew;
00056e  82b4              STRH     r4,[r6,#0x14]
000570  e001              B        |L1.1398|
                  |L1.1394|
;;;602      } else {
;;;603        WM__FirstWin = hNew;
000572  48aa              LDR      r0,|L1.2076|
000574  8004              STRH     r4,[r0,#0]
                  |L1.1398|
;;;604      }
;;;605    }
000576  bd70              POP      {r4-r6,pc}
;;;606    
                          ENDP

                  _Findy1 PROC
;;;626    */
;;;627    static void _Findy1(WM_HWIN iWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000578  e92d47fc          PUSH     {r2-r10,lr}
00057c  4606              MOV      r6,r0
00057e  460c              MOV      r4,r1
000580  4617              MOV      r7,r2
;;;628      WM_Obj* pWin;
;;;629      for (; iWin; iWin = pWin->hNext) { 
000582  e04e              B        |L1.1570|
                  |L1.1412|
;;;630        int Status = (pWin = WM_H2P(iWin))->Status;
000584  4630              MOV      r0,r6
000586  f7fffffe          BL       GUI_ALLOC_h2p
00058a  4605              MOV      r5,r0
00058c  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;631        /* Check if this window affects us at all */    
;;;632        if (Status & WM_SF_ISVIS) {
000590  f0080002          AND      r0,r8,#2
000594  2800              CMP      r0,#0
000596  d042              BEQ      |L1.1566|
;;;633          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;634          if (pParentRect) {
000598  b12f              CBZ      r7,|L1.1446|
;;;635            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
00059a  463a              MOV      r2,r7
00059c  4629              MOV      r1,r5
00059e  4668              MOV      r0,sp
0005a0  f7fffffe          BL       GUI__IntersectRects
0005a4  e003              B        |L1.1454|
                  |L1.1446|
;;;636          } else {
;;;637            rWinClipped = pWin->Rect;
0005a6  e9d50100          LDRD     r0,r1,[r5,#0]
0005aa  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1454|
;;;638          }
;;;639          /* Check if this window affects us at all */    
;;;640          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
0005ae  4669              MOV      r1,sp
0005b0  4620              MOV      r0,r4
0005b2  f7fffffe          BL       GUI_RectsIntersect
0005b6  b388              CBZ      r0,|L1.1564|
;;;641            if ((Status & WM_SF_HASTRANS) == 0) {
0005b8  f0080001          AND      r0,r8,#1
0005bc  b9e0              CBNZ     r0,|L1.1528|
;;;642              if (pWin->Rect.y0 > pRect->y0) {
0005be  f9b50002          LDRSH    r0,[r5,#2]
0005c2  f9b41002          LDRSH    r1,[r4,#2]
0005c6  4288              CMP      r0,r1
0005c8  dd0c              BLE      |L1.1508|
;;;643                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
0005ca  f9bd0002          LDRSH    r0,[sp,#2]
0005ce  1e40              SUBS     r0,r0,#1
0005d0  f9b41006          LDRSH    r1,[r4,#6]
0005d4  4288              CMP      r0,r1
0005d6  da21              BGE      |L1.1564|
0005d8  f8bd0002          LDRH     r0,[sp,#2]
0005dc  1e40              SUBS     r0,r0,#1
0005de  b200              SXTH     r0,r0
0005e0  80e0              STRH     r0,[r4,#6]
0005e2  e01b              B        |L1.1564|
                  |L1.1508|
;;;644              } else {
;;;645                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
0005e4  f9bd0006          LDRSH    r0,[sp,#6]
0005e8  f9b41006          LDRSH    r1,[r4,#6]
0005ec  4288              CMP      r0,r1
0005ee  da15              BGE      |L1.1564|
0005f0  f8bd0006          LDRH     r0,[sp,#6]
0005f4  80e0              STRH     r0,[r4,#6]
0005f6  e011              B        |L1.1564|
                  |L1.1528|
;;;646              }
;;;647            } else {
;;;648              /* Check all children*/ 
;;;649              WM_HWIN hChild;
;;;650              WM_Obj* pChild;
;;;651              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
0005f8  f9b59018          LDRSH    r9,[r5,#0x18]
0005fc  e00a              B        |L1.1556|
                  |L1.1534|
;;;652                pChild = WM_H2P(hChild);
0005fe  4648              MOV      r0,r9
000600  f7fffffe          BL       GUI_ALLOC_h2p
000604  4682              MOV      r10,r0
;;;653                _Findy1(hChild, pRect, &rWinClipped);
000606  466a              MOV      r2,sp
000608  4621              MOV      r1,r4
00060a  4648              MOV      r0,r9
00060c  f7fffffe          BL       _Findy1
000610  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;651
                  |L1.1556|
000614  f1b90f00          CMP      r9,#0                 ;651
000618  d1f1              BNE      |L1.1534|
;;;654              }
;;;655            }
00061a  bf00              NOP      
                  |L1.1564|
;;;656          }
;;;657        }
00061c  bf00              NOP      
                  |L1.1566|
00061e  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;629
                  |L1.1570|
000622  2e00              CMP      r6,#0                 ;629
000624  d1ae              BNE      |L1.1412|
;;;658      }
;;;659    }
000626  e8bd87fc          POP      {r2-r10,pc}
;;;660    
                          ENDP

                  _Findx0 PROC
;;;664    */
;;;665    static int _Findx0(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
00062a  e92d5ffc          PUSH     {r2-r12,lr}
00062e  4606              MOV      r6,r0
000630  460d              MOV      r5,r1
000632  4617              MOV      r7,r2
;;;666      WM_Obj* pWin;
;;;667      int r = 0;
000634  f04f0b00          MOV      r11,#0
;;;668      for (; hWin; hWin = pWin->hNext) { 
000638  e03b              B        |L1.1714|
                  |L1.1594|
;;;669        int Status = (pWin = WM_H2P(hWin))->Status;
00063a  4630              MOV      r0,r6
00063c  f7fffffe          BL       GUI_ALLOC_h2p
000640  4604              MOV      r4,r0
000642  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;670        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
000646  f0080002          AND      r0,r8,#2
00064a  b380              CBZ      r0,|L1.1710|
;;;671          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;672          if (pParentRect) {
00064c  b12f              CBZ      r7,|L1.1626|
;;;673            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
00064e  463a              MOV      r2,r7
000650  4621              MOV      r1,r4
000652  4668              MOV      r0,sp
000654  f7fffffe          BL       GUI__IntersectRects
000658  e003              B        |L1.1634|
                  |L1.1626|
;;;674          } else {
;;;675            rWinClipped = pWin->Rect;
00065a  e9d40100          LDRD     r0,r1,[r4,#0]
00065e  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1634|
;;;676          }
;;;677          /* Check if this window affects us at all */    
;;;678          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000662  4669              MOV      r1,sp
000664  4628              MOV      r0,r5
000666  f7fffffe          BL       GUI_RectsIntersect
00066a  b1f8              CBZ      r0,|L1.1708|
;;;679            if ((Status & WM_SF_HASTRANS) == 0) {
00066c  f0080001          AND      r0,r8,#1
000670  b938              CBNZ     r0,|L1.1666|
;;;680              pRect->x0 = rWinClipped.x1+1;
000672  f8bd0004          LDRH     r0,[sp,#4]
000676  1c40              ADDS     r0,r0,#1
000678  b200              SXTH     r0,r0
00067a  8028              STRH     r0,[r5,#0]
;;;681              r = 1;
00067c  f04f0b01          MOV      r11,#1
000680  e014              B        |L1.1708|
                  |L1.1666|
;;;682            } else {
;;;683              /* Check all children */
;;;684              WM_HWIN hChild;
;;;685              WM_Obj* pChild;
;;;686              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000682  f9b49018          LDRSH    r9,[r4,#0x18]
000686  e00d              B        |L1.1700|
                  |L1.1672|
;;;687                pChild = WM_H2P(hChild);
000688  4648              MOV      r0,r9
00068a  f7fffffe          BL       GUI_ALLOC_h2p
00068e  4682              MOV      r10,r0
;;;688                if (_Findx0(hChild, pRect, &rWinClipped)) {
000690  466a              MOV      r2,sp
000692  4629              MOV      r1,r5
000694  4648              MOV      r0,r9
000696  f7fffffe          BL       _Findx0
00069a  b108              CBZ      r0,|L1.1696|
;;;689                  r = 1;
00069c  f04f0b01          MOV      r11,#1
                  |L1.1696|
0006a0  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;686
                  |L1.1700|
0006a4  f1b90f00          CMP      r9,#0                 ;686
0006a8  d1ee              BNE      |L1.1672|
;;;690                }
;;;691              }
;;;692            }
0006aa  bf00              NOP      
                  |L1.1708|
;;;693          }
;;;694        }
0006ac  bf00              NOP      
                  |L1.1710|
0006ae  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;668
                  |L1.1714|
0006b2  2e00              CMP      r6,#0                 ;668
0006b4  d1c1              BNE      |L1.1594|
;;;695      }
;;;696      return r;
0006b6  4658              MOV      r0,r11
;;;697    }
0006b8  e8bd9ffc          POP      {r2-r12,pc}
;;;698    
                          ENDP

                  _Findx1 PROC
;;;702    */
;;;703    static void _Findx1(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
0006bc  e92d47fc          PUSH     {r2-r10,lr}
0006c0  4606              MOV      r6,r0
0006c2  460d              MOV      r5,r1
0006c4  4617              MOV      r7,r2
;;;704      WM_Obj* pWin;
;;;705      for (; hWin; hWin = pWin->hNext) { 
0006c6  e036              B        |L1.1846|
                  |L1.1736|
;;;706        int Status = (pWin = WM_H2P(hWin))->Status;
0006c8  4630              MOV      r0,r6
0006ca  f7fffffe          BL       GUI_ALLOC_h2p
0006ce  4604              MOV      r4,r0
0006d0  f8b0801c          LDRH     r8,[r0,#0x1c]
;;;707        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
0006d4  f0080002          AND      r0,r8,#2
0006d8  b358              CBZ      r0,|L1.1842|
;;;708          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;709          if (pParentRect) {
0006da  b12f              CBZ      r7,|L1.1768|
;;;710            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
0006dc  463a              MOV      r2,r7
0006de  4621              MOV      r1,r4
0006e0  4668              MOV      r0,sp
0006e2  f7fffffe          BL       GUI__IntersectRects
0006e6  e003              B        |L1.1776|
                  |L1.1768|
;;;711          } else {
;;;712            rWinClipped = pWin->Rect;
0006e8  e9d40100          LDRD     r0,r1,[r4,#0]
0006ec  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L1.1776|
;;;713          }
;;;714          /* Check if this window affects us at all */    
;;;715          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
0006f0  4669              MOV      r1,sp
0006f2  4628              MOV      r0,r5
0006f4  f7fffffe          BL       GUI_RectsIntersect
0006f8  b1d0              CBZ      r0,|L1.1840|
;;;716            if ((Status & WM_SF_HASTRANS) == 0) {
0006fa  f0080001          AND      r0,r8,#1
0006fe  b928              CBNZ     r0,|L1.1804|
;;;717              pRect->x1 = rWinClipped.x0-1;
000700  f8bd0000          LDRH     r0,[sp,#0]
000704  1e40              SUBS     r0,r0,#1
000706  b200              SXTH     r0,r0
000708  80a8              STRH     r0,[r5,#4]
00070a  e011              B        |L1.1840|
                  |L1.1804|
;;;718            } else {
;;;719              /* Check all children */
;;;720              WM_HWIN hChild;
;;;721              WM_Obj* pChild;
;;;722              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00070c  f9b49018          LDRSH    r9,[r4,#0x18]
000710  e00a              B        |L1.1832|
                  |L1.1810|
;;;723                pChild = WM_H2P(hChild);
000712  4648              MOV      r0,r9
000714  f7fffffe          BL       GUI_ALLOC_h2p
000718  4682              MOV      r10,r0
;;;724                _Findx1(hChild, pRect, &rWinClipped);
00071a  466a              MOV      r2,sp
00071c  4629              MOV      r1,r5
00071e  4648              MOV      r0,r9
000720  f7fffffe          BL       _Findx1
000724  f9ba901a          LDRSH    r9,[r10,#0x1a]        ;722
                  |L1.1832|
000728  f1b90f00          CMP      r9,#0                 ;722
00072c  d1f1              BNE      |L1.1810|
;;;725              }
;;;726            }
00072e  bf00              NOP      
                  |L1.1840|
;;;727          }
;;;728        }
000730  bf00              NOP      
                  |L1.1842|
000732  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;705
                  |L1.1846|
000736  2e00              CMP      r6,#0                 ;705
000738  d1c6              BNE      |L1.1736|
;;;729      }
;;;730    }
00073a  e8bd87fc          POP      {r2-r10,pc}
;;;731    
                          ENDP

                  WM_SendMessage PROC
;;;741    */
;;;742    void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
00073e  b570              PUSH     {r4-r6,lr}
000740  4604              MOV      r4,r0
000742  460d              MOV      r5,r1
;;;743      if (hWin) {
000744  b11c              CBZ      r4,|L1.1870|
;;;744        WM_LOCK();
;;;745        WM__SendMessage(hWin, pMsg);
000746  4629              MOV      r1,r5
000748  4620              MOV      r0,r4
00074a  f7fffffe          BL       WM__SendMessage
                  |L1.1870|
;;;746        WM_UNLOCK();
;;;747      }  
;;;748    }
00074e  bd70              POP      {r4-r6,pc}
;;;749    
                          ENDP

                  WM__GetClientRectWin PROC
;;;767    */
;;;768    void WM__GetClientRectWin(const WM_Obj* pWin, GUI_RECT* pRect) {
000750  2200              MOVS     r2,#0
;;;769      pRect->x0 = pRect->y0 = 0;
000752  804a              STRH     r2,[r1,#2]
000754  800a              STRH     r2,[r1,#0]
;;;770      pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
000756  8882              LDRH     r2,[r0,#4]
000758  8803              LDRH     r3,[r0,#0]
00075a  1ad2              SUBS     r2,r2,r3
00075c  b212              SXTH     r2,r2
00075e  808a              STRH     r2,[r1,#4]
;;;771      pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
000760  88c2              LDRH     r2,[r0,#6]
000762  8843              LDRH     r3,[r0,#2]
000764  1ad2              SUBS     r2,r2,r3
000766  b212              SXTH     r2,r2
000768  80ca              STRH     r2,[r1,#6]
;;;772    }
00076a  4770              BX       lr
;;;773    
                          ENDP

                  WM__GetInvalidRectAbs PROC
;;;777    */
;;;778    static void WM__GetInvalidRectAbs(WM_Obj* pWin, GUI_RECT* pRect) {
00076c  6882              LDR      r2,[r0,#8]
;;;779      *pRect = pWin->InvalidRect;
00076e  600a              STR      r2,[r1,#0]
000770  68c2              LDR      r2,[r0,#0xc]
000772  604a              STR      r2,[r1,#4]
;;;780    }
000774  4770              BX       lr
;;;781    
                          ENDP

                  WM_InvalidateRect PROC
;;;795    */
;;;796    void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT*pRect) {
000776  e92d41ff          PUSH     {r0-r8,lr}
00077a  4605              MOV      r5,r0
00077c  460e              MOV      r6,r1
;;;797      GUI_RECT r;
;;;798      WM_Obj* pWin;
;;;799      int Status;
;;;800      if (hWin) {
00077e  b355              CBZ      r5,|L1.2006|
;;;801        WM_LOCK();
;;;802        pWin = WM_H2P(hWin);
000780  4628              MOV      r0,r5
000782  f7fffffe          BL       GUI_ALLOC_h2p
000786  4604              MOV      r4,r0
;;;803        Status = pWin->Status;
000788  8ba7              LDRH     r7,[r4,#0x1c]
;;;804        if (Status & WM_SF_ISVIS) {
00078a  f0070002          AND      r0,r7,#2
00078e  b310              CBZ      r0,|L1.2006|
;;;805          r = pWin->Rect;
000790  e9d40100          LDRD     r0,r1,[r4,#0]
000794  e9cd0102          STRD     r0,r1,[sp,#8]
;;;806          if (pRect) {
000798  b166              CBZ      r6,|L1.1972|
;;;807            GUI_RECT rPara;
;;;808            rPara = *pRect;
00079a  6830              LDR      r0,[r6,#0]
00079c  9000              STR      r0,[sp,#0]
00079e  6870              LDR      r0,[r6,#4]
0007a0  9001              STR      r0,[sp,#4]
;;;809            WM__Client2Screen(pWin, &rPara);
0007a2  4669              MOV      r1,sp
0007a4  4620              MOV      r0,r4
0007a6  f7fffffe          BL       WM__Client2Screen
;;;810            GUI__IntersectRect(&r, &rPara);
0007aa  4669              MOV      r1,sp
0007ac  a802              ADD      r0,sp,#8
0007ae  f7fffffe          BL       GUI__IntersectRect
;;;811          }
0007b2  bf00              NOP      
                  |L1.1972|
;;;812          if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
0007b4  4629              MOV      r1,r5
0007b6  a802              ADD      r0,sp,#8
0007b8  f7fffffe          BL       WM__ClipAtParentBorders
0007bc  b158              CBZ      r0,|L1.2006|
;;;813            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
0007be  f6400001          MOV      r0,#0x801
0007c2  4038              ANDS     r0,r0,r7
0007c4  2801              CMP      r0,#1
0007c6  d107              BNE      |L1.2008|
;;;814              WM__InvalidateRectEx(&r, pWin->hParent, pWin->hNext);
0007c8  f9b4201a          LDRSH    r2,[r4,#0x1a]
0007cc  f9b41016          LDRSH    r1,[r4,#0x16]
0007d0  a802              ADD      r0,sp,#8
0007d2  f7fffffe          BL       WM__InvalidateRectEx
                  |L1.2006|
0007d6  e003              B        |L1.2016|
                  |L1.2008|
;;;815            } else {
;;;816              WM__Invalidate1Abs(hWin, &r);
0007d8  a902              ADD      r1,sp,#8
0007da  4628              MOV      r0,r5
0007dc  f7fffffe          BL       WM__Invalidate1Abs
                  |L1.2016|
;;;817            }
;;;818          }
;;;819        }
;;;820        WM_UNLOCK();
;;;821      }
;;;822    }
0007e0  e8bd81ff          POP      {r0-r8,pc}
;;;823    
                          ENDP

                  WM_InvalidateWindow PROC
;;;829    */
;;;830    void WM_InvalidateWindow(WM_HWIN hWin) {
0007e4  b510              PUSH     {r4,lr}
0007e6  4604              MOV      r4,r0
;;;831      WM_InvalidateRect(hWin, NULL);
0007e8  2100              MOVS     r1,#0
0007ea  4620              MOV      r0,r4
0007ec  f7fffffe          BL       WM_InvalidateRect
;;;832    }
0007f0  bd10              POP      {r4,pc}
;;;833    
                          ENDP

                  WM_CreateWindowAsChild PROC
;;;843    */
;;;844    WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
0007f2  e92d4ff8          PUSH     {r3-r11,lr}
;;;845                                   ,WM_HWIN hParent, U16 Style, WM_CALLBACK* cb
;;;846                                   ,int NumExtraBytes) {
0007f6  4680              MOV      r8,r0
0007f8  4689              MOV      r9,r1
0007fa  4692              MOV      r10,r2
0007fc  469b              MOV      r11,r3
0007fe  e9dd750a          LDRD     r7,r5,[sp,#0x28]
;;;847      WM_Obj* pWin;
;;;848      WM_HWIN hWin;
;;;849      WM_ASSERT_NOT_IN_PAINT();
;;;850      WM_LOCK();
;;;851      Style |= WM__CreateFlags;
000802  480c              LDR      r0,|L1.2100|
000804  8800              LDRH     r0,[r0,#0]  ; WM__CreateFlags
000806  4305              ORRS     r5,r5,r0
;;;852      /* Default parent is Desktop 0 */
;;;853      if (!hParent) {
000808  b92f              CBNZ     r7,|L1.2070|
;;;854        if (WM__NumWindows) {
00080a  4809              LDR      r0,|L1.2096|
00080c  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
00080e  b110              CBZ      r0,|L1.2070|
;;;855        #if GUI_NUM_LAYERS == 1
;;;856          hParent = WM__ahDesktopWin[0];
000810  4809              LDR      r0,|L1.2104|
000812  f9b07000          LDRSH    r7,[r0,#0]  ; WM__ahDesktopWin
                  |L1.2070|
;;;857        #else
;;;858          hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
;;;859        #endif
;;;860        }
;;;861      }
;;;862      if (hParent == WM_UNATTACHED) {
000816  1c78              ADDS     r0,r7,#1
000818  b988              CBNZ     r0,|L1.2110|
;;;863        hParent = WM_HWIN_NULL;
00081a  e00f              B        |L1.2108|
                  |L1.2076|
                          DCD      WM__FirstWin
                  |L1.2080|
                          DCD      WM__hWinFocus
                  |L1.2084|
                          DCD      WM__hCapture
                  |L1.2088|
                          DCD      WM__TransWindowCnt
                  |L1.2092|
                          DCD      WM__NumInvalidWindows
                  |L1.2096|
                          DCD      WM__NumWindows
                  |L1.2100|
                          DCD      WM__CreateFlags
                  |L1.2104|
                          DCD      WM__ahDesktopWin
                  |L1.2108|
00083c  2700              MOVS     r7,#0
                  |L1.2110|
;;;864      }  
;;;865      if (hParent) {
00083e  b1f7              CBZ      r7,|L1.2174|
;;;866        WM_Obj* pParent = WM_H2P(hParent);
000840  4638              MOV      r0,r7
000842  f7fffffe          BL       GUI_ALLOC_h2p
000846  4606              MOV      r6,r0
;;;867        x0 += pParent->Rect.x0;
000848  f9b60000          LDRSH    r0,[r6,#0]
00084c  4480              ADD      r8,r8,r0
;;;868        y0 += pParent->Rect.y0;
00084e  f9b60002          LDRSH    r0,[r6,#2]
000852  4481              ADD      r9,r9,r0
;;;869        if (width==0) {
000854  f1ba0f00          CMP      r10,#0
000858  d106              BNE      |L1.2152|
;;;870          width = pParent->Rect.x1 - pParent->Rect.x0+1;
00085a  f9b60004          LDRSH    r0,[r6,#4]
00085e  f9b61000          LDRSH    r1,[r6,#0]
000862  1a40              SUBS     r0,r0,r1
000864  f1000a01          ADD      r10,r0,#1
                  |L1.2152|
;;;871        }
;;;872        if (height==0) {
000868  f1bb0f00          CMP      r11,#0
00086c  d106              BNE      |L1.2172|
;;;873          height = pParent->Rect.y1 - pParent->Rect.y0+1;
00086e  f9b60006          LDRSH    r0,[r6,#6]
000872  f9b61002          LDRSH    r1,[r6,#2]
000876  1a40              SUBS     r0,r0,r1
000878  f1000b01          ADD      r11,r0,#1
                  |L1.2172|
;;;874        }
;;;875      }
00087c  bf00              NOP      
                  |L1.2174|
;;;876      if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
00087e  980d              LDR      r0,[sp,#0x34]
000880  3020              ADDS     r0,r0,#0x20
000882  b200              SXTH     r0,r0
000884  f7fffffe          BL       GUI_ALLOC_AllocZero
000888  9000              STR      r0,[sp,#0]
00088a  2800              CMP      r0,#0
00088c  d049              BEQ      |L1.2338|
;;;877        GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
;;;878      } else {
;;;879        WM__NumWindows++;
00088e  48fe              LDR      r0,|L1.3208|
000890  8800              LDRH     r0,[r0,#0]  ; WM__NumWindows
000892  1c40              ADDS     r0,r0,#1
000894  49fc              LDR      r1,|L1.3208|
000896  8008              STRH     r0,[r1,#0]
;;;880        pWin = WM_H2P(hWin);
000898  9800              LDR      r0,[sp,#0]
00089a  f7fffffe          BL       GUI_ALLOC_h2p
00089e  4604              MOV      r4,r0
;;;881        pWin->Rect.x0 = x0;
0008a0  fa0ff088          SXTH     r0,r8
0008a4  8020              STRH     r0,[r4,#0]
;;;882        pWin->Rect.y0 = y0;
0008a6  fa0ff089          SXTH     r0,r9
0008aa  8060              STRH     r0,[r4,#2]
;;;883        pWin->Rect.x1 = x0 + width - 1;
0008ac  eb08000a          ADD      r0,r8,r10
0008b0  1e40              SUBS     r0,r0,#1
0008b2  b200              SXTH     r0,r0
0008b4  80a0              STRH     r0,[r4,#4]
;;;884        pWin->Rect.y1 = y0 + height - 1;
0008b6  eb09000b          ADD      r0,r9,r11
0008ba  1e40              SUBS     r0,r0,#1
0008bc  b200              SXTH     r0,r0
0008be  80e0              STRH     r0,[r4,#6]
;;;885        pWin->cb = cb;
0008c0  980c              LDR      r0,[sp,#0x30]
0008c2  6120              STR      r0,[r4,#0x10]
;;;886        /* Copy the flags which can simply be accepted */
;;;887        pWin->Status |= (Style & (WM_CF_SHOW |
0008c4  8ba0              LDRH     r0,[r4,#0x1c]
0008c6  f643719f          MOV      r1,#0x3f9f
0008ca  4029              ANDS     r1,r1,r5
0008cc  4308              ORRS     r0,r0,r1
0008ce  83a0              STRH     r0,[r4,#0x1c]
;;;888                                  WM_SF_MEMDEV |
;;;889                                  WM_CF_MEMDEV_ON_REDRAW |
;;;890                                  WM_SF_STAYONTOP |
;;;891                                  WM_CF_DISABLED |
;;;892                                  WM_SF_CONST_OUTLINE |
;;;893                                  WM_SF_HASTRANS |
;;;894                                  WM_CF_ANCHOR_RIGHT |
;;;895                                  WM_CF_ANCHOR_BOTTOM |
;;;896                                  WM_CF_ANCHOR_LEFT |
;;;897                                  WM_CF_ANCHOR_TOP |
;;;898                                  WM_CF_LATE_CLIP));
;;;899        /* Add to linked lists */
;;;900        _AddToLinList(hWin);
0008d0  9800              LDR      r0,[sp,#0]
0008d2  f7fffffe          BL       _AddToLinList
;;;901        WM__InsertWindowIntoList(hWin, hParent);
0008d6  4639              MOV      r1,r7
0008d8  9800              LDR      r0,[sp,#0]
0008da  f7fffffe          BL       WM__InsertWindowIntoList
;;;902        /* Activate window if WM_CF_ACTIVATE is specified */
;;;903        if (Style & WM_CF_ACTIVATE) {
0008de  f0050020          AND      r0,r5,#0x20
0008e2  b110              CBZ      r0,|L1.2282|
;;;904          WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
0008e4  9800              LDR      r0,[sp,#0]
0008e6  f7fffffe          BL       WM_SelectWindow
                  |L1.2282|
;;;905        }
;;;906        /* Handle the Style flags, one at a time */
;;;907        #if WM_SUPPORT_TRANSPARENCY
;;;908          if (Style & WM_SF_HASTRANS) {
0008ea  f0050001          AND      r0,r5,#1
0008ee  b120              CBZ      r0,|L1.2298|
;;;909            WM__TransWindowCnt++;          /* Increment counter for transparency windows */
0008f0  48e6              LDR      r0,|L1.3212|
0008f2  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
0008f4  1c40              ADDS     r0,r0,#1
0008f6  49e5              LDR      r1,|L1.3212|
0008f8  6008              STR      r0,[r1,#0]  ; WM__TransWindowCnt
                  |L1.2298|
;;;910          }
;;;911        #endif
;;;912        if (Style & WM_CF_BGND) {
0008fa  f0050040          AND      r0,r5,#0x40
0008fe  b110              CBZ      r0,|L1.2310|
;;;913          WM_BringToBottom(hWin);
000900  9800              LDR      r0,[sp,#0]
000902  f7fffffe          BL       WM_BringToBottom
                  |L1.2310|
;;;914        }
;;;915        if (Style & WM_CF_SHOW) {
000906  f0050002          AND      r0,r5,#2
00090a  b130              CBZ      r0,|L1.2330|
;;;916          pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
00090c  8ba0              LDRH     r0,[r4,#0x1c]
00090e  f0400002          ORR      r0,r0,#2
000912  83a0              STRH     r0,[r4,#0x1c]
;;;917          WM_InvalidateWindow(hWin);    /* Mark content as invalid */
000914  9800              LDR      r0,[sp,#0]
000916  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2330|
;;;918        }
;;;919        WM__SendMsgNoData(hWin, WM_CREATE);
00091a  2101              MOVS     r1,#1
00091c  9800              LDR      r0,[sp,#0]
00091e  f7fffffe          BL       WM__SendMsgNoData
                  |L1.2338|
;;;920      }
;;;921      WM_UNLOCK();
;;;922      return hWin;
000922  9800              LDR      r0,[sp,#0]
;;;923    }
000924  e8bd8ff8          POP      {r3-r11,pc}
;;;924    
                          ENDP

                  WM_CreateWindow PROC
;;;928    */
;;;929    WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U16 Style, WM_CALLBACK* cb, int NumExtraBytes) {
000928  e92d47ff          PUSH     {r0-r10,lr}
00092c  4604              MOV      r4,r0
00092e  460d              MOV      r5,r1
000930  4616              MOV      r6,r2
000932  461f              MOV      r7,r3
000934  e9dd9a0d          LDRD     r9,r10,[sp,#0x34]
000938  f8dd8030          LDR      r8,[sp,#0x30]
;;;930      return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
00093c  2000              MOVS     r0,#0
00093e  463b              MOV      r3,r7
000940  4632              MOV      r2,r6
000942  4629              MOV      r1,r5
000944  e88d0701          STM      sp,{r0,r8-r10}
000948  4620              MOV      r0,r4
00094a  f7fffffe          BL       WM_CreateWindowAsChild
;;;931    }
00094e  b004              ADD      sp,sp,#0x10
000950  e8bd87f0          POP      {r4-r10,pc}
;;;932    
                          ENDP

                  WM_GetActiveWindow PROC
;;;1036   */
;;;1037   WM_HWIN WM_GetActiveWindow(void) {
000954  48ce              LDR      r0,|L1.3216|
;;;1038     return GUI_Context.hAWin;
000956  f9b0003c          LDRSH    r0,[r0,#0x3c]  ; GUI_Context
;;;1039   }
00095a  4770              BX       lr
;;;1040   
                          ENDP

                  _FindNext_IVR PROC
;;;1071   #if WM_SUPPORT_OBSTRUCT
;;;1072   static int _FindNext_IVR(void) {
00095c  b57c              PUSH     {r2-r6,lr}
;;;1073     WM_HMEM hParent;
;;;1074     GUI_RECT r;
;;;1075     WM_Obj* pAWin;
;;;1076     WM_Obj* pParent;
;;;1077     r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
00095e  49cd              LDR      r1,|L1.3220|
000960  e9d10102          LDRD     r0,r1,[r1,#8]
000964  e9cd0100          STRD     r0,r1,[sp,#0]
;;;1078     /*
;;;1079        STEP 1:
;;;1080          Set the next position which could be part of the next IVR
;;;1081          This will be the first unhandle pixel in reading order, i.e. next one to the right
;;;1082          or next one down if we are at the right border.
;;;1083     */
;;;1084     if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
000968  48ca              LDR      r0,|L1.3220|
00096a  6900              LDR      r0,[r0,#0x10]  ; _ClipContext
00096c  b940              CBNZ     r0,|L1.2432|
;;;1085       r.x0 = _ClipContext.ClientRect.x0;
00096e  48c9              LDR      r0,|L1.3220|
000970  8800              LDRH     r0,[r0,#0]  ; _ClipContext
000972  f8ad0000          STRH     r0,[sp,#0]
;;;1086       r.y0 = _ClipContext.ClientRect.y0;
000976  48c7              LDR      r0,|L1.3220|
000978  8840              LDRH     r0,[r0,#2]  ; _ClipContext
00097a  f8ad0002          STRH     r0,[sp,#2]
00097e  e01b              B        |L1.2488|
                  |L1.2432|
;;;1087     } else {
;;;1088       r.x0 = _ClipContext.CurRect.x1+1;
000980  48c4              LDR      r0,|L1.3220|
000982  8980              LDRH     r0,[r0,#0xc]
000984  1c40              ADDS     r0,r0,#1
000986  b200              SXTH     r0,r0
000988  f8ad0000          STRH     r0,[sp,#0]
;;;1089       r.y0 = _ClipContext.CurRect.y0;
00098c  48c1              LDR      r0,|L1.3220|
00098e  8940              LDRH     r0,[r0,#0xa]
000990  f8ad0002          STRH     r0,[sp,#2]
;;;1090       if (r.x0 > _ClipContext.ClientRect.x1) {
000994  f9bd0000          LDRSH    r0,[sp,#0]
000998  49be              LDR      r1,|L1.3220|
00099a  f9b11004          LDRSH    r1,[r1,#4]  ; _ClipContext
00099e  4288              CMP      r0,r1
0009a0  dd0a              BLE      |L1.2488|
;;;1091   NextStripe:  /* go down to next stripe */
0009a2  bf00              NOP      
                  |L1.2468|
;;;1092         r.x0 = _ClipContext.ClientRect.x0;
0009a4  48bb              LDR      r0,|L1.3220|
0009a6  8800              LDRH     r0,[r0,#0]  ; _ClipContext
0009a8  f8ad0000          STRH     r0,[sp,#0]
;;;1093         r.y0 = _ClipContext.CurRect.y1+1;
0009ac  48b9              LDR      r0,|L1.3220|
0009ae  89c0              LDRH     r0,[r0,#0xe]
0009b0  1c40              ADDS     r0,r0,#1
0009b2  b200              SXTH     r0,r0
0009b4  f8ad0002          STRH     r0,[sp,#2]
                  |L1.2488|
;;;1094       }
;;;1095     }
;;;1096     /*
;;;1097        STEP 2:
;;;1098          Check if we are done completely.
;;;1099     */
;;;1100     if (r.y0 >_ClipContext.ClientRect.y1) {
0009b8  f9bd0002          LDRSH    r0,[sp,#2]
0009bc  49b5              LDR      r1,|L1.3220|
0009be  f9b11006          LDRSH    r1,[r1,#6]  ; _ClipContext
0009c2  4288              CMP      r0,r1
0009c4  dd01              BLE      |L1.2506|
;;;1101       return 0;
0009c6  2000              MOVS     r0,#0
                  |L1.2504|
;;;1102     }
;;;1103     /* STEP 3:
;;;1104          Find out the max. height (r.y1) if we are at the left border.
;;;1105          Since we are using the same height for all IVRs at the same y0,
;;;1106          we do this only for the leftmost one.
;;;1107     */
;;;1108     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1109     if (r.x0 == _ClipContext.ClientRect.x0) {
;;;1110       r.y1 = _ClipContext.ClientRect.y1;
;;;1111       r.x1 = _ClipContext.ClientRect.x1;
;;;1112       /* Iterate over all windows which are above */
;;;1113       /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1114       for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
;;;1115         pParent = WM_H2P(hParent);
;;;1116         _Findy1(pParent->hNext, &r, NULL);
;;;1117       }
;;;1118       /* Check all children */
;;;1119       _Findy1(pAWin->hFirstChild, &r, NULL);
;;;1120     }
;;;1121     /* 
;;;1122       STEP 4
;;;1123         Find out x0 for the given y0, y1 by iterating over windows above.
;;;1124         if we find one that intersects, adjust x0 to the right.
;;;1125     */
;;;1126   Find_x0:
;;;1127     r.x1 = r.x0;
;;;1128     /* Iterate over all windows which are above */
;;;1129     /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
;;;1130     #if 0   /* This is a planned, but not yet released optimization */
;;;1131       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1132       {
;;;1133         hParent = pAWin->hParent;
;;;1134       } else
;;;1135     #endif
;;;1136     {
;;;1137       hParent = GUI_Context.hAWin;
;;;1138     }
;;;1139     for (; hParent; hParent = pParent->hParent) {
;;;1140       pParent = WM_H2P(hParent);
;;;1141       if (_Findx0(pParent->hNext, &r, NULL)) {
;;;1142         goto Find_x0;
;;;1143       }
;;;1144     }
;;;1145     /* Check all children */
;;;1146     if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
;;;1147       goto Find_x0;
;;;1148     }
;;;1149     /* 
;;;1150      STEP 5:
;;;1151        If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
;;;1152        Find out x1 for the given x0, y0, y1
;;;1153     */
;;;1154     r.x1 = _ClipContext.ClientRect.x1;
;;;1155     if (r.x1 < r.x0) {/* horizontal border reached ? */
;;;1156       _ClipContext.CurRect = r;
;;;1157       goto NextStripe;
;;;1158     }    
;;;1159     /* 
;;;1160      STEP 6:
;;;1161        Find r.x1. We have to Iterate over all windows which are above
;;;1162     */
;;;1163     /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1164     #if 0   /* This is a planned, but not yet released optimization */
;;;1165       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1166       {
;;;1167         hParent = pAWin->hParent;
;;;1168       } else
;;;1169     #endif
;;;1170     {
;;;1171       hParent = GUI_Context.hAWin;
;;;1172     }
;;;1173     for (; hParent; hParent = pParent->hParent) {
;;;1174       pParent = WM_H2P(hParent);
;;;1175       _Findx1(pParent->hNext, &r, NULL);
;;;1176     }
;;;1177     /* Check all children */
;;;1178     _Findx1(pAWin->hFirstChild, &r, NULL);
;;;1179     /* We are done. Return the rectangle we found in the _ClipContext. */
;;;1180     if (_ClipContext.Cnt >200) {
;;;1181       return 0;  /* error !!! This should not happen !*/
;;;1182     }
;;;1183     _ClipContext.CurRect = r;
;;;1184     return 1;  /* IVR is valid ! */
;;;1185   }
0009c8  bd7c              POP      {r2-r6,pc}
                  |L1.2506|
0009ca  49b1              LDR      r1,|L1.3216|
0009cc  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1108  ; GUI_Context
0009d0  f7fffffe          BL       GUI_ALLOC_h2p
0009d4  4605              MOV      r5,r0                 ;1108
0009d6  f9bd0000          LDRSH    r0,[sp,#0]            ;1109
0009da  49ae              LDR      r1,|L1.3220|
0009dc  f9b11000          LDRSH    r1,[r1,#0]            ;1109  ; _ClipContext
0009e0  4288              CMP      r0,r1                 ;1109
0009e2  d11f              BNE      |L1.2596|
0009e4  48ab              LDR      r0,|L1.3220|
0009e6  88c0              LDRH     r0,[r0,#6]            ;1110  ; _ClipContext
0009e8  f8ad0006          STRH     r0,[sp,#6]            ;1110
0009ec  48a9              LDR      r0,|L1.3220|
0009ee  8880              LDRH     r0,[r0,#4]            ;1111  ; _ClipContext
0009f0  f8ad0004          STRH     r0,[sp,#4]            ;1111
0009f4  48a6              LDR      r0,|L1.3216|
0009f6  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1114  ; GUI_Context
0009fa  e00b              B        |L1.2580|
                  |L1.2556|
0009fc  4630              MOV      r0,r6                 ;1115
0009fe  f7fffffe          BL       GUI_ALLOC_h2p
000a02  4604              MOV      r4,r0                 ;1115
000a04  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1116
000a08  2200              MOVS     r2,#0                 ;1116
000a0a  4669              MOV      r1,sp                 ;1116
000a0c  f7fffffe          BL       _Findy1
000a10  f9b46016          LDRSH    r6,[r4,#0x16]         ;1114
                  |L1.2580|
000a14  2e00              CMP      r6,#0                 ;1114
000a16  d1f1              BNE      |L1.2556|
000a18  f9b50018          LDRSH    r0,[r5,#0x18]         ;1119
000a1c  2200              MOVS     r2,#0                 ;1119
000a1e  4669              MOV      r1,sp                 ;1119
000a20  f7fffffe          BL       _Findy1
                  |L1.2596|
000a24  bf00              NOP                            ;1126
                  |L1.2598|
000a26  f8bd0000          LDRH     r0,[sp,#0]            ;1127
000a2a  f8ad0004          STRH     r0,[sp,#4]            ;1127
000a2e  4898              LDR      r0,|L1.3216|
000a30  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1137  ; GUI_Context
000a34  e00d              B        |L1.2642|
                  |L1.2614|
000a36  4630              MOV      r0,r6                 ;1140
000a38  f7fffffe          BL       GUI_ALLOC_h2p
000a3c  4604              MOV      r4,r0                 ;1140
000a3e  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1141
000a42  2200              MOVS     r2,#0                 ;1141
000a44  4669              MOV      r1,sp                 ;1141
000a46  f7fffffe          BL       _Findx0
000a4a  b100              CBZ      r0,|L1.2638|
000a4c  e7eb              B        |L1.2598|
                  |L1.2638|
000a4e  f9b46016          LDRSH    r6,[r4,#0x16]         ;1139
                  |L1.2642|
000a52  2e00              CMP      r6,#0                 ;1139
000a54  d1ef              BNE      |L1.2614|
000a56  f9b50018          LDRSH    r0,[r5,#0x18]         ;1146
000a5a  2200              MOVS     r2,#0                 ;1146
000a5c  4669              MOV      r1,sp                 ;1146
000a5e  f7fffffe          BL       _Findx0
000a62  b100              CBZ      r0,|L1.2662|
000a64  e7df              B        |L1.2598|
                  |L1.2662|
000a66  488b              LDR      r0,|L1.3220|
000a68  8880              LDRH     r0,[r0,#4]            ;1154  ; _ClipContext
000a6a  f8ad0004          STRH     r0,[sp,#4]            ;1154
000a6e  f9bd0004          LDRSH    r0,[sp,#4]            ;1155
000a72  f9bd1000          LDRSH    r1,[sp,#0]            ;1155
000a76  4288              CMP      r0,r1                 ;1155
000a78  da05              BGE      |L1.2694|
000a7a  4886              LDR      r0,|L1.3220|
000a7c  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1156
000a80  e9c01202          STRD     r1,r2,[r0,#8]         ;1156
000a84  e78e              B        |L1.2468|
                  |L1.2694|
000a86  4882              LDR      r0,|L1.3216|
000a88  f9b0603c          LDRSH    r6,[r0,#0x3c]         ;1171  ; GUI_Context
000a8c  e00b              B        |L1.2726|
                  |L1.2702|
000a8e  4630              MOV      r0,r6                 ;1174
000a90  f7fffffe          BL       GUI_ALLOC_h2p
000a94  4604              MOV      r4,r0                 ;1174
000a96  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;1175
000a9a  2200              MOVS     r2,#0                 ;1175
000a9c  4669              MOV      r1,sp                 ;1175
000a9e  f7fffffe          BL       _Findx1
000aa2  f9b46016          LDRSH    r6,[r4,#0x16]         ;1173
                  |L1.2726|
000aa6  2e00              CMP      r6,#0                 ;1173
000aa8  d1f1              BNE      |L1.2702|
000aaa  f9b50018          LDRSH    r0,[r5,#0x18]         ;1178
000aae  2200              MOVS     r2,#0                 ;1178
000ab0  4669              MOV      r1,sp                 ;1178
000ab2  f7fffffe          BL       _Findx1
000ab6  4877              LDR      r0,|L1.3220|
000ab8  6900              LDR      r0,[r0,#0x10]         ;1180  ; _ClipContext
000aba  28c8              CMP      r0,#0xc8              ;1180
000abc  dd01              BLE      |L1.2754|
000abe  2000              MOVS     r0,#0                 ;1181
000ac0  e782              B        |L1.2504|
                  |L1.2754|
000ac2  4874              LDR      r0,|L1.3220|
000ac4  e9dd1200          LDRD     r1,r2,[sp,#0]         ;1183
000ac8  e9c01202          STRD     r1,r2,[r0,#8]         ;1183
000acc  2001              MOVS     r0,#1                 ;1184
000ace  e77b              B        |L1.2504|
;;;1186   
                          ENDP

                  WM__GetNextIVR PROC
;;;1210   */
;;;1211   int  WM__GetNextIVR(void) {
000ad0  b510              PUSH     {r4,lr}
;;;1212     #if GUI_SUPPORT_CURSOR
;;;1213       static char _CursorHidden;
;;;1214     #endif
;;;1215     /* If WM is not active, we have no rectangles to return */
;;;1216     if (WM_IsActive==0) {
000ad2  4871              LDR      r0,|L1.3224|
000ad4  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000ad6  b908              CBNZ     r0,|L1.2780|
;;;1217       return 0;
000ad8  2000              MOVS     r0,#0
                  |L1.2778|
;;;1218     }
;;;1219     if (_ClipContext.EntranceCnt > 1) {
;;;1220       _ClipContext.EntranceCnt--;
;;;1221       return 0;
;;;1222     }
;;;1223     #if GUI_SUPPORT_CURSOR
;;;1224       if (_CursorHidden) {
;;;1225         _CursorHidden = 0;
;;;1226         (*GUI_CURSOR_pfTempUnhide) ();
;;;1227       }
;;;1228     #endif
;;;1229     ++_ClipContext.Cnt;
;;;1230     /* Find next rectangle and use it as ClipRect */
;;;1231     if (!_FindNext_IVR()) {
;;;1232       _ClipContext.EntranceCnt--;  /* This search is over ! */
;;;1233       return 0;        /* Could not find an other one ! */
;;;1234     }
;;;1235     WM__ActivateClipRect();
;;;1236     /* Hide cursor if necessary */
;;;1237     #if GUI_SUPPORT_CURSOR
;;;1238       if (GUI_CURSOR_pfTempHide) {
;;;1239         _CursorHidden = (*GUI_CURSOR_pfTempHide) ( &_ClipContext.CurRect);
;;;1240       }
;;;1241     #endif
;;;1242     return 1;
;;;1243   }
000ada  bd10              POP      {r4,pc}
                  |L1.2780|
000adc  486d              LDR      r0,|L1.3220|
000ade  6940              LDR      r0,[r0,#0x14]         ;1219  ; _ClipContext
000ae0  2801              CMP      r0,#1                 ;1219
000ae2  dd06              BLE      |L1.2802|
000ae4  486b              LDR      r0,|L1.3220|
000ae6  6940              LDR      r0,[r0,#0x14]         ;1220  ; _ClipContext
000ae8  1e40              SUBS     r0,r0,#1              ;1220
000aea  496a              LDR      r1,|L1.3220|
000aec  6148              STR      r0,[r1,#0x14]         ;1220  ; _ClipContext
000aee  2000              MOVS     r0,#0                 ;1221
000af0  e7f3              B        |L1.2778|
                  |L1.2802|
000af2  4868              LDR      r0,|L1.3220|
000af4  6900              LDR      r0,[r0,#0x10]         ;1229  ; _ClipContext
000af6  1c40              ADDS     r0,r0,#1              ;1229
000af8  4966              LDR      r1,|L1.3220|
000afa  6108              STR      r0,[r1,#0x10]         ;1229  ; _ClipContext
000afc  f7fffffe          BL       _FindNext_IVR
000b00  b930              CBNZ     r0,|L1.2832|
000b02  4864              LDR      r0,|L1.3220|
000b04  6940              LDR      r0,[r0,#0x14]         ;1232  ; _ClipContext
000b06  1e40              SUBS     r0,r0,#1              ;1232
000b08  4962              LDR      r1,|L1.3220|
000b0a  6148              STR      r0,[r1,#0x14]         ;1232  ; _ClipContext
000b0c  2000              MOVS     r0,#0                 ;1233
000b0e  e7e4              B        |L1.2778|
                  |L1.2832|
000b10  f7fffffe          BL       WM__ActivateClipRect
000b14  2001              MOVS     r0,#1                 ;1242
000b16  e7e0              B        |L1.2778|
;;;1244   
                          ENDP

                  WM__InitIVRSearch PROC
;;;1256   */
;;;1257   int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
000b18  b57f              PUSH     {r0-r6,lr}
000b1a  4605              MOV      r5,r0
;;;1258     GUI_RECT r;
;;;1259     WM_Obj* pAWin;
;;;1260     GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
;;;1261      /* If WM is not active -> nothing to do, leave cliprect alone */
;;;1262     if (WM_IsActive==0) {
000b1c  485e              LDR      r0,|L1.3224|
000b1e  7800              LDRB     r0,[r0,#0]  ; WM_IsActive
000b20  b920              CBNZ     r0,|L1.2860|
;;;1263       WM__ActivateClipRect();
000b22  f7fffffe          BL       WM__ActivateClipRect
;;;1264       return 1;
000b26  2001              MOVS     r0,#1
                  |L1.2856|
;;;1265     }
;;;1266     /* If we entered multiple times, leave Cliprect alone */
;;;1267     if (++_ClipContext.EntranceCnt > 1)
;;;1268       return 1;
;;;1269     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1270     _ClipContext.Cnt        = -1;
;;;1271    /* When using callback mechanism, it is legal to reduce drawing
;;;1272       area to the invalid area ! */
;;;1273     if (WM__PaintCallbackCnt) {
;;;1274       WM__GetInvalidRectAbs(pAWin, &r);
;;;1275     } else {  /* Not using callback mechanism, therefor allow entire rectangle */
;;;1276       if (pAWin->Status & WM_SF_ISVIS) {
;;;1277         r = pAWin->Rect;
;;;1278       } else {
;;;1279         --_ClipContext.EntranceCnt;
;;;1280         return 0;  /* window is not even visible ! */
;;;1281       }
;;;1282     }
;;;1283     /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
;;;1284     if (pMaxRect) {
;;;1285       GUI__IntersectRect(&r, pMaxRect);
;;;1286     }
;;;1287     /* If user has reduced the cliprect size, reduce the rectangle */
;;;1288     if (GUI_Context.WM__pUserClipRect) {
;;;1289       WM_Obj* pWin = pAWin;
;;;1290       GUI_RECT rUser = *(GUI_Context.WM__pUserClipRect);
;;;1291       #if WM_SUPPORT_TRANSPARENCY
;;;1292         if (WM__hATransWindow) {
;;;1293           pWin = WM_H2P(WM__hATransWindow);
;;;1294         }   
;;;1295       #endif
;;;1296       WM__Client2Screen(pWin, &rUser);
;;;1297       GUI__IntersectRect(&r, &rUser);
;;;1298     }
;;;1299     /* For transparent windows, we need to further reduce the rectangle */
;;;1300     #if WM_SUPPORT_TRANSPARENCY
;;;1301       if (WM__hATransWindow) {
;;;1302         if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
;;;1303           --_ClipContext.EntranceCnt;
;;;1304           return 0;           /* Nothing to draw */
;;;1305         }
;;;1306       }
;;;1307     #endif
;;;1308     /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
;;;1309     if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
;;;1310       --_ClipContext.EntranceCnt;
;;;1311       return 0;           /* Nothing to draw */
;;;1312     }
;;;1313     /* Store the rectangle and find the first rectangle of the area */
;;;1314     _ClipContext.ClientRect = r;
;;;1315     return WM__GetNextIVR();
;;;1316   }
000b28  b004              ADD      sp,sp,#0x10
000b2a  bd70              POP      {r4-r6,pc}
                  |L1.2860|
000b2c  4859              LDR      r0,|L1.3220|
000b2e  6940              LDR      r0,[r0,#0x14]         ;1267  ; _ClipContext
000b30  1c40              ADDS     r0,r0,#1              ;1267
000b32  4958              LDR      r1,|L1.3220|
000b34  6148              STR      r0,[r1,#0x14]         ;1267  ; _ClipContext
000b36  2801              CMP      r0,#1                 ;1267
000b38  dd01              BLE      |L1.2878|
000b3a  2001              MOVS     r0,#1                 ;1268
000b3c  e7f4              B        |L1.2856|
                  |L1.2878|
000b3e  4954              LDR      r1,|L1.3216|
000b40  f9b1003c          LDRSH    r0,[r1,#0x3c]         ;1269  ; GUI_Context
000b44  f7fffffe          BL       GUI_ALLOC_h2p
000b48  4604              MOV      r4,r0                 ;1269
000b4a  f04f30ff          MOV      r0,#0xffffffff        ;1270
000b4e  4951              LDR      r1,|L1.3220|
000b50  6108              STR      r0,[r1,#0x10]         ;1270  ; _ClipContext
000b52  4852              LDR      r0,|L1.3228|
000b54  7800              LDRB     r0,[r0,#0]            ;1273  ; WM__PaintCallbackCnt
000b56  b120              CBZ      r0,|L1.2914|
000b58  a902              ADD      r1,sp,#8              ;1274
000b5a  4620              MOV      r0,r4                 ;1274
000b5c  f7fffffe          BL       WM__GetInvalidRectAbs
000b60  e00f              B        |L1.2946|
                  |L1.2914|
000b62  7f20              LDRB     r0,[r4,#0x1c]         ;1276
000b64  f0000002          AND      r0,r0,#2              ;1276
000b68  b120              CBZ      r0,|L1.2932|
000b6a  e9d40100          LDRD     r0,r1,[r4,#0]         ;1277
000b6e  e9cd0102          STRD     r0,r1,[sp,#8]         ;1277
000b72  e006              B        |L1.2946|
                  |L1.2932|
000b74  4847              LDR      r0,|L1.3220|
000b76  6940              LDR      r0,[r0,#0x14]         ;1279  ; _ClipContext
000b78  1e40              SUBS     r0,r0,#1              ;1279
000b7a  4946              LDR      r1,|L1.3220|
000b7c  6148              STR      r0,[r1,#0x14]         ;1279  ; _ClipContext
000b7e  2000              MOVS     r0,#0                 ;1280
000b80  e7d2              B        |L1.2856|
                  |L1.2946|
000b82  b11d              CBZ      r5,|L1.2956|
000b84  4629              MOV      r1,r5                 ;1285
000b86  a802              ADD      r0,sp,#8              ;1285
000b88  f7fffffe          BL       GUI__IntersectRect
                  |L1.2956|
000b8c  4840              LDR      r0,|L1.3216|
000b8e  6b80              LDR      r0,[r0,#0x38]         ;1288  ; GUI_Context
000b90  b1c0              CBZ      r0,|L1.3012|
000b92  4626              MOV      r6,r4                 ;1289
000b94  483e              LDR      r0,|L1.3216|
000b96  6b80              LDR      r0,[r0,#0x38]         ;1290  ; GUI_Context
000b98  6801              LDR      r1,[r0,#0]            ;1290
000b9a  9100              STR      r1,[sp,#0]            ;1290
000b9c  6840              LDR      r0,[r0,#4]            ;1290
000b9e  9001              STR      r0,[sp,#4]            ;1290
000ba0  483f              LDR      r0,|L1.3232|
000ba2  8800              LDRH     r0,[r0,#0]            ;1292  ; WM__hATransWindow
000ba4  b128              CBZ      r0,|L1.2994|
000ba6  483e              LDR      r0,|L1.3232|
000ba8  f9b00000          LDRSH    r0,[r0,#0]            ;1293  ; WM__hATransWindow
000bac  f7fffffe          BL       GUI_ALLOC_h2p
000bb0  4606              MOV      r6,r0                 ;1293
                  |L1.2994|
000bb2  4669              MOV      r1,sp                 ;1296
000bb4  4630              MOV      r0,r6                 ;1296
000bb6  f7fffffe          BL       WM__Client2Screen
000bba  4669              MOV      r1,sp                 ;1297
000bbc  a802              ADD      r0,sp,#8              ;1297
000bbe  f7fffffe          BL       GUI__IntersectRect
000bc2  bf00              NOP                            ;1298
                  |L1.3012|
000bc4  4836              LDR      r0,|L1.3232|
000bc6  8800              LDRH     r0,[r0,#0]            ;1301  ; WM__hATransWindow
000bc8  b168              CBZ      r0,|L1.3046|
000bca  4835              LDR      r0,|L1.3232|
000bcc  f9b01000          LDRSH    r1,[r0,#0]            ;1302  ; WM__hATransWindow
000bd0  a802              ADD      r0,sp,#8              ;1302
000bd2  f7fffffe          BL       WM__ClipAtParentBorders
000bd6  b930              CBNZ     r0,|L1.3046|
000bd8  482e              LDR      r0,|L1.3220|
000bda  6940              LDR      r0,[r0,#0x14]         ;1303  ; _ClipContext
000bdc  1e40              SUBS     r0,r0,#1              ;1303
000bde  492d              LDR      r1,|L1.3220|
000be0  6148              STR      r0,[r1,#0x14]         ;1303  ; _ClipContext
000be2  2000              MOVS     r0,#0                 ;1304
000be4  e7a0              B        |L1.2856|
                  |L1.3046|
000be6  482a              LDR      r0,|L1.3216|
000be8  f9b0103c          LDRSH    r1,[r0,#0x3c]         ;1309  ; GUI_Context
000bec  a802              ADD      r0,sp,#8              ;1309
000bee  f7fffffe          BL       WM__ClipAtParentBorders
000bf2  b930              CBNZ     r0,|L1.3074|
000bf4  4827              LDR      r0,|L1.3220|
000bf6  6940              LDR      r0,[r0,#0x14]         ;1310  ; _ClipContext
000bf8  1e40              SUBS     r0,r0,#1              ;1310
000bfa  4926              LDR      r1,|L1.3220|
000bfc  6148              STR      r0,[r1,#0x14]         ;1310  ; _ClipContext
000bfe  2000              MOVS     r0,#0                 ;1311
000c00  e792              B        |L1.2856|
                  |L1.3074|
000c02  4824              LDR      r0,|L1.3220|
000c04  e9dd1202          LDRD     r1,r2,[sp,#8]         ;1314
000c08  c006              STM      r0!,{r1,r2}           ;1314
000c0a  f7fffffe          BL       WM__GetNextIVR
000c0e  e78b              B        |L1.2856|
;;;1317   
                          ENDP

                  WM_SetDefault PROC
;;;1326   */
;;;1327   void WM_SetDefault(void) {
000c10  b510              PUSH     {r4,lr}
;;;1328     GL_SetDefault();
000c12  f7fffffe          BL       GL_SetDefault
;;;1329     GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
000c16  2000              MOVS     r0,#0
000c18  491d              LDR      r1,|L1.3216|
000c1a  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1330   }
000c1c  bd10              POP      {r4,pc}
;;;1331   
                          ENDP

                  _Paint1 PROC
;;;1335   */
;;;1336   static void _Paint1(WM_HWIN hWin, WM_Obj* pWin) {
000c1e  b5fe              PUSH     {r1-r7,lr}
000c20  4605              MOV      r5,r0
000c22  460c              MOV      r4,r1
;;;1337     int Status = pWin->Status;
000c24  8ba6              LDRH     r6,[r4,#0x1c]
;;;1338     /* Send WM_PAINT if window is visible and a callback is defined */
;;;1339     if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
000c26  6920              LDR      r0,[r4,#0x10]
000c28  2800              CMP      r0,#0
000c2a  d045              BEQ      |L1.3256|
000c2c  f0060002          AND      r0,r6,#2
000c30  b348              CBZ      r0,|L1.3206|
;;;1340       WM_MESSAGE Msg;
;;;1341       WM__PaintCallbackCnt++;
000c32  481a              LDR      r0,|L1.3228|
000c34  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000c36  1c40              ADDS     r0,r0,#1
000c38  4918              LDR      r1,|L1.3228|
000c3a  7008              STRB     r0,[r1,#0]
;;;1342       if (Status & WM_SF_LATE_CLIP) {
000c3c  f4065080          AND      r0,r6,#0x1000
000c40  b168              CBZ      r0,|L1.3166|
;;;1343         Msg.hWin   = hWin;
000c42  f8ad5004          STRH     r5,[sp,#4]
;;;1344         Msg.MsgId  = WM_PAINT;
000c46  200f              MOVS     r0,#0xf
000c48  9000              STR      r0,[sp,#0]
;;;1345         Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000c4a  f1040008          ADD      r0,r4,#8
000c4e  9002              STR      r0,[sp,#8]
;;;1346         WM_SetDefault();
000c50  f7fffffe          BL       WM_SetDefault
;;;1347         WM__SendMessage(hWin, &Msg);
000c54  4669              MOV      r1,sp
000c56  4628              MOV      r0,r5
000c58  f7fffffe          BL       WM__SendMessage
000c5c  e026              B        |L1.3244|
                  |L1.3166|
;;;1348       } else {
;;;1349         WM_ITERATE_START(&pWin->InvalidRect) {
000c5e  f1040008          ADD      r0,r4,#8
000c62  f7fffffe          BL       WM__InitIVRSearch
000c66  b308              CBZ      r0,|L1.3244|
000c68  bf00              NOP      
                  |L1.3178|
;;;1350           Msg.hWin   = hWin;
000c6a  f8ad5004          STRH     r5,[sp,#4]
;;;1351           Msg.MsgId  = WM_PAINT;
000c6e  200f              MOVS     r0,#0xf
000c70  9000              STR      r0,[sp,#0]
;;;1352           Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000c72  f1040008          ADD      r0,r4,#8
000c76  9002              STR      r0,[sp,#8]
;;;1353           WM_SetDefault();
000c78  f7fffffe          BL       WM_SetDefault
;;;1354           WM__SendMessage(hWin, &Msg);
000c7c  4669              MOV      r1,sp
000c7e  4628              MOV      r0,r5
000c80  f7fffffe          BL       WM__SendMessage
;;;1355         } WM_ITERATE_END();
000c84  e00e              B        |L1.3236|
                  |L1.3206|
000c86  e017              B        |L1.3256|
                  |L1.3208|
                          DCD      WM__NumWindows
                  |L1.3212|
                          DCD      WM__TransWindowCnt
                  |L1.3216|
                          DCD      GUI_Context
                  |L1.3220|
                          DCD      _ClipContext
                  |L1.3224|
                          DCD      WM_IsActive
                  |L1.3228|
                          DCD      WM__PaintCallbackCnt
                  |L1.3232|
                          DCD      WM__hATransWindow
                  |L1.3236|
000ca4  f7fffffe          BL       WM__GetNextIVR
000ca8  2800              CMP      r0,#0
000caa  d1de              BNE      |L1.3178|
                  |L1.3244|
;;;1356       }
;;;1357       WM__PaintCallbackCnt--;
000cac  48f6              LDR      r0,|L1.4232|
000cae  7800              LDRB     r0,[r0,#0]  ; WM__PaintCallbackCnt
000cb0  1e40              SUBS     r0,r0,#1
000cb2  49f5              LDR      r1,|L1.4232|
000cb4  7008              STRB     r0,[r1,#0]
;;;1358     }
000cb6  bf00              NOP      
                  |L1.3256|
;;;1359   }
000cb8  bdfe              POP      {r1-r7,pc}
;;;1360   /*********************************************************************
                          ENDP

                  _Paint1Trans PROC
;;;1382   #if WM_SUPPORT_TRANSPARENCY
;;;1383   static int _Paint1Trans(WM_HWIN hWin, WM_Obj* pWin) {
000cba  e92d41f0          PUSH     {r4-r8,lr}
000cbe  4605              MOV      r5,r0
000cc0  460c              MOV      r4,r1
;;;1384     int xPrev, yPrev;
;;;1385     WM_Obj* pAWin = WM_H2P(GUI_Context.hAWin);
000cc2  49f2              LDR      r1,|L1.4236|
000cc4  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
000cc8  f7fffffe          BL       GUI_ALLOC_h2p
000ccc  4680              MOV      r8,r0
;;;1386     /* Check if we need to do any drawing */
;;;1387     if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
000cce  4621              MOV      r1,r4
000cd0  f1080008          ADD      r0,r8,#8
000cd4  f7fffffe          BL       GUI_RectsIntersect
000cd8  b1f8              CBZ      r0,|L1.3354|
;;;1388       /* Save old values */
;;;1389       xPrev = GUI_Context.xOff;
000cda  48ec              LDR      r0,|L1.4236|
000cdc  6c06              LDR      r6,[r0,#0x40]  ; GUI_Context
;;;1390       yPrev = GUI_Context.yOff;
000cde  6c47              LDR      r7,[r0,#0x44]  ; GUI_Context
;;;1391       /* Set values for the current (transparent) window, rather than the one below */
;;;1392       GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
000ce0  f1080208          ADD      r2,r8,#8
000ce4  4621              MOV      r1,r4
000ce6  f1040008          ADD      r0,r4,#8
000cea  f7fffffe          BL       GUI__IntersectRects
;;;1393       WM__hATransWindow = hWin;
000cee  48e8              LDR      r0,|L1.4240|
000cf0  8005              STRH     r5,[r0,#0]
;;;1394       GUI_Context.xOff = pWin->Rect.x0;
000cf2  f9b40000          LDRSH    r0,[r4,#0]
000cf6  49e5              LDR      r1,|L1.4236|
000cf8  6408              STR      r0,[r1,#0x40]  ; GUI_Context
;;;1395       GUI_Context.yOff = pWin->Rect.y0;
000cfa  f9b40002          LDRSH    r0,[r4,#2]
000cfe  6448              STR      r0,[r1,#0x44]  ; GUI_Context
;;;1396       /* Do the actual drawing ... */
;;;1397       _Paint1(hWin, pWin);
000d00  4621              MOV      r1,r4
000d02  4628              MOV      r0,r5
000d04  f7fffffe          BL       _Paint1
;;;1398       /* Restore settings */
;;;1399       WM__hATransWindow = 0;
000d08  2000              MOVS     r0,#0
000d0a  49e1              LDR      r1,|L1.4240|
000d0c  8008              STRH     r0,[r1,#0]
;;;1400       GUI_Context.xOff = xPrev;
000d0e  48df              LDR      r0,|L1.4236|
000d10  6406              STR      r6,[r0,#0x40]  ; GUI_Context
;;;1401       GUI_Context.yOff = yPrev;
000d12  6447              STR      r7,[r0,#0x44]  ; GUI_Context
;;;1402       return 1;                       /* Some drawing took place */
000d14  2001              MOVS     r0,#1
                  |L1.3350|
;;;1403     }
;;;1404     return 0;                         /* No invalid area, so nothing was drawn */
;;;1405   }
000d16  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3354|
000d1a  2000              MOVS     r0,#0                 ;1404
000d1c  e7fb              B        |L1.3350|
;;;1406   #endif
                          ENDP

                  _PaintTransChildren PROC
;;;1419   #if WM_SUPPORT_TRANSPARENCY
;;;1420   static void _PaintTransChildren(WM_HWIN hWin, WM_Obj* pWin) {
000d1e  e92d41fc          PUSH     {r2-r8,lr}
000d22  4607              MOV      r7,r0
000d24  460c              MOV      r4,r1
;;;1421     WM_HWIN hChild;
;;;1422     WM_Obj* pChild;
;;;1423     if (pWin->Status & WM_SF_ISVIS) {
000d26  7f20              LDRB     r0,[r4,#0x1c]
000d28  f0000002          AND      r0,r0,#2
000d2c  2800              CMP      r0,#0
000d2e  d033              BEQ      |L1.3480|
;;;1424       for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000d30  f9b46018          LDRSH    r6,[r4,#0x18]
000d34  e02e              B        |L1.3476|
                  |L1.3382|
;;;1425         pChild = WM_H2P(hChild);
000d36  4630              MOV      r0,r6
000d38  f7fffffe          BL       GUI_ALLOC_h2p
000d3c  4605              MOV      r5,r0
;;;1426         if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
000d3e  7f28              LDRB     r0,[r5,#0x1c]
000d40  f0000003          AND      r0,r0,#3
000d44  2803              CMP      r0,#3
000d46  d123              BNE      |L1.3472|
;;;1427   		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
;;;1428           /* Set invalid area of the window to draw */
;;;1429           if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
000d48  f1040108          ADD      r1,r4,#8
000d4c  4628              MOV      r0,r5
000d4e  f7fffffe          BL       GUI_RectsIntersect
000d52  b1e8              CBZ      r0,|L1.3472|
;;;1430             GUI_RECT InvalidRectPrev;
;;;1431             InvalidRectPrev = pWin->InvalidRect;
000d54  68a0              LDR      r0,[r4,#8]
000d56  9000              STR      r0,[sp,#0]
000d58  68e0              LDR      r0,[r4,#0xc]
000d5a  9001              STR      r0,[sp,#4]
;;;1432             if(_Paint1Trans(hChild, pChild)) {
000d5c  4629              MOV      r1,r5
000d5e  4630              MOV      r0,r6
000d60  f7fffffe          BL       _Paint1Trans
000d64  b178              CBZ      r0,|L1.3462|
;;;1433               #if GUI_SUPPORT_MEMDEV
;;;1434                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1435                    So the pointer(s) could be invalid after the last function call and needs
;;;1436                    to be restored.
;;;1437                 */
;;;1438                 pChild = WM_H2P(hChild);
000d66  4630              MOV      r0,r6
000d68  f7fffffe          BL       GUI_ALLOC_h2p
000d6c  4605              MOV      r5,r0
;;;1439               #endif
;;;1440               _PaintTransChildren(hChild, pChild);
000d6e  4629              MOV      r1,r5
000d70  4630              MOV      r0,r6
000d72  f7fffffe          BL       _PaintTransChildren
;;;1441               #if GUI_SUPPORT_MEMDEV
;;;1442                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1443                    So the pointer(s) could be invalid after the last function call and needs
;;;1444                    to be restored.
;;;1445                 */
;;;1446                 pChild = WM_H2P(hChild);
000d76  4630              MOV      r0,r6
000d78  f7fffffe          BL       GUI_ALLOC_h2p
000d7c  4605              MOV      r5,r0
;;;1447                 pWin   = WM_H2P(hWin);
000d7e  4638              MOV      r0,r7
000d80  f7fffffe          BL       GUI_ALLOC_h2p
000d84  4604              MOV      r4,r0
                  |L1.3462|
;;;1448               #endif
;;;1449             }
;;;1450             pWin->InvalidRect = InvalidRectPrev;
000d86  9800              LDR      r0,[sp,#0]
000d88  60a0              STR      r0,[r4,#8]
000d8a  9801              LDR      r0,[sp,#4]
000d8c  60e0              STR      r0,[r4,#0xc]
;;;1451           }
000d8e  bf00              NOP      
                  |L1.3472|
000d90  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;1424
                  |L1.3476|
000d94  2e00              CMP      r6,#0                 ;1424
000d96  d1ce              BNE      |L1.3382|
                  |L1.3480|
;;;1452         }
;;;1453       }
;;;1454     }
;;;1455   }
000d98  e8bd81fc          POP      {r2-r8,pc}
;;;1456   #endif
                          ENDP

                  _PaintTransTopSiblings PROC
;;;1469   #if WM_SUPPORT_TRANSPARENCY
;;;1470   static void _PaintTransTopSiblings(WM_HWIN hWin, WM_Obj* pWin) {
000d9c  e92d41f0          PUSH     {r4-r8,lr}
000da0  4606              MOV      r6,r0
000da2  460c              MOV      r4,r1
;;;1471     WM_HWIN hParent;
;;;1472     WM_Obj* pParent;
;;;1473     hParent = pWin->hParent;
000da4  f9b47016          LDRSH    r7,[r4,#0x16]
;;;1474     hWin = pWin->hNext;
000da8  f9b4601a          LDRSH    r6,[r4,#0x1a]
;;;1475     while (hParent) { /* Go hierarchy up to desktop window */
000dac  e021              B        |L1.3570|
                  |L1.3502|
;;;1476       for (; hWin; hWin = pWin->hNext) {
000dae  e016              B        |L1.3550|
                  |L1.3504|
;;;1477         pWin = WM_H2P(hWin);
000db0  4630              MOV      r0,r6
000db2  f7fffffe          BL       GUI_ALLOC_h2p
000db6  4604              MOV      r4,r0
;;;1478         /* paint window if it is transparent & visible */
;;;1479         if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_ISVIS)) ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
000db8  7f20              LDRB     r0,[r4,#0x1c]
000dba  f0000003          AND      r0,r0,#3
000dbe  2803              CMP      r0,#3
000dc0  d107              BNE      |L1.3538|
;;;1480           _Paint1Trans(hWin, pWin);
000dc2  4621              MOV      r1,r4
000dc4  4630              MOV      r0,r6
000dc6  f7fffffe          BL       _Paint1Trans
;;;1481           #if GUI_SUPPORT_MEMDEV
;;;1482             /* Within the paint event the application is alowed to deal with memory devices.
;;;1483                So the pointer(s) could be invalid after the last function call and needs
;;;1484                to be restored.
;;;1485             */
;;;1486             pWin   = WM_H2P(hWin);
000dca  4630              MOV      r0,r6
000dcc  f7fffffe          BL       GUI_ALLOC_h2p
000dd0  4604              MOV      r4,r0
                  |L1.3538|
;;;1487           #endif
;;;1488         }
;;;1489         /* paint transparent & visible children */
;;;1490         _PaintTransChildren(hWin, pWin);
000dd2  4621              MOV      r1,r4
000dd4  4630              MOV      r0,r6
000dd6  f7fffffe          BL       _PaintTransChildren
000dda  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;1476
                  |L1.3550|
000dde  2e00              CMP      r6,#0                 ;1476
000de0  d1e6              BNE      |L1.3504|
;;;1491       }
;;;1492       pParent = WM_H2P(hParent);
000de2  4638              MOV      r0,r7
000de4  f7fffffe          BL       GUI_ALLOC_h2p
000de8  4605              MOV      r5,r0
;;;1493       hWin = pParent->hNext;
000dea  f9b5601a          LDRSH    r6,[r5,#0x1a]
;;;1494       hParent = pParent->hParent;
000dee  f9b57016          LDRSH    r7,[r5,#0x16]
                  |L1.3570|
000df2  2f00              CMP      r7,#0                 ;1475
000df4  d1db              BNE      |L1.3502|
;;;1495     }
;;;1496   }
000df6  e8bd81f0          POP      {r4-r8,pc}
;;;1497   #endif
                          ENDP

                  WM__PaintWinAndOverlays PROC
;;;1518   */
;;;1519   void WM__PaintWinAndOverlays(WM_PAINTINFO* pInfo) {
000dfa  b570              PUSH     {r4-r6,lr}
000dfc  4604              MOV      r4,r0
;;;1520     WM_HWIN hWin;
;;;1521     WM_Obj* pWin;
;;;1522     hWin = pInfo->hWin;
000dfe  f9b46000          LDRSH    r6,[r4,#0]
;;;1523     pWin = pInfo->pWin;
000e02  6865              LDR      r5,[r4,#4]
;;;1524     if (!pWin) {
000e04  b91d              CBNZ     r5,|L1.3598|
;;;1525       pWin = WM_H2P(hWin);
000e06  4630              MOV      r0,r6
000e08  f7fffffe          BL       GUI_ALLOC_h2p
000e0c  4605              MOV      r5,r0
                  |L1.3598|
;;;1526     }
;;;1527     #if WM_SUPPORT_TRANSPARENCY
;;;1528       /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
;;;1529       if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
000e0e  8ba8              LDRH     r0,[r5,#0x1c]
000e10  f6400101          MOV      r1,#0x801
000e14  4008              ANDS     r0,r0,r1
000e16  2801              CMP      r0,#1
000e18  d007              BEQ      |L1.3626|
;;;1530     #endif
;;;1531     _Paint1(hWin, pWin);    /* Draw the window itself */
000e1a  4629              MOV      r1,r5
000e1c  4630              MOV      r0,r6
000e1e  f7fffffe          BL       _Paint1
;;;1532     #if GUI_SUPPORT_MEMDEV
;;;1533       /* Within the paint event the application is alowed to deal with memory devices.
;;;1534          So the pointer(s) could be invalid after the last function call and needs
;;;1535          to be restored.
;;;1536       */
;;;1537       pWin = WM_H2P(hWin);
000e22  4630              MOV      r0,r6
000e24  f7fffffe          BL       GUI_ALLOC_h2p
000e28  4605              MOV      r5,r0
                  |L1.3626|
;;;1538     #endif
;;;1539     #if WM_SUPPORT_TRANSPARENCY
;;;1540       }
;;;1541       if (WM__TransWindowCnt != 0) {
000e2a  489a              LDR      r0,|L1.4244|
000e2c  6800              LDR      r0,[r0,#0]  ; WM__TransWindowCnt
000e2e  b158              CBZ      r0,|L1.3656|
;;;1542         _PaintTransChildren(hWin, pWin);             /* Draw all transparent children */
000e30  4629              MOV      r1,r5
000e32  4630              MOV      r0,r6
000e34  f7fffffe          BL       _PaintTransChildren
;;;1543         #if GUI_SUPPORT_MEMDEV
;;;1544           /* Within the paint event the application is alowed to deal with memory devices.
;;;1545              So the pointer(s) could be invalid after the last function call and needs
;;;1546              to be restored.
;;;1547           */
;;;1548           pWin = WM_H2P(hWin);
000e38  4630              MOV      r0,r6
000e3a  f7fffffe          BL       GUI_ALLOC_h2p
000e3e  4605              MOV      r5,r0
;;;1549         #endif
;;;1550         _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
000e40  4629              MOV      r1,r5
000e42  4630              MOV      r0,r6
000e44  f7fffffe          BL       _PaintTransTopSiblings
                  |L1.3656|
;;;1551       }
;;;1552     #endif
;;;1553   }
000e48  bd70              POP      {r4-r6,pc}
;;;1554   
                          ENDP

                  _cbPaintMemDev PROC
;;;1567   #if GUI_SUPPORT_MEMDEV
;;;1568   static void _cbPaintMemDev(void* p) {
000e4a  b57c              PUSH     {r2-r6,lr}
000e4c  4605              MOV      r5,r0
;;;1569     GUI_RECT Rect;
;;;1570     WM_Obj* pWin = WM_H2P(GUI_Context.hAWin);
000e4e  498f              LDR      r1,|L1.4236|
000e50  f9b1003c          LDRSH    r0,[r1,#0x3c]  ; GUI_Context
000e54  f7fffffe          BL       GUI_ALLOC_h2p
000e58  4604              MOV      r4,r0
;;;1571     Rect = pWin->InvalidRect;
000e5a  68a0              LDR      r0,[r4,#8]
000e5c  9000              STR      r0,[sp,#0]
000e5e  68e0              LDR      r0,[r4,#0xc]
000e60  9001              STR      r0,[sp,#4]
;;;1572     pWin->InvalidRect = GUI_Context.ClipRect;
000e62  488a              LDR      r0,|L1.4236|
000e64  6881              LDR      r1,[r0,#8]  ; GUI_Context
000e66  60a1              STR      r1,[r4,#8]
000e68  68c0              LDR      r0,[r0,#0xc]  ; GUI_Context
000e6a  60e0              STR      r0,[r4,#0xc]
;;;1573     WM__PaintWinAndOverlays((WM_PAINTINFO*)p);
000e6c  4628              MOV      r0,r5
000e6e  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1574     pWin->InvalidRect = Rect;
000e72  9800              LDR      r0,[sp,#0]
000e74  60a0              STR      r0,[r4,#8]
000e76  9801              LDR      r0,[sp,#4]
000e78  60e0              STR      r0,[r4,#0xc]
;;;1575   }
000e7a  bd7c              POP      {r2-r6,pc}
;;;1576   #endif
                          ENDP

                  WM__Paint PROC
;;;1584   */
;;;1585   int WM__Paint(WM_HWIN hWin, WM_Obj* pWin) {
000e7c  b5f0              PUSH     {r4-r7,lr}
000e7e  b085              SUB      sp,sp,#0x14
000e80  4605              MOV      r5,r0
000e82  460c              MOV      r4,r1
;;;1586     int Ret = 0;
000e84  2600              MOVS     r6,#0
;;;1587     if (pWin->Status & WM_SF_INVALID) {
000e86  7f20              LDRB     r0,[r4,#0x1c]
000e88  f0000020          AND      r0,r0,#0x20
000e8c  2800              CMP      r0,#0
000e8e  d03d              BEQ      |L1.3852|
;;;1588       if (pWin->cb) {
000e90  6920              LDR      r0,[r4,#0x10]
000e92  b350              CBZ      r0,|L1.3818|
;;;1589         if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
000e94  4629              MOV      r1,r5
000e96  f1040008          ADD      r0,r4,#8
000e9a  f7fffffe          BL       WM__ClipAtParentBorders
000e9e  b320              CBZ      r0,|L1.3818|
;;;1590           WM_PAINTINFO Info;
;;;1591           Info.hWin = hWin;
000ea0  f8ad500c          STRH     r5,[sp,#0xc]
;;;1592           WM_SelectWindow(hWin);
000ea4  4628              MOV      r0,r5
000ea6  f7fffffe          BL       WM_SelectWindow
;;;1593           #if GUI_SUPPORT_MEMDEV
;;;1594             Info.pWin = NULL; /* 'Invalidate' the window pointer, because it can 
000eaa  2000              MOVS     r0,#0
000eac  9004              STR      r0,[sp,#0x10]
;;;1595                                   become invalid through the creation of a memory device
;;;1596                               */
;;;1597             if (pWin->Status & WM_SF_MEMDEV) {
000eae  7f20              LDRB     r0,[r4,#0x1c]
000eb0  f0000004          AND      r0,r0,#4
000eb4  b198              CBZ      r0,|L1.3806|
;;;1598               int Flags;
;;;1599               GUI_RECT r = pWin->InvalidRect;
000eb6  68a0              LDR      r0,[r4,#8]
000eb8  9001              STR      r0,[sp,#4]
000eba  68e0              LDR      r0,[r4,#0xc]
000ebc  9002              STR      r0,[sp,#8]
;;;1600               Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
000ebe  7f20              LDRB     r0,[r4,#0x1c]
000ec0  f0000001          AND      r0,r0,#1
000ec4  f0800701          EOR      r7,r0,#1
;;;1601               /*
;;;1602                * Currently we treat a desktop window as transparent, because per default it does not repaint itself.
;;;1603                */
;;;1604               if (pWin->hParent == 0) {
000ec8  8ae0              LDRH     r0,[r4,#0x16]
000eca  b900              CBNZ     r0,|L1.3790|
;;;1605                 Flags = GUI_MEMDEV_HASTRANS;
000ecc  2700              MOVS     r7,#0
                  |L1.3790|
;;;1606               }
;;;1607               GUI_MEMDEV_Draw(&r, _cbPaintMemDev, &Info, 0, Flags);
000ece  2300              MOVS     r3,#0
000ed0  aa03              ADD      r2,sp,#0xc
000ed2  4971              LDR      r1,|L1.4248|
000ed4  a801              ADD      r0,sp,#4
000ed6  9700              STR      r7,[sp,#0]
000ed8  f7fffffe          BL       GUI_MEMDEV_Draw
;;;1608             } else
000edc  e004              B        |L1.3816|
                  |L1.3806|
;;;1609           #endif
;;;1610           {
;;;1611             Info.pWin = pWin;
000ede  9404              STR      r4,[sp,#0x10]
;;;1612             WM__PaintWinAndOverlays(&Info);
000ee0  a803              ADD      r0,sp,#0xc
000ee2  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1613             Ret = 1;    /* Something has been done */
000ee6  2601              MOVS     r6,#1
                  |L1.3816|
;;;1614           }
;;;1615         }
000ee8  bf00              NOP      
                  |L1.3818|
;;;1616       }
;;;1617       /* We purposly clear the invalid flag after painting so we can still query the invalid rectangle while painting */
;;;1618       pWin->Status &=  ~WM_SF_INVALID; /* Clear invalid flag */
000eea  8ba0              LDRH     r0,[r4,#0x1c]
000eec  f0200020          BIC      r0,r0,#0x20
000ef0  83a0              STRH     r0,[r4,#0x1c]
;;;1619       if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
000ef2  8ba0              LDRH     r0,[r4,#0x1c]
000ef4  f4005000          AND      r0,r0,#0x2000
000ef8  b118              CBZ      r0,|L1.3842|
;;;1620         pWin->Status |= WM_CF_MEMDEV;
000efa  8ba0              LDRH     r0,[r4,#0x1c]
000efc  f0400004          ORR      r0,r0,#4
000f00  83a0              STRH     r0,[r4,#0x1c]
                  |L1.3842|
;;;1621       }
;;;1622       WM__NumInvalidWindows--;
000f02  4866              LDR      r0,|L1.4252|
000f04  8800              LDRH     r0,[r0,#0]  ; WM__NumInvalidWindows
000f06  1e40              SUBS     r0,r0,#1
000f08  4964              LDR      r1,|L1.4252|
000f0a  8008              STRH     r0,[r1,#0]
                  |L1.3852|
;;;1623     }
;;;1624     return Ret;      /* Nothing done */
000f0c  4630              MOV      r0,r6
;;;1625   }
000f0e  b005              ADD      sp,sp,#0x14
000f10  bdf0              POP      {r4-r7,pc}
;;;1626   
                          ENDP

                  _DrawNext PROC
;;;1630   */
;;;1631   static void _DrawNext(void) {
000f12  b570              PUSH     {r4-r6,lr}
000f14  b098              SUB      sp,sp,#0x60
;;;1632     int UpdateRem = 1;
000f16  2601              MOVS     r6,#1
;;;1633     WM_HWIN iWin = (NextDrawWin == WM_HWIN_NULL) ? WM__FirstWin : NextDrawWin;
000f18  4861              LDR      r0,|L1.4256|
000f1a  8800              LDRH     r0,[r0,#0]  ; NextDrawWin
000f1c  b918              CBNZ     r0,|L1.3878|
000f1e  4861              LDR      r0,|L1.4260|
000f20  f9b00000          LDRSH    r0,[r0,#0]  ; WM__FirstWin
000f24  e002              B        |L1.3884|
                  |L1.3878|
000f26  485e              LDR      r0,|L1.4256|
000f28  f9b00000          LDRSH    r0,[r0,#0]  ; NextDrawWin
                  |L1.3884|
000f2c  4604              MOV      r4,r0
;;;1634     GUI_CONTEXT ContextOld;
;;;1635     GUI_SaveContext(&ContextOld);
000f2e  4668              MOV      r0,sp
000f30  f7fffffe          BL       GUI_SaveContext_W_M
;;;1636     /* Make sure the next window to redraw is valid */
;;;1637     for (; iWin && UpdateRem; ) {
000f34  e00c              B        |L1.3920|
                  |L1.3894|
;;;1638       WM_Obj* pWin = WM_H2P(iWin);
000f36  4620              MOV      r0,r4
000f38  f7fffffe          BL       GUI_ALLOC_h2p
000f3c  4605              MOV      r5,r0
;;;1639       if (WM__Paint(iWin, pWin)) {
000f3e  4629              MOV      r1,r5
000f40  4620              MOV      r0,r4
000f42  f7fffffe          BL       WM__Paint
000f46  b100              CBZ      r0,|L1.3914|
;;;1640         UpdateRem--;  /* Only the given number of windows at a time ... */
000f48  1e76              SUBS     r6,r6,#1
                  |L1.3914|
;;;1641       }
;;;1642       iWin = pWin->hNextLin;
000f4a  f9b54014          LDRSH    r4,[r5,#0x14]
;;;1643     }  
000f4e  bf00              NOP      
                  |L1.3920|
000f50  b10c              CBZ      r4,|L1.3926|
000f52  2e00              CMP      r6,#0                 ;1637
000f54  d1ef              BNE      |L1.3894|
                  |L1.3926|
;;;1644     NextDrawWin = iWin;   /* Remember the window */
000f56  4852              LDR      r0,|L1.4256|
000f58  8004              STRH     r4,[r0,#0]
;;;1645     GUI_RestoreContext(&ContextOld);
000f5a  4668              MOV      r0,sp
000f5c  f7fffffe          BL       GUI_RestoreContext
;;;1646   }
000f60  b018              ADD      sp,sp,#0x60
000f62  bd70              POP      {r4-r6,pc}
;;;1647   
                          ENDP

                  WM_Exec1 PROC
;;;1651   */
;;;1652   int WM_Exec1(void) {
000f64  b510              PUSH     {r4,lr}
;;;1653     /* Poll PID if necessary */
;;;1654     if (WM_pfPollPID) {
000f66  4850              LDR      r0,|L1.4264|
000f68  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000f6a  b110              CBZ      r0,|L1.3954|
;;;1655       WM_pfPollPID();
000f6c  484e              LDR      r0,|L1.4264|
000f6e  6800              LDR      r0,[r0,#0]  ; WM_pfPollPID
000f70  4780              BLX      r0
                  |L1.3954|
;;;1656     }
;;;1657     if (WM_pfHandlePID) {
000f72  484e              LDR      r0,|L1.4268|
000f74  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000f76  b128              CBZ      r0,|L1.3972|
;;;1658       if (WM_pfHandlePID())
000f78  484c              LDR      r0,|L1.4268|
000f7a  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000f7c  4780              BLX      r0
000f7e  b108              CBZ      r0,|L1.3972|
;;;1659         return 1;               /* We have done something ... */
000f80  2001              MOVS     r0,#1
                  |L1.3970|
;;;1660     }
;;;1661     if (WM_IsActive) {
;;;1662       if (GUI_PollKeyMsg()) {
;;;1663         return 1;               /* We have done something ... */
;;;1664       }
;;;1665     }
;;;1666   #ifdef WIN32
;;;1667     if (WM_PollSimMsg()) {
;;;1668       return 1;               /* We have done something ... */
;;;1669     }
;;;1670   #endif
;;;1671     if (WM_IsActive && WM__NumInvalidWindows) {
;;;1672       WM_LOCK();
;;;1673       _DrawNext();
;;;1674       WM_UNLOCK();
;;;1675       return 1;               /* We have done something ... */
;;;1676     }
;;;1677     return 0;                  /* There was nothing to do ... */
;;;1678   }
000f82  bd10              POP      {r4,pc}
                  |L1.3972|
000f84  484a              LDR      r0,|L1.4272|
000f86  7800              LDRB     r0,[r0,#0]            ;1661  ; WM_IsActive
000f88  b120              CBZ      r0,|L1.3988|
000f8a  f7fffffe          BL       GUI_PollKeyMsg
000f8e  b108              CBZ      r0,|L1.3988|
000f90  2001              MOVS     r0,#1                 ;1663
000f92  e7f6              B        |L1.3970|
                  |L1.3988|
000f94  4846              LDR      r0,|L1.4272|
000f96  7800              LDRB     r0,[r0,#0]            ;1671  ; WM_IsActive
000f98  b130              CBZ      r0,|L1.4008|
000f9a  4840              LDR      r0,|L1.4252|
000f9c  8800              LDRH     r0,[r0,#0]            ;1671  ; WM__NumInvalidWindows
000f9e  b118              CBZ      r0,|L1.4008|
000fa0  f7fffffe          BL       _DrawNext
000fa4  2001              MOVS     r0,#1                 ;1675
000fa6  e7ec              B        |L1.3970|
                  |L1.4008|
000fa8  2000              MOVS     r0,#0                 ;1677
000faa  e7ea              B        |L1.3970|
;;;1679   
                          ENDP

                  WM_Exec PROC
;;;1683   */
;;;1684   int WM_Exec(void) {
000fac  b510              PUSH     {r4,lr}
;;;1685     int r = 0;
000fae  2400              MOVS     r4,#0
;;;1686     while (WM_Exec1()) {
000fb0  e000              B        |L1.4020|
                  |L1.4018|
;;;1687       r = 1;                  /* We have done something */
000fb2  2401              MOVS     r4,#1
                  |L1.4020|
000fb4  f7fffffe          BL       WM_Exec1
000fb8  2800              CMP      r0,#0                 ;1686
000fba  d1fa              BNE      |L1.4018|
;;;1688     }
;;;1689     return r;
000fbc  4620              MOV      r0,r4
;;;1690   }
000fbe  bd10              POP      {r4,pc}
;;;1691   
                          ENDP

                  WM_DefaultProc PROC
;;;1755   */
;;;1756   void WM_DefaultProc(WM_MESSAGE* pMsg) {
000fc0  e92d41f0          PUSH     {r4-r8,lr}
000fc4  4604              MOV      r4,r0
;;;1757     WM_HWIN hWin = pMsg->hWin;
000fc6  f9b45004          LDRSH    r5,[r4,#4]
;;;1758     const void *p = pMsg->Data.p;
000fca  68a6              LDR      r6,[r4,#8]
;;;1759     WM_Obj* pWin = WM_H2P(hWin);
000fcc  4628              MOV      r0,r5
000fce  f7fffffe          BL       GUI_ALLOC_h2p
000fd2  4607              MOV      r7,r0
;;;1760     /* Exec message */
;;;1761     switch (pMsg->MsgId) {
000fd4  6820              LDR      r0,[r4,#0]
000fd6  2817              CMP      r0,#0x17
000fd8  d00f              BEQ      |L1.4090|
000fda  dc04              BGT      |L1.4070|
000fdc  280e              CMP      r0,#0xe
000fde  d00f              BEQ      |L1.4096|
000fe0  2814              CMP      r0,#0x14
000fe2  d11a              BNE      |L1.4122|
000fe4  e004              B        |L1.4080|
                  |L1.4070|
000fe6  2822              CMP      r0,#0x22
000fe8  d00f              BEQ      |L1.4106|
000fea  2828              CMP      r0,#0x28
000fec  d115              BNE      |L1.4122|
000fee  e010              B        |L1.4114|
                  |L1.4080|
;;;1762     case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
;;;1763       WM__GetClientRectWin(pWin, (GUI_RECT*)p);
000ff0  4631              MOV      r1,r6
000ff2  4638              MOV      r0,r7
000ff4  f7fffffe          BL       WM__GetClientRectWin
;;;1764       break;
000ff8  e00f              B        |L1.4122|
                  |L1.4090|
;;;1765     case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
;;;1766       pMsg->Data.v = (int)hWin;
000ffa  60a5              STR      r5,[r4,#8]
                  |L1.4092|
;;;1767       return;                       /* Message handled */
;;;1768     case WM_KEY:
;;;1769       WM_SendToParent(hWin, pMsg);
;;;1770       return;                       /* Message handled */
;;;1771      case WM_GET_BKCOLOR:
;;;1772       pMsg->Data.Color = GUI_INVALID_COLOR;
;;;1773       return;                       /* Message handled */
;;;1774     case WM_NOTIFY_ENABLE:
;;;1775       WM_InvalidateWindow(hWin);    
;;;1776       return;                       /* Message handled */
;;;1777     }
;;;1778     /* Message not handled. If it queries something, we return 0 to be on the safe side. */
;;;1779     pMsg->Data.v = 0;
;;;1780     pMsg->Data.p = 0;
;;;1781   }
000ffc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4096|
001000  4621              MOV      r1,r4                 ;1769
001002  4628              MOV      r0,r5                 ;1769
001004  f7fffffe          BL       WM_SendToParent
001008  e7f8              B        |L1.4092|
                  |L1.4106|
00100a  f06f4070          MVN      r0,#0xf0000000        ;1772
00100e  60a0              STR      r0,[r4,#8]            ;1772
001010  e7f4              B        |L1.4092|
                  |L1.4114|
001012  4628              MOV      r0,r5                 ;1775
001014  f7fffffe          BL       WM_InvalidateWindow
001018  e7f0              B        |L1.4092|
                  |L1.4122|
00101a  bf00              NOP                            ;1764
00101c  2000              MOVS     r0,#0                 ;1779
00101e  60a0              STR      r0,[r4,#8]            ;1779
001020  60a0              STR      r0,[r4,#8]            ;1780
001022  bf00              NOP      
001024  e7ea              B        |L1.4092|
;;;1782   
                          ENDP

                  cbBackWin PROC
;;;1699   */
;;;1700   static void cbBackWin( WM_MESSAGE* pMsg) {
001026  b570              PUSH     {r4-r6,lr}
001028  4604              MOV      r4,r0
;;;1701     const WM_KEY_INFO* pKeyInfo;
;;;1702     switch (pMsg->MsgId) {
00102a  6820              LDR      r0,[r4,#0]
00102c  280e              CMP      r0,#0xe
00102e  d002              BEQ      |L1.4150|
001030  280f              CMP      r0,#0xf
001032  d118              BNE      |L1.4198|
001034  e007              B        |L1.4166|
                  |L1.4150|
;;;1703     case WM_KEY:
;;;1704       pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
001036  68a5              LDR      r5,[r4,#8]
;;;1705       if (pKeyInfo->PressedCnt == 1) {
001038  6868              LDR      r0,[r5,#4]
00103a  2801              CMP      r0,#1
00103c  d102              BNE      |L1.4164|
;;;1706         GUI_StoreKey(pKeyInfo->Key);
00103e  6828              LDR      r0,[r5,#0]
001040  f7fffffe          BL       GUI_StoreKey
                  |L1.4164|
;;;1707       }
;;;1708       break;
001044  e013              B        |L1.4206|
                  |L1.4166|
;;;1709     case WM_PAINT:
;;;1710       {
;;;1711         int LayerIndex;
;;;1712         #if GUI_NUM_LAYERS > 1
;;;1713           LayerIndex = _DesktopHandle2Index(pMsg->hWin);
;;;1714         #else
;;;1715           LayerIndex = 0;
001046  2600              MOVS     r6,#0
;;;1716         #endif
;;;1717         if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
001048  481a              LDR      r0,|L1.4276|
00104a  f8500026          LDR      r0,[r0,r6,LSL #2]
00104e  f06f4170          MVN      r1,#0xf0000000
001052  4288              CMP      r0,r1
001054  d006              BEQ      |L1.4196|
;;;1718           GUI_SetBkColor(WM__aBkColor[LayerIndex]);
001056  4917              LDR      r1,|L1.4276|
001058  f8510026          LDR      r0,[r1,r6,LSL #2]
00105c  f7fffffe          BL       GUI_SetBkColor
;;;1719           GUI_Clear();
001060  f7fffffe          BL       GUI_Clear
                  |L1.4196|
;;;1720         }
;;;1721       }
;;;1722     default:
001064  bf00              NOP      
                  |L1.4198|
;;;1723       WM_DefaultProc(pMsg);
001066  4620              MOV      r0,r4
001068  f7fffffe          BL       WM_DefaultProc
00106c  bf00              NOP                            ;1702
                  |L1.4206|
00106e  bf00              NOP                            ;1708
;;;1724     }
;;;1725   }
001070  bd70              POP      {r4-r6,pc}
;;;1726   
                          ENDP

                  WM_Activate PROC
;;;1730   */
;;;1731   void WM_Activate(void) {
001072  2001              MOVS     r0,#1
;;;1732     WM_IsActive = 1;       /* Running */
001074  490e              LDR      r1,|L1.4272|
001076  7008              STRB     r0,[r1,#0]
;;;1733   }
001078  4770              BX       lr
;;;1734   
                          ENDP

                  WM_Deactivate PROC
;;;1738   */
;;;1739   void WM_Deactivate(void) {
00107a  b510              PUSH     {r4,lr}
;;;1740     WM_IsActive = 0;       /* No clipping performed by WM */
00107c  2000              MOVS     r0,#0
00107e  490c              LDR      r1,|L1.4272|
001080  7008              STRB     r0,[r1,#0]
;;;1741     WM_LOCK();
;;;1742     LCD_SetClipRectMax();
001082  f7fffffe          BL       LCD_SetClipRectMax
;;;1743     WM_UNLOCK();
;;;1744   }
001086  bd10              POP      {r4,pc}
                  |L1.4232|
                          DCD      WM__PaintCallbackCnt
                  |L1.4236|
                          DCD      GUI_Context
                  |L1.4240|
                          DCD      WM__hATransWindow
                  |L1.4244|
                          DCD      WM__TransWindowCnt
                  |L1.4248|
                          DCD      _cbPaintMemDev
                  |L1.4252|
                          DCD      WM__NumInvalidWindows
                  |L1.4256|
                          DCD      NextDrawWin
                  |L1.4260|
                          DCD      WM__FirstWin
                  |L1.4264|
                          DCD      WM_pfPollPID
                  |L1.4268|
                          DCD      WM_pfHandlePID
                  |L1.4272|
                          DCD      WM_IsActive
                  |L1.4276|
                          DCD      WM__aBkColor
                          ENDP

                  WM_Init PROC
;;;1786   */
;;;1787   void WM_Init(void) {
0010b8  b50e              PUSH     {r1-r3,lr}
;;;1788   	if (!_IsInited) {
0010ba  481a              LDR      r0,|L1.4388|
0010bc  7800              LDRB     r0,[r0,#0]  ; _IsInited
0010be  bb80              CBNZ     r0,|L1.4386|
;;;1789   	  NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
0010c0  2000              MOVS     r0,#0
0010c2  4919              LDR      r1,|L1.4392|
0010c4  8008              STRH     r0,[r1,#0]
0010c6  4919              LDR      r1,|L1.4396|
0010c8  8008              STRH     r0,[r1,#0]
;;;1790   	  GUI_Context.WM__pUserClipRect = NULL;
0010ca  4919              LDR      r1,|L1.4400|
0010cc  6388              STR      r0,[r1,#0x38]  ; GUI_Context
;;;1791   	  WM__NumWindows = WM__NumInvalidWindows =0;
0010ce  4919              LDR      r1,|L1.4404|
0010d0  8008              STRH     r0,[r1,#0]
0010d2  4919              LDR      r1,|L1.4408|
0010d4  8008              STRH     r0,[r1,#0]
;;;1792   	  /* Make sure we have at least one window. This greatly simplifies the
;;;1793   		  drawing routines as they do not have to check if the window is valid.
;;;1794   	  */
;;;1795       #if GUI_NUM_LAYERS == 1
;;;1796         WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
0010d6  4919              LDR      r1,|L1.4412|
0010d8  2202              MOVS     r2,#2
0010da  f64073ff          MOV      r3,#0xfff
0010de  e9cd2100          STRD     r2,r1,[sp,#0]
0010e2  9002              STR      r0,[sp,#8]
0010e4  461a              MOV      r2,r3
0010e6  4601              MOV      r1,r0
0010e8  f7fffffe          BL       WM_CreateWindow
0010ec  4914              LDR      r1,|L1.4416|
0010ee  8008              STRH     r0,[r1,#0]
;;;1797         WM__aBkColor[0] = GUI_INVALID_COLOR;
0010f0  f06f4070          MVN      r0,#0xf0000000
0010f4  4913              LDR      r1,|L1.4420|
0010f6  6008              STR      r0,[r1,#0]  ; WM__aBkColor
;;;1798         WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
0010f8  4911              LDR      r1,|L1.4416|
0010fa  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
0010fe  f7fffffe          BL       WM_InvalidateWindow
;;;1799       #else
;;;1800       {
;;;1801         int i;
;;;1802         for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;1803           WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
;;;1804           WM__aBkColor[i] = GUI_INVALID_COLOR;
;;;1805           WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
;;;1806         }
;;;1807       }
;;;1808       #endif
;;;1809       /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
;;;1810       WM__AddCriticalHandle(&WM__CHWinModal);
001102  4811              LDR      r0,|L1.4424|
001104  f7fffffe          BL       WM__AddCriticalHandle
;;;1811       WM__AddCriticalHandle(&WM__CHWinLast);
001108  4810              LDR      r0,|L1.4428|
00110a  f7fffffe          BL       WM__AddCriticalHandle
;;;1812       #if GUI_SUPPORT_MOUSE
;;;1813         WM__AddCriticalHandle(&WM__CHWinMouseOver);
;;;1814       #endif
;;;1815   
;;;1816       WM_SelectWindow(WM__ahDesktopWin[0]);
00110e  490c              LDR      r1,|L1.4416|
001110  f9b10000          LDRSH    r0,[r1,#0]  ; WM__ahDesktopWin
001114  f7fffffe          BL       WM_SelectWindow
;;;1817   	  WM_Activate();
001118  f7fffffe          BL       WM_Activate
;;;1818       _IsInited =1;
00111c  2001              MOVS     r0,#1
00111e  4901              LDR      r1,|L1.4388|
001120  7008              STRB     r0,[r1,#0]
                  |L1.4386|
;;;1819   	}
;;;1820   }
001122  bd0e              POP      {r1-r3,pc}
;;;1821   
                          ENDP

                  |L1.4388|
                          DCD      _IsInited
                  |L1.4392|
                          DCD      WM__FirstWin
                  |L1.4396|
                          DCD      NextDrawWin
                  |L1.4400|
                          DCD      GUI_Context
                  |L1.4404|
                          DCD      WM__NumInvalidWindows
                  |L1.4408|
                          DCD      WM__NumWindows
                  |L1.4412|
                          DCD      cbBackWin
                  |L1.4416|
                          DCD      WM__ahDesktopWin
                  |L1.4420|
                          DCD      WM__aBkColor
                  |L1.4424|
                          DCD      WM__CHWinModal
                  |L1.4428|
                          DCD      WM__CHWinLast

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  WM_PID__StateLast
                          %        12
                  _ClipContext
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  WM__NumWindows
000000  0000              DCB      0x00,0x00
                  WM__NumInvalidWindows
000002  0000              DCB      0x00,0x00
                  WM__FirstWin
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__pFirstCriticalHandle
                          DCD      0x00000000
                  WM__ahDesktopWin
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__aBkColor
                          DCD      0x00000000
                  WM_IsActive
000014  0000              DCB      0x00,0x00
                  WM__CreateFlags
000016  0000              DCB      0x00,0x00
                  WM__hCapture
000018  0000              DCB      0x00,0x00
                  WM__hWinFocus
00001a  0000              DCB      0x00,0x00
                  WM__CaptureReleaseAuto
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                  WM_pfPollPID
                          DCD      0x00000000
                  WM__PaintCallbackCnt
000024  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__TransWindowCnt
                          DCD      0x00000000
                  WM__hATransWindow
00002c  0000              DCB      0x00,0x00
                  NextDrawWin
00002e  0000              DCB      0x00,0x00
                  _IsInited
000030  00                DCB      0x00
