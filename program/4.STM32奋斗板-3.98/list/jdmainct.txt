; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdmainct.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdmainct.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdmainct.crf GUI\JPEG\jdmainct.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  alloc_funny_pointers PROC
;;;156    LOCAL(void)
;;;157    alloc_funny_pointers (j_decompress_ptr cinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;158    /* Allocate space for the funny pointer lists.
;;;159     * This is done only once, not once per pass.
;;;160     */
;;;161    {
000004  4604              MOV      r4,r0
;;;162      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000006  f8d451a8          LDR      r5,[r4,#0x1a8]
;;;163      int ci, rgroup;
;;;164      int M = cinfo->min_DCT_scaled_size;
00000a  f8d4a13c          LDR      r10,[r4,#0x13c]
;;;165      jpeg_component_info *compptr;
;;;166      JSAMPARRAY xbuf;
;;;167    
;;;168      /* Get top-level space for component array pointers.
;;;169       * We alloc both arrays with one call to save a few cycles.
;;;170       */
;;;171      pMain->xbuffer[0] = (JSAMPIMAGE)
00000e  6a60              LDR      r0,[r4,#0x24]
000010  00c2              LSLS     r2,r0,#3
000012  6860              LDR      r0,[r4,#4]
000014  2101              MOVS     r1,#1
000016  6803              LDR      r3,[r0,#0]
000018  4620              MOV      r0,r4
00001a  4798              BLX      r3
00001c  6228              STR      r0,[r5,#0x20]
;;;172        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;173    				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
;;;174      pMain->xbuffer[1] = pMain->xbuffer[0] + cinfo->num_components;
00001e  6a28              LDR      r0,[r5,#0x20]
000020  6a61              LDR      r1,[r4,#0x24]
000022  eb000181          ADD      r1,r0,r1,LSL #2
000026  6269              STR      r1,[r5,#0x24]
;;;175    
;;;176      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000028  2600              MOVS     r6,#0
00002a  f8d490d8          LDR      r9,[r4,#0xd8]
00002e  e022              B        |L1.118|
                  |L1.48|
;;;177           ci++, compptr++) {
;;;178        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
000030  f8d91024          LDR      r1,[r9,#0x24]
000034  f8d9000c          LDR      r0,[r9,#0xc]
000038  4348              MULS     r0,r1,r0
00003a  f8d4113c          LDR      r1,[r4,#0x13c]
00003e  fb90f7f1          SDIV     r7,r0,r1
;;;179          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;180        /* Get space for pointer lists --- M+4 row groups in each list.
;;;181         * We alloc both pointer lists with one call to save a few cycles.
;;;182         */
;;;183        xbuf = (JSAMPARRAY)
000042  f10a0004          ADD      r0,r10,#4
000046  4378              MULS     r0,r7,r0
000048  00c2              LSLS     r2,r0,#3
00004a  6860              LDR      r0,[r4,#4]
00004c  2101              MOVS     r1,#1
00004e  6803              LDR      r3,[r0,#0]
000050  4620              MOV      r0,r4
000052  4798              BLX      r3
000054  4680              MOV      r8,r0
;;;184          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;185    				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
;;;186        xbuf += rgroup;		/* want one row group at negative offsets */
000056  eb080887          ADD      r8,r8,r7,LSL #2
;;;187        pMain->xbuffer[0][ci] = xbuf;
00005a  6a28              LDR      r0,[r5,#0x20]
00005c  f8408026          STR      r8,[r0,r6,LSL #2]
;;;188        xbuf += rgroup * (M + 4);
000060  f10a0004          ADD      r0,r10,#4
000064  4378              MULS     r0,r7,r0
000066  eb080880          ADD      r8,r8,r0,LSL #2
;;;189        pMain->xbuffer[1][ci] = xbuf;
00006a  6a68              LDR      r0,[r5,#0x24]
00006c  f8408026          STR      r8,[r0,r6,LSL #2]
000070  1c76              ADDS     r6,r6,#1              ;177
000072  f1090954          ADD      r9,r9,#0x54           ;177
                  |L1.118|
000076  6a60              LDR      r0,[r4,#0x24]         ;176
000078  42b0              CMP      r0,r6                 ;176
00007a  dcd9              BGT      |L1.48|
;;;190      }
;;;191    }
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;192    
                          ENDP

                  make_funny_pointers PROC
;;;194    LOCAL(void)
;;;195    make_funny_pointers (j_decompress_ptr cinfo)
000080  e92d47f0          PUSH     {r4-r10,lr}
;;;196    /* Create the funny pointer lists discussed in the comments above.
;;;197     * The actual workspace is already allocated (in pMain->buffer),
;;;198     * and the space for the pointer lists is allocated too.
;;;199     * This routine just fills in the curiously ordered lists.
;;;200     * This will be repeated at the beginning of each pass.
;;;201     */
;;;202    {
000084  4602              MOV      r2,r0
;;;203      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000086  f8d2c1a8          LDR      r12,[r2,#0x1a8]
;;;204      int ci, i, rgroup;
;;;205      int M = cinfo->min_DCT_scaled_size;
00008a  f8d2413c          LDR      r4,[r2,#0x13c]
;;;206      jpeg_component_info *compptr;
;;;207      JSAMPARRAY buf, xbuf0, xbuf1;
;;;208    
;;;209      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00008e  2300              MOVS     r3,#0
000090  f8d280d8          LDR      r8,[r2,#0xd8]
000094  e04c              B        |L1.304|
                  |L1.150|
;;;210           ci++, compptr++) {
;;;211        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
000096  f8d8a024          LDR      r10,[r8,#0x24]
00009a  f8d8900c          LDR      r9,[r8,#0xc]
00009e  fb09f90a          MUL      r9,r9,r10
0000a2  f8d2a13c          LDR      r10,[r2,#0x13c]
0000a6  fb99f1fa          SDIV     r1,r9,r10
;;;212          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;213        xbuf0 = pMain->xbuffer[0][ci];
0000aa  f8dc9020          LDR      r9,[r12,#0x20]
0000ae  f8596023          LDR      r6,[r9,r3,LSL #2]
;;;214        xbuf1 = pMain->xbuffer[1][ci];
0000b2  f8dc9024          LDR      r9,[r12,#0x24]
0000b6  f8597023          LDR      r7,[r9,r3,LSL #2]
;;;215        /* First copy the workspace pointers as-is */
;;;216        buf = pMain->buffer[ci];
0000ba  f10c0908          ADD      r9,r12,#8
0000be  f8595023          LDR      r5,[r9,r3,LSL #2]
;;;217        for (i = 0; i < rgroup * (M + 2); i++) {
0000c2  2000              MOVS     r0,#0
0000c4  e006              B        |L1.212|
                  |L1.198|
;;;218          xbuf0[i] = xbuf1[i] = buf[i];
0000c6  f8559020          LDR      r9,[r5,r0,LSL #2]
0000ca  f8479020          STR      r9,[r7,r0,LSL #2]
0000ce  f8469020          STR      r9,[r6,r0,LSL #2]
0000d2  1c40              ADDS     r0,r0,#1              ;217
                  |L1.212|
0000d4  f1040902          ADD      r9,r4,#2              ;217
0000d8  fb01f909          MUL      r9,r1,r9              ;217
0000dc  4581              CMP      r9,r0                 ;217
0000de  dcf2              BGT      |L1.198|
;;;219        }
;;;220        /* In the second list, put the last four row groups in swapped order */
;;;221        for (i = 0; i < rgroup * 2; i++) {
0000e0  2000              MOVS     r0,#0
0000e2  e014              B        |L1.270|
                  |L1.228|
;;;222          xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
0000e4  fb010904          MLA      r9,r1,r4,r0
0000e8  f855a029          LDR      r10,[r5,r9,LSL #2]
0000ec  f1a40902          SUB      r9,r4,#2
0000f0  fb010909          MLA      r9,r1,r9,r0
0000f4  f847a029          STR      r10,[r7,r9,LSL #2]
;;;223          xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
0000f8  f1a40902          SUB      r9,r4,#2
0000fc  fb010909          MLA      r9,r1,r9,r0
000100  f8559029          LDR      r9,[r5,r9,LSL #2]
000104  fb010a04          MLA      r10,r1,r4,r0
000108  f847902a          STR      r9,[r7,r10,LSL #2]
00010c  1c40              ADDS     r0,r0,#1              ;221
                  |L1.270|
00010e  ebb00f41          CMP      r0,r1,LSL #1          ;221
000112  dbe7              BLT      |L1.228|
;;;224        }
;;;225        /* The wraparound pointers at top and bottom will be filled later
;;;226         * (see set_wraparound_pointers, below).  Initially we want the "above"
;;;227         * pointers to duplicate the first actual data line.  This only needs
;;;228         * to happen in xbuffer[0].
;;;229         */
;;;230        for (i = 0; i < rgroup; i++) {
000114  2000              MOVS     r0,#0
000116  e006              B        |L1.294|
                  |L1.280|
;;;231          xbuf0[i - rgroup] = xbuf0[0];
000118  eba00a01          SUB      r10,r0,r1
00011c  f8d69000          LDR      r9,[r6,#0]
000120  f846902a          STR      r9,[r6,r10,LSL #2]
000124  1c40              ADDS     r0,r0,#1              ;230
                  |L1.294|
000126  4288              CMP      r0,r1                 ;230
000128  dbf6              BLT      |L1.280|
00012a  1c5b              ADDS     r3,r3,#1              ;210
00012c  f1080854          ADD      r8,r8,#0x54           ;210
                  |L1.304|
000130  f8d29024          LDR      r9,[r2,#0x24]         ;209
000134  4599              CMP      r9,r3                 ;209
000136  dcae              BGT      |L1.150|
;;;232        }
;;;233      }
;;;234    }
000138  e8bd87f0          POP      {r4-r10,pc}
;;;235    
                          ENDP

                  set_wraparound_pointers PROC
;;;237    LOCAL(void)
;;;238    set_wraparound_pointers (j_decompress_ptr cinfo)
00013c  e92d43f0          PUSH     {r4-r9,lr}
;;;239    /* Set up the "wraparound" pointers at top and bottom of the pointer lists.
;;;240     * This changes the pointer list state from top-of-image to the normal state.
;;;241     */
;;;242    {
000140  4602              MOV      r2,r0
;;;243      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000142  f8d2c1a8          LDR      r12,[r2,#0x1a8]
;;;244      int ci, i, rgroup;
;;;245      int M = cinfo->min_DCT_scaled_size;
000146  f8d2613c          LDR      r6,[r2,#0x13c]
;;;246      jpeg_component_info *compptr;
;;;247      JSAMPARRAY xbuf0, xbuf1;
;;;248    
;;;249      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00014a  2500              MOVS     r5,#0
00014c  f8d270d8          LDR      r7,[r2,#0xd8]
000150  e03c              B        |L1.460|
                  |L1.338|
;;;250           ci++, compptr++) {
;;;251        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
000152  f8d79024          LDR      r9,[r7,#0x24]
000156  f8d7800c          LDR      r8,[r7,#0xc]
00015a  fb08f809          MUL      r8,r8,r9
00015e  f8d2913c          LDR      r9,[r2,#0x13c]
000162  fb98f1f9          SDIV     r1,r8,r9
;;;252          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;253        xbuf0 = pMain->xbuffer[0][ci];
000166  f8dc8020          LDR      r8,[r12,#0x20]
00016a  f8583025          LDR      r3,[r8,r5,LSL #2]
;;;254        xbuf1 = pMain->xbuffer[1][ci];
00016e  f8dc8024          LDR      r8,[r12,#0x24]
000172  f8584025          LDR      r4,[r8,r5,LSL #2]
;;;255        for (i = 0; i < rgroup; i++) {
000176  2000              MOVS     r0,#0
000178  e024              B        |L1.452|
                  |L1.378|
;;;256          xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
00017a  f1060801          ADD      r8,r6,#1
00017e  fb010808          MLA      r8,r1,r8,r0
000182  f8538028          LDR      r8,[r3,r8,LSL #2]
000186  eba00901          SUB      r9,r0,r1
00018a  f8438029          STR      r8,[r3,r9,LSL #2]
;;;257          xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
00018e  f1060801          ADD      r8,r6,#1
000192  fb010808          MLA      r8,r1,r8,r0
000196  f8548028          LDR      r8,[r4,r8,LSL #2]
00019a  eba00901          SUB      r9,r0,r1
00019e  f8448029          STR      r8,[r4,r9,LSL #2]
;;;258          xbuf0[rgroup*(M+2) + i] = xbuf0[i];
0001a2  f8539020          LDR      r9,[r3,r0,LSL #2]
0001a6  f1060802          ADD      r8,r6,#2
0001aa  fb010808          MLA      r8,r1,r8,r0
0001ae  f8439028          STR      r9,[r3,r8,LSL #2]
;;;259          xbuf1[rgroup*(M+2) + i] = xbuf1[i];
0001b2  f8549020          LDR      r9,[r4,r0,LSL #2]
0001b6  f1060802          ADD      r8,r6,#2
0001ba  fb010808          MLA      r8,r1,r8,r0
0001be  f8449028          STR      r9,[r4,r8,LSL #2]
0001c2  1c40              ADDS     r0,r0,#1              ;255
                  |L1.452|
0001c4  4288              CMP      r0,r1                 ;255
0001c6  dbd8              BLT      |L1.378|
0001c8  1c6d              ADDS     r5,r5,#1              ;250
0001ca  3754              ADDS     r7,r7,#0x54           ;250
                  |L1.460|
0001cc  f8d28024          LDR      r8,[r2,#0x24]         ;249
0001d0  45a8              CMP      r8,r5                 ;249
0001d2  dcbe              BGT      |L1.338|
;;;260        }
;;;261      }
;;;262    }
0001d4  e8bd83f0          POP      {r4-r9,pc}
;;;263    
                          ENDP

                  set_bottom_pointers PROC
;;;265    LOCAL(void)
;;;266    set_bottom_pointers (j_decompress_ptr cinfo)
0001d8  e92d43f0          PUSH     {r4-r9,lr}
;;;267    /* Change the pointer lists to duplicate the last sample row at the bottom
;;;268     * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
;;;269     * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
;;;270     */
;;;271    {
;;;272      my_main_ptr pMain = (my_main_ptr) cinfo->main;
0001dc  f8d071a8          LDR      r7,[r0,#0x1a8]
;;;273      int ci, i, rgroup, iMCUheight, rows_left;
;;;274      jpeg_component_info *compptr;
;;;275      JSAMPARRAY xbuf;
;;;276    
;;;277      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
0001e0  2100              MOVS     r1,#0
0001e2  f8d050d8          LDR      r5,[r0,#0xd8]
0001e6  e034              B        |L1.594|
                  |L1.488|
;;;278           ci++, compptr++) {
;;;279        /* Count sample rows in one iMCU row and in one row group */
;;;280        iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
0001e8  f8d59024          LDR      r9,[r5,#0x24]
0001ec  f8d5800c          LDR      r8,[r5,#0xc]
0001f0  fb08f309          MUL      r3,r8,r9
;;;281        rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
0001f4  f8d0813c          LDR      r8,[r0,#0x13c]
0001f8  fb93f2f8          SDIV     r2,r3,r8
;;;282        /* Count nondummy sample rows remaining for this component */
;;;283        rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
0001fc  f8d5802c          LDR      r8,[r5,#0x2c]
000200  fbb8f9f3          UDIV     r9,r8,r3
000204  fb038419          MLS      r4,r3,r9,r8
;;;284        if (rows_left == 0) rows_left = iMCUheight;
000208  b904              CBNZ     r4,|L1.524|
00020a  461c              MOV      r4,r3
                  |L1.524|
;;;285        /* Count nondummy row groups.  Should get same answer for each component,
;;;286         * so we need only do it once.
;;;287         */
;;;288        if (ci == 0) {
00020c  b939              CBNZ     r1,|L1.542|
;;;289          pMain->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
00020e  f1a40801          SUB      r8,r4,#1
000212  fb98f8f2          SDIV     r8,r8,r2
000216  f1080801          ADD      r8,r8,#1
00021a  f8c78030          STR      r8,[r7,#0x30]
                  |L1.542|
;;;290        }
;;;291        /* Duplicate the last real sample row rgroup*2 times; this pads out the
;;;292         * last partial rowgroup and ensures at least one full rowgroup of context.
;;;293         */
;;;294        xbuf = pMain->xbuffer[pMain->whichptr][ci];
00021e  f1070820          ADD      r8,r7,#0x20
000222  f8d79028          LDR      r9,[r7,#0x28]
000226  f8588029          LDR      r8,[r8,r9,LSL #2]
00022a  f8586021          LDR      r6,[r8,r1,LSL #2]
;;;295        for (i = 0; i < rgroup * 2; i++) {
00022e  f04f0c00          MOV      r12,#0
000232  e009              B        |L1.584|
                  |L1.564|
;;;296          xbuf[rows_left + i] = xbuf[rows_left-1];
000234  f1a40801          SUB      r8,r4,#1
000238  f8568028          LDR      r8,[r6,r8,LSL #2]
00023c  eb04090c          ADD      r9,r4,r12
000240  f8468029          STR      r8,[r6,r9,LSL #2]
000244  f10c0c01          ADD      r12,r12,#1            ;295
                  |L1.584|
000248  ebbc0f42          CMP      r12,r2,LSL #1         ;295
00024c  dbf2              BLT      |L1.564|
00024e  1c49              ADDS     r1,r1,#1              ;278
000250  3554              ADDS     r5,r5,#0x54           ;278
                  |L1.594|
000252  f8d08024          LDR      r8,[r0,#0x24]         ;277
000256  4588              CMP      r8,r1                 ;277
000258  dcc6              BGT      |L1.488|
;;;297        }
;;;298      }
;;;299    }
00025a  e8bd83f0          POP      {r4-r9,pc}
;;;300    
                          ENDP

                  process_data_crank_post PROC
;;;458    METHODDEF(void)
;;;459    process_data_crank_post (j_decompress_ptr cinfo,
00025e  b5fe              PUSH     {r1-r7,lr}
;;;460    			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;461    			 JDIMENSION out_rows_avail)
;;;462    {
000260  4604              MOV      r4,r0
000262  460d              MOV      r5,r1
000264  4616              MOV      r6,r2
000266  461f              MOV      r7,r3
;;;463      (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
000268  e88d00e0          STM      sp,{r5-r7}
00026c  f8d401b0          LDR      r0,[r4,#0x1b0]
000270  2300              MOVS     r3,#0
000272  461a              MOV      r2,r3
000274  4619              MOV      r1,r3
000276  f8d0c004          LDR      r12,[r0,#4]
00027a  4620              MOV      r0,r4
00027c  47e0              BLX      r12
;;;464    				     (JDIMENSION *) NULL, (JDIMENSION) 0,
;;;465    				     output_buf, out_row_ctr, out_rows_avail);
;;;466    }
00027e  bdfe              POP      {r1-r7,pc}
;;;467    
                          ENDP

                  process_data_simple_main PROC
;;;344    METHODDEF(void)
;;;345    process_data_simple_main (j_decompress_ptr cinfo,
000280  e92d43fe          PUSH     {r1-r9,lr}
;;;346    			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;347    			  JDIMENSION out_rows_avail)
;;;348    {
000284  4605              MOV      r5,r0
000286  460f              MOV      r7,r1
000288  4690              MOV      r8,r2
00028a  4699              MOV      r9,r3
;;;349      my_main_ptr pMain = (my_main_ptr) cinfo->main;
00028c  f8d541a8          LDR      r4,[r5,#0x1a8]
;;;350      JDIMENSION rowgroups_avail;
;;;351    
;;;352      /* Read input data if we haven't filled the main buffer yet */
;;;353      if (! pMain->buffer_full) {
000290  69a0              LDR      r0,[r4,#0x18]
000292  b958              CBNZ     r0,|L1.684|
;;;354        if (! (*cinfo->coef->decompress_data) (cinfo, pMain->buffer))
000294  f8d501ac          LDR      r0,[r5,#0x1ac]
000298  f1040108          ADD      r1,r4,#8
00029c  68c2              LDR      r2,[r0,#0xc]
00029e  4628              MOV      r0,r5
0002a0  4790              BLX      r2
0002a2  b908              CBNZ     r0,|L1.680|
                  |L1.676|
;;;355          return;			/* suspension forced, can do nothing more */
;;;356        pMain->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
;;;357      }
;;;358    
;;;359      /* There are always min_DCT_scaled_size row groups in an iMCU row. */
;;;360      rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
;;;361      /* Note: at the bottom of the image, we may pass extra garbage row groups
;;;362       * to the postprocessor.  The postprocessor has to check for bottom
;;;363       * of image anyway (at row resolution), so no point in us doing it too.
;;;364       */
;;;365    
;;;366      /* Feed the postprocessor */
;;;367      (*cinfo->post->post_process_data) (cinfo, pMain->buffer,
;;;368    				     &pMain->rowgroup_ctr, rowgroups_avail,
;;;369    				     output_buf, out_row_ctr, out_rows_avail);
;;;370    
;;;371      /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
;;;372      if (pMain->rowgroup_ctr >= rowgroups_avail) {
;;;373        pMain->buffer_full = FALSE;
;;;374        pMain->rowgroup_ctr = 0;
;;;375      }
;;;376    }
0002a4  e8bd83fe          POP      {r1-r9,pc}
                  |L1.680|
0002a8  2001              MOVS     r0,#1                 ;356
0002aa  61a0              STR      r0,[r4,#0x18]         ;356
                  |L1.684|
0002ac  f8d5613c          LDR      r6,[r5,#0x13c]        ;360
0002b0  e88d0380          STM      sp,{r7-r9}            ;367
0002b4  f8d501b0          LDR      r0,[r5,#0x1b0]        ;367
0002b8  4633              MOV      r3,r6                 ;367
0002ba  f104021c          ADD      r2,r4,#0x1c           ;367
0002be  f1040108          ADD      r1,r4,#8              ;367
0002c2  f8d0c004          LDR      r12,[r0,#4]           ;367
0002c6  4628              MOV      r0,r5                 ;367
0002c8  47e0              BLX      r12                   ;367
0002ca  69e0              LDR      r0,[r4,#0x1c]         ;372
0002cc  42b0              CMP      r0,r6                 ;372
0002ce  d302              BCC      |L1.726|
0002d0  2000              MOVS     r0,#0                 ;373
0002d2  61a0              STR      r0,[r4,#0x18]         ;373
0002d4  61e0              STR      r0,[r4,#0x1c]         ;374
                  |L1.726|
0002d6  bf00              NOP      
0002d8  e7e4              B        |L1.676|
;;;377    
                          ENDP

                  process_data_context_main PROC
;;;384    METHODDEF(void)
;;;385    process_data_context_main (j_decompress_ptr cinfo,
0002da  e92d43fe          PUSH     {r1-r9,lr}
;;;386    			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;387    			   JDIMENSION out_rows_avail)
;;;388    {
0002de  4605              MOV      r5,r0
0002e0  4688              MOV      r8,r1
0002e2  4616              MOV      r6,r2
0002e4  461f              MOV      r7,r3
;;;389      my_main_ptr pMain = (my_main_ptr) cinfo->main;
0002e6  f8d541a8          LDR      r4,[r5,#0x1a8]
;;;390    
;;;391      /* Read input data if we haven't filled the main buffer yet */
;;;392      if (! pMain->buffer_full) {
0002ea  69a0              LDR      r0,[r4,#0x18]
0002ec  b988              CBNZ     r0,|L1.786|
;;;393        if (! (*cinfo->coef->decompress_data) (cinfo,
0002ee  f1040020          ADD      r0,r4,#0x20
0002f2  6aa3              LDR      r3,[r4,#0x28]
0002f4  f8501023          LDR      r1,[r0,r3,LSL #2]
0002f8  f8d501ac          LDR      r0,[r5,#0x1ac]
0002fc  68c2              LDR      r2,[r0,#0xc]
0002fe  4628              MOV      r0,r5
000300  4790              BLX      r2
000302  b908              CBNZ     r0,|L1.776|
                  |L1.772|
;;;394    					   pMain->xbuffer[pMain->whichptr]))
;;;395          return;			/* suspension forced, can do nothing more */
;;;396        pMain->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
;;;397        pMain->iMCU_row_ctr++;	/* count rows received */
;;;398      }
;;;399    
;;;400      /* Postprocessor typically will not swallow all the input data it is handed
;;;401       * in one call (due to filling the output buffer first).  Must be prepared
;;;402       * to exit and restart.  This switch lets us keep track of how far we got.
;;;403       * Note that each case falls through to the next on successful completion.
;;;404       */
;;;405      switch (pMain->context_state) {
;;;406      case CTX_POSTPONED_ROW:
;;;407        /* Call postprocessor using previously set pointers for postponed row */
;;;408        (*cinfo->post->post_process_data) (cinfo, pMain->xbuffer[pMain->whichptr],
;;;409    			&pMain->rowgroup_ctr, pMain->rowgroups_avail,
;;;410    			output_buf, out_row_ctr, out_rows_avail);
;;;411        if (pMain->rowgroup_ctr < pMain->rowgroups_avail)
;;;412          return;			/* Need to suspend */
;;;413        pMain->context_state = CTX_PREPARE_FOR_IMCU;
;;;414        if (*out_row_ctr >= out_rows_avail)
;;;415          return;			/* Postprocessor exactly filled output buf */
;;;416        /*FALLTHROUGH*/
;;;417      case CTX_PREPARE_FOR_IMCU:
;;;418        /* Prepare to process first M-1 row groups of this iMCU row */
;;;419        pMain->rowgroup_ctr = 0;
;;;420        pMain->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
;;;421        /* Check for bottom of image: if so, tweak pointers to "duplicate"
;;;422         * the last sample row, and adjust rowgroups_avail to ignore padding rows.
;;;423         */
;;;424        if (pMain->iMCU_row_ctr == cinfo->total_iMCU_rows)
;;;425          set_bottom_pointers(cinfo);
;;;426        pMain->context_state = CTX_PROCESS_IMCU;
;;;427        /*FALLTHROUGH*/
;;;428      case CTX_PROCESS_IMCU:
;;;429        /* Call postprocessor using previously set pointers */
;;;430        (*cinfo->post->post_process_data) (cinfo, pMain->xbuffer[pMain->whichptr],
;;;431    			&pMain->rowgroup_ctr, pMain->rowgroups_avail,
;;;432    			output_buf, out_row_ctr, out_rows_avail);
;;;433        if (pMain->rowgroup_ctr < pMain->rowgroups_avail)
;;;434          return;			/* Need to suspend */
;;;435        /* After the first iMCU, change wraparound pointers to normal state */
;;;436        if (pMain->iMCU_row_ctr == 1)
;;;437          set_wraparound_pointers(cinfo);
;;;438        /* Prepare to load new iMCU row using other xbuffer list */
;;;439        pMain->whichptr ^= 1;	/* 0=>1 or 1=>0 */
;;;440        pMain->buffer_full = FALSE;
;;;441        /* Still need to process last row group of this iMCU row, */
;;;442        /* which is saved at index M+1 of the other xbuffer */
;;;443        pMain->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
;;;444        pMain->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
;;;445        pMain->context_state = CTX_POSTPONED_ROW;
;;;446      }
;;;447    }
000304  e8bd83fe          POP      {r1-r9,pc}
                  |L1.776|
000308  2001              MOVS     r0,#1                 ;396
00030a  61a0              STR      r0,[r4,#0x18]         ;396
00030c  6b60              LDR      r0,[r4,#0x34]         ;397
00030e  1c40              ADDS     r0,r0,#1              ;397
000310  6360              STR      r0,[r4,#0x34]         ;397
                  |L1.786|
000312  6ae0              LDR      r0,[r4,#0x2c]         ;405
000314  b300              CBZ      r0,|L1.856|
000316  2801              CMP      r0,#1                 ;405
000318  d02f              BEQ      |L1.890|
00031a  2802              CMP      r0,#2                 ;405
00031c  d15a              BNE      |L1.980|
00031e  e9cd8600          STRD     r8,r6,[sp,#0]         ;408
000322  9702              STR      r7,[sp,#8]            ;408
000324  f1040020          ADD      r0,r4,#0x20           ;408
000328  6aa2              LDR      r2,[r4,#0x28]         ;408
00032a  f8501022          LDR      r1,[r0,r2,LSL #2]     ;408
00032e  6b23              LDR      r3,[r4,#0x30]         ;408
000330  f8d501b0          LDR      r0,[r5,#0x1b0]        ;408
000334  f104021c          ADD      r2,r4,#0x1c           ;408
000338  f8d0c004          LDR      r12,[r0,#4]           ;408
00033c  4628              MOV      r0,r5                 ;408
00033e  47e0              BLX      r12                   ;408
000340  6b21              LDR      r1,[r4,#0x30]         ;411
000342  69e0              LDR      r0,[r4,#0x1c]         ;411
000344  4288              CMP      r0,r1                 ;411
000346  d200              BCS      |L1.842|
000348  e7dc              B        |L1.772|
                  |L1.842|
00034a  2000              MOVS     r0,#0                 ;413
00034c  62e0              STR      r0,[r4,#0x2c]         ;413
00034e  6830              LDR      r0,[r6,#0]            ;414
000350  42b8              CMP      r0,r7                 ;414
000352  d300              BCC      |L1.854|
000354  e7d6              B        |L1.772|
                  |L1.854|
000356  bf00              NOP                            ;417
                  |L1.856|
000358  2000              MOVS     r0,#0                 ;419
00035a  61e0              STR      r0,[r4,#0x1c]         ;419
00035c  f8d5013c          LDR      r0,[r5,#0x13c]        ;420
000360  1e40              SUBS     r0,r0,#1              ;420
000362  6320              STR      r0,[r4,#0x30]         ;420
000364  6b60              LDR      r0,[r4,#0x34]         ;424
000366  f8d51140          LDR      r1,[r5,#0x140]        ;424
00036a  4288              CMP      r0,r1                 ;424
00036c  d102              BNE      |L1.884|
00036e  4628              MOV      r0,r5                 ;425
000370  f7fffffe          BL       set_bottom_pointers
                  |L1.884|
000374  2001              MOVS     r0,#1                 ;426
000376  62e0              STR      r0,[r4,#0x2c]         ;426
000378  bf00              NOP                            ;428
                  |L1.890|
00037a  e9cd8600          STRD     r8,r6,[sp,#0]         ;430
00037e  9702              STR      r7,[sp,#8]            ;430
000380  f1040020          ADD      r0,r4,#0x20           ;430
000384  6aa2              LDR      r2,[r4,#0x28]         ;430
000386  f8501022          LDR      r1,[r0,r2,LSL #2]     ;430
00038a  6b23              LDR      r3,[r4,#0x30]         ;430
00038c  f8d501b0          LDR      r0,[r5,#0x1b0]        ;430
000390  f104021c          ADD      r2,r4,#0x1c           ;430
000394  f8d0c004          LDR      r12,[r0,#4]           ;430
000398  4628              MOV      r0,r5                 ;430
00039a  47e0              BLX      r12                   ;430
00039c  6b21              LDR      r1,[r4,#0x30]         ;433
00039e  69e0              LDR      r0,[r4,#0x1c]         ;433
0003a0  4288              CMP      r0,r1                 ;433
0003a2  d200              BCS      |L1.934|
0003a4  e7ae              B        |L1.772|
                  |L1.934|
0003a6  6b60              LDR      r0,[r4,#0x34]         ;436
0003a8  2801              CMP      r0,#1                 ;436
0003aa  d102              BNE      |L1.946|
0003ac  4628              MOV      r0,r5                 ;437
0003ae  f7fffffe          BL       set_wraparound_pointers
                  |L1.946|
0003b2  6aa0              LDR      r0,[r4,#0x28]         ;439
0003b4  f0800001          EOR      r0,r0,#1              ;439
0003b8  62a0              STR      r0,[r4,#0x28]         ;439
0003ba  2000              MOVS     r0,#0                 ;440
0003bc  61a0              STR      r0,[r4,#0x18]         ;440
0003be  f8d5013c          LDR      r0,[r5,#0x13c]        ;443
0003c2  1c40              ADDS     r0,r0,#1              ;443
0003c4  61e0              STR      r0,[r4,#0x1c]         ;443
0003c6  f8d5013c          LDR      r0,[r5,#0x13c]        ;444
0003ca  1c80              ADDS     r0,r0,#2              ;444
0003cc  6320              STR      r0,[r4,#0x30]         ;444
0003ce  2002              MOVS     r0,#2                 ;445
0003d0  62e0              STR      r0,[r4,#0x2c]         ;445
0003d2  bf00              NOP                            ;405
                  |L1.980|
0003d4  bf00              NOP                            ;405
0003d6  bf00              NOP      
0003d8  e794              B        |L1.772|
;;;448    
                          ENDP

                  start_pass_main PROC
;;;306    METHODDEF(void)
;;;307    start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
0003da  b570              PUSH     {r4-r6,lr}
;;;308    {
0003dc  4605              MOV      r5,r0
0003de  460e              MOV      r6,r1
;;;309      my_main_ptr pMain = (my_main_ptr) cinfo->main;
0003e0  f8d541a8          LDR      r4,[r5,#0x1a8]
;;;310    
;;;311      switch (pass_mode) {
0003e4  b116              CBZ      r6,|L1.1004|
0003e6  2e02              CMP      r6,#2
0003e8  d117              BNE      |L1.1050|
0003ea  e013              B        |L1.1044|
                  |L1.1004|
;;;312      case JBUF_PASS_THRU:
;;;313        if (cinfo->upsample->need_context_rows) {
0003ec  f8d501c4          LDR      r0,[r5,#0x1c4]
0003f0  6880              LDR      r0,[r0,#8]
0003f2  b148              CBZ      r0,|L1.1032|
;;;314          pMain->pub.process_data = process_data_context_main;
0003f4  4838              LDR      r0,|L1.1240|
0003f6  6060              STR      r0,[r4,#4]
;;;315          make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
0003f8  4628              MOV      r0,r5
0003fa  f7fffffe          BL       make_funny_pointers
;;;316          pMain->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
0003fe  2000              MOVS     r0,#0
000400  62a0              STR      r0,[r4,#0x28]
;;;317          pMain->context_state = CTX_PREPARE_FOR_IMCU;
000402  62e0              STR      r0,[r4,#0x2c]
;;;318          pMain->iMCU_row_ctr = 0;
000404  6360              STR      r0,[r4,#0x34]
000406  e001              B        |L1.1036|
                  |L1.1032|
;;;319        } else {
;;;320          /* Simple case with no context needed */
;;;321          pMain->pub.process_data = process_data_simple_main;
000408  4834              LDR      r0,|L1.1244|
00040a  6060              STR      r0,[r4,#4]
                  |L1.1036|
;;;322        }
;;;323        pMain->buffer_full = FALSE;	/* Mark buffer empty */
00040c  2000              MOVS     r0,#0
00040e  61a0              STR      r0,[r4,#0x18]
;;;324        pMain->rowgroup_ctr = 0;
000410  61e0              STR      r0,[r4,#0x1c]
;;;325        break;
000412  e00a              B        |L1.1066|
                  |L1.1044|
;;;326    #ifdef QUANT_2PASS_SUPPORTED
;;;327      case JBUF_CRANK_DEST:
;;;328        /* For last pass of 2-pass quantization, just crank the postprocessor */
;;;329        pMain->pub.process_data = process_data_crank_post;
000414  4832              LDR      r0,|L1.1248|
000416  6060              STR      r0,[r4,#4]
;;;330        break;
000418  e007              B        |L1.1066|
                  |L1.1050|
;;;331    #endif
;;;332      default:
;;;333        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
00041a  2004              MOVS     r0,#4
00041c  6829              LDR      r1,[r5,#0]
00041e  6148              STR      r0,[r1,#0x14]
000420  6828              LDR      r0,[r5,#0]
000422  6801              LDR      r1,[r0,#0]
000424  4628              MOV      r0,r5
000426  4788              BLX      r1
;;;334        break;
000428  bf00              NOP      
                  |L1.1066|
00042a  bf00              NOP                            ;325
;;;335      }
;;;336    }
00042c  bd70              POP      {r4-r6,pc}
;;;337    
                          ENDP

                  jinit_d_main_controller PROC
;;;475    GLOBAL(void)
;;;476    jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
00042e  e92d47f0          PUSH     {r4-r10,lr}
;;;477    {
000432  4604              MOV      r4,r0
000434  4689              MOV      r9,r1
;;;478      my_main_ptr pMain;
;;;479      int ci, rgroup, ngroups;
;;;480      jpeg_component_info *compptr;
;;;481    
;;;482      pMain = (my_main_ptr)
000436  6860              LDR      r0,[r4,#4]
000438  2238              MOVS     r2,#0x38
00043a  2101              MOVS     r1,#1
00043c  6803              LDR      r3,[r0,#0]
00043e  4620              MOV      r0,r4
000440  4798              BLX      r3
000442  4607              MOV      r7,r0
;;;483        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;484    				SIZEOF(my_main_controller));
;;;485      cinfo->main = (struct jpeg_d_main_controller *) pMain;
000444  f8c471a8          STR      r7,[r4,#0x1a8]
;;;486      pMain->pub.start_pass = start_pass_main;
000448  4826              LDR      r0,|L1.1252|
00044a  6038              STR      r0,[r7,#0]
;;;487    
;;;488      if (need_full_buffer)		/* shouldn't happen */
00044c  f1b90f00          CMP      r9,#0
000450  d006              BEQ      |L1.1120|
;;;489        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000452  2004              MOVS     r0,#4
000454  6821              LDR      r1,[r4,#0]
000456  6148              STR      r0,[r1,#0x14]
000458  6820              LDR      r0,[r4,#0]
00045a  6801              LDR      r1,[r0,#0]
00045c  4620              MOV      r0,r4
00045e  4788              BLX      r1
                  |L1.1120|
;;;490    
;;;491      /* Allocate the workspace.
;;;492       * ngroups is the number of row groups we need.
;;;493       */
;;;494      if (cinfo->upsample->need_context_rows) {
000460  f8d401c4          LDR      r0,[r4,#0x1c4]
000464  6880              LDR      r0,[r0,#8]
000466  b190              CBZ      r0,|L1.1166|
;;;495        if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
000468  f8d4013c          LDR      r0,[r4,#0x13c]
00046c  2802              CMP      r0,#2
00046e  da06              BGE      |L1.1150|
;;;496          ERREXIT(cinfo, JERR_NOTIMPL);
000470  202f              MOVS     r0,#0x2f
000472  6821              LDR      r1,[r4,#0]
000474  6148              STR      r0,[r1,#0x14]
000476  6820              LDR      r0,[r4,#0]
000478  6801              LDR      r1,[r0,#0]
00047a  4620              MOV      r0,r4
00047c  4788              BLX      r1
                  |L1.1150|
;;;497        alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
00047e  4620              MOV      r0,r4
000480  f7fffffe          BL       alloc_funny_pointers
;;;498        ngroups = cinfo->min_DCT_scaled_size + 2;
000484  f8d4013c          LDR      r0,[r4,#0x13c]
000488  f1000802          ADD      r8,r0,#2
00048c  e001              B        |L1.1170|
                  |L1.1166|
;;;499      } else {
;;;500        ngroups = cinfo->min_DCT_scaled_size;
00048e  f8d4813c          LDR      r8,[r4,#0x13c]
                  |L1.1170|
;;;501      }
;;;502    
;;;503      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000492  2600              MOVS     r6,#0
000494  f8d450d8          LDR      r5,[r4,#0xd8]
000498  e018              B        |L1.1228|
                  |L1.1178|
;;;504           ci++, compptr++) {
;;;505        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
00049a  6a69              LDR      r1,[r5,#0x24]
00049c  68e8              LDR      r0,[r5,#0xc]
00049e  4348              MULS     r0,r1,r0
0004a0  f8d4113c          LDR      r1,[r4,#0x13c]
0004a4  fb90faf1          SDIV     r10,r0,r1
;;;506          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;507        pMain->buffer[ci] = (*cinfo->mem->alloc_sarray)
0004a8  6a69              LDR      r1,[r5,#0x24]
0004aa  69e8              LDR      r0,[r5,#0x1c]
0004ac  fb00f201          MUL      r2,r0,r1
0004b0  fb0af308          MUL      r3,r10,r8
0004b4  6860              LDR      r0,[r4,#4]
0004b6  2101              MOVS     r1,#1
0004b8  f8d0c008          LDR      r12,[r0,#8]
0004bc  4620              MOV      r0,r4
0004be  47e0              BLX      r12
0004c0  f1070108          ADD      r1,r7,#8
0004c4  f8410026          STR      r0,[r1,r6,LSL #2]
0004c8  1c76              ADDS     r6,r6,#1              ;504
0004ca  3554              ADDS     r5,r5,#0x54           ;504
                  |L1.1228|
0004cc  6a60              LDR      r0,[r4,#0x24]         ;503
0004ce  42b0              CMP      r0,r6                 ;503
0004d0  dce3              BGT      |L1.1178|
;;;508    			((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;509    			 compptr->width_in_blocks * compptr->DCT_scaled_size,
;;;510    			 (JDIMENSION) (rgroup * ngroups));
;;;511      }
;;;512    }
0004d2  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

0004d6  0000              DCW      0x0000
                  |L1.1240|
                          DCD      process_data_context_main
                  |L1.1244|
                          DCD      process_data_simple_main
                  |L1.1248|
                          DCD      process_data_crank_post
                  |L1.1252|
                          DCD      start_pass_main
