; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\header.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\header.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\header.crf GUI\Widget\HEADER.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _DrawTriangle PROC
;;;100    */
;;;101    static void _DrawTriangle(int x, int y, int Size, int Inc) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;102      for (; Size >= 0; Size--, y += Inc) {
00000c  e006              B        |L1.28|
                  |L1.14|
;;;103        GUI_DrawHLine(y, x - Size, x + Size);
00000e  192a              ADDS     r2,r5,r4
000010  1b29              SUBS     r1,r5,r4
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       GUI_DrawHLine
000018  1e64              SUBS     r4,r4,#1              ;102
00001a  443e              ADD      r6,r6,r7              ;102
                  |L1.28|
00001c  2c00              CMP      r4,#0                 ;102
00001e  daf6              BGE      |L1.14|
;;;104      }
;;;105    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;106    
                          ENDP

                  _Paint PROC
;;;110    */
;;;111    static void _Paint(HEADER_Obj* pObj) {
000024  e92d4ff0          PUSH     {r4-r11,lr}
000028  b089              SUB      sp,sp,#0x24
00002a  4605              MOV      r5,r0
;;;112      GUI_RECT Rect, RectItem;
;;;113      int i, xPos = -pObj->ScrollPos;
00002c  6be8              LDR      r0,[r5,#0x3c]
00002e  f1c00900          RSB      r9,r0,#0
;;;114      int NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
000032  f1050030          ADD      r0,r5,#0x30
000036  f7fffffe          BL       GUI_ARRAY_GetNumItems
00003a  9004              STR      r0,[sp,#0x10]
;;;115      int EffectSize = pObj->Widget.pEffect->EffectSize;
00003c  6a28              LDR      r0,[r5,#0x20]
00003e  6946              LDR      r6,[r0,#0x14]
;;;116      int ArrowSize, ArrowPos;
;;;117      LCD_SetBkColor(pObj->BkColor);
000040  6aa8              LDR      r0,[r5,#0x28]
000042  f7fffffe          BL       LCD_SetBkColor
;;;118      GUI_SetFont(pObj->pFont);
000046  6ce8              LDR      r0,[r5,#0x4c]
000048  f7fffffe          BL       GUI_SetFont
;;;119      GUI_Clear();
00004c  f7fffffe          BL       GUI_Clear
;;;120      for (i = 0; i < NumItems; i++) {
000050  2700              MOVS     r7,#0
000052  e0fa              B        |L1.586|
                  |L1.84|
;;;121        int Subtract = 0;
000054  f04f0b00          MOV      r11,#0
;;;122        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
000058  4639              MOV      r1,r7
00005a  f1050030          ADD      r0,r5,#0x30
00005e  f7fffffe          BL       GUI_ARRAY_GetpItem
000062  4604              MOV      r4,r0
;;;123        GUI_GetClientRect(&Rect);
000064  a807              ADD      r0,sp,#0x1c
000066  f7fffffe          BL       GUI_GetClientRect
;;;124        Rect.x0 = xPos;
00006a  fa0ff089          SXTH     r0,r9
00006e  f8ad001c          STRH     r0,[sp,#0x1c]
;;;125        Rect.x1 = Rect.x0 + pColumn->Width;
000072  f8bd001c          LDRH     r0,[sp,#0x1c]
000076  8821              LDRH     r1,[r4,#0]
000078  4408              ADD      r0,r0,r1
00007a  b200              SXTH     r0,r0
00007c  f8ad0020          STRH     r0,[sp,#0x20]
;;;126        RectItem = Rect;
000080  e9dd0107          LDRD     r0,r1,[sp,#0x1c]
000084  e9cd0105          STRD     r0,r1,[sp,#0x14]
;;;127        ArrowSize = ((RectItem.y1 - RectItem.y0 - EffectSize * 2) / 3) - 1;
000088  f9bd001a          LDRSH    r0,[sp,#0x1a]
00008c  f9bd1016          LDRSH    r1,[sp,#0x16]
000090  1a40              SUBS     r0,r0,r1
000092  eba00046          SUB      r0,r0,r6,LSL #1
000096  2103              MOVS     r1,#3
000098  fb90f0f1          SDIV     r0,r0,r1
00009c  f1a00801          SUB      r8,r0,#1
;;;128        ArrowPos = RectItem.x1 - 4 - ArrowSize;
0000a0  f9bd0018          LDRSH    r0,[sp,#0x18]
0000a4  1f00              SUBS     r0,r0,#4
0000a6  eba00a08          SUB      r10,r0,r8
;;;129        if (pColumn->hDrawObj) {
0000aa  88e0              LDRH     r0,[r4,#6]
0000ac  2800              CMP      r0,#0
0000ae  d055              BEQ      |L1.348|
;;;130          int xOff = 0, yOff = 0;
0000b0  2000              MOVS     r0,#0
0000b2  9003              STR      r0,[sp,#0xc]
0000b4  9002              STR      r0,[sp,#8]
;;;131          switch (pColumn->Align & GUI_TA_HORIZONTAL) {
0000b6  7920              LDRB     r0,[r4,#4]
0000b8  f0000003          AND      r0,r0,#3
0000bc  2801              CMP      r0,#1
0000be  d002              BEQ      |L1.198|
0000c0  2802              CMP      r0,#2
0000c2  d114              BNE      |L1.238|
0000c4  e007              B        |L1.214|
                  |L1.198|
;;;132            case GUI_TA_RIGHT:
;;;133              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj));
0000c6  f9b40006          LDRSH    r0,[r4,#6]
0000ca  f7fffffe          BL       GUI_DRAW__GetXSize
0000ce  6821              LDR      r1,[r4,#0]
0000d0  1a08              SUBS     r0,r1,r0
0000d2  9003              STR      r0,[sp,#0xc]
;;;134              break;
0000d4  e00b              B        |L1.238|
                  |L1.214|
;;;135            case GUI_TA_HCENTER:
;;;136              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj)) / 2;
0000d6  f9b40006          LDRSH    r0,[r4,#6]
0000da  f7fffffe          BL       GUI_DRAW__GetXSize
0000de  6821              LDR      r1,[r4,#0]
0000e0  1a08              SUBS     r0,r1,r0
0000e2  9001              STR      r0,[sp,#4]
0000e4  eb0070d0          ADD      r0,r0,r0,LSR #31
0000e8  1040              ASRS     r0,r0,#1
0000ea  9003              STR      r0,[sp,#0xc]
;;;137              break;
0000ec  bf00              NOP      
                  |L1.238|
0000ee  bf00              NOP                            ;134
;;;138          }
;;;139          switch (pColumn->Align & GUI_TA_VERTICAL) {
0000f0  7920              LDRB     r0,[r4,#4]
0000f2  f000000c          AND      r0,r0,#0xc
0000f6  2804              CMP      r0,#4
0000f8  d002              BEQ      |L1.256|
0000fa  280c              CMP      r0,#0xc
0000fc  d11e              BNE      |L1.316|
0000fe  e00c              B        |L1.282|
                  |L1.256|
;;;140    	      case GUI_TA_BOTTOM:
;;;141              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj));
000100  f9b40006          LDRSH    r0,[r4,#6]
000104  f7fffffe          BL       GUI_DRAW__GetYSize
000108  f9bd1022          LDRSH    r1,[sp,#0x22]
00010c  f9bd201e          LDRSH    r2,[sp,#0x1e]
000110  1a89              SUBS     r1,r1,r2
000112  1c49              ADDS     r1,r1,#1
000114  1a08              SUBS     r0,r1,r0
000116  9002              STR      r0,[sp,#8]
;;;142              break;
000118  e010              B        |L1.316|
                  |L1.282|
;;;143    	      case GUI_TA_VCENTER:
;;;144              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj)) / 2;
00011a  f9b40006          LDRSH    r0,[r4,#6]
00011e  f7fffffe          BL       GUI_DRAW__GetYSize
000122  f9bd1022          LDRSH    r1,[sp,#0x22]
000126  f9bd201e          LDRSH    r2,[sp,#0x1e]
00012a  1a89              SUBS     r1,r1,r2
00012c  1c49              ADDS     r1,r1,#1
00012e  1a08              SUBS     r0,r1,r0
000130  9001              STR      r0,[sp,#4]
000132  eb0070d0          ADD      r0,r0,r0,LSR #31
000136  1040              ASRS     r0,r0,#1
000138  9002              STR      r0,[sp,#8]
;;;145              break;
00013a  bf00              NOP      
                  |L1.316|
00013c  bf00              NOP                            ;142
;;;146          }
;;;147          WM_SetUserClipRect(&Rect);
00013e  a807              ADD      r0,sp,#0x1c
000140  f7fffffe          BL       WM_SetUserClipRect
;;;148          GUI_DRAW__Draw(pColumn->hDrawObj, xPos + xOff, yOff);
000144  9a03              LDR      r2,[sp,#0xc]
000146  eb090102          ADD      r1,r9,r2
00014a  f9b40006          LDRSH    r0,[r4,#6]
00014e  9a02              LDR      r2,[sp,#8]
000150  f7fffffe          BL       GUI_DRAW__Draw
;;;149          WM_SetUserClipRect(NULL);
000154  2000              MOVS     r0,#0
000156  f7fffffe          BL       WM_SetUserClipRect
;;;150        }
00015a  bf00              NOP      
                  |L1.348|
;;;151        WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
00015c  a907              ADD      r1,sp,#0x1c
00015e  4628              MOV      r0,r5
000160  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;152        xPos += Rect.x1 - Rect.x0;
000164  f9bd0020          LDRSH    r0,[sp,#0x20]
000168  f9bd101c          LDRSH    r1,[sp,#0x1c]
00016c  1a40              SUBS     r0,r0,r1
00016e  4481              ADD      r9,r9,r0
;;;153        Rect.x0 += EffectSize + _DefaultBorderH;
000170  f8bd001c          LDRH     r0,[sp,#0x1c]
000174  49f9              LDR      r1,|L1.1372|
000176  8809              LDRH     r1,[r1,#0]  ; _DefaultBorderH
000178  4431              ADD      r1,r1,r6
00017a  4408              ADD      r0,r0,r1
00017c  b200              SXTH     r0,r0
00017e  f8ad001c          STRH     r0,[sp,#0x1c]
;;;154        Rect.x1 -= EffectSize + _DefaultBorderH;
000182  f8bd0020          LDRH     r0,[sp,#0x20]
000186  49f5              LDR      r1,|L1.1372|
000188  8809              LDRH     r1,[r1,#0]  ; _DefaultBorderH
00018a  4431              ADD      r1,r1,r6
00018c  1a40              SUBS     r0,r0,r1
00018e  b200              SXTH     r0,r0
000190  f8ad0020          STRH     r0,[sp,#0x20]
;;;155        Rect.y0 += EffectSize + _DefaultBorderV;
000194  f8bd001e          LDRH     r0,[sp,#0x1e]
000198  49f1              LDR      r1,|L1.1376|
00019a  8809              LDRH     r1,[r1,#0]  ; _DefaultBorderV
00019c  4431              ADD      r1,r1,r6
00019e  4408              ADD      r0,r0,r1
0001a0  b200              SXTH     r0,r0
0001a2  f8ad001e          STRH     r0,[sp,#0x1e]
;;;156        Rect.y1 -= EffectSize + _DefaultBorderV;
0001a6  f8bd0022          LDRH     r0,[sp,#0x22]
0001aa  49ed              LDR      r1,|L1.1376|
0001ac  8809              LDRH     r1,[r1,#0]  ; _DefaultBorderV
0001ae  4431              ADD      r1,r1,r6
0001b0  1a40              SUBS     r0,r0,r1
0001b2  b200              SXTH     r0,r0
0001b4  f8ad0022          STRH     r0,[sp,#0x22]
;;;157        LCD_SetColor(pObj->TextColor);
0001b8  6ae8              LDR      r0,[r5,#0x2c]
0001ba  f7fffffe          BL       LCD_SetColor
;;;158        if ((pObj->DirIndicatorColumn == i) && ((pColumn->Align & GUI_TA_HORIZONTAL) == GUI_TA_RIGHT)) {
0001be  6c68              LDR      r0,[r5,#0x44]
0001c0  42b8              CMP      r0,r7
0001c2  d106              BNE      |L1.466|
0001c4  7920              LDRB     r0,[r4,#4]
0001c6  f0000003          AND      r0,r0,#3
0001ca  2801              CMP      r0,#1
0001cc  d101              BNE      |L1.466|
;;;159          Subtract = (ArrowSize << 1) + 1;
0001ce  eb000b48          ADD      r11,r0,r8,LSL #1
                  |L1.466|
;;;160        }
;;;161        Rect.x1 -= Subtract;
0001d2  f8bd0020          LDRH     r0,[sp,#0x20]
0001d6  eba0000b          SUB      r0,r0,r11
0001da  b200              SXTH     r0,r0
0001dc  f8ad0020          STRH     r0,[sp,#0x20]
;;;162        GUI_DispStringInRect(pColumn->acText, &Rect, pColumn->Align);
0001e0  f9b42004          LDRSH    r2,[r4,#4]
0001e4  a907              ADD      r1,sp,#0x1c
0001e6  f1040008          ADD      r0,r4,#8
0001ea  f7fffffe          BL       GUI_DispStringInRect
;;;163        Rect.x1 += Subtract;
0001ee  f8bd0020          LDRH     r0,[sp,#0x20]
0001f2  4458              ADD      r0,r0,r11
0001f4  b200              SXTH     r0,r0
0001f6  f8ad0020          STRH     r0,[sp,#0x20]
;;;164        if (pObj->DirIndicatorColumn == i) {
0001fa  6c68              LDR      r0,[r5,#0x44]
0001fc  42b8              CMP      r0,r7
0001fe  d123              BNE      |L1.584|
;;;165          LCD_SetColor(GUI_BLACK);
000200  2000              MOVS     r0,#0
000202  f7fffffe          BL       LCD_SetColor
;;;166          WM_SetUserClipRect(&RectItem);
000206  a805              ADD      r0,sp,#0x14
000208  f7fffffe          BL       WM_SetUserClipRect
;;;167          if (pObj->DirIndicatorReverse == 0) {
00020c  6ca8              LDR      r0,[r5,#0x48]
00020e  b958              CBNZ     r0,|L1.552|
;;;168            _DrawTriangle(ArrowPos, ((Rect.y1 - Rect.y0) >> 1), ArrowSize, 1);
000210  f9bd0022          LDRSH    r0,[sp,#0x22]
000214  f9bd201e          LDRSH    r2,[sp,#0x1e]
000218  1a80              SUBS     r0,r0,r2
00021a  1041              ASRS     r1,r0,#1
00021c  2301              MOVS     r3,#1
00021e  4642              MOV      r2,r8
000220  4650              MOV      r0,r10
000222  f7fffffe          BL       _DrawTriangle
000226  e00c              B        |L1.578|
                  |L1.552|
;;;169          } else {
;;;170            _DrawTriangle(ArrowPos, ((Rect.y1 - Rect.y0) >> 1) + ArrowSize, ArrowSize, -1);
000228  f9bd0022          LDRSH    r0,[sp,#0x22]
00022c  f9bd201e          LDRSH    r2,[sp,#0x1e]
000230  1a80              SUBS     r0,r0,r2
000232  eb080160          ADD      r1,r8,r0,ASR #1
000236  f04f33ff          MOV      r3,#0xffffffff
00023a  4642              MOV      r2,r8
00023c  4650              MOV      r0,r10
00023e  f7fffffe          BL       _DrawTriangle
                  |L1.578|
;;;171          }
;;;172          WM_SetUserClipRect(NULL);
000242  2000              MOVS     r0,#0
000244  f7fffffe          BL       WM_SetUserClipRect
                  |L1.584|
000248  1c7f              ADDS     r7,r7,#1              ;120
                  |L1.586|
00024a  9804              LDR      r0,[sp,#0x10]         ;120
00024c  4287              CMP      r7,r0                 ;120
00024e  f6ffaf01          BLT      |L1.84|
;;;173        }
;;;174      }
;;;175      GUI_GetClientRect(&Rect);
000252  a807              ADD      r0,sp,#0x1c
000254  f7fffffe          BL       GUI_GetClientRect
;;;176      Rect.x0 = xPos;
000258  fa0ff089          SXTH     r0,r9
00025c  f8ad001c          STRH     r0,[sp,#0x1c]
;;;177      Rect.x1 = 0xfff;
000260  f64070ff          MOV      r0,#0xfff
000264  f8ad0020          STRH     r0,[sp,#0x20]
;;;178      WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
000268  a907              ADD      r1,sp,#0x1c
00026a  4628              MOV      r0,r5
00026c  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;179    }
000270  b009              ADD      sp,sp,#0x24
000272  e8bd8ff0          POP      {r4-r11,pc}
;;;180    
                          ENDP

                  _RestoreOldCursor PROC
;;;184    */
;;;185    static void _RestoreOldCursor(void) {
000276  48bb              LDR      r0,|L1.1380|
;;;186      if (_pOldCursor) {
000278  6800              LDR      r0,[r0,#0]  ; _pOldCursor
00027a  b110              CBZ      r0,|L1.642|
;;;187        #if GUI_SUPPORT_CURSOR
;;;188          GUI_CURSOR_Select(_pOldCursor);
;;;189        #endif
;;;190        _pOldCursor = 0;
00027c  2000              MOVS     r0,#0
00027e  49b9              LDR      r1,|L1.1380|
000280  6008              STR      r0,[r1,#0]  ; _pOldCursor
                  |L1.642|
;;;191      }
;;;192    }
000282  4770              BX       lr
;;;193    
                          ENDP

                  _FreeAttached PROC
;;;199    */
;;;200    static void _FreeAttached(HEADER_Obj * pObj) {
000284  e92d41f0          PUSH     {r4-r8,lr}
000288  4604              MOV      r4,r0
;;;201      int i, NumItems;
;;;202      NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
00028a  f1040030          ADD      r0,r4,#0x30
00028e  f7fffffe          BL       GUI_ARRAY_GetNumItems
000292  4607              MOV      r7,r0
;;;203      for (i = 0; i < NumItems; i++) {
000294  2500              MOVS     r5,#0
000296  e00c              B        |L1.690|
                  |L1.664|
;;;204        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
000298  4629              MOV      r1,r5
00029a  f1040030          ADD      r0,r4,#0x30
00029e  f7fffffe          BL       GUI_ARRAY_GetpItem
0002a2  4606              MOV      r6,r0
;;;205        if (pColumn->hDrawObj) {
0002a4  88f0              LDRH     r0,[r6,#6]
0002a6  b118              CBZ      r0,|L1.688|
;;;206          GUI_ALLOC_Free(pColumn->hDrawObj);
0002a8  f9b60006          LDRSH    r0,[r6,#6]
0002ac  f7fffffe          BL       GUI_ALLOC_Free
                  |L1.688|
0002b0  1c6d              ADDS     r5,r5,#1              ;203
                  |L1.690|
0002b2  42bd              CMP      r5,r7                 ;203
0002b4  dbf0              BLT      |L1.664|
;;;207        }
;;;208      }
;;;209      /* Delete attached objects (if any) */
;;;210      GUI_ARRAY_Delete(&pObj->Columns);
0002b6  f1040030          ADD      r0,r4,#0x30
0002ba  f7fffffe          BL       GUI_ARRAY_Delete
;;;211      _RestoreOldCursor();
0002be  f7fffffe          BL       _RestoreOldCursor
;;;212    }
0002c2  e8bd81f0          POP      {r4-r8,pc}
;;;213    
                          ENDP

                  _GetDividerIndex PROC
;;;218    #if (HEADER_SUPPORT_DRAG)
;;;219    static int _GetDividerIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
0002c6  e92d4ff8          PUSH     {r3-r11,lr}
0002ca  4681              MOV      r9,r0
0002cc  460d              MOV      r5,r1
0002ce  4616              MOV      r6,r2
0002d0  4698              MOV      r8,r3
;;;220      int Item = -1;
0002d2  f04f30ff          MOV      r0,#0xffffffff
0002d6  9000              STR      r0,[sp,#0]
;;;221      if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
0002d8  f1b80f00          CMP      r8,#0
0002dc  db34              BLT      |L1.840|
0002de  4648              MOV      r0,r9
0002e0  f7fffffe          BL       WM_GetWindowSizeY
0002e4  4540              CMP      r0,r8
0002e6  dd2f              BLE      |L1.840|
;;;222        if (hObj) {
0002e8  f1b90f00          CMP      r9,#0
0002ec  d02c              BEQ      |L1.840|
;;;223          int Index, xPos = 0, NumColumns;
0002ee  2700              MOVS     r7,#0
;;;224          NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
0002f0  f1050030          ADD      r0,r5,#0x30
0002f4  f7fffffe          BL       GUI_ARRAY_GetNumItems
0002f8  4682              MOV      r10,r0
;;;225          for (Index = 0; Index < NumColumns; Index++) {
0002fa  2400              MOVS     r4,#0
0002fc  e020              B        |L1.832|
                  |L1.766|
;;;226            HEADER_COLUMN * pColumn;
;;;227            pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
0002fe  4621              MOV      r1,r4
000300  f1050030          ADD      r0,r5,#0x30
000304  f7fffffe          BL       GUI_ARRAY_GetpItem
000308  4683              MOV      r11,r0
;;;228            xPos += pColumn->Width;
00030a  f8db0000          LDR      r0,[r11,#0]
00030e  4407              ADD      r7,r7,r0
;;;229            if ((xPos >= (x - 4)) && (xPos <= (x + 4))) {
000310  1f30              SUBS     r0,r6,#4
000312  42b8              CMP      r0,r7
000314  dc13              BGT      |L1.830|
000316  1d30              ADDS     r0,r6,#4
000318  4287              CMP      r7,r0
00031a  dc10              BGT      |L1.830|
;;;230              Item = Index;
00031c  9400              STR      r4,[sp,#0]
;;;231              if ((Index < (NumColumns - 1)) && (x < xPos)) {
00031e  f1aa0001          SUB      r0,r10,#1
000322  42a0              CMP      r0,r4
000324  dd0b              BLE      |L1.830|
000326  42be              CMP      r6,r7
000328  da09              BGE      |L1.830|
;;;232                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index + 1);
00032a  1c61              ADDS     r1,r4,#1
00032c  f1050030          ADD      r0,r5,#0x30
000330  f7fffffe          BL       GUI_ARRAY_GetpItem
000334  4683              MOV      r11,r0
;;;233                if (pColumn->Width == 0) {
000336  f8db0000          LDR      r0,[r11,#0]
00033a  b900              CBNZ     r0,|L1.830|
;;;234                  break;
00033c  e002              B        |L1.836|
                  |L1.830|
00033e  1c64              ADDS     r4,r4,#1              ;225
                  |L1.832|
000340  4554              CMP      r4,r10                ;225
000342  dbdc              BLT      |L1.766|
                  |L1.836|
000344  bf00              NOP      
;;;235                }
;;;236              }
;;;237            }
;;;238          }
;;;239        }
000346  bf00              NOP      
                  |L1.840|
;;;240      }
;;;241      return Item;
000348  9800              LDR      r0,[sp,#0]
;;;242    }
00034a  e8bd8ff8          POP      {r3-r11,pc}
;;;243    #endif
                          ENDP

                  HEADER_SetItemWidth PROC
;;;792    */
;;;793    void HEADER_SetItemWidth(HEADER_Handle hObj, unsigned int Index, int Width) {
00034e  e92d43fe          PUSH     {r1-r9,lr}
000352  4604              MOV      r4,r0
000354  460e              MOV      r6,r1
000356  4615              MOV      r5,r2
;;;794      if (hObj && (Width >= 0)) {
000358  b384              CBZ      r4,|L1.956|
00035a  2d00              CMP      r5,#0
00035c  db2e              BLT      |L1.956|
;;;795        HEADER_Obj * pObj;
;;;796        WM_LOCK();
;;;797        pObj = HEADER_H2P(hObj);
00035e  4620              MOV      r0,r4
000360  f7fffffe          BL       GUI_ALLOC_h2p
000364  4607              MOV      r7,r0
;;;798        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000366  f1070030          ADD      r0,r7,#0x30
00036a  f7fffffe          BL       GUI_ARRAY_GetNumItems
00036e  42b0              CMP      r0,r6
000370  d323              BCC      |L1.954|
;;;799          HEADER_COLUMN * pColumn;
;;;800          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000372  4631              MOV      r1,r6
000374  f1070030          ADD      r0,r7,#0x30
000378  f7fffffe          BL       GUI_ARRAY_GetpItem
00037c  4680              MOV      r8,r0
;;;801          if (pColumn) {
00037e  f1b80f00          CMP      r8,#0
000382  d019              BEQ      |L1.952|
;;;802            WM_MESSAGE Msg;
;;;803            pColumn->Width = Width;
000384  f8c85000          STR      r5,[r8,#0]
;;;804            Msg.hWin  = WM_GetParent(hObj);
000388  4620              MOV      r0,r4
00038a  f7fffffe          BL       WM_GetParent
00038e  f8ad0004          STRH     r0,[sp,#4]
;;;805            Msg.MsgId = WM_NOTIFY_CLIENTCHANGE;
000392  2025              MOVS     r0,#0x25
000394  9000              STR      r0,[sp,#0]
;;;806            Msg.hWinSrc = hObj;
000396  f8ad4006          STRH     r4,[sp,#6]
;;;807            WM_InvalidateWindow(hObj);
00039a  4620              MOV      r0,r4
00039c  f7fffffe          BL       WM_InvalidateWindow
;;;808            WM__SendMessage(Msg.hWin, &Msg);
0003a0  f9bd0004          LDRSH    r0,[sp,#4]
0003a4  4669              MOV      r1,sp
0003a6  f7fffffe          BL       WM__SendMessage
;;;809            //WM__SendMsgNoData(WM_GetParent(hObj), WM_NOTIFY_CLIENTCHANGE);
;;;810            WM_InvalidateWindow(WM_GetParent(hObj));
0003aa  4620              MOV      r0,r4
0003ac  f7fffffe          BL       WM_GetParent
0003b0  4681              MOV      r9,r0
0003b2  f7fffffe          BL       WM_InvalidateWindow
;;;811          }
0003b6  bf00              NOP      
                  |L1.952|
;;;812        }
0003b8  bf00              NOP      
                  |L1.954|
;;;813        WM_UNLOCK();
;;;814      }
0003ba  bf00              NOP      
                  |L1.956|
;;;815    }
0003bc  e8bd83fe          POP      {r1-r9,pc}
;;;816    
                          ENDP

                  HEADER_GetItemWidth PROC
;;;835    */
;;;836    int HEADER_GetItemWidth(HEADER_Handle hObj, unsigned int Index) {
0003c0  e92d41f0          PUSH     {r4-r8,lr}
0003c4  4604              MOV      r4,r0
0003c6  460d              MOV      r5,r1
;;;837      int Width = 0;
0003c8  2700              MOVS     r7,#0
;;;838      if (hObj) {
0003ca  b19c              CBZ      r4,|L1.1012|
;;;839        HEADER_Obj * pObj;
;;;840        WM_LOCK();
;;;841        pObj = HEADER_H2P(hObj);
0003cc  4620              MOV      r0,r4
0003ce  f7fffffe          BL       GUI_ALLOC_h2p
0003d2  4606              MOV      r6,r0
;;;842        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
0003d4  f1060030          ADD      r0,r6,#0x30
0003d8  f7fffffe          BL       GUI_ARRAY_GetNumItems
0003dc  42a8              CMP      r0,r5
0003de  d308              BCC      |L1.1010|
;;;843          HEADER_COLUMN * pColumn;
;;;844          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
0003e0  4629              MOV      r1,r5
0003e2  f1060030          ADD      r0,r6,#0x30
0003e6  f7fffffe          BL       GUI_ARRAY_GetpItem
0003ea  4680              MOV      r8,r0
;;;845          Width = pColumn->Width;
0003ec  f8d87000          LDR      r7,[r8,#0]
;;;846        }
0003f0  bf00              NOP      
                  |L1.1010|
;;;847        WM_UNLOCK();
;;;848      }
0003f2  bf00              NOP      
                  |L1.1012|
;;;849      return Width;
0003f4  4638              MOV      r0,r7
;;;850    }
0003f6  e8bd81f0          POP      {r4-r8,pc}
;;;851    
                          ENDP

                  _LimitDragWitdh PROC
;;;255    */
;;;256    static int _LimitDragWitdh(HEADER_Handle hObj, HEADER_Obj * pObj) {
0003fa  e92d5ffc          PUSH     {r2-r12,lr}
0003fe  4681              MOV      r9,r0
000400  460d              MOV      r5,r1
;;;257      if (pObj->DragLimit) {
000402  f8950050          LDRB     r0,[r5,#0x50]
000406  2800              CMP      r0,#0
000408  d03e              BEQ      |L1.1160|
;;;258        int DragLimit, i, SumX;
;;;259        GUI_RECT Rect;
;;;260        WM_HWIN hVScroll, hParent;
;;;261        /* Take the x-size of the widgets client rectangle as limit */
;;;262        WM_GetClientRectEx(hObj, &Rect);
00040a  4669              MOV      r1,sp
00040c  4648              MOV      r0,r9
00040e  f7fffffe          BL       WM_GetClientRectEx
;;;263        DragLimit = Rect.x1;
000412  f9bd7004          LDRSH    r7,[sp,#4]
;;;264        /* If the parent window has a vertical scrollbar, reduce the drag limit by the xsize of the scrollbar */
;;;265        hParent = WM_GetParent(hObj);
000416  4648              MOV      r0,r9
000418  f7fffffe          BL       WM_GetParent
00041c  4682              MOV      r10,r0
;;;266        if (hParent) {
00041e  f1ba0f00          CMP      r10,#0
000422  d00d              BEQ      |L1.1088|
;;;267          hVScroll = WM_GetScrollbarV(WM_GetParent(hObj));
000424  4648              MOV      r0,r9
000426  f7fffffe          BL       WM_GetParent
00042a  4683              MOV      r11,r0
00042c  f7fffffe          BL       WM_GetScrollbarV
000430  4680              MOV      r8,r0
;;;268          if (hVScroll) {
000432  f1b80f00          CMP      r8,#0
000436  d003              BEQ      |L1.1088|
;;;269            DragLimit -= WM_GetWindowSizeX(hVScroll);
000438  4640              MOV      r0,r8
00043a  f7fffffe          BL       WM_GetWindowSizeX
00043e  1a3f              SUBS     r7,r7,r0
                  |L1.1088|
;;;270          }
;;;271        }
;;;272        /* Calculate the sum of the width of all header items */
;;;273        for (SumX = i = 0; i <= pObj->CaptureItem; i++) {
000440  2400              MOVS     r4,#0
000442  4626              MOV      r6,r4
000444  e005              B        |L1.1106|
                  |L1.1094|
;;;274          SumX += HEADER_GetItemWidth(hObj, i);
000446  4621              MOV      r1,r4
000448  4648              MOV      r0,r9
00044a  f7fffffe          BL       HEADER_GetItemWidth
00044e  4406              ADD      r6,r6,r0
000450  1c64              ADDS     r4,r4,#1              ;273
                  |L1.1106|
000452  6ba8              LDR      r0,[r5,#0x38]         ;273
000454  42a0              CMP      r0,r4                 ;273
000456  daf6              BGE      |L1.1094|
;;;275        }
;;;276        /* If the sum of the width of all header items exeeds the limit, limit the captured item */
;;;277        if (SumX > DragLimit) {
000458  42be              CMP      r6,r7
00045a  dd14              BLE      |L1.1158|
;;;278          for (SumX = i = 0; i < pObj->CaptureItem; i++) {
00045c  2000              MOVS     r0,#0
00045e  4604              MOV      r4,r0
000460  4606              MOV      r6,r0
000462  e005              B        |L1.1136|
                  |L1.1124|
;;;279            SumX += HEADER_GetItemWidth(hObj, i);
000464  4621              MOV      r1,r4
000466  4648              MOV      r0,r9
000468  f7fffffe          BL       HEADER_GetItemWidth
00046c  4406              ADD      r6,r6,r0
00046e  1c64              ADDS     r4,r4,#1              ;278
                  |L1.1136|
000470  6ba8              LDR      r0,[r5,#0x38]         ;278
000472  42a0              CMP      r0,r4                 ;278
000474  dcf6              BGT      |L1.1124|
;;;280          }
;;;281          HEADER_SetItemWidth(hObj, pObj->CaptureItem, DragLimit - SumX);
000476  1bba              SUBS     r2,r7,r6
000478  4648              MOV      r0,r9
00047a  6ba9              LDR      r1,[r5,#0x38]
00047c  f7fffffe          BL       HEADER_SetItemWidth
;;;282          return 1;
000480  2001              MOVS     r0,#1
                  |L1.1154|
;;;283        }
;;;284      }
;;;285      return 0;
;;;286    }
000482  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.1158|
000486  bf00              NOP                            ;284
                  |L1.1160|
000488  2000              MOVS     r0,#0                 ;285
00048a  e7fa              B        |L1.1154|
;;;287    
                          ENDP

                  _HandlePID PROC
;;;292    #if (HEADER_SUPPORT_DRAG)
;;;293    static void _HandlePID(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y, int Pressed) {
00048c  e92d47f0          PUSH     {r4-r10,lr}
000490  4681              MOV      r9,r0
000492  460c              MOV      r4,r1
000494  4615              MOV      r5,r2
000496  469a              MOV      r10,r3
000498  9e08              LDR      r6,[sp,#0x20]
;;;294      int Hit = _GetDividerIndex(hObj, pObj, x, y);
00049a  4653              MOV      r3,r10
00049c  462a              MOV      r2,r5
00049e  4621              MOV      r1,r4
0004a0  4648              MOV      r0,r9
0004a2  f7fffffe          BL       _GetDividerIndex
0004a6  4607              MOV      r7,r0
;;;295      /* set capture position */
;;;296      if ((Pressed == 1) && (Hit >= 0) && (pObj->CapturePosX == -1)) {
0004a8  2e01              CMP      r6,#1
0004aa  d106              BNE      |L1.1210|
0004ac  2f00              CMP      r7,#0
0004ae  db04              BLT      |L1.1210|
0004b0  6b60              LDR      r0,[r4,#0x34]
0004b2  1c40              ADDS     r0,r0,#1
0004b4  b908              CBNZ     r0,|L1.1210|
;;;297        pObj->CapturePosX = x;
0004b6  6365              STR      r5,[r4,#0x34]
;;;298        pObj->CaptureItem = Hit;
0004b8  63a7              STR      r7,[r4,#0x38]
                  |L1.1210|
;;;299      }
;;;300      if (Pressed <= 0) {
0004ba  2e00              CMP      r6,#0
0004bc  dc02              BGT      |L1.1220|
;;;301        pObj->CapturePosX = -1;
0004be  f04f30ff          MOV      r0,#0xffffffff
0004c2  6360              STR      r0,[r4,#0x34]
                  |L1.1220|
;;;302      }
;;;303      /* set mouse cursor and capture */
;;;304      if (Hit >= 0) {
0004c4  2f00              CMP      r7,#0
0004c6  db03              BLT      |L1.1232|
;;;305        WM_SetCapture(hObj, 1);
0004c8  2101              MOVS     r1,#1
0004ca  4648              MOV      r0,r9
0004cc  f7fffffe          BL       WM_SetCapture
                  |L1.1232|
;;;306        #if GUI_SUPPORT_CURSOR
;;;307          if (!_pOldCursor) {
;;;308            _pOldCursor = GUI_CURSOR_Select(_pDefaultCursor);
;;;309          }
;;;310        #endif
;;;311      }
;;;312      /* modify header */
;;;313      if ((pObj->CapturePosX >= 0) && (x != pObj->CapturePosX) && (Pressed == 1)) {
0004d0  6b60              LDR      r0,[r4,#0x34]
0004d2  2800              CMP      r0,#0
0004d4  db1b              BLT      |L1.1294|
0004d6  6b60              LDR      r0,[r4,#0x34]
0004d8  42a8              CMP      r0,r5
0004da  d018              BEQ      |L1.1294|
0004dc  2e01              CMP      r6,#1
0004de  d116              BNE      |L1.1294|
;;;314        int NewSize = HEADER_GetItemWidth(hObj, pObj->CaptureItem) + x - pObj->CapturePosX;
0004e0  4648              MOV      r0,r9
0004e2  6ba1              LDR      r1,[r4,#0x38]
0004e4  f7fffffe          BL       HEADER_GetItemWidth
0004e8  4428              ADD      r0,r0,r5
0004ea  6b61              LDR      r1,[r4,#0x34]
0004ec  eba00801          SUB      r8,r0,r1
;;;315        if (NewSize >= 0) {
0004f0  f1b80f00          CMP      r8,#0
0004f4  db0a              BLT      |L1.1292|
;;;316          HEADER_SetItemWidth(hObj, pObj->CaptureItem, NewSize);
0004f6  4642              MOV      r2,r8
0004f8  4648              MOV      r0,r9
0004fa  6ba1              LDR      r1,[r4,#0x38]
0004fc  f7fffffe          BL       HEADER_SetItemWidth
;;;317          if (!_LimitDragWitdh(hObj, pObj)) {
000500  4621              MOV      r1,r4
000502  4648              MOV      r0,r9
000504  f7fffffe          BL       _LimitDragWitdh
000508  b900              CBNZ     r0,|L1.1292|
;;;318            pObj->CapturePosX = x;
00050a  6365              STR      r5,[r4,#0x34]
                  |L1.1292|
;;;319          }
;;;320        }
;;;321      }
00050c  bf00              NOP      
                  |L1.1294|
;;;322      /* release capture & restore cursor */
;;;323      if (Pressed <= 0) {
00050e  2e00              CMP      r6,#0
000510  dc06              BGT      |L1.1312|
;;;324        #if (GUI_SUPPORT_MOUSE)
;;;325        if (Hit == -1)
;;;326        #endif
;;;327        {
;;;328          _RestoreOldCursor();
000512  f7fffffe          BL       _RestoreOldCursor
;;;329          pObj->CapturePosX = -1;
000516  f04f30ff          MOV      r0,#0xffffffff
00051a  6360              STR      r0,[r4,#0x34]
;;;330          WM_ReleaseCapture();
00051c  f7fffffe          BL       WM_ReleaseCapture
                  |L1.1312|
;;;331        }
;;;332      }
;;;333    }
000520  e8bd87f0          POP      {r4-r10,pc}
;;;334    #endif
                          ENDP

                  _GetItemIndex PROC
;;;352    */
;;;353    static int _GetItemIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
000524  e92d4ff8          PUSH     {r3-r11,lr}
000528  4681              MOV      r9,r0
00052a  460d              MOV      r5,r1
00052c  4616              MOV      r6,r2
00052e  461f              MOV      r7,r3
;;;354      int Item = -1;
000530  f04f30ff          MOV      r0,#0xffffffff
000534  9000              STR      r0,[sp,#0]
;;;355      if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
000536  2f00              CMP      r7,#0
000538  db30              BLT      |L1.1436|
00053a  4648              MOV      r0,r9
00053c  f7fffffe          BL       WM_GetWindowSizeY
000540  42b8              CMP      r0,r7
000542  dd2b              BLE      |L1.1436|
;;;356        if (hObj) {
000544  f1b90f00          CMP      r9,#0
000548  d028              BEQ      |L1.1436|
;;;357          int Index, xPos = 0, NumColumns;
00054a  f04f0800          MOV      r8,#0
;;;358          NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
00054e  f1050030          ADD      r0,r5,#0x30
000552  f7fffffe          BL       GUI_ARRAY_GetNumItems
000556  4683              MOV      r11,r0
;;;359          for (Index = 0; Index < NumColumns; Index++) {
000558  2400              MOVS     r4,#0
00055a  e01b              B        |L1.1428|
                  |L1.1372|
                          DCD      _DefaultBorderH
                  |L1.1376|
                          DCD      _DefaultBorderV
                  |L1.1380|
                          DCD      _pOldCursor
                  |L1.1384|
;;;360            HEADER_COLUMN * pColumn;
;;;361            pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000568  4621              MOV      r1,r4
00056a  f1050030          ADD      r0,r5,#0x30
00056e  f7fffffe          BL       GUI_ARRAY_GetpItem
000572  4682              MOV      r10,r0
;;;362            if ((x > (xPos + 4)) && (x < (xPos + pColumn->Width - 4))) {
000574  f1080004          ADD      r0,r8,#4
000578  4286              CMP      r6,r0
00057a  dd07              BLE      |L1.1420|
00057c  f8da0000          LDR      r0,[r10,#0]
000580  4440              ADD      r0,r0,r8
000582  1f00              SUBS     r0,r0,#4
000584  42b0              CMP      r0,r6
000586  dd01              BLE      |L1.1420|
;;;363              Item = Index;
000588  9400              STR      r4,[sp,#0]
;;;364              break;
00058a  e005              B        |L1.1432|
                  |L1.1420|
;;;365            }
;;;366            xPos += pColumn->Width;
00058c  f8da0000          LDR      r0,[r10,#0]
000590  4480              ADD      r8,r8,r0
000592  1c64              ADDS     r4,r4,#1              ;359
                  |L1.1428|
000594  455c              CMP      r4,r11                ;359
000596  dbe7              BLT      |L1.1384|
                  |L1.1432|
000598  bf00              NOP                            ;364
;;;367          }
;;;368        }
00059a  bf00              NOP      
                  |L1.1436|
;;;369      }
;;;370      return Item;
00059c  9800              LDR      r0,[sp,#0]
;;;371    }
00059e  e8bd8ff8          POP      {r3-r11,pc}
;;;372    
                          ENDP

                  _OnTouch PROC
;;;377    #if (HEADER_SUPPORT_DRAG)
;;;378    static void _OnTouch(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
0005a2  e92d43f8          PUSH     {r3-r9,lr}
0005a6  4680              MOV      r8,r0
0005a8  460f              MOV      r7,r1
0005aa  4616              MOV      r6,r2
;;;379      int Notification;
;;;380      const GUI_PID_STATE * pState = (const GUI_PID_STATE *)pMsg->Data.p;
0005ac  68b4              LDR      r4,[r6,#8]
;;;381      if (pState) {
0005ae  b14c              CBZ      r4,|L1.1476|
;;;382        _HandlePID(hObj, pObj, pState->x + pObj->ScrollPos, pState->y, pState->Pressed);
0005b0  7a20              LDRB     r0,[r4,#8]
0005b2  9000              STR      r0,[sp,#0]
0005b4  6820              LDR      r0,[r4,#0]
0005b6  6bf9              LDR      r1,[r7,#0x3c]
0005b8  1842              ADDS     r2,r0,r1
0005ba  4639              MOV      r1,r7
0005bc  4640              MOV      r0,r8
0005be  6863              LDR      r3,[r4,#4]
0005c0  f7fffffe          BL       _HandlePID
                  |L1.1476|
;;;383      }
;;;384      if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
0005c4  68b0              LDR      r0,[r6,#8]
0005c6  b128              CBZ      r0,|L1.1492|
;;;385        if (pState->Pressed) {
0005c8  7a20              LDRB     r0,[r4,#8]
0005ca  b108              CBZ      r0,|L1.1488|
;;;386          Notification = WM_NOTIFICATION_CLICKED;
0005cc  2501              MOVS     r5,#1
0005ce  e002              B        |L1.1494|
                  |L1.1488|
;;;387        } else {
;;;388          Notification = WM_NOTIFICATION_RELEASED;
0005d0  2502              MOVS     r5,#2
0005d2  e000              B        |L1.1494|
                  |L1.1492|
;;;389        }
;;;390      } else {
;;;391        Notification = WM_NOTIFICATION_MOVED_OUT;
0005d4  2503              MOVS     r5,#3
                  |L1.1494|
;;;392      }
;;;393      WM_NotifyParent(hObj, Notification);
0005d6  4629              MOV      r1,r5
0005d8  4640              MOV      r0,r8
0005da  f7fffffe          BL       WM_NotifyParent
;;;394    }
0005de  e8bd83f8          POP      {r3-r9,pc}
;;;395    #endif
                          ENDP

                  _OnPidStateChange PROC
;;;400    */
;;;401    static void _OnPidStateChange(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
0005e2  e92d41f0          PUSH     {r4-r8,lr}
0005e6  4607              MOV      r7,r0
0005e8  460d              MOV      r5,r1
0005ea  4616              MOV      r6,r2
;;;402      const WM_PID_STATE_CHANGED_INFO * pState = (const WM_PID_STATE_CHANGED_INFO *)pMsg->Data.p;
0005ec  68b4              LDR      r4,[r6,#8]
;;;403      if ((pState->StatePrev == 1) && (pState->State == 0)) {
0005ee  7a60              LDRB     r0,[r4,#9]
0005f0  2801              CMP      r0,#1
0005f2  d10a              BNE      |L1.1546|
0005f4  7a20              LDRB     r0,[r4,#8]
0005f6  b940              CBNZ     r0,|L1.1546|
;;;404        pObj->Sel = _GetItemIndex(hObj, pObj, pState->x + pObj->ScrollPos, pState->y);
0005f8  6820              LDR      r0,[r4,#0]
0005fa  6be9              LDR      r1,[r5,#0x3c]
0005fc  1842              ADDS     r2,r0,r1
0005fe  4629              MOV      r1,r5
000600  4638              MOV      r0,r7
000602  6863              LDR      r3,[r4,#4]
000604  f7fffffe          BL       _GetItemIndex
000608  6428              STR      r0,[r5,#0x40]
                  |L1.1546|
;;;405      }
;;;406    }
00060a  e8bd81f0          POP      {r4-r8,pc}
;;;407    
                          ENDP

                  HEADER_Callback PROC
;;;440    */
;;;441    void HEADER_Callback (WM_MESSAGE *pMsg) {
00060e  b570              PUSH     {r4-r6,lr}
000610  4604              MOV      r4,r0
;;;442      HEADER_Handle hObj;
;;;443      HEADER_Obj * pObj;
;;;444      hObj = pMsg->hWin;
000612  f9b45004          LDRSH    r5,[r4,#4]
;;;445      /* Let widget handle the standard messages */
;;;446      if (WIDGET_HandleActive(hObj, pMsg) == 0) {
000616  4621              MOV      r1,r4
000618  4628              MOV      r0,r5
00061a  f7fffffe          BL       WIDGET_HandleActive
00061e  b900              CBNZ     r0,|L1.1570|
                  |L1.1568|
;;;447        return;
;;;448      }
;;;449      WM_LOCK();
;;;450      pObj = (HEADER_Obj *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
;;;451      switch (pMsg->MsgId) {
;;;452      case WM_PAINT:
;;;453        _Paint(pObj);
;;;454        break;
;;;455      case WM_PID_STATE_CHANGED:
;;;456        _OnPidStateChange(hObj, pObj, pMsg);
;;;457        break;
;;;458    #if (HEADER_SUPPORT_DRAG)
;;;459      case WM_TOUCH:
;;;460        _OnTouch(hObj, pObj, pMsg);
;;;461        break;
;;;462    #endif
;;;463    #if (HEADER_SUPPORT_DRAG & GUI_SUPPORT_MOUSE)
;;;464      case WM_MOUSEOVER:
;;;465        _OnMouseOver(hObj, pObj, pMsg);
;;;466        break;
;;;467    #endif
;;;468      case WM_DELETE:
;;;469        _FreeAttached(pObj); /* No return here ... WM_DefaultProc needs to be called */
;;;470      default:
;;;471        WM_DefaultProc(pMsg);
;;;472      }
;;;473      WM_UNLOCK();
;;;474    }
000620  bd70              POP      {r4-r6,pc}
                  |L1.1570|
000622  4628              MOV      r0,r5                 ;450
000624  f7fffffe          BL       GUI_ALLOC_h2p
000628  4606              MOV      r6,r0                 ;450
00062a  6820              LDR      r0,[r4,#0]            ;451
00062c  280b              CMP      r0,#0xb               ;451
00062e  d016              BEQ      |L1.1630|
000630  280c              CMP      r0,#0xc               ;451
000632  d00e              BEQ      |L1.1618|
000634  280f              CMP      r0,#0xf               ;451
000636  d002              BEQ      |L1.1598|
000638  2811              CMP      r0,#0x11              ;451
00063a  d114              BNE      |L1.1638|
00063c  e003              B        |L1.1606|
                  |L1.1598|
00063e  4630              MOV      r0,r6                 ;453
000640  f7fffffe          BL       _Paint
000644  e013              B        |L1.1646|
                  |L1.1606|
000646  4622              MOV      r2,r4                 ;456
000648  4631              MOV      r1,r6                 ;456
00064a  4628              MOV      r0,r5                 ;456
00064c  f7fffffe          BL       _OnPidStateChange
000650  e00d              B        |L1.1646|
                  |L1.1618|
000652  4622              MOV      r2,r4                 ;460
000654  4631              MOV      r1,r6                 ;460
000656  4628              MOV      r0,r5                 ;460
000658  f7fffffe          BL       _OnTouch
00065c  e007              B        |L1.1646|
                  |L1.1630|
00065e  4630              MOV      r0,r6                 ;469
000660  f7fffffe          BL       _FreeAttached
000664  bf00              NOP                            ;470
                  |L1.1638|
000666  4620              MOV      r0,r4                 ;471
000668  f7fffffe          BL       WM_DefaultProc
00066c  bf00              NOP                            ;451
                  |L1.1646|
00066e  bf00              NOP                            ;454
000670  bf00              NOP      
000672  e7d5              B        |L1.1568|
;;;475    
                          ENDP

                  HEADER_CreateEx PROC
;;;493    */
;;;494    HEADER_Handle HEADER_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
000674  e92d5fff          PUSH     {r0-r12,lr}
;;;495                                  int WinFlags, int ExFlags, int Id)
;;;496    {
000678  4607              MOV      r7,r0
00067a  4688              MOV      r8,r1
00067c  4691              MOV      r9,r2
00067e  461d              MOV      r5,r3
000680  e9ddab0e          LDRD     r10,r11,[sp,#0x38]
;;;497      HEADER_Handle hObj;
;;;498      GUI_USE_PARA(ExFlags);
000684  9810              LDR      r0,[sp,#0x40]
000686  9010              STR      r0,[sp,#0x40]
;;;499      /* Create the window */
;;;500      WM_LOCK();
;;;501      if ((xsize == 0) && (x0 == 0) && (y0 == 0)) {
000688  f1b90f00          CMP      r9,#0
00068c  d113              BNE      |L1.1718|
00068e  b997              CBNZ     r7,|L1.1718|
000690  f1b80f00          CMP      r8,#0
000694  d10f              BNE      |L1.1718|
;;;502        GUI_RECT Rect;
;;;503        WM_GetInsideRectEx(hParent, &Rect);
000696  a902              ADD      r1,sp,#8
000698  4650              MOV      r0,r10
00069a  f7fffffe          BL       WM_GetInsideRectEx
;;;504        xsize = Rect.x1 - Rect.x0 + 1;
00069e  f9bd000c          LDRSH    r0,[sp,#0xc]
0006a2  f9bd1008          LDRSH    r1,[sp,#8]
0006a6  1a40              SUBS     r0,r0,r1
0006a8  f1000901          ADD      r9,r0,#1
;;;505        x0    = Rect.x0;
0006ac  f9bd7008          LDRSH    r7,[sp,#8]
;;;506        y0    = Rect.y0;
0006b0  f9bd800a          LDRSH    r8,[sp,#0xa]
;;;507      }
0006b4  bf00              NOP      
                  |L1.1718|
;;;508      if (ysize == 0) {
0006b6  b985              CBNZ     r5,|L1.1754|
;;;509        const WIDGET_EFFECT* pEffect = WIDGET_GetDefaultEffect();
0006b8  f7fffffe          BL       WIDGET_GetDefaultEffect
0006bc  4604              MOV      r4,r0
;;;510        ysize  = GUI_GetYDistOfFont(_pDefaultFont);
0006be  48f9              LDR      r0,|L1.2724|
0006c0  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
0006c2  f7fffffe          BL       GUI_GetYDistOfFont
0006c6  4605              MOV      r5,r0
;;;511        ysize += 2 * _DefaultBorderV;
0006c8  48f7              LDR      r0,|L1.2728|
0006ca  6800              LDR      r0,[r0,#0]  ; _DefaultBorderV
0006cc  2102              MOVS     r1,#2
0006ce  fb015500          MLA      r5,r1,r0,r5
;;;512        ysize += 2 * (unsigned)pEffect->EffectSize;
0006d2  6960              LDR      r0,[r4,#0x14]
0006d4  fb015500          MLA      r5,r1,r0,r5
;;;513      }
0006d8  bf00              NOP      
                  |L1.1754|
;;;514      WinFlags |= WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_RIGHT;
0006da  f44b7b20          ORR      r11,r11,#0x280
;;;515      hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &HEADER_Callback,
0006de  2134              MOVS     r1,#0x34
0006e0  f2af02d5          ADR      r2,HEADER_Callback + 1
0006e4  fa1ff08b          UXTH     r0,r11
0006e8  462b              MOV      r3,r5
0006ea  e9cda000          STRD     r10,r0,[sp,#0]
0006ee  e9cd2102          STRD     r2,r1,[sp,#8]
0006f2  464a              MOV      r2,r9
0006f4  4641              MOV      r1,r8
0006f6  4638              MOV      r0,r7
0006f8  f7fffffe          BL       WM_CreateWindowAsChild
0006fc  4606              MOV      r6,r0
;;;516                                    sizeof(HEADER_Obj) - sizeof(WM_Obj));
;;;517      if (hObj) {
0006fe  b1d6              CBZ      r6,|L1.1846|
;;;518        HEADER_Obj * pObj;
;;;519        pObj = (HEADER_Obj *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
000700  4630              MOV      r0,r6
000702  f7fffffe          BL       GUI_ALLOC_h2p
000706  4604              MOV      r4,r0
;;;520        /* Init sub-classes */
;;;521        GUI_ARRAY_CREATE(&pObj->Columns);
;;;522        /* init widget specific variables */
;;;523        WIDGET__Init(&pObj->Widget, Id, 0);
000708  2200              MOVS     r2,#0
00070a  4620              MOV      r0,r4
00070c  9911              LDR      r1,[sp,#0x44]
00070e  f7fffffe          BL       WIDGET__Init
;;;524        /* init member variables */
;;;525        HEADER_INIT_ID(pObj);
;;;526        pObj->BkColor     = _DefaultBkColor;
000712  48e6              LDR      r0,|L1.2732|
000714  6800              LDR      r0,[r0,#0]  ; _DefaultBkColor
000716  62a0              STR      r0,[r4,#0x28]
;;;527        pObj->TextColor   = _DefaultTextColor;
000718  48e5              LDR      r0,|L1.2736|
00071a  6800              LDR      r0,[r0,#0]  ; _DefaultTextColor
00071c  62e0              STR      r0,[r4,#0x2c]
;;;528        pObj->pFont       = _pDefaultFont;
00071e  48e1              LDR      r0,|L1.2724|
000720  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
000722  64e0              STR      r0,[r4,#0x4c]
;;;529        pObj->CapturePosX = -1;
000724  f04f30ff          MOV      r0,#0xffffffff
000728  6360              STR      r0,[r4,#0x34]
;;;530        pObj->CaptureItem = -1;
00072a  63a0              STR      r0,[r4,#0x38]
;;;531        pObj->ScrollPos   = 0;
00072c  2000              MOVS     r0,#0
00072e  63e0              STR      r0,[r4,#0x3c]
;;;532        pObj->DirIndicatorColumn = -1;
000730  1e40              SUBS     r0,r0,#1
000732  6460              STR      r0,[r4,#0x44]
;;;533      } else {
000734  bf00              NOP      
                  |L1.1846|
;;;534        GUI_DEBUG_ERROROUT_IF(hObj==0, "HEADER_Create failed")
;;;535      }
;;;536      WM_UNLOCK();
;;;537      return hObj;
000736  4630              MOV      r0,r6
;;;538    }
000738  b004              ADD      sp,sp,#0x10
00073a  e8bd9ff0          POP      {r4-r12,pc}
;;;539    
                          ENDP

                  HEADER_Create PROC
;;;485    */
;;;486    HEADER_Handle HEADER_Create(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int Id, int Flags, int ExFlags) {
00073e  e92d5fff          PUSH     {r0-r12,lr}
000742  4604              MOV      r4,r0
000744  460d              MOV      r5,r1
000746  4616              MOV      r6,r2
000748  461f              MOV      r7,r3
00074a  e9ddab10          LDRD     r10,r11,[sp,#0x40]
00074e  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;487      return HEADER_CreateEx(x0, y0, xsize, ysize, hParent, Flags, ExFlags, Id);
000752  463b              MOV      r3,r7
000754  4632              MOV      r2,r6
000756  4629              MOV      r1,r5
000758  4620              MOV      r0,r4
00075a  e88d0d00          STM      sp,{r8,r10,r11}
00075e  f8cd900c          STR      r9,[sp,#0xc]
000762  f7fffffe          BL       HEADER_CreateEx
;;;488    }
000766  b004              ADD      sp,sp,#0x10
000768  e8bd9ff0          POP      {r4-r12,pc}
;;;489    
                          ENDP

                  HEADER_SetDefaultCursor PROC
;;;549    */
;;;550    const GUI_CURSOR GUI_UNI_PTR * HEADER_SetDefaultCursor(const GUI_CURSOR * pCursor) {
00076c  4601              MOV      r1,r0
;;;551      const GUI_CURSOR GUI_UNI_PTR * pOldCursor = _pDefaultCursor;
00076e  4ad1              LDR      r2,|L1.2740|
000770  6810              LDR      r0,[r2,#0]  ; _pDefaultCursor
;;;552      _pDefaultCursor = pCursor;
000772  6011              STR      r1,[r2,#0]  ; _pDefaultCursor
;;;553      return pOldCursor;
;;;554    }
000774  4770              BX       lr
;;;555    
                          ENDP

                  HEADER_SetDefaultBkColor PROC
;;;559    */
;;;560    GUI_COLOR HEADER_SetDefaultBkColor(GUI_COLOR Color) {
000776  4601              MOV      r1,r0
;;;561      GUI_COLOR OldColor = _DefaultBkColor;
000778  4acc              LDR      r2,|L1.2732|
00077a  6810              LDR      r0,[r2,#0]  ; _DefaultBkColor
;;;562      _DefaultBkColor = Color;
00077c  6011              STR      r1,[r2,#0]  ; _DefaultBkColor
;;;563      return OldColor;
;;;564    }
00077e  4770              BX       lr
;;;565    
                          ENDP

                  HEADER_SetDefaultTextColor PROC
;;;569    */
;;;570    GUI_COLOR HEADER_SetDefaultTextColor(GUI_COLOR Color) {
000780  4601              MOV      r1,r0
;;;571      GUI_COLOR OldColor = _DefaultTextColor;
000782  4acb              LDR      r2,|L1.2736|
000784  6810              LDR      r0,[r2,#0]  ; _DefaultTextColor
;;;572      _DefaultTextColor = Color;
000786  6011              STR      r1,[r2,#0]  ; _DefaultTextColor
;;;573      return OldColor;
;;;574    }
000788  4770              BX       lr
;;;575    
                          ENDP

                  HEADER_SetDefaultBorderH PROC
;;;579    */
;;;580    int HEADER_SetDefaultBorderH(int Spacing) {
00078a  4601              MOV      r1,r0
;;;581      int OldSpacing = _DefaultBorderH;
00078c  4aca              LDR      r2,|L1.2744|
00078e  6810              LDR      r0,[r2,#0]  ; _DefaultBorderH
;;;582      _DefaultBorderH = Spacing;
000790  6011              STR      r1,[r2,#0]  ; _DefaultBorderH
;;;583      return OldSpacing;
;;;584    }
000792  4770              BX       lr
;;;585    
                          ENDP

                  HEADER_SetDefaultBorderV PROC
;;;589    */
;;;590    int HEADER_SetDefaultBorderV(int Spacing) {
000794  4601              MOV      r1,r0
;;;591      int OldSpacing = _DefaultBorderV;
000796  4ac4              LDR      r2,|L1.2728|
000798  6810              LDR      r0,[r2,#0]  ; _DefaultBorderV
;;;592      _DefaultBorderV = Spacing;
00079a  6011              STR      r1,[r2,#0]  ; _DefaultBorderV
;;;593      return OldSpacing;
;;;594    }
00079c  4770              BX       lr
;;;595    
                          ENDP

                  HEADER_SetDefaultFont PROC
;;;599    */
;;;600    const GUI_FONT GUI_UNI_PTR * HEADER_SetDefaultFont(const GUI_FONT GUI_UNI_PTR * pFont) {
00079e  4601              MOV      r1,r0
;;;601      const GUI_FONT GUI_UNI_PTR * pOldFont = _pDefaultFont;
0007a0  4ac0              LDR      r2,|L1.2724|
0007a2  6810              LDR      r0,[r2,#0]  ; _pDefaultFont
;;;602      _pDefaultFont = pFont;
0007a4  6011              STR      r1,[r2,#0]  ; _pDefaultFont
;;;603      return pOldFont;
;;;604    }
0007a6  4770              BX       lr
;;;605    
                          ENDP

                  HEADER_GetDefaultCursor PROC
;;;609    */
;;;610    const GUI_CURSOR GUI_UNI_PTR *  HEADER_GetDefaultCursor(void)    { return _pDefaultCursor; }
0007a8  48c2              LDR      r0,|L1.2740|
0007aa  6800              LDR      r0,[r0,#0]  ; _pDefaultCursor
0007ac  4770              BX       lr
;;;611    GUI_COLOR          HEADER_GetDefaultBkColor(void)   { return _DefaultBkColor; }
                          ENDP

                  HEADER_GetDefaultBkColor PROC
0007ae  48bf              LDR      r0,|L1.2732|
0007b0  6800              LDR      r0,[r0,#0]  ; _DefaultBkColor
0007b2  4770              BX       lr
;;;612    GUI_COLOR          HEADER_GetDefaultTextColor(void) { return _DefaultTextColor; }
                          ENDP

                  HEADER_GetDefaultTextColor PROC
0007b4  48be              LDR      r0,|L1.2736|
0007b6  6800              LDR      r0,[r0,#0]  ; _DefaultTextColor
0007b8  4770              BX       lr
;;;613    int                HEADER_GetDefaultBorderH(void)   { return _DefaultBorderH; }
                          ENDP

                  HEADER_GetDefaultBorderH PROC
0007ba  48bf              LDR      r0,|L1.2744|
0007bc  6800              LDR      r0,[r0,#0]  ; _DefaultBorderH
0007be  4770              BX       lr
;;;614    int                HEADER_GetDefaultBorderV(void)   { return _DefaultBorderV; }
                          ENDP

                  HEADER_GetDefaultBorderV PROC
0007c0  48b9              LDR      r0,|L1.2728|
0007c2  6800              LDR      r0,[r0,#0]  ; _DefaultBorderV
0007c4  4770              BX       lr
;;;615    const GUI_FONT GUI_UNI_PTR *    HEADER_GetDefaultFont(void)      { return _pDefaultFont; }
                          ENDP

                  HEADER_GetDefaultFont PROC
0007c6  48b7              LDR      r0,|L1.2724|
0007c8  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
0007ca  4770              BX       lr
;;;616    
                          ENDP

                  HEADER_SetHeight PROC
;;;642    */
;;;643    void HEADER_SetHeight(HEADER_Handle hObj, int Height) {
0007cc  b57c              PUSH     {r2-r6,lr}
0007ce  4604              MOV      r4,r0
0007d0  460d              MOV      r5,r1
;;;644      if (hObj) {
0007d2  b1a4              CBZ      r4,|L1.2046|
;;;645        GUI_RECT Rect;
;;;646        WM_GetClientRectEx(hObj, &Rect);
0007d4  4669              MOV      r1,sp
0007d6  4620              MOV      r0,r4
0007d8  f7fffffe          BL       WM_GetClientRectEx
;;;647        WM_SetSize(hObj, Rect.x1 - Rect.x0 + 1, Height);
0007dc  f9bd0004          LDRSH    r0,[sp,#4]
0007e0  f9bd2000          LDRSH    r2,[sp,#0]
0007e4  1a80              SUBS     r0,r0,r2
0007e6  1c41              ADDS     r1,r0,#1
0007e8  462a              MOV      r2,r5
0007ea  4620              MOV      r0,r4
0007ec  f7fffffe          BL       WM_SetSize
;;;648        WM_InvalidateWindow(WM_GetParent(hObj));
0007f0  4620              MOV      r0,r4
0007f2  f7fffffe          BL       WM_GetParent
0007f6  4606              MOV      r6,r0
0007f8  f7fffffe          BL       WM_InvalidateWindow
;;;649      }
0007fc  bf00              NOP      
                  |L1.2046|
;;;650    }
0007fe  bd7c              POP      {r2-r6,pc}
;;;651    
                          ENDP

                  HEADER_SetFont PROC
;;;626    */
;;;627    void HEADER_SetFont(HEADER_Handle hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
000800  e92d41f0          PUSH     {r4-r8,lr}
000804  4605              MOV      r5,r0
000806  460c              MOV      r4,r1
;;;628      if (hObj) {
000808  b1a5              CBZ      r5,|L1.2100|
;;;629        HEADER_Obj * pObj;
;;;630        WM_LOCK();
;;;631        pObj = HEADER_H2P(hObj);
00080a  4628              MOV      r0,r5
00080c  f7fffffe          BL       GUI_ALLOC_h2p
000810  4606              MOV      r6,r0
;;;632        pObj->pFont = pFont;
000812  64f4              STR      r4,[r6,#0x4c]
;;;633        HEADER_SetHeight(hObj, GUI_GetYDistOfFont(pFont) + 2 * HEADER_BORDER_V_DEFAULT + 2 * pObj->Widget.pEffect->EffectSize);
000814  4620              MOV      r0,r4
000816  f7fffffe          BL       GUI_GetYDistOfFont
00081a  6a31              LDR      r1,[r6,#0x20]
00081c  6949              LDR      r1,[r1,#0x14]
00081e  2202              MOVS     r2,#2
000820  fb020701          MLA      r7,r2,r1,r0
000824  4639              MOV      r1,r7
000826  4628              MOV      r0,r5
000828  f7fffffe          BL       HEADER_SetHeight
;;;634        WM_InvalidateWindow(hObj);
00082c  4628              MOV      r0,r5
00082e  f7fffffe          BL       WM_InvalidateWindow
;;;635        WM_UNLOCK();
;;;636      }
000832  bf00              NOP      
                  |L1.2100|
;;;637    }
000834  e8bd81f0          POP      {r4-r8,pc}
;;;638    
                          ENDP

                  HEADER_SetTextColor PROC
;;;655    */
;;;656    void HEADER_SetTextColor(HEADER_Handle hObj, GUI_COLOR Color) {
000838  b570              PUSH     {r4-r6,lr}
00083a  4604              MOV      r4,r0
00083c  460d              MOV      r5,r1
;;;657      if (hObj) {
00083e  b144              CBZ      r4,|L1.2130|
;;;658        HEADER_Obj * pObj;
;;;659        WM_LOCK();
;;;660        pObj = HEADER_H2P(hObj);
000840  4620              MOV      r0,r4
000842  f7fffffe          BL       GUI_ALLOC_h2p
000846  4606              MOV      r6,r0
;;;661        pObj->TextColor = Color;
000848  62f5              STR      r5,[r6,#0x2c]
;;;662        WM_InvalidateWindow(hObj);
00084a  4620              MOV      r0,r4
00084c  f7fffffe          BL       WM_InvalidateWindow
;;;663        WM_UNLOCK();
;;;664      }
000850  bf00              NOP      
                  |L1.2130|
;;;665    }
000852  bd70              POP      {r4-r6,pc}
;;;666    
                          ENDP

                  HEADER_SetBkColor PROC
;;;670    */
;;;671    void HEADER_SetBkColor(HEADER_Handle hObj, GUI_COLOR Color) {
000854  b570              PUSH     {r4-r6,lr}
000856  4604              MOV      r4,r0
000858  460d              MOV      r5,r1
;;;672      if (hObj) {
00085a  b144              CBZ      r4,|L1.2158|
;;;673        HEADER_Obj * pObj;
;;;674        WM_LOCK();
;;;675        pObj = HEADER_H2P(hObj);
00085c  4620              MOV      r0,r4
00085e  f7fffffe          BL       GUI_ALLOC_h2p
000862  4606              MOV      r6,r0
;;;676        pObj->BkColor = Color;
000864  62b5              STR      r5,[r6,#0x28]
;;;677        WM_InvalidateWindow(hObj);
000866  4620              MOV      r0,r4
000868  f7fffffe          BL       WM_InvalidateWindow
;;;678        WM_UNLOCK();
;;;679      }
00086c  bf00              NOP      
                  |L1.2158|
;;;680    }
00086e  bd70              POP      {r4-r6,pc}
;;;681    
                          ENDP

                  HEADER_SetTextAlign PROC
;;;685    */
;;;686    void HEADER_SetTextAlign(HEADER_Handle hObj, unsigned int Index, int Align) {
000870  e92d41f0          PUSH     {r4-r8,lr}
000874  4604              MOV      r4,r0
000876  460d              MOV      r5,r1
000878  4616              MOV      r6,r2
;;;687      if (hObj) {
00087a  b1bc              CBZ      r4,|L1.2220|
;;;688        HEADER_Obj * pObj;
;;;689        WM_LOCK();
;;;690        pObj = HEADER_H2P(hObj);
00087c  4620              MOV      r0,r4
00087e  f7fffffe          BL       GUI_ALLOC_h2p
000882  4607              MOV      r7,r0
;;;691        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000884  f1070030          ADD      r0,r7,#0x30
000888  f7fffffe          BL       GUI_ARRAY_GetNumItems
00088c  42a8              CMP      r0,r5
00088e  d30c              BCC      |L1.2218|
;;;692          HEADER_COLUMN * pColumn;
;;;693          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000890  4629              MOV      r1,r5
000892  f1070030          ADD      r0,r7,#0x30
000896  f7fffffe          BL       GUI_ARRAY_GetpItem
00089a  4680              MOV      r8,r0
;;;694          pColumn->Align = Align;
00089c  b230              SXTH     r0,r6
00089e  f8a80004          STRH     r0,[r8,#4]
;;;695          WM_InvalidateWindow(hObj);
0008a2  4620              MOV      r0,r4
0008a4  f7fffffe          BL       WM_InvalidateWindow
;;;696        }
0008a8  bf00              NOP      
                  |L1.2218|
;;;697        WM_UNLOCK();
;;;698      }
0008aa  bf00              NOP      
                  |L1.2220|
;;;699    }
0008ac  e8bd81f0          POP      {r4-r8,pc}
;;;700    
                          ENDP

                  HEADER_SetScrollPos PROC
;;;704    */
;;;705    void HEADER_SetScrollPos(HEADER_Handle hObj, int ScrollPos) {
0008b0  e92d41f0          PUSH     {r4-r8,lr}
0008b4  4605              MOV      r5,r0
0008b6  460c              MOV      r4,r1
;;;706      if (hObj && (ScrollPos >= 0)) {
0008b8  b19d              CBZ      r5,|L1.2274|
0008ba  2c00              CMP      r4,#0
0008bc  db11              BLT      |L1.2274|
;;;707        HEADER_Obj* pObj;
;;;708        WM_LOCK();
;;;709        pObj = HEADER_H2P(hObj);
0008be  4628              MOV      r0,r5
0008c0  f7fffffe          BL       GUI_ALLOC_h2p
0008c4  4606              MOV      r6,r0
;;;710        if (ScrollPos != pObj->ScrollPos) {
0008c6  6bf0              LDR      r0,[r6,#0x3c]
0008c8  42a0              CMP      r0,r4
0008ca  d009              BEQ      |L1.2272|
;;;711          pObj->ScrollPos = ScrollPos;
0008cc  63f4              STR      r4,[r6,#0x3c]
;;;712          WM_Invalidate(hObj);
0008ce  4628              MOV      r0,r5
0008d0  f7fffffe          BL       WM_InvalidateWindow
;;;713          WM_InvalidateWindow(WM_GetParent(hObj));
0008d4  4628              MOV      r0,r5
0008d6  f7fffffe          BL       WM_GetParent
0008da  4607              MOV      r7,r0
0008dc  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2272|
;;;714        }
;;;715        WM_UNLOCK();
;;;716      }
0008e0  bf00              NOP      
                  |L1.2274|
;;;717    }
0008e2  e8bd81f0          POP      {r4-r8,pc}
;;;718    
                          ENDP

                  HEADER_AddItem PROC
;;;722    */
;;;723    void HEADER_AddItem(HEADER_Handle hObj, int Width, const char * s, int Align) {
0008e6  e92d4ffe          PUSH     {r1-r11,lr}
0008ea  4607              MOV      r7,r0
0008ec  460d              MOV      r5,r1
0008ee  4616              MOV      r6,r2
0008f0  4698              MOV      r8,r3
;;;724      if (hObj) {
0008f2  2f00              CMP      r7,#0
0008f4  d04a              BEQ      |L1.2444|
;;;725        HEADER_Obj * pObj;
;;;726        HEADER_COLUMN Column;
;;;727        int Index;
;;;728        WM_LOCK();
;;;729        pObj = HEADER_H2P(hObj);
0008f6  4638              MOV      r0,r7
0008f8  f7fffffe          BL       GUI_ALLOC_h2p
0008fc  4604              MOV      r4,r0
;;;730        if (!Width) {
0008fe  b995              CBNZ     r5,|L1.2342|
;;;731          const GUI_FONT GUI_UNI_PTR * pFont = GUI_SetFont(pObj->pFont);
000900  6ce0              LDR      r0,[r4,#0x4c]
000902  f7fffffe          BL       GUI_SetFont
000906  4681              MOV      r9,r0
;;;732          Width = GUI_GetStringDistX(s) + 2 * (pObj->Widget.pEffect->EffectSize + _DefaultBorderH);
000908  4630              MOV      r0,r6
00090a  f7fffffe          BL       GUI_GetStringDistX
00090e  6a21              LDR      r1,[r4,#0x20]
000910  6949              LDR      r1,[r1,#0x14]
000912  4a69              LDR      r2,|L1.2744|
000914  6812              LDR      r2,[r2,#0]  ; _DefaultBorderH
000916  4411              ADD      r1,r1,r2
000918  2202              MOVS     r2,#2
00091a  fb020501          MLA      r5,r2,r1,r0
;;;733          GUI_SetFont(pFont);
00091e  4648              MOV      r0,r9
000920  f7fffffe          BL       GUI_SetFont
;;;734        }
000924  bf00              NOP      
                  |L1.2342|
;;;735        Column.Width    = Width;
000926  9500              STR      r5,[sp,#0]
;;;736        Column.Align    = Align;
000928  fa0ff088          SXTH     r0,r8
00092c  f8ad0004          STRH     r0,[sp,#4]
;;;737        Column.hDrawObj = 0;
000930  2000              MOVS     r0,#0
000932  f8ad0006          STRH     r0,[sp,#6]
;;;738        Index = GUI_ARRAY_GetNumItems(&pObj->Columns);
000936  f1040030          ADD      r0,r4,#0x30
00093a  f7fffffe          BL       GUI_ARRAY_GetNumItems
00093e  4682              MOV      r10,r0
;;;739        if (GUI_ARRAY_AddItem(&pObj->Columns, &Column, sizeof(HEADER_COLUMN) + strlen(s) + 1) == 0) {
000940  4630              MOV      r0,r6
000942  f7fffffe          BL       strlen
000946  f100090d          ADD      r9,r0,#0xd
00094a  464a              MOV      r2,r9
00094c  4669              MOV      r1,sp
00094e  f1040030          ADD      r0,r4,#0x30
000952  f7fffffe          BL       GUI_ARRAY_AddItem
000956  b9c0              CBNZ     r0,|L1.2442|
;;;740          HEADER_COLUMN * pColumn;
;;;741          pObj = HEADER_H2P(hObj);
000958  4638              MOV      r0,r7
00095a  f7fffffe          BL       GUI_ALLOC_h2p
00095e  4604              MOV      r4,r0
;;;742          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000960  4651              MOV      r1,r10
000962  f1040030          ADD      r0,r4,#0x30
000966  f7fffffe          BL       GUI_ARRAY_GetpItem
00096a  4681              MOV      r9,r0
;;;743          strcpy(pColumn->acText, s);
00096c  4631              MOV      r1,r6
00096e  f1090008          ADD      r0,r9,#8
000972  f7fffffe          BL       strcpy
;;;744          WM_InvalidateWindow(hObj);
000976  4638              MOV      r0,r7
000978  f7fffffe          BL       WM_InvalidateWindow
;;;745          WM_InvalidateWindow(WM_GetParent(hObj));
00097c  4638              MOV      r0,r7
00097e  f7fffffe          BL       WM_GetParent
000982  4683              MOV      r11,r0
000984  f7fffffe          BL       WM_InvalidateWindow
;;;746        }
000988  bf00              NOP      
                  |L1.2442|
;;;747        WM_UNLOCK();
;;;748      }
00098a  bf00              NOP      
                  |L1.2444|
;;;749    }
00098c  e8bd8ffe          POP      {r1-r11,pc}
;;;750    
                          ENDP

                  HEADER_DeleteItem PROC
;;;754    */
;;;755    void HEADER_DeleteItem(HEADER_Handle hObj, unsigned Index) {
000990  e92d41f0          PUSH     {r4-r8,lr}
000994  4604              MOV      r4,r0
000996  460d              MOV      r5,r1
;;;756      if (hObj) {
000998  b1c4              CBZ      r4,|L1.2508|
;;;757        HEADER_Obj* pObj;
;;;758        WM_LOCK();
;;;759        pObj = HEADER_H2P(hObj);
00099a  4620              MOV      r0,r4
00099c  f7fffffe          BL       GUI_ALLOC_h2p
0009a0  4606              MOV      r6,r0
;;;760        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
0009a2  f1060030          ADD      r0,r6,#0x30
0009a6  f7fffffe          BL       GUI_ARRAY_GetNumItems
0009aa  42a8              CMP      r0,r5
0009ac  d90d              BLS      |L1.2506|
;;;761          GUI_ARRAY_DeleteItem(&pObj->Columns, Index);
0009ae  4629              MOV      r1,r5
0009b0  f1060030          ADD      r0,r6,#0x30
0009b4  f7fffffe          BL       GUI_ARRAY_DeleteItem
;;;762          WM_InvalidateWindow(hObj);
0009b8  4620              MOV      r0,r4
0009ba  f7fffffe          BL       WM_InvalidateWindow
;;;763          WM_InvalidateWindow(WM_GetParent(hObj));
0009be  4620              MOV      r0,r4
0009c0  f7fffffe          BL       WM_GetParent
0009c4  4607              MOV      r7,r0
0009c6  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2506|
;;;764        }
;;;765        WM_UNLOCK();
;;;766      }
0009ca  bf00              NOP      
                  |L1.2508|
;;;767    }
0009cc  e8bd81f0          POP      {r4-r8,pc}
;;;768    
                          ENDP

                  HEADER_SetItemText PROC
;;;772    */
;;;773    void HEADER_SetItemText(HEADER_Handle hObj, unsigned int Index, const char* s) {
0009d0  e92d47f0          PUSH     {r4-r10,lr}
0009d4  4605              MOV      r5,r0
0009d6  460e              MOV      r6,r1
0009d8  4614              MOV      r4,r2
;;;774      if (hObj) {
0009da  b1fd              CBZ      r5,|L1.2588|
;;;775        HEADER_Obj* pObj;
;;;776        WM_LOCK();
;;;777        pObj = HEADER_H2P(hObj);
0009dc  4628              MOV      r0,r5
0009de  f7fffffe          BL       GUI_ALLOC_h2p
0009e2  4607              MOV      r7,r0
;;;778        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
0009e4  f1070030          ADD      r0,r7,#0x30
0009e8  f7fffffe          BL       GUI_ARRAY_GetNumItems
0009ec  42b0              CMP      r0,r6
0009ee  d914              BLS      |L1.2586|
;;;779          HEADER_COLUMN* pColumn;
;;;780          pColumn = (HEADER_COLUMN*)GUI_ARRAY_ResizeItem(&pObj->Columns, Index, sizeof(HEADER_COLUMN) + strlen(s));
0009f0  4620              MOV      r0,r4
0009f2  f7fffffe          BL       strlen
0009f6  f100090c          ADD      r9,r0,#0xc
0009fa  464a              MOV      r2,r9
0009fc  4631              MOV      r1,r6
0009fe  f1070030          ADD      r0,r7,#0x30
000a02  f7fffffe          BL       GUI_ARRAY_ResizeItem
000a06  4680              MOV      r8,r0
;;;781          if (pColumn) {
000a08  f1b80f00          CMP      r8,#0
000a0c  d004              BEQ      |L1.2584|
;;;782            strcpy(pColumn->acText, s);
000a0e  4621              MOV      r1,r4
000a10  f1080008          ADD      r0,r8,#8
000a14  f7fffffe          BL       strcpy
                  |L1.2584|
;;;783          }
;;;784        }
000a18  bf00              NOP      
                  |L1.2586|
;;;785        WM_UNLOCK();
;;;786      }
000a1a  bf00              NOP      
                  |L1.2588|
;;;787    }
000a1c  e8bd87f0          POP      {r4-r10,pc}
;;;788    
                          ENDP

                  HEADER_GetHeight PROC
;;;820    */
;;;821    int HEADER_GetHeight(HEADER_Handle hObj) {
000a20  b57c              PUSH     {r2-r6,lr}
000a22  4604              MOV      r4,r0
;;;822      int Height = 0;
000a24  2500              MOVS     r5,#0
;;;823      if (hObj) {
000a26  b19c              CBZ      r4,|L1.2640|
;;;824        GUI_RECT Rect;
;;;825        WM_GetClientRectEx(hObj, &Rect);
000a28  4669              MOV      r1,sp
000a2a  4620              MOV      r0,r4
000a2c  f7fffffe          BL       WM_GetClientRectEx
;;;826        GUI_MoveRect(&Rect, -Rect.x0, -Rect.y0);
000a30  f9bd0002          LDRSH    r0,[sp,#2]
000a34  4242              RSBS     r2,r0,#0
000a36  f9bd0000          LDRSH    r0,[sp,#0]
000a3a  4241              RSBS     r1,r0,#0
000a3c  4668              MOV      r0,sp
000a3e  f7fffffe          BL       GUI_MoveRect
;;;827        Height = Rect.y1 - Rect.y0 + 1;
000a42  f9bd0006          LDRSH    r0,[sp,#6]
000a46  f9bd1002          LDRSH    r1,[sp,#2]
000a4a  1a40              SUBS     r0,r0,r1
000a4c  1c45              ADDS     r5,r0,#1
;;;828      }
000a4e  bf00              NOP      
                  |L1.2640|
;;;829      return Height;
000a50  4628              MOV      r0,r5
;;;830    }
000a52  bd7c              POP      {r2-r6,pc}
;;;831    
                          ENDP

                  HEADER_GetNumItems PROC
;;;855    */
;;;856    int  HEADER_GetNumItems(HEADER_Handle hObj) {
000a54  b570              PUSH     {r4-r6,lr}
000a56  4604              MOV      r4,r0
;;;857      int NumCols = 0;
000a58  2500              MOVS     r5,#0
;;;858      if (hObj) {
000a5a  b14c              CBZ      r4,|L1.2672|
;;;859        HEADER_Obj * pObj;
;;;860        WM_LOCK();
;;;861        pObj = HEADER_H2P(hObj);
000a5c  4620              MOV      r0,r4
000a5e  f7fffffe          BL       GUI_ALLOC_h2p
000a62  4606              MOV      r6,r0
;;;862        NumCols = GUI_ARRAY_GetNumItems(&pObj->Columns);
000a64  f1060030          ADD      r0,r6,#0x30
000a68  f7fffffe          BL       GUI_ARRAY_GetNumItems
000a6c  4605              MOV      r5,r0
;;;863        WM_UNLOCK();
;;;864      }
000a6e  bf00              NOP      
                  |L1.2672|
;;;865      return NumCols;
000a70  4628              MOV      r0,r5
;;;866    }
000a72  bd70              POP      {r4-r6,pc}
;;;867    
                          ENDP

                  HEADER_SetDirIndicator PROC
;;;871    */
;;;872    void HEADER_SetDirIndicator(HEADER_Handle hObj, int Column, int Reverse) {
000a74  e92d41f0          PUSH     {r4-r8,lr}
000a78  4607              MOV      r7,r0
000a7a  460d              MOV      r5,r1
000a7c  4616              MOV      r6,r2
;;;873      if (hObj) {
000a7e  b17f              CBZ      r7,|L1.2720|
;;;874        HEADER_Obj * pObj;
;;;875        WM_LOCK();
;;;876        pObj = HEADER_H2P(hObj);
000a80  4638              MOV      r0,r7
000a82  f7fffffe          BL       GUI_ALLOC_h2p
000a86  4604              MOV      r4,r0
;;;877        if ((pObj->DirIndicatorColumn != Column) || (pObj->DirIndicatorReverse != Reverse)) {
000a88  6c60              LDR      r0,[r4,#0x44]
000a8a  42a8              CMP      r0,r5
000a8c  d102              BNE      |L1.2708|
000a8e  6ca0              LDR      r0,[r4,#0x48]
000a90  42b0              CMP      r0,r6
000a92  d004              BEQ      |L1.2718|
                  |L1.2708|
;;;878          pObj->DirIndicatorColumn = Column;
000a94  6465              STR      r5,[r4,#0x44]
;;;879          pObj->DirIndicatorReverse = Reverse;
000a96  64a6              STR      r6,[r4,#0x48]
;;;880          WM_InvalidateWindow(hObj);
000a98  4638              MOV      r0,r7
000a9a  f7fffffe          BL       WM_InvalidateWindow
                  |L1.2718|
;;;881        }
;;;882        WM_UNLOCK();
;;;883      }
000a9e  bf00              NOP      
                  |L1.2720|
;;;884    }
000aa0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2724|
                          DCD      _pDefaultFont
                  |L1.2728|
                          DCD      _DefaultBorderV
                  |L1.2732|
                          DCD      _DefaultBkColor
                  |L1.2736|
                          DCD      _DefaultTextColor
                  |L1.2740|
                          DCD      _pDefaultCursor
                  |L1.2744|
                          DCD      _DefaultBorderH
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  _pOldCursor
                          DCD      0x00000000
                  _pDefaultCursor
                          DCD      GUI_CursorHeaderM
                  _DefaultBkColor
                          DCD      0x00aaaaaa
                  _DefaultTextColor
                          DCD      0x00000000
                  _DefaultBorderH
                          DCD      0x00000002
                  _DefaultBorderV
                          DCD      0x00000000
                  _pDefaultFont
                          DCD      GUI_Font13_1
