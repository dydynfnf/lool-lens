; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\guidev_usagebm.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\guidev_usagebm.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\guidev_usagebm.crf GUI\MemDev\GUIDEV_UsageBM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GUI_USAGE_BM_AddPixel PROC
;;;54     */
;;;55     static void GUI_USAGE_BM_AddPixel(GUI_USAGE* p, int x, int y) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4614              MOV      r4,r2
;;;56       U8* pData;
;;;57       GUI_USAGE_BM * pThis = (GUI_USAGE_BM*)p;
000004  4603              MOV      r3,r0
;;;58       #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
;;;59         if ((x >= pThis->Public.x0 + pThis->Public.XSize) | (x < pThis->Public.x0)
;;;60           | (y >= pThis->Public.y0 + pThis->Public.YSize) | (y < pThis->Public.y0))
;;;61         {
;;;62           GUI_DEBUG_ERROROUT2("GUI_USAGE_BM_AddPixel: parameters out of bounds",x,y);
;;;63         }
;;;64       #endif
;;;65       x -= pThis->Public.x0;
000006  f9b35000          LDRSH    r5,[r3,#0]
00000a  1b49              SUBS     r1,r1,r5
;;;66       pData =  (U8*)(pThis+1); 
00000c  f1030214          ADD      r2,r3,#0x14
;;;67       pData += (y-pThis->Public.y0) * pThis->Private.BytesPerLine;
000010  f9b35002          LDRSH    r5,[r3,#2]
000014  1b65              SUBS     r5,r4,r5
000016  691e              LDR      r6,[r3,#0x10]
000018  fb052206          MLA      r2,r5,r6,r2
;;;68       pData += x>>3;
00001c  eb0202e1          ADD      r2,r2,r1,ASR #3
;;;69       *pData|= 0x80>>(x&7);
000020  7815              LDRB     r5,[r2,#0]
000022  f0010707          AND      r7,r1,#7
000026  2680              MOVS     r6,#0x80
000028  413e              ASRS     r6,r6,r7
00002a  4335              ORRS     r5,r5,r6
00002c  7015              STRB     r5,[r2,#0]
;;;70     }
00002e  bdf0              POP      {r4-r7,pc}
;;;71     
                          ENDP

                  GUI_USAGE_BM_AddHLine PROC
;;;75     */
;;;76     static void GUI_USAGE_BM_AddHLine(GUI_USAGE* p, int x, int y, int len) {
000030  e92d4fff          PUSH     {r0-r11,lr}
000034  b081              SUB      sp,sp,#4
000036  4605              MOV      r5,r0
000038  460e              MOV      r6,r1
00003a  4691              MOV      r9,r2
;;;77     #if 0   /* Enable for the slower, but smaller version ... xxx*/
;;;78       while (len-- >0)
;;;79         GUI_USAGE_BM_AddPixel(h, x++,y);
;;;80     #else
;;;81       U8* pData;
;;;82       GUI_USAGE_BM * pThis = (GUI_USAGE_BM*)p;
00003c  462f              MOV      r7,r5
;;;83       /* Asserts */
;;;84       GUI_DEBUG_ERROROUT3_IF( x<pThis->Public.x0, "GUIDEV.c: MarkPixels: negative x offset, Act= %d, Border= %d, Clip= %d"
;;;85                         ,x, pThis->Public.x0, GUI_Context.ClipRect.x0);
;;;86       /* Calculate pointers */
;;;87       x -= pThis->Public.x0;
00003e  f9b70000          LDRSH    r0,[r7,#0]
000042  1a36              SUBS     r6,r6,r0
;;;88       pData =  (U8*)(pThis+1); 
000044  f1070414          ADD      r4,r7,#0x14
;;;89       pData += (y-pThis->Public.y0) * pThis->Private.BytesPerLine;
000048  f9b70002          LDRSH    r0,[r7,#2]
00004c  eba90000          SUB      r0,r9,r0
000050  6939              LDR      r1,[r7,#0x10]
000052  fb004401          MLA      r4,r0,r1,r4
;;;90       pData += x>>3;
000056  eb0404e6          ADD      r4,r4,r6,ASR #3
;;;91       /* Set bits */
;;;92       {  
;;;93         int x1 = x+len-1;   /* last pixel */
00005a  9804              LDR      r0,[sp,#0x10]
00005c  4430              ADD      r0,r0,r6
00005e  1e40              SUBS     r0,r0,#1
000060  9000              STR      r0,[sp,#0]
;;;94         int NumBytes = (x1>>3) - (x>>3);
000062  9800              LDR      r0,[sp,#0]
000064  10c0              ASRS     r0,r0,#3
000066  eba008e6          SUB      r8,r0,r6,ASR #3
;;;95         U8 Mask0 = 0xff >> (x&7);
00006a  f0060107          AND      r1,r6,#7
00006e  20ff              MOVS     r0,#0xff
000070  fa40fa01          ASR      r10,r0,r1
;;;96         U8 Mask1 = 0xff << (7-(x1&7));
000074  9800              LDR      r0,[sp,#0]
000076  f0000007          AND      r0,r0,#7
00007a  f1c00107          RSB      r1,r0,#7
00007e  20ff              MOVS     r0,#0xff
000080  4088              LSLS     r0,r0,r1
000082  f0000bff          AND      r11,r0,#0xff
;;;97         if (NumBytes ==0) {
000086  f1b80f00          CMP      r8,#0
00008a  d105              BNE      |L1.152|
;;;98           *pData |= (Mask0&Mask1);
00008c  7820              LDRB     r0,[r4,#0]
00008e  ea0a010b          AND      r1,r10,r11
000092  4308              ORRS     r0,r0,r1
000094  7020              STRB     r0,[r4,#0]
000096  e013              B        |L1.192|
                  |L1.152|
;;;99         } else {
;;;100          *pData++ |= Mask0;               /* Mark first byte */
000098  7820              LDRB     r0,[r4,#0]
00009a  ea40000a          ORR      r0,r0,r10
00009e  f8040b01          STRB     r0,[r4],#1
;;;101          /* Mark middle bytes */
;;;102          if (--NumBytes > 0) {
0000a2  f1a80001          SUB      r0,r8,#1
0000a6  f1b00800          SUBS     r8,r0,#0
0000aa  dd05              BLE      |L1.184|
;;;103            memset (pData, 0xff, NumBytes);
0000ac  22ff              MOVS     r2,#0xff
0000ae  4641              MOV      r1,r8
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       __aeabi_memset
;;;104            pData += NumBytes;
0000b6  4444              ADD      r4,r4,r8
                  |L1.184|
;;;105          }
;;;106          *pData |= Mask1;                 /* Mark last bytes */
0000b8  7820              LDRB     r0,[r4,#0]
0000ba  ea40000b          ORR      r0,r0,r11
0000be  7020              STRB     r0,[r4,#0]
                  |L1.192|
;;;107        }
;;;108      }
;;;109    #endif
;;;110    }
0000c0  b005              ADD      sp,sp,#0x14
0000c2  e8bd8ff0          POP      {r4-r11,pc}
;;;111    
                          ENDP

                  GUI_USAGE_BM_Clear PROC
;;;115    */
;;;116    static void GUI_USAGE_BM_Clear(GUI_USAGE* p) {
0000c6  b570              PUSH     {r4-r6,lr}
0000c8  4604              MOV      r4,r0
;;;117      GUI_USAGE_BM * pThis = (GUI_USAGE_BM*) p;
0000ca  4625              MOV      r5,r4
;;;118      memset (pThis+1, 0, pThis->Public.YSize * pThis->Private.BytesPerLine);
0000cc  f9b50006          LDRSH    r0,[r5,#6]
0000d0  692a              LDR      r2,[r5,#0x10]
0000d2  fb00f102          MUL      r1,r0,r2
0000d6  f1050014          ADD      r0,r5,#0x14
0000da  f7fffffe          BL       __aeabi_memclr4
;;;119    }
0000de  bd70              POP      {r4-r6,pc}
;;;120    
                          ENDP

                  GUI_USAGE_BM_GetNextDirty PROC
;;;124    */
;;;125    static int GUI_USAGE_BM_GetNextDirty(GUI_USAGE* p, int *pxOff, int yOff) {
0000e0  e92d47f0          PUSH     {r4-r10,lr}
0000e4  4605              MOV      r5,r0
0000e6  460f              MOV      r7,r1
0000e8  4694              MOV      r12,r2
;;;126      int x = *pxOff;
0000ea  6839              LDR      r1,[r7,#0]
;;;127      int xEnd;
;;;128      GUI_USAGE_BM * pThis = (GUI_USAGE_BM*)p;
0000ec  462e              MOV      r6,r5
;;;129      int xSize = pThis->Public.XSize;
0000ee  f9b69004          LDRSH    r9,[r6,#4]
;;;130      U8* pData = (U8*)(pThis+1);
0000f2  f1060214          ADD      r2,r6,#0x14
;;;131      if (yOff >= pThis->Public.YSize) {
0000f6  f9b60006          LDRSH    r0,[r6,#6]
0000fa  4560              CMP      r0,r12
0000fc  dc02              BGT      |L1.260|
;;;132        return 0;
0000fe  2000              MOVS     r0,#0
                  |L1.256|
;;;133      }
;;;134      pData += yOff * pThis->Private.BytesPerLine;
;;;135      pData += (x>>3);
;;;136      if (x>=xSize)
;;;137        return 0;
;;;138      {
;;;139    /* Find first bit */
;;;140        int BytesLeft = ((xSize-1) >>3) - (x>>3);
;;;141        /* Check first byte */
;;;142        U8 Data = (*pData++) << (x&7);
;;;143        while (Data == 0) {
;;;144          if (BytesLeft ==0)
;;;145            return 0;
;;;146          Data = *pData++;
;;;147          BytesLeft--;
;;;148          x= (x+8) & ~7;
;;;149        }
;;;150        while ((Data&0x80) ==0) {
;;;151          Data<<=1;
;;;152          x++;
;;;153        }
;;;154    /* Find last cleared byte */
;;;155        if (Data != 0xff) {   /* This line is simply a speed-opt and may be eliminated */
;;;156          xEnd =x;
;;;157          while (Data&0x40) {
;;;158            Data<<=1;
;;;159            xEnd++;
;;;160          }
;;;161        } else {
;;;162          xEnd =x+7;
;;;163        }
;;;164        if ((xEnd&7) ==7) {
;;;165          while (--BytesLeft >= 0) {
;;;166            if ((Data = *pData++) == 0xff) {
;;;167              xEnd+=8;
;;;168            } else {
;;;169              while (Data&0x80) {
;;;170                Data<<=1;
;;;171                xEnd++;
;;;172              }
;;;173              break;
;;;174            }
;;;175          }
;;;176        }
;;;177    
;;;178      }
;;;179      *pxOff =x;
;;;180      return xEnd-x+1;
;;;181    }
000100  e8bd87f0          POP      {r4-r10,pc}
                  |L1.260|
000104  6930              LDR      r0,[r6,#0x10]         ;134
000106  fb0c2200          MLA      r2,r12,r0,r2          ;134
00010a  eb0202e1          ADD      r2,r2,r1,ASR #3       ;135
00010e  4549              CMP      r1,r9                 ;136
000110  db01              BLT      |L1.278|
000112  2000              MOVS     r0,#0                 ;137
000114  e7f4              B        |L1.256|
                  |L1.278|
000116  f1a90001          SUB      r0,r9,#1              ;140
00011a  10c0              ASRS     r0,r0,#3              ;140
00011c  eba008e1          SUB      r8,r0,r1,ASR #3       ;140
000120  f8120b01          LDRB     r0,[r2],#1            ;142
000124  f0010a07          AND      r10,r1,#7             ;142
000128  fa00f00a          LSL      r0,r0,r10             ;142
00012c  b2c3              UXTB     r3,r0                 ;142
00012e  e00c              B        |L1.330|
                  |L1.304|
000130  f1b80f00          CMP      r8,#0                 ;144
000134  d101              BNE      |L1.314|
000136  2000              MOVS     r0,#0                 ;145
000138  e7e2              B        |L1.256|
                  |L1.314|
00013a  f8123b01          LDRB     r3,[r2],#1            ;146
00013e  f1a80801          SUB      r8,r8,#1              ;147
000142  f1010008          ADD      r0,r1,#8              ;148
000146  f0200107          BIC      r1,r0,#7              ;148
                  |L1.330|
00014a  2b00              CMP      r3,#0                 ;143
00014c  d0f0              BEQ      |L1.304|
00014e  e002              B        |L1.342|
                  |L1.336|
000150  0658              LSLS     r0,r3,#25             ;151
000152  0e03              LSRS     r3,r0,#24             ;151
000154  1c49              ADDS     r1,r1,#1              ;152
                  |L1.342|
000156  f0030080          AND      r0,r3,#0x80           ;150
00015a  2800              CMP      r0,#0                 ;150
00015c  d0f8              BEQ      |L1.336|
00015e  2bff              CMP      r3,#0xff              ;155
000160  d009              BEQ      |L1.374|
000162  460c              MOV      r4,r1                 ;156
000164  e002              B        |L1.364|
                  |L1.358|
000166  0658              LSLS     r0,r3,#25             ;158
000168  0e03              LSRS     r3,r0,#24             ;158
00016a  1c64              ADDS     r4,r4,#1              ;159
                  |L1.364|
00016c  f0030040          AND      r0,r3,#0x40           ;157
000170  2800              CMP      r0,#0                 ;157
000172  d1f8              BNE      |L1.358|
000174  e000              B        |L1.376|
                  |L1.374|
000176  1dcc              ADDS     r4,r1,#7              ;162
                  |L1.376|
000178  f0040007          AND      r0,r4,#7              ;164
00017c  2807              CMP      r0,#7                 ;164
00017e  d117              BNE      |L1.432|
000180  e010              B        |L1.420|
                  |L1.386|
000182  f812ab01          LDRB     r10,[r2],#1           ;166
000186  4653              MOV      r3,r10                ;166
000188  f1ba0fff          CMP      r10,#0xff             ;166
00018c  d101              BNE      |L1.402|
00018e  3408              ADDS     r4,r4,#8              ;167
000190  e008              B        |L1.420|
                  |L1.402|
000192  e002              B        |L1.410|
                  |L1.404|
000194  0658              LSLS     r0,r3,#25             ;170
000196  0e03              LSRS     r3,r0,#24             ;170
000198  1c64              ADDS     r4,r4,#1              ;171
                  |L1.410|
00019a  f0030080          AND      r0,r3,#0x80           ;169
00019e  2800              CMP      r0,#0                 ;169
0001a0  d1f8              BNE      |L1.404|
0001a2  e004              B        |L1.430|
                  |L1.420|
0001a4  f1a80001          SUB      r0,r8,#1              ;165
0001a8  f1b00800          SUBS     r8,r0,#0              ;165
0001ac  dae9              BGE      |L1.386|
                  |L1.430|
0001ae  bf00              NOP                            ;173
                  |L1.432|
0001b0  6039              STR      r1,[r7,#0]            ;179
0001b2  1a60              SUBS     r0,r4,r1              ;180
0001b4  1c40              ADDS     r0,r0,#1              ;180
0001b6  e7a3              B        |L1.256|
;;;182    
                          ENDP

                  _GUI_USAGE_BM_Delete PROC
;;;186    */
;;;187    static void _GUI_USAGE_BM_Delete(GUI_MEMDEV_Handle hDevUsage) {
0001b8  b510              PUSH     {r4,lr}
0001ba  4604              MOV      r4,r0
;;;188      GUI_ALLOC_Free(hDevUsage);
0001bc  4620              MOV      r0,r4
0001be  f7fffffe          BL       GUI_ALLOC_Free
;;;189    }
0001c2  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  GUI_USAGE_BM_Create PROC
;;;214    */
;;;215    GUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags) {
0001c4  e92d4ff8          PUSH     {r3-r11,lr}
0001c8  4607              MOV      r7,r0
0001ca  4688              MOV      r8,r1
0001cc  4615              MOV      r5,r2
0001ce  461e              MOV      r6,r3
0001d0  f8ddb028          LDR      r11,[sp,#0x28]
;;;216      int MemSize;
;;;217      int BytesPerLine;
;;;218      GUI_USAGE_Handle hMem;
;;;219      GUI_USE_PARA(Flags);
0001d4  bf00              NOP      
;;;220      BytesPerLine = ((xsize+15) >>4)<<1;  /* 2 byte alignment */
0001d6  f105000f          ADD      r0,r5,#0xf
0001da  1100              ASRS     r0,r0,#4
0001dc  ea4f0940          LSL      r9,r0,#1
;;;221      MemSize = ysize*BytesPerLine +sizeof(GUI_USAGE_BM);
0001e0  fb06f009          MUL      r0,r6,r9
0001e4  3014              ADDS     r0,r0,#0x14
0001e6  9000              STR      r0,[sp,#0]
;;;222      hMem = GUI_ALLOC_AllocZero(MemSize);
0001e8  9800              LDR      r0,[sp,#0]
0001ea  b200              SXTH     r0,r0
0001ec  f7fffffe          BL       GUI_ALLOC_AllocZero
0001f0  4682              MOV      r10,r0
;;;223      /* Check if we can alloc sufficient memory */
;;;224      if (!hMem) {
0001f2  f1ba0f00          CMP      r10,#0
0001f6  d102              BNE      |L1.510|
;;;225        GUI_DEBUG_ERROROUT("GUI_USAGE_BM_Create: Too little memory");
;;;226        return 0;    
0001f8  2000              MOVS     r0,#0
                  |L1.506|
;;;227      }
;;;228      {
;;;229        GUI_USAGE_BM * pUsage;
;;;230        GUI_LOCK();
;;;231        pUsage = (GUI_USAGE_BM*)GUI_ALLOC_h2p(hMem);
;;;232        pUsage->Public.x0    = x0;
;;;233        pUsage->Public.y0    = y0;
;;;234        pUsage->Public.XSize = xsize;
;;;235        pUsage->Public.YSize = ysize;
;;;236        pUsage->Public.pAPI  = &API;
;;;237        pUsage->Public.UseCnt= 1;
;;;238        pUsage->Private.BytesPerLine= BytesPerLine;
;;;239        GUI_UNLOCK();
;;;240      }
;;;241      return hMem;
;;;242    }
0001fa  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.510|
0001fe  4650              MOV      r0,r10                ;231
000200  f7fffffe          BL       GUI_ALLOC_h2p
000204  4604              MOV      r4,r0                 ;231
000206  b238              SXTH     r0,r7                 ;232
000208  8020              STRH     r0,[r4,#0]            ;232
00020a  fa0ff088          SXTH     r0,r8                 ;233
00020e  8060              STRH     r0,[r4,#2]            ;233
000210  b228              SXTH     r0,r5                 ;234
000212  80a0              STRH     r0,[r4,#4]            ;234
000214  b230              SXTH     r0,r6                 ;235
000216  80e0              STRH     r0,[r4,#6]            ;235
000218  4803              LDR      r0,|L1.552|
00021a  60a0              STR      r0,[r4,#8]            ;236
00021c  2001              MOVS     r0,#1                 ;237
00021e  81a0              STRH     r0,[r4,#0xc]          ;237
000220  f8c49010          STR      r9,[r4,#0x10]         ;238
000224  4650              MOV      r0,r10                ;241
000226  e7e8              B        |L1.506|
;;;243    
                          ENDP

                  |L1.552|
                          DCD      API

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  API
                          DCD      GUI_USAGE_BM_AddPixel
                          DCD      GUI_USAGE_BM_AddHLine
                          DCD      GUI_USAGE_BM_Clear
                          DCD      0x00000000
                          DCD      _GUI_USAGE_BM_Delete
                          DCD      GUI_USAGE_BM_GetNextDirty
