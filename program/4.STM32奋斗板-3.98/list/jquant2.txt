; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jquant2.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jquant2.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jquant2.crf GUI\JPEG\jquant2.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prescan_quantize PROC
;;;223    METHODDEF(void)
;;;224    prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;225    		  JSAMPARRAY output_buf, int num_rows)
;;;226    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;227      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00000a  f8d4c1cc          LDR      r12,[r4,#0x1cc]
;;;228      register JSAMPROW ptr;
;;;229      register histptr histp;
;;;230      register hist3d histogram = cquantize->histogram;
00000e  f8dc8018          LDR      r8,[r12,#0x18]
;;;231      int row;
;;;232      JDIMENSION col;
;;;233      JDIMENSION width = cinfo->output_width;
000012  f8d49070          LDR      r9,[r4,#0x70]
;;;234    
;;;235      GUI_USE_PARA(output_buf);
000016  bf00              NOP      
;;;236      for (row = 0; row < num_rows; row++) {
000018  2200              MOVS     r2,#0
00001a  e02b              B        |L1.116|
                  |L1.28|
;;;237        ptr = input_buf[row];
00001c  f8551022          LDR      r1,[r5,r2,LSL #2]
;;;238        for (col = width; col > 0; col--) {
000020  464f              MOV      r7,r9
000022  e024              B        |L1.110|
                  |L1.36|
;;;239          /* get pixel value and index into the histogram */
;;;240          histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
000024  f891a000          LDRB     r10,[r1,#0]
000028  ea4f0aea          ASR      r10,r10,#3
00002c  f858a02a          LDR      r10,[r8,r10,LSL #2]
000030  f891b001          LDRB     r11,[r1,#1]
000034  ea4f0bab          ASR      r11,r11,#2
000038  eb0a1a8b          ADD      r10,r10,r11,LSL #6
00003c  f891b002          LDRB     r11,[r1,#2]
000040  ea4f0beb          ASR      r11,r11,#3
000044  eb0a004b          ADD      r0,r10,r11,LSL #1
;;;241    			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
;;;242    			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
;;;243          /* increment, check for overflow and undo increment if so. */
;;;244          if (++(*histp) <= 0)
000048  f8b0a000          LDRH     r10,[r0,#0]
00004c  f10a0a01          ADD      r10,r10,#1
000050  fa1ffa8a          UXTH     r10,r10
000054  f8a0a000          STRH     r10,[r0,#0]
000058  f1ba0f00          CMP      r10,#0
00005c  dc05              BGT      |L1.106|
;;;245    	(*histp)--;
00005e  f8b0a000          LDRH     r10,[r0,#0]
000062  f1aa0a01          SUB      r10,r10,#1
000066  f8a0a000          STRH     r10,[r0,#0]
                  |L1.106|
;;;246          ptr += 3;
00006a  1cc9              ADDS     r1,r1,#3
00006c  1e7f              SUBS     r7,r7,#1              ;238
                  |L1.110|
00006e  2f00              CMP      r7,#0                 ;238
000070  d1d8              BNE      |L1.36|
000072  1c52              ADDS     r2,r2,#1              ;236
                  |L1.116|
000074  429a              CMP      r2,r3                 ;236
000076  dbd1              BLT      |L1.28|
;;;247        }
;;;248      }
;;;249    }
000078  e8bd8ff0          POP      {r4-r11,pc}
;;;250    
                          ENDP

                  find_biggest_color_pop PROC
;;;273    LOCAL(boxptr)
;;;274    find_biggest_color_pop (boxptr boxlist, int numboxes)
00007c  b570              PUSH     {r4-r6,lr}
;;;275    /* Find the splittable box with the largest color population */
;;;276    /* Returns NULL if no splittable boxes remain */
;;;277    {
00007e  4602              MOV      r2,r0
000080  460b              MOV      r3,r1
;;;278      register boxptr boxp;
;;;279      register int i;
;;;280      register long maxc = 0;
000082  2500              MOVS     r5,#0
;;;281      boxptr which = NULL;
000084  2000              MOVS     r0,#0
;;;282      
;;;283      for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
000086  2400              MOVS     r4,#0
000088  4611              MOV      r1,r2
00008a  e009              B        |L1.160|
                  |L1.140|
;;;284        if (boxp->colorcount > maxc && boxp->volume > 0) {
00008c  69ce              LDR      r6,[r1,#0x1c]
00008e  42ae              CMP      r6,r5
000090  dd04              BLE      |L1.156|
000092  698e              LDR      r6,[r1,#0x18]
000094  2e00              CMP      r6,#0
000096  dd01              BLE      |L1.156|
;;;285          which = boxp;
000098  4608              MOV      r0,r1
;;;286          maxc = boxp->colorcount;
00009a  69cd              LDR      r5,[r1,#0x1c]
                  |L1.156|
00009c  1c64              ADDS     r4,r4,#1              ;283
00009e  3120              ADDS     r1,r1,#0x20           ;283
                  |L1.160|
0000a0  429c              CMP      r4,r3                 ;283
0000a2  dbf3              BLT      |L1.140|
;;;287        }
;;;288      }
;;;289      return which;
;;;290    }
0000a4  bd70              POP      {r4-r6,pc}
;;;291    
                          ENDP

                  find_biggest_volume PROC
;;;293    LOCAL(boxptr)
;;;294    find_biggest_volume (boxptr boxlist, int numboxes)
0000a6  b570              PUSH     {r4-r6,lr}
;;;295    /* Find the splittable box with the largest (scaled) volume */
;;;296    /* Returns NULL if no splittable boxes remain */
;;;297    {
0000a8  4602              MOV      r2,r0
0000aa  460b              MOV      r3,r1
;;;298      register boxptr boxp;
;;;299      register int i;
;;;300      register INT32 maxv = 0;
0000ac  2500              MOVS     r5,#0
;;;301      boxptr which = NULL;
0000ae  2000              MOVS     r0,#0
;;;302      
;;;303      for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
0000b0  2400              MOVS     r4,#0
0000b2  4611              MOV      r1,r2
0000b4  e006              B        |L1.196|
                  |L1.182|
;;;304        if (boxp->volume > maxv) {
0000b6  698e              LDR      r6,[r1,#0x18]
0000b8  42ae              CMP      r6,r5
0000ba  dd01              BLE      |L1.192|
;;;305          which = boxp;
0000bc  4608              MOV      r0,r1
;;;306          maxv = boxp->volume;
0000be  698d              LDR      r5,[r1,#0x18]
                  |L1.192|
0000c0  1c64              ADDS     r4,r4,#1              ;303
0000c2  3120              ADDS     r1,r1,#0x20           ;303
                  |L1.196|
0000c4  429c              CMP      r4,r3                 ;303
0000c6  dbf6              BLT      |L1.182|
;;;307        }
;;;308      }
;;;309      return which;
;;;310    }
0000c8  bd70              POP      {r4-r6,pc}
;;;311    
                          ENDP

                  update_box PROC
;;;313    LOCAL(void)
;;;314    update_box (j_decompress_ptr cinfo, boxptr boxp)
0000ca  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;315    /* Shrink the min/max bounds of a box to enclose only nonzero elements, */
;;;316    /* and recompute its volume and population */
;;;317    {
0000ce  b085              SUB      sp,sp,#0x14
0000d0  460b              MOV      r3,r1
;;;318      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0000d2  f8ddb014          LDR      r11,[sp,#0x14]
0000d6  f8dbb1cc          LDR      r11,[r11,#0x1cc]
0000da  f8cdb010          STR      r11,[sp,#0x10]
;;;319      hist3d histogram = cquantize->histogram;
0000de  f8ddb010          LDR      r11,[sp,#0x10]
0000e2  f8dba018          LDR      r10,[r11,#0x18]
;;;320      histptr histp;
;;;321      int c0,c1,c2;
;;;322      int c0min,c0max,c1min,c1max,c2min,c2max;
;;;323      INT32 dist0,dist1,dist2;
;;;324      long ccount;
;;;325      
;;;326      c0min = boxp->c0min;  c0max = boxp->c0max;
0000e6  681f              LDR      r7,[r3,#0]
0000e8  f8d3c004          LDR      r12,[r3,#4]
;;;327      c1min = boxp->c1min;  c1max = boxp->c1max;
0000ec  689e              LDR      r6,[r3,#8]
0000ee  f8d3800c          LDR      r8,[r3,#0xc]
;;;328      c2min = boxp->c2min;  c2max = boxp->c2max;
0000f2  691c              LDR      r4,[r3,#0x10]
0000f4  f8d39014          LDR      r9,[r3,#0x14]
;;;329      
;;;330      if (c0max > c0min)
0000f8  45bc              CMP      r12,r7
0000fa  dd1c              BLE      |L1.310|
;;;331        for (c0 = c0min; c0 <= c0max; c0++)
0000fc  4638              MOV      r0,r7
0000fe  e018              B        |L1.306|
                  |L1.256|
;;;332          for (c1 = c1min; c1 <= c1max; c1++) {
000100  4631              MOV      r1,r6
000102  e013              B        |L1.300|
                  |L1.260|
;;;333    	histp = & histogram[c0][c1][c2min];
000104  f85ab020          LDR      r11,[r10,r0,LSL #2]
000108  eb0b1b81          ADD      r11,r11,r1,LSL #6
00010c  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;334    	for (c2 = c2min; c2 <= c2max; c2++)
000110  4622              MOV      r2,r4
000112  e008              B        |L1.294|
                  |L1.276|
;;;335    	  if (*histp++ != 0) {
000114  f835bb02          LDRH     r11,[r5],#2
000118  f1bb0f00          CMP      r11,#0
00011c  d002              BEQ      |L1.292|
;;;336    	    boxp->c0min = c0min = c0;
00011e  4607              MOV      r7,r0
000120  6018              STR      r0,[r3,#0]
;;;337    	    goto have_c0min;
000122  e009              B        |L1.312|
                  |L1.292|
000124  1c52              ADDS     r2,r2,#1              ;334
                  |L1.294|
000126  454a              CMP      r2,r9                 ;334
000128  ddf4              BLE      |L1.276|
00012a  1c49              ADDS     r1,r1,#1              ;332
                  |L1.300|
00012c  4541              CMP      r1,r8                 ;332
00012e  dde9              BLE      |L1.260|
000130  1c40              ADDS     r0,r0,#1              ;331
                  |L1.306|
000132  4560              CMP      r0,r12                ;331
000134  dde4              BLE      |L1.256|
                  |L1.310|
;;;338    	  }
;;;339          }
;;;340     have_c0min:
000136  bf00              NOP      
                  |L1.312|
;;;341      if (c0max > c0min)
000138  45bc              CMP      r12,r7
00013a  dd1c              BLE      |L1.374|
;;;342        for (c0 = c0max; c0 >= c0min; c0--)
00013c  4660              MOV      r0,r12
00013e  e018              B        |L1.370|
                  |L1.320|
;;;343          for (c1 = c1min; c1 <= c1max; c1++) {
000140  4631              MOV      r1,r6
000142  e013              B        |L1.364|
                  |L1.324|
;;;344    	histp = & histogram[c0][c1][c2min];
000144  f85ab020          LDR      r11,[r10,r0,LSL #2]
000148  eb0b1b81          ADD      r11,r11,r1,LSL #6
00014c  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;345    	for (c2 = c2min; c2 <= c2max; c2++)
000150  4622              MOV      r2,r4
000152  e008              B        |L1.358|
                  |L1.340|
;;;346    	  if (*histp++ != 0) {
000154  f835bb02          LDRH     r11,[r5],#2
000158  f1bb0f00          CMP      r11,#0
00015c  d002              BEQ      |L1.356|
;;;347    	    boxp->c0max = c0max = c0;
00015e  4684              MOV      r12,r0
000160  6058              STR      r0,[r3,#4]
;;;348    	    goto have_c0max;
000162  e009              B        |L1.376|
                  |L1.356|
000164  1c52              ADDS     r2,r2,#1              ;345
                  |L1.358|
000166  454a              CMP      r2,r9                 ;345
000168  ddf4              BLE      |L1.340|
00016a  1c49              ADDS     r1,r1,#1              ;343
                  |L1.364|
00016c  4541              CMP      r1,r8                 ;343
00016e  dde9              BLE      |L1.324|
000170  1e40              SUBS     r0,r0,#1              ;342
                  |L1.370|
000172  42b8              CMP      r0,r7                 ;342
000174  dae4              BGE      |L1.320|
                  |L1.374|
;;;349    	  }
;;;350          }
;;;351     have_c0max:
000176  bf00              NOP      
                  |L1.376|
;;;352      if (c1max > c1min)
000178  45b0              CMP      r8,r6
00017a  dd1c              BLE      |L1.438|
;;;353        for (c1 = c1min; c1 <= c1max; c1++)
00017c  4631              MOV      r1,r6
00017e  e018              B        |L1.434|
                  |L1.384|
;;;354          for (c0 = c0min; c0 <= c0max; c0++) {
000180  4638              MOV      r0,r7
000182  e013              B        |L1.428|
                  |L1.388|
;;;355    	histp = & histogram[c0][c1][c2min];
000184  f85ab020          LDR      r11,[r10,r0,LSL #2]
000188  eb0b1b81          ADD      r11,r11,r1,LSL #6
00018c  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;356    	for (c2 = c2min; c2 <= c2max; c2++)
000190  4622              MOV      r2,r4
000192  e008              B        |L1.422|
                  |L1.404|
;;;357    	  if (*histp++ != 0) {
000194  f835bb02          LDRH     r11,[r5],#2
000198  f1bb0f00          CMP      r11,#0
00019c  d002              BEQ      |L1.420|
;;;358    	    boxp->c1min = c1min = c1;
00019e  460e              MOV      r6,r1
0001a0  6099              STR      r1,[r3,#8]
;;;359    	    goto have_c1min;
0001a2  e009              B        |L1.440|
                  |L1.420|
0001a4  1c52              ADDS     r2,r2,#1              ;356
                  |L1.422|
0001a6  454a              CMP      r2,r9                 ;356
0001a8  ddf4              BLE      |L1.404|
0001aa  1c40              ADDS     r0,r0,#1              ;354
                  |L1.428|
0001ac  4560              CMP      r0,r12                ;354
0001ae  dde9              BLE      |L1.388|
0001b0  1c49              ADDS     r1,r1,#1              ;353
                  |L1.434|
0001b2  4541              CMP      r1,r8                 ;353
0001b4  dde4              BLE      |L1.384|
                  |L1.438|
;;;360    	  }
;;;361          }
;;;362     have_c1min:
0001b6  bf00              NOP      
                  |L1.440|
;;;363      if (c1max > c1min)
0001b8  45b0              CMP      r8,r6
0001ba  dd1c              BLE      |L1.502|
;;;364        for (c1 = c1max; c1 >= c1min; c1--)
0001bc  4641              MOV      r1,r8
0001be  e018              B        |L1.498|
                  |L1.448|
;;;365          for (c0 = c0min; c0 <= c0max; c0++) {
0001c0  4638              MOV      r0,r7
0001c2  e013              B        |L1.492|
                  |L1.452|
;;;366    	histp = & histogram[c0][c1][c2min];
0001c4  f85ab020          LDR      r11,[r10,r0,LSL #2]
0001c8  eb0b1b81          ADD      r11,r11,r1,LSL #6
0001cc  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;367    	for (c2 = c2min; c2 <= c2max; c2++)
0001d0  4622              MOV      r2,r4
0001d2  e008              B        |L1.486|
                  |L1.468|
;;;368    	  if (*histp++ != 0) {
0001d4  f835bb02          LDRH     r11,[r5],#2
0001d8  f1bb0f00          CMP      r11,#0
0001dc  d002              BEQ      |L1.484|
;;;369    	    boxp->c1max = c1max = c1;
0001de  4688              MOV      r8,r1
0001e0  60d9              STR      r1,[r3,#0xc]
;;;370    	    goto have_c1max;
0001e2  e009              B        |L1.504|
                  |L1.484|
0001e4  1c52              ADDS     r2,r2,#1              ;367
                  |L1.486|
0001e6  454a              CMP      r2,r9                 ;367
0001e8  ddf4              BLE      |L1.468|
0001ea  1c40              ADDS     r0,r0,#1              ;365
                  |L1.492|
0001ec  4560              CMP      r0,r12                ;365
0001ee  dde9              BLE      |L1.452|
0001f0  1e49              SUBS     r1,r1,#1              ;364
                  |L1.498|
0001f2  42b1              CMP      r1,r6                 ;364
0001f4  dae4              BGE      |L1.448|
                  |L1.502|
;;;371    	  }
;;;372          }
;;;373     have_c1max:
0001f6  bf00              NOP      
                  |L1.504|
;;;374      if (c2max > c2min)
0001f8  45a1              CMP      r9,r4
0001fa  dd1d              BLE      |L1.568|
;;;375        for (c2 = c2min; c2 <= c2max; c2++)
0001fc  4622              MOV      r2,r4
0001fe  e019              B        |L1.564|
                  |L1.512|
;;;376          for (c0 = c0min; c0 <= c0max; c0++) {
000200  4638              MOV      r0,r7
000202  e014              B        |L1.558|
                  |L1.516|
;;;377    	histp = & histogram[c0][c1min][c2];
000204  f85ab020          LDR      r11,[r10,r0,LSL #2]
000208  eb0b1b86          ADD      r11,r11,r6,LSL #6
00020c  eb0b0542          ADD      r5,r11,r2,LSL #1
;;;378    	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
000210  4631              MOV      r1,r6
000212  e009              B        |L1.552|
                  |L1.532|
;;;379    	  if (*histp != 0) {
000214  f8b5b000          LDRH     r11,[r5,#0]
000218  f1bb0f00          CMP      r11,#0
00021c  d002              BEQ      |L1.548|
;;;380    	    boxp->c2min = c2min = c2;
00021e  4614              MOV      r4,r2
000220  611a              STR      r2,[r3,#0x10]
;;;381    	    goto have_c2min;
000222  e00a              B        |L1.570|
                  |L1.548|
000224  1c49              ADDS     r1,r1,#1              ;378
000226  3540              ADDS     r5,r5,#0x40           ;378
                  |L1.552|
000228  4541              CMP      r1,r8                 ;378
00022a  ddf3              BLE      |L1.532|
00022c  1c40              ADDS     r0,r0,#1              ;376
                  |L1.558|
00022e  4560              CMP      r0,r12                ;376
000230  dde8              BLE      |L1.516|
000232  1c52              ADDS     r2,r2,#1              ;375
                  |L1.564|
000234  454a              CMP      r2,r9                 ;375
000236  dde3              BLE      |L1.512|
                  |L1.568|
;;;382    	  }
;;;383          }
;;;384     have_c2min:
000238  bf00              NOP      
                  |L1.570|
;;;385      if (c2max > c2min)
00023a  45a1              CMP      r9,r4
00023c  dd1d              BLE      |L1.634|
;;;386        for (c2 = c2max; c2 >= c2min; c2--)
00023e  464a              MOV      r2,r9
000240  e019              B        |L1.630|
                  |L1.578|
;;;387          for (c0 = c0min; c0 <= c0max; c0++) {
000242  4638              MOV      r0,r7
000244  e014              B        |L1.624|
                  |L1.582|
;;;388    	histp = & histogram[c0][c1min][c2];
000246  f85ab020          LDR      r11,[r10,r0,LSL #2]
00024a  eb0b1b86          ADD      r11,r11,r6,LSL #6
00024e  eb0b0542          ADD      r5,r11,r2,LSL #1
;;;389    	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
000252  4631              MOV      r1,r6
000254  e009              B        |L1.618|
                  |L1.598|
;;;390    	  if (*histp != 0) {
000256  f8b5b000          LDRH     r11,[r5,#0]
00025a  f1bb0f00          CMP      r11,#0
00025e  d002              BEQ      |L1.614|
;;;391    	    boxp->c2max = c2max = c2;
000260  4691              MOV      r9,r2
000262  615a              STR      r2,[r3,#0x14]
;;;392    	    goto have_c2max;
000264  e00a              B        |L1.636|
                  |L1.614|
000266  1c49              ADDS     r1,r1,#1              ;389
000268  3540              ADDS     r5,r5,#0x40           ;389
                  |L1.618|
00026a  4541              CMP      r1,r8                 ;389
00026c  ddf3              BLE      |L1.598|
00026e  1c40              ADDS     r0,r0,#1              ;387
                  |L1.624|
000270  4560              CMP      r0,r12                ;387
000272  dde8              BLE      |L1.582|
000274  1e52              SUBS     r2,r2,#1              ;386
                  |L1.630|
000276  42a2              CMP      r2,r4                 ;386
000278  dae3              BGE      |L1.578|
                  |L1.634|
;;;393    	  }
;;;394          }
;;;395     have_c2max:
00027a  bf00              NOP      
                  |L1.636|
;;;396    
;;;397      /* Update box volume.
;;;398       * We use 2-norm rather than real volume here; this biases the method
;;;399       * against making long narrow boxes, and it has the side benefit that
;;;400       * a box is splittable iff norm > 0.
;;;401       * Since the differences are expressed in histogram-cell units,
;;;402       * we have to shift back to JSAMPLE units to get consistent distances;
;;;403       * after which, we scale according to the selected distance scale factors.
;;;404       */
;;;405      dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
00027c  ebac0b07          SUB      r11,r12,r7
000280  ea4f1e0b          LSL      lr,r11,#4
000284  f8cde00c          STR      lr,[sp,#0xc]
;;;406      dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
000288  eba80b06          SUB      r11,r8,r6
00028c  ea4f0b8b          LSL      r11,r11,#2
000290  eb0b0b4b          ADD      r11,r11,r11,LSL #1
000294  f8cdb008          STR      r11,[sp,#8]
;;;407      dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
000298  eba90b04          SUB      r11,r9,r4
00029c  ea4f0bcb          LSL      r11,r11,#3
0002a0  f8cdb004          STR      r11,[sp,#4]
;;;408      boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
0002a4  f8dde00c          LDR      lr,[sp,#0xc]
0002a8  fb0efe0e          MUL      lr,lr,lr
0002ac  f8ddb008          LDR      r11,[sp,#8]
0002b0  fb0bee0b          MLA      lr,r11,r11,lr
0002b4  f8ddb004          LDR      r11,[sp,#4]
0002b8  fb0beb0b          MLA      r11,r11,r11,lr
0002bc  f8c3b018          STR      r11,[r3,#0x18]
;;;409      
;;;410      /* Now scan remaining volume of box and compute population */
;;;411      ccount = 0;
0002c0  f04f0b00          MOV      r11,#0
0002c4  f8cdb000          STR      r11,[sp,#0]
;;;412      for (c0 = c0min; c0 <= c0max; c0++)
0002c8  4638              MOV      r0,r7
0002ca  e01c              B        |L1.774|
                  |L1.716|
;;;413        for (c1 = c1min; c1 <= c1max; c1++) {
0002cc  4631              MOV      r1,r6
0002ce  e017              B        |L1.768|
                  |L1.720|
;;;414          histp = & histogram[c0][c1][c2min];
0002d0  f85ab020          LDR      r11,[r10,r0,LSL #2]
0002d4  eb0b1b81          ADD      r11,r11,r1,LSL #6
0002d8  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;415          for (c2 = c2min; c2 <= c2max; c2++, histp++)
0002dc  4622              MOV      r2,r4
0002de  e00c              B        |L1.762|
                  |L1.736|
;;;416    	if (*histp != 0) {
0002e0  f8b5b000          LDRH     r11,[r5,#0]
0002e4  f1bb0f00          CMP      r11,#0
0002e8  d005              BEQ      |L1.758|
;;;417    	  ccount++;
0002ea  f8ddb000          LDR      r11,[sp,#0]
0002ee  f10b0b01          ADD      r11,r11,#1
0002f2  f8cdb000          STR      r11,[sp,#0]
                  |L1.758|
0002f6  1c52              ADDS     r2,r2,#1              ;415
0002f8  1cad              ADDS     r5,r5,#2              ;415
                  |L1.762|
0002fa  454a              CMP      r2,r9                 ;415
0002fc  ddf0              BLE      |L1.736|
0002fe  1c49              ADDS     r1,r1,#1              ;413
                  |L1.768|
000300  4541              CMP      r1,r8                 ;413
000302  dde5              BLE      |L1.720|
000304  1c40              ADDS     r0,r0,#1              ;412
                  |L1.774|
000306  4560              CMP      r0,r12                ;412
000308  dde0              BLE      |L1.716|
;;;418    	}
;;;419        }
;;;420      boxp->colorcount = ccount;
00030a  f8ddb000          LDR      r11,[sp,#0]
00030e  f8c3b01c          STR      r11,[r3,#0x1c]
;;;421    }
000312  b007              ADD      sp,sp,#0x1c
000314  e8bd8ff0          POP      {r4-r11,pc}
;;;422    
                          ENDP

                  median_cut PROC
;;;424    LOCAL(int)
;;;425    median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
000318  e92d4fff          PUSH     {r0-r11,lr}
;;;426    	    int desired_colors)
;;;427    /* Repeatedly select and split the largest box until we have enough boxes */
;;;428    {
00031c  b083              SUB      sp,sp,#0xc
00031e  4688              MOV      r8,r1
000320  4616              MOV      r6,r2
000322  4699              MOV      r9,r3
;;;429      int n,lb;
;;;430      int c0,c1,c2,cmax;
;;;431      register boxptr b1,b2;
;;;432    
;;;433      while (numboxes < desired_colors) {
000324  e06d              B        |L1.1026|
                  |L1.806|
;;;434        /* Select box to split.
;;;435         * Current algorithm: by population for first half, then by volume.
;;;436         */
;;;437        if (numboxes*2 <= desired_colors) {
000326  ebb90f46          CMP      r9,r6,LSL #1
00032a  db05              BLT      |L1.824|
;;;438          b1 = find_biggest_color_pop(boxlist, numboxes);
00032c  4631              MOV      r1,r6
00032e  4640              MOV      r0,r8
000330  f7fffffe          BL       find_biggest_color_pop
000334  4604              MOV      r4,r0
000336  e004              B        |L1.834|
                  |L1.824|
;;;439        } else {
;;;440          b1 = find_biggest_volume(boxlist, numboxes);
000338  4631              MOV      r1,r6
00033a  4640              MOV      r0,r8
00033c  f7fffffe          BL       find_biggest_volume
000340  4604              MOV      r4,r0
                  |L1.834|
;;;441        }
;;;442        if (b1 == NULL)		/* no splittable boxes left! */
000342  b904              CBNZ     r4,|L1.838|
;;;443          break;
000344  e05f              B        |L1.1030|
                  |L1.838|
;;;444        b2 = &boxlist[numboxes];	/* where new box will go */
000346  eb081546          ADD      r5,r8,r6,LSL #5
;;;445        /* Copy the color bounds to the new box. */
;;;446        b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
00034a  6860              LDR      r0,[r4,#4]
00034c  6068              STR      r0,[r5,#4]
00034e  68e0              LDR      r0,[r4,#0xc]
000350  60e8              STR      r0,[r5,#0xc]
000352  6960              LDR      r0,[r4,#0x14]
000354  6168              STR      r0,[r5,#0x14]
;;;447        b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
000356  6820              LDR      r0,[r4,#0]
000358  6028              STR      r0,[r5,#0]
00035a  68a0              LDR      r0,[r4,#8]
00035c  60a8              STR      r0,[r5,#8]
00035e  6920              LDR      r0,[r4,#0x10]
000360  6128              STR      r0,[r5,#0x10]
;;;448        /* Choose which axis to split the box on.
;;;449         * Current algorithm: longest scaled axis.
;;;450         * See notes in update_box about scaling distances.
;;;451         */
;;;452        c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
000362  e9d41000          LDRD     r1,r0,[r4,#0]
000366  1a40              SUBS     r0,r0,r1
000368  0100              LSLS     r0,r0,#4
00036a  9001              STR      r0,[sp,#4]
;;;453        c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
00036c  e9d41002          LDRD     r1,r0,[r4,#8]
000370  1a40              SUBS     r0,r0,r1
000372  0080              LSLS     r0,r0,#2
000374  eb000a40          ADD      r10,r0,r0,LSL #1
;;;454        c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
000378  e9d41004          LDRD     r1,r0,[r4,#0x10]
00037c  1a40              SUBS     r0,r0,r1
00037e  ea4f0bc0          LSL      r11,r0,#3
;;;455        /* We want to break any ties in favor of green, then red, blue last.
;;;456         * This code does the right thing for R,G,B or B,G,R color orders only.
;;;457         */
;;;458    #if RGB_RED == 0
;;;459        cmax = c1; n = 1;
000382  f8cda000          STR      r10,[sp,#0]
000386  2001              MOVS     r0,#1
000388  9002              STR      r0,[sp,#8]
;;;460        if (c0 > cmax) { cmax = c0; n = 0; }
00038a  e9dda000          LDRD     r10,r0,[sp,#0]
00038e  4550              CMP      r0,r10
000390  dd03              BLE      |L1.922|
000392  9801              LDR      r0,[sp,#4]
000394  9000              STR      r0,[sp,#0]
000396  2000              MOVS     r0,#0
000398  9002              STR      r0,[sp,#8]
                  |L1.922|
;;;461        if (c2 > cmax) { n = 2; }
00039a  9800              LDR      r0,[sp,#0]
00039c  4583              CMP      r11,r0
00039e  dd01              BLE      |L1.932|
0003a0  2002              MOVS     r0,#2
0003a2  9002              STR      r0,[sp,#8]
                  |L1.932|
;;;462    #else
;;;463        cmax = c1; n = 1;
;;;464        if (c2 > cmax) { cmax = c2; n = 2; }
;;;465        if (c0 > cmax) { n = 0; }
;;;466    #endif
;;;467        /* Choose split point along selected axis, and update box bounds.
;;;468         * Current algorithm: split at halfway point.
;;;469         * (Since the box has been shrunk to minimum volume,
;;;470         * any split will produce two nonempty subboxes.)
;;;471         * Note that lb value is max for lower box, so must be < old max.
;;;472         */
;;;473        switch (n) {
0003a4  9802              LDR      r0,[sp,#8]
0003a6  b120              CBZ      r0,|L1.946|
0003a8  2801              CMP      r0,#1
0003aa  d00c              BEQ      |L1.966|
0003ac  2802              CMP      r0,#2
0003ae  d11e              BNE      |L1.1006|
0003b0  e013              B        |L1.986|
                  |L1.946|
;;;474        case 0:
;;;475          lb = (b1->c0max + b1->c0min) / 2;
0003b2  e9d42100          LDRD     r2,r1,[r4,#0]
0003b6  1888              ADDS     r0,r1,r2
0003b8  eb0071d0          ADD      r1,r0,r0,LSR #31
0003bc  104f              ASRS     r7,r1,#1
;;;476          b1->c0max = lb;
0003be  6067              STR      r7,[r4,#4]
;;;477          b2->c0min = lb+1;
0003c0  1c78              ADDS     r0,r7,#1
0003c2  6028              STR      r0,[r5,#0]
;;;478          break;
0003c4  e013              B        |L1.1006|
                  |L1.966|
;;;479        case 1:
;;;480          lb = (b1->c1max + b1->c1min) / 2;
0003c6  e9d42102          LDRD     r2,r1,[r4,#8]
0003ca  1888              ADDS     r0,r1,r2
0003cc  eb0071d0          ADD      r1,r0,r0,LSR #31
0003d0  104f              ASRS     r7,r1,#1
;;;481          b1->c1max = lb;
0003d2  60e7              STR      r7,[r4,#0xc]
;;;482          b2->c1min = lb+1;
0003d4  1c78              ADDS     r0,r7,#1
0003d6  60a8              STR      r0,[r5,#8]
;;;483          break;
0003d8  e009              B        |L1.1006|
                  |L1.986|
;;;484        case 2:
;;;485          lb = (b1->c2max + b1->c2min) / 2;
0003da  e9d42104          LDRD     r2,r1,[r4,#0x10]
0003de  1888              ADDS     r0,r1,r2
0003e0  eb0071d0          ADD      r1,r0,r0,LSR #31
0003e4  104f              ASRS     r7,r1,#1
;;;486          b1->c2max = lb;
0003e6  6167              STR      r7,[r4,#0x14]
;;;487          b2->c2min = lb+1;
0003e8  1c78              ADDS     r0,r7,#1
0003ea  6128              STR      r0,[r5,#0x10]
;;;488          break;
0003ec  bf00              NOP      
                  |L1.1006|
0003ee  bf00              NOP                            ;478
;;;489        }
;;;490        /* Update stats for boxes */
;;;491        update_box(cinfo, b1);
0003f0  4621              MOV      r1,r4
0003f2  9803              LDR      r0,[sp,#0xc]
0003f4  f7fffffe          BL       update_box
;;;492        update_box(cinfo, b2);
0003f8  4629              MOV      r1,r5
0003fa  9803              LDR      r0,[sp,#0xc]
0003fc  f7fffffe          BL       update_box
;;;493        numboxes++;
000400  1c76              ADDS     r6,r6,#1
                  |L1.1026|
000402  454e              CMP      r6,r9                 ;433
000404  db8f              BLT      |L1.806|
                  |L1.1030|
000406  bf00              NOP                            ;443
;;;494      }
;;;495      return numboxes;
000408  4630              MOV      r0,r6
;;;496    }
00040a  b007              ADD      sp,sp,#0x1c
00040c  e8bd8ff0          POP      {r4-r11,pc}
;;;497    
                          ENDP

                  compute_color PROC
;;;499    LOCAL(void)
;;;500    compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
000410  e92d4ff0          PUSH     {r4-r11,lr}
;;;501    /* Compute representative color for a box, put it in colormap[icolor] */
;;;502    {
000414  b088              SUB      sp,sp,#0x20
000416  4603              MOV      r3,r0
000418  4614              MOV      r4,r2
;;;503      /* Current algorithm: mean weighted by pixels (not colors) */
;;;504      /* Note it is important to get the rounding correct! */
;;;505      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00041a  f8d3b1cc          LDR      r11,[r3,#0x1cc]
00041e  f8cdb01c          STR      r11,[sp,#0x1c]
;;;506      hist3d histogram = cquantize->histogram;
000422  f8ddb01c          LDR      r11,[sp,#0x1c]
000426  f8dbb018          LDR      r11,[r11,#0x18]
00042a  f8cdb018          STR      r11,[sp,#0x18]
;;;507      histptr histp;
;;;508      int c0,c1,c2;
;;;509      int c0min,c0max,c1min,c1max,c2min,c2max;
;;;510      long count;
;;;511      long total = 0;
00042e  2000              MOVS     r0,#0
;;;512      long c0total = 0;
000430  4684              MOV      r12,r0
;;;513      long c1total = 0;
000432  4680              MOV      r8,r0
;;;514      long c2total = 0;
000434  4681              MOV      r9,r0
;;;515      
;;;516      c0min = boxp->c0min;  c0max = boxp->c0max;
000436  f8d1b000          LDR      r11,[r1,#0]
00043a  f8cdb014          STR      r11,[sp,#0x14]
00043e  f8d1b004          LDR      r11,[r1,#4]
000442  f8cdb010          STR      r11,[sp,#0x10]
;;;517      c1min = boxp->c1min;  c1max = boxp->c1max;
000446  f8d1b008          LDR      r11,[r1,#8]
00044a  f8cdb00c          STR      r11,[sp,#0xc]
00044e  f8d1b00c          LDR      r11,[r1,#0xc]
000452  f8cdb008          STR      r11,[sp,#8]
;;;518      c2min = boxp->c2min;  c2max = boxp->c2max;
000456  f8d1b010          LDR      r11,[r1,#0x10]
00045a  f8cdb004          STR      r11,[sp,#4]
00045e  f8d1b014          LDR      r11,[r1,#0x14]
000462  f8cdb000          STR      r11,[sp,#0]
;;;519      
;;;520      for (c0 = c0min; c0 <= c0max; c0++)
000466  9d05              LDR      r5,[sp,#0x14]
000468  e02e              B        |L1.1224|
                  |L1.1130|
;;;521        for (c1 = c1min; c1 <= c1max; c1++) {
00046a  9e03              LDR      r6,[sp,#0xc]
00046c  e027              B        |L1.1214|
                  |L1.1134|
;;;522          histp = & histogram[c0][c1][c2min];
00046e  f8ddb018          LDR      r11,[sp,#0x18]
000472  f85bb025          LDR      r11,[r11,r5,LSL #2]
000476  eb0b1e86          ADD      lr,r11,r6,LSL #6
00047a  f8ddb004          LDR      r11,[sp,#4]
00047e  eb0e0a4b          ADD      r10,lr,r11,LSL #1
;;;523          for (c2 = c2min; c2 <= c2max; c2++) {
000482  9f01              LDR      r7,[sp,#4]
000484  e016              B        |L1.1204|
                  |L1.1158|
;;;524    	if ((count = *histp++) != 0) {
000486  f83a2b02          LDRH     r2,[r10],#2
00048a  b192              CBZ      r2,|L1.1202|
;;;525    	  total += count;
00048c  4410              ADD      r0,r0,r2
;;;526    	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
00048e  f04f0b04          MOV      r11,#4
000492  eb0b0bc5          ADD      r11,r11,r5,LSL #3
000496  fb0bcc02          MLA      r12,r11,r2,r12
;;;527    	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
00049a  f04f0b02          MOV      r11,#2
00049e  eb0b0b86          ADD      r11,r11,r6,LSL #2
0004a2  fb0b8802          MLA      r8,r11,r2,r8
;;;528    	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
0004a6  f04f0b04          MOV      r11,#4
0004aa  eb0b0bc7          ADD      r11,r11,r7,LSL #3
0004ae  fb0b9902          MLA      r9,r11,r2,r9
                  |L1.1202|
0004b2  1c7f              ADDS     r7,r7,#1              ;523
                  |L1.1204|
0004b4  f8ddb000          LDR      r11,[sp,#0]           ;523
0004b8  455f              CMP      r7,r11                ;523
0004ba  dde4              BLE      |L1.1158|
0004bc  1c76              ADDS     r6,r6,#1              ;521
                  |L1.1214|
0004be  f8ddb008          LDR      r11,[sp,#8]           ;521
0004c2  455e              CMP      r6,r11                ;521
0004c4  ddd3              BLE      |L1.1134|
0004c6  1c6d              ADDS     r5,r5,#1              ;520
                  |L1.1224|
0004c8  f8ddb010          LDR      r11,[sp,#0x10]        ;520
0004cc  455d              CMP      r5,r11                ;520
0004ce  ddcc              BLE      |L1.1130|
;;;529    	}
;;;530          }
;;;531        }
;;;532      
;;;533      cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
0004d0  eb0c0b60          ADD      r11,r12,r0,ASR #1
0004d4  fb9bfbf0          SDIV     r11,r11,r0
0004d8  f8d3e088          LDR      lr,[r3,#0x88]
0004dc  f8dee000          LDR      lr,[lr,#0]
0004e0  f80eb004          STRB     r11,[lr,r4]
;;;534      cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
0004e4  eb080b60          ADD      r11,r8,r0,ASR #1
0004e8  fb9bfbf0          SDIV     r11,r11,r0
0004ec  f8d3e088          LDR      lr,[r3,#0x88]
0004f0  f8dee004          LDR      lr,[lr,#4]
0004f4  f80eb004          STRB     r11,[lr,r4]
;;;535      cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
0004f8  eb090b60          ADD      r11,r9,r0,ASR #1
0004fc  fb9bfbf0          SDIV     r11,r11,r0
000500  f8d3e088          LDR      lr,[r3,#0x88]
000504  f8dee008          LDR      lr,[lr,#8]
000508  f80eb004          STRB     r11,[lr,r4]
;;;536    }
00050c  b008              ADD      sp,sp,#0x20
00050e  e8bd8ff0          POP      {r4-r11,pc}
;;;537    
                          ENDP

                  select_colors PROC
;;;539    LOCAL(void)
;;;540    select_colors (j_decompress_ptr cinfo, int desired_colors)
000512  e92d41f0          PUSH     {r4-r8,lr}
;;;541    /* Master routine for color selection */
;;;542    {
000516  4605              MOV      r5,r0
000518  4688              MOV      r8,r1
;;;543      boxptr boxlist;
;;;544      int numboxes;
;;;545      int i;
;;;546    
;;;547      /* Allocate workspace for box list */
;;;548      boxlist = (boxptr) (*cinfo->mem->alloc_small)
00051a  ea4f1248          LSL      r2,r8,#5
00051e  6868              LDR      r0,[r5,#4]
000520  2101              MOVS     r1,#1
000522  6803              LDR      r3,[r0,#0]
000524  4628              MOV      r0,r5
000526  4798              BLX      r3
000528  4604              MOV      r4,r0
;;;549        ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
;;;550      /* Initialize one box containing whole space */
;;;551      numboxes = 1;
00052a  2601              MOVS     r6,#1
;;;552      boxlist[0].c0min = 0;
00052c  2000              MOVS     r0,#0
00052e  6020              STR      r0,[r4,#0]
;;;553      boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
000530  201f              MOVS     r0,#0x1f
000532  6060              STR      r0,[r4,#4]
;;;554      boxlist[0].c1min = 0;
000534  2000              MOVS     r0,#0
000536  60a0              STR      r0,[r4,#8]
;;;555      boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
000538  203f              MOVS     r0,#0x3f
00053a  60e0              STR      r0,[r4,#0xc]
;;;556      boxlist[0].c2min = 0;
00053c  2000              MOVS     r0,#0
00053e  6120              STR      r0,[r4,#0x10]
;;;557      boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
000540  201f              MOVS     r0,#0x1f
000542  6160              STR      r0,[r4,#0x14]
;;;558      /* Shrink it to actually-used volume and set its statistics */
;;;559      update_box(cinfo, & boxlist[0]);
000544  4621              MOV      r1,r4
000546  4628              MOV      r0,r5
000548  f7fffffe          BL       update_box
;;;560      /* Perform median-cut to produce final box list */
;;;561      numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
00054c  4643              MOV      r3,r8
00054e  4632              MOV      r2,r6
000550  4621              MOV      r1,r4
000552  4628              MOV      r0,r5
000554  f7fffffe          BL       median_cut
000558  4606              MOV      r6,r0
;;;562      /* Compute the representative color for each box, fill colormap */
;;;563      for (i = 0; i < numboxes; i++)
00055a  2700              MOVS     r7,#0
00055c  e006              B        |L1.1388|
                  |L1.1374|
;;;564        compute_color(cinfo, & boxlist[i], i);
00055e  eb041147          ADD      r1,r4,r7,LSL #5
000562  463a              MOV      r2,r7
000564  4628              MOV      r0,r5
000566  f7fffffe          BL       compute_color
00056a  1c7f              ADDS     r7,r7,#1              ;563
                  |L1.1388|
00056c  42b7              CMP      r7,r6                 ;563
00056e  dbf6              BLT      |L1.1374|
;;;565      cinfo->actual_number_of_colors = numboxes;
000570  f8c56084          STR      r6,[r5,#0x84]
;;;566      TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
000574  2060              MOVS     r0,#0x60
000576  6829              LDR      r1,[r5,#0]
000578  6148              STR      r0,[r1,#0x14]
00057a  6828              LDR      r0,[r5,#0]
00057c  6186              STR      r6,[r0,#0x18]
00057e  6828              LDR      r0,[r5,#0]
000580  2101              MOVS     r1,#1
000582  6842              LDR      r2,[r0,#4]
000584  4628              MOV      r0,r5
000586  4790              BLX      r2
;;;567    }
000588  e8bd81f0          POP      {r4-r8,pc}
;;;568    
                          ENDP

                  find_nearby_colors PROC
;;;646    LOCAL(int)
;;;647    find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
00058c  e92d4fff          PUSH     {r0-r11,lr}
;;;648    		    JSAMPLE colorlist[])
;;;649    /* Locate the colormap entries close enough to an update box to be candidates
;;;650     * for the nearest entry to some cell(s) in the update box.  The update box
;;;651     * is specified by the center coordinates of its first cell.  The number of
;;;652     * candidate colormap entries is returned, and their colormap indexes are
;;;653     * placed in colorlist[].
;;;654     * This routine uses Heckbert's "locally sorted search" criterion to select
;;;655     * the colors that need further consideration.
;;;656     */
;;;657    {
000590  f5ad6d83          SUB      sp,sp,#0x418
000594  460d              MOV      r5,r1
000596  4616              MOV      r6,r2
000598  461f              MOV      r7,r3
;;;658      int numcolors = cinfo->actual_number_of_colors;
00059a  f8dd0418          LDR      r0,[sp,#0x418]
00059e  f8d00084          LDR      r0,[r0,#0x84]
0005a2  f8cd0414          STR      r0,[sp,#0x414]
;;;659      int maxc0, maxc1, maxc2;
;;;660      int centerc0, centerc1, centerc2;
;;;661      int i, x, ncolors;
;;;662      INT32 minmaxdist, min_dist, max_dist, tdist;
;;;663      INT32 mindist[MAXNUMCOLORS];	/* min distance to colormap entry i */
;;;664    
;;;665      /* Compute true coordinates of update box's upper corner and center.
;;;666       * Actually we compute the coordinates of the center of the upper-corner
;;;667       * histogram cell, which are the upper bounds of the volume we care about.
;;;668       * Note that since ">>" rounds down, the "center" values may be closer to
;;;669       * min than to max; hence comparisons to them must be "<=", not "<".
;;;670       */
;;;671      maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
0005a6  f1050c18          ADD      r12,r5,#0x18
;;;672      centerc0 = (minc0 + maxc0) >> 1;
0005aa  eb05000c          ADD      r0,r5,r12
0005ae  1040              ASRS     r0,r0,#1
0005b0  f8cd0410          STR      r0,[sp,#0x410]
;;;673      maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
0005b4  f106081c          ADD      r8,r6,#0x1c
;;;674      centerc1 = (minc1 + maxc1) >> 1;
0005b8  eb060008          ADD      r0,r6,r8
0005bc  1040              ASRS     r0,r0,#1
0005be  f8cd040c          STR      r0,[sp,#0x40c]
;;;675      maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
0005c2  f1070918          ADD      r9,r7,#0x18
;;;676      centerc2 = (minc2 + maxc2) >> 1;
0005c6  eb070009          ADD      r0,r7,r9
0005ca  1040              ASRS     r0,r0,#1
0005cc  f8cd0408          STR      r0,[sp,#0x408]
;;;677    
;;;678      /* For each color in colormap, find:
;;;679       *  1. its minimum squared-distance to any point in the update box
;;;680       *     (zero if color is within update box);
;;;681       *  2. its maximum squared-distance to any point in the update box.
;;;682       * Both of these can be found by considering only the corners of the box.
;;;683       * We save the minimum distance for each color in mindist[];
;;;684       * only the smallest maximum distance is of interest.
;;;685       */
;;;686      minmaxdist = 0x7FFFFFFFL;
0005d0  f06f4000          MVN      r0,#0x80000000
0005d4  f8cd0400          STR      r0,[sp,#0x400]
;;;687    
;;;688      for (i = 0; i < numcolors; i++) {
0005d8  2300              MOVS     r3,#0
0005da  e08e              B        |L1.1786|
                  |L1.1500|
;;;689        /* We compute the squared-c0-distance term, then add in the other two. */
;;;690        x = GETJSAMPLE(cinfo->colormap[0][i]);
0005dc  f8dd0418          LDR      r0,[sp,#0x418]
0005e0  f8d00088          LDR      r0,[r0,#0x88]
0005e4  6800              LDR      r0,[r0,#0]
0005e6  5cc2              LDRB     r2,[r0,r3]
;;;691        if (x < minc0) {
0005e8  42aa              CMP      r2,r5
0005ea  da09              BGE      |L1.1536|
;;;692          tdist = (x - minc0) * C0_SCALE;
0005ec  1b50              SUBS     r0,r2,r5
0005ee  0041              LSLS     r1,r0,#1
;;;693          min_dist = tdist*tdist;
0005f0  fb01fa01          MUL      r10,r1,r1
;;;694          tdist = (x - maxc0) * C0_SCALE;
0005f4  eba2000c          SUB      r0,r2,r12
0005f8  0041              LSLS     r1,r0,#1
;;;695          max_dist = tdist*tdist;
0005fa  fb01f401          MUL      r4,r1,r1
0005fe  e01b              B        |L1.1592|
                  |L1.1536|
;;;696        } else if (x > maxc0) {
000600  4562              CMP      r2,r12
000602  dd09              BLE      |L1.1560|
;;;697          tdist = (x - maxc0) * C0_SCALE;
000604  eba2000c          SUB      r0,r2,r12
000608  0041              LSLS     r1,r0,#1
;;;698          min_dist = tdist*tdist;
00060a  fb01fa01          MUL      r10,r1,r1
;;;699          tdist = (x - minc0) * C0_SCALE;
00060e  1b50              SUBS     r0,r2,r5
000610  0041              LSLS     r1,r0,#1
;;;700          max_dist = tdist*tdist;
000612  fb01f401          MUL      r4,r1,r1
000616  e00f              B        |L1.1592|
                  |L1.1560|
;;;701        } else {
;;;702          /* within cell range so no contribution to min_dist */
;;;703          min_dist = 0;
000618  f04f0a00          MOV      r10,#0
;;;704          if (x <= centerc0) {
00061c  f8dd0410          LDR      r0,[sp,#0x410]
000620  4282              CMP      r2,r0
000622  dc05              BGT      |L1.1584|
;;;705    	tdist = (x - maxc0) * C0_SCALE;
000624  eba2000c          SUB      r0,r2,r12
000628  0041              LSLS     r1,r0,#1
;;;706    	max_dist = tdist*tdist;
00062a  fb01f401          MUL      r4,r1,r1
00062e  e003              B        |L1.1592|
                  |L1.1584|
;;;707          } else {
;;;708    	tdist = (x - minc0) * C0_SCALE;
000630  1b50              SUBS     r0,r2,r5
000632  0041              LSLS     r1,r0,#1
;;;709    	max_dist = tdist*tdist;
000634  fb01f401          MUL      r4,r1,r1
                  |L1.1592|
;;;710          }
;;;711        }
;;;712    
;;;713        x = GETJSAMPLE(cinfo->colormap[1][i]);
000638  f8dd0418          LDR      r0,[sp,#0x418]
00063c  f8d00088          LDR      r0,[r0,#0x88]
000640  6840              LDR      r0,[r0,#4]
000642  5cc2              LDRB     r2,[r0,r3]
;;;714        if (x < minc1) {
000644  42b2              CMP      r2,r6
000646  da0b              BGE      |L1.1632|
;;;715          tdist = (x - minc1) * C1_SCALE;
000648  1b90              SUBS     r0,r2,r6
00064a  eb000140          ADD      r1,r0,r0,LSL #1
;;;716          min_dist += tdist*tdist;
00064e  fb01aa01          MLA      r10,r1,r1,r10
;;;717          tdist = (x - maxc1) * C1_SCALE;
000652  eba20008          SUB      r0,r2,r8
000656  eb000140          ADD      r1,r0,r0,LSL #1
;;;718          max_dist += tdist*tdist;
00065a  fb014401          MLA      r4,r1,r1,r4
00065e  e01d              B        |L1.1692|
                  |L1.1632|
;;;719        } else if (x > maxc1) {
000660  4542              CMP      r2,r8
000662  dd0b              BLE      |L1.1660|
;;;720          tdist = (x - maxc1) * C1_SCALE;
000664  eba20008          SUB      r0,r2,r8
000668  eb000140          ADD      r1,r0,r0,LSL #1
;;;721          min_dist += tdist*tdist;
00066c  fb01aa01          MLA      r10,r1,r1,r10
;;;722          tdist = (x - minc1) * C1_SCALE;
000670  1b90              SUBS     r0,r2,r6
000672  eb000140          ADD      r1,r0,r0,LSL #1
;;;723          max_dist += tdist*tdist;
000676  fb014401          MLA      r4,r1,r1,r4
00067a  e00f              B        |L1.1692|
                  |L1.1660|
;;;724        } else {
;;;725          /* within cell range so no contribution to min_dist */
;;;726          if (x <= centerc1) {
00067c  f8dd040c          LDR      r0,[sp,#0x40c]
000680  4282              CMP      r2,r0
000682  dc06              BGT      |L1.1682|
;;;727    	tdist = (x - maxc1) * C1_SCALE;
000684  eba20008          SUB      r0,r2,r8
000688  eb000140          ADD      r1,r0,r0,LSL #1
;;;728    	max_dist += tdist*tdist;
00068c  fb014401          MLA      r4,r1,r1,r4
000690  e004              B        |L1.1692|
                  |L1.1682|
;;;729          } else {
;;;730    	tdist = (x - minc1) * C1_SCALE;
000692  1b90              SUBS     r0,r2,r6
000694  eb000140          ADD      r1,r0,r0,LSL #1
;;;731    	max_dist += tdist*tdist;
000698  fb014401          MLA      r4,r1,r1,r4
                  |L1.1692|
;;;732          }
;;;733        }
;;;734    
;;;735        x = GETJSAMPLE(cinfo->colormap[2][i]);
00069c  f8dd0418          LDR      r0,[sp,#0x418]
0006a0  f8d00088          LDR      r0,[r0,#0x88]
0006a4  6880              LDR      r0,[r0,#8]
0006a6  5cc2              LDRB     r2,[r0,r3]
;;;736        if (x < minc2) {
0006a8  42ba              CMP      r2,r7
0006aa  da07              BGE      |L1.1724|
;;;737          tdist = (x - minc2) * C2_SCALE;
0006ac  1bd1              SUBS     r1,r2,r7
;;;738          min_dist += tdist*tdist;
0006ae  fb01aa01          MLA      r10,r1,r1,r10
;;;739          tdist = (x - maxc2) * C2_SCALE;
0006b2  eba20109          SUB      r1,r2,r9
;;;740          max_dist += tdist*tdist;
0006b6  fb014401          MLA      r4,r1,r1,r4
0006ba  e015              B        |L1.1768|
                  |L1.1724|
;;;741        } else if (x > maxc2) {
0006bc  454a              CMP      r2,r9
0006be  dd07              BLE      |L1.1744|
;;;742          tdist = (x - maxc2) * C2_SCALE;
0006c0  eba20109          SUB      r1,r2,r9
;;;743          min_dist += tdist*tdist;
0006c4  fb01aa01          MLA      r10,r1,r1,r10
;;;744          tdist = (x - minc2) * C2_SCALE;
0006c8  1bd1              SUBS     r1,r2,r7
;;;745          max_dist += tdist*tdist;
0006ca  fb014401          MLA      r4,r1,r1,r4
0006ce  e00b              B        |L1.1768|
                  |L1.1744|
;;;746        } else {
;;;747          /* within cell range so no contribution to min_dist */
;;;748          if (x <= centerc2) {
0006d0  f8dd0408          LDR      r0,[sp,#0x408]
0006d4  4282              CMP      r2,r0
0006d6  dc04              BGT      |L1.1762|
;;;749    	tdist = (x - maxc2) * C2_SCALE;
0006d8  eba20109          SUB      r1,r2,r9
;;;750    	max_dist += tdist*tdist;
0006dc  fb014401          MLA      r4,r1,r1,r4
0006e0  e002              B        |L1.1768|
                  |L1.1762|
;;;751          } else {
;;;752    	tdist = (x - minc2) * C2_SCALE;
0006e2  1bd1              SUBS     r1,r2,r7
;;;753    	max_dist += tdist*tdist;
0006e4  fb014401          MLA      r4,r1,r1,r4
                  |L1.1768|
;;;754          }
;;;755        }
;;;756    
;;;757        mindist[i] = min_dist;	/* save away the results */
0006e8  f84da023          STR      r10,[sp,r3,LSL #2]
;;;758        if (max_dist < minmaxdist)
0006ec  f8dd0400          LDR      r0,[sp,#0x400]
0006f0  4284              CMP      r4,r0
0006f2  da01              BGE      |L1.1784|
;;;759          minmaxdist = max_dist;
0006f4  f8cd4400          STR      r4,[sp,#0x400]
                  |L1.1784|
0006f8  1c5b              ADDS     r3,r3,#1              ;688
                  |L1.1786|
0006fa  f8dd0414          LDR      r0,[sp,#0x414]        ;688
0006fe  4283              CMP      r3,r0                 ;688
000700  f6ffaf6c          BLT      |L1.1500|
;;;760      }
;;;761    
;;;762      /* Now we know that no cell in the update box is more than minmaxdist
;;;763       * away from some colormap entry.  Therefore, only colors that are
;;;764       * within minmaxdist of some part of the box need be considered.
;;;765       */
;;;766      ncolors = 0;
000704  2000              MOVS     r0,#0
000706  f8cd0404          STR      r0,[sp,#0x404]
;;;767      for (i = 0; i < numcolors; i++) {
00070a  2300              MOVS     r3,#0
00070c  e010              B        |L1.1840|
                  |L1.1806|
;;;768        if (mindist[i] <= minmaxdist)
00070e  f85db023          LDR      r11,[sp,r3,LSL #2]
000712  f8dd0400          LDR      r0,[sp,#0x400]
000716  4583              CMP      r11,r0
000718  dc09              BGT      |L1.1838|
;;;769          colorlist[ncolors++] = (JSAMPLE) i;
00071a  f8dd0404          LDR      r0,[sp,#0x404]
00071e  f1000e01          ADD      lr,r0,#1
000722  f8cde404          STR      lr,[sp,#0x404]
000726  f8dde44c          LDR      lr,[sp,#0x44c]
00072a  f80e3000          STRB     r3,[lr,r0]
                  |L1.1838|
00072e  1c5b              ADDS     r3,r3,#1              ;767
                  |L1.1840|
000730  f8dd0414          LDR      r0,[sp,#0x414]        ;767
000734  4283              CMP      r3,r0                 ;767
000736  dbea              BLT      |L1.1806|
;;;770      }
;;;771      return ncolors;
000738  f8dd0404          LDR      r0,[sp,#0x404]
;;;772    }
00073c  f50d6d85          ADD      sp,sp,#0x428
000740  e8bd8ff0          POP      {r4-r11,pc}
;;;773    
                          ENDP

                  find_best_colors PROC
;;;775    LOCAL(void)
;;;776    find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
000744  e92d4fff          PUSH     {r0-r11,lr}
;;;777    		  int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])
;;;778    /* Find the closest colormap entry for each cell in the update box,
;;;779     * given the list of candidate colors prepared by find_nearby_colors.
;;;780     * Return the indexes of the closest entries in the bestcolor[] array.
;;;781     * This routine uses Thomas' incremental distance calculation method to
;;;782     * find the distance from a colormap entry to successive cells in the box.
;;;783     */
;;;784    {
000748  f5ad7d05          SUB      sp,sp,#0x214
00074c  4604              MOV      r4,r0
;;;785      int ic0, ic1, ic2;
;;;786      int i, icolor;
;;;787      register INT32 * bptr;	/* pointer into bestdist[] array */
;;;788      JSAMPLE * cptr;		/* pointer into bestcolor[] array */
;;;789      INT32 dist0, dist1;		/* initial distance values */
;;;790      register INT32 dist2;		/* current distance in inner loop */
;;;791      INT32 xx0, xx1;		/* distance increments */
;;;792      register INT32 xx2;
;;;793      INT32 inc0, inc1, inc2;	/* initial values for increments */
;;;794      /* This array holds the distance to the nearest-so-far color for each cell */
;;;795      INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
;;;796    
;;;797      /* Initialize best-distance for each cell of the update box */
;;;798      bptr = bestdist;
00074e  466a              MOV      r2,sp
;;;799      for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
000750  207f              MOVS     r0,#0x7f
000752  e004              B        |L1.1886|
                  |L1.1876|
;;;800        *bptr++ = 0x7FFFFFFFL;
000754  f06f4b00          MVN      r11,#0x80000000
000758  f842bb04          STR      r11,[r2],#4
00075c  1e40              SUBS     r0,r0,#1              ;799
                  |L1.1886|
00075e  2800              CMP      r0,#0                 ;799
000760  daf8              BGE      |L1.1876|
;;;801      
;;;802      /* For each color selected by find_nearby_colors,
;;;803       * compute its distance to the center of each cell in the box.
;;;804       * If that's less than best-so-far, update best distance and color number.
;;;805       */
;;;806      
;;;807      /* Nominal steps between cell centers ("x" in Thomas article) */
;;;808    #define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
;;;809    #define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
;;;810    #define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
;;;811      
;;;812      for (i = 0; i < numcolors; i++) {
000762  2000              MOVS     r0,#0
000764  e08d              B        |L1.2178|
                  |L1.1894|
;;;813        icolor = GETJSAMPLE(colorlist[i]);
000766  f8ddb24c          LDR      r11,[sp,#0x24c]
00076a  f81b1000          LDRB     r1,[r11,r0]
;;;814        /* Compute (square of) distance from minc0/c1/c2 to this color */
;;;815        inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
00076e  f8d4b088          LDR      r11,[r4,#0x88]
000772  f8dbb000          LDR      r11,[r11,#0]
000776  f81be001          LDRB     lr,[r11,r1]
00077a  f8ddb218          LDR      r11,[sp,#0x218]
00077e  ebab0b0e          SUB      r11,r11,lr
000782  ea4f064b          LSL      r6,r11,#1
;;;816        dist0 = inc0*inc0;
000786  fb06f506          MUL      r5,r6,r6
;;;817        inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
00078a  f8d4b088          LDR      r11,[r4,#0x88]
00078e  f8dbb004          LDR      r11,[r11,#4]
000792  f81be001          LDRB     lr,[r11,r1]
000796  f8ddb21c          LDR      r11,[sp,#0x21c]
00079a  ebab0b0e          SUB      r11,r11,lr
00079e  eb0b074b          ADD      r7,r11,r11,LSL #1
;;;818        dist0 += inc1*inc1;
0007a2  fb075507          MLA      r5,r7,r7,r5
;;;819        inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
0007a6  f8d4b088          LDR      r11,[r4,#0x88]
0007aa  f8dbb008          LDR      r11,[r11,#8]
0007ae  f81be001          LDRB     lr,[r11,r1]
0007b2  f8ddb220          LDR      r11,[sp,#0x220]
0007b6  ebab030e          SUB      r3,r11,lr
;;;820        dist0 += inc2*inc2;
0007ba  fb035503          MLA      r5,r3,r3,r5
;;;821        /* Form the initial difference increments */
;;;822        inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
0007be  f44f7b80          MOV      r11,#0x100
0007c2  eb0b1646          ADD      r6,r11,r6,LSL #5
;;;823        inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
0007c6  eb070b47          ADD      r11,r7,r7,LSL #1
0007ca  f04f0e90          MOV      lr,#0x90
0007ce  eb0e07cb          ADD      r7,lr,r11,LSL #3
;;;824        inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
0007d2  f04f0b40          MOV      r11,#0x40
0007d6  eb0b1303          ADD      r3,r11,r3,LSL #4
;;;825        /* Now loop over all cells in box, updating distance per Thomas method */
;;;826        bptr = bestdist;
0007da  466a              MOV      r2,sp
;;;827        cptr = bestcolor;
0007dc  f8dda250          LDR      r10,[sp,#0x250]
;;;828        xx0 = inc0;
0007e0  9682              STR      r6,[sp,#0x208]
;;;829        for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
0007e2  f04f0803          MOV      r8,#3
0007e6  e048              B        |L1.2170|
                  |L1.2024|
;;;830          dist1 = dist0;
0007e8  9583              STR      r5,[sp,#0x20c]
;;;831          xx1 = inc1;
0007ea  9781              STR      r7,[sp,#0x204]
;;;832          for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
0007ec  f04f0907          MOV      r9,#7
0007f0  e035              B        |L1.2142|
                  |L1.2034|
;;;833    	dist2 = dist1;
0007f2  f8ddc20c          LDR      r12,[sp,#0x20c]
;;;834    	xx2 = inc2;
0007f6  9380              STR      r3,[sp,#0x200]
;;;835    	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
0007f8  f04f0b03          MOV      r11,#3
0007fc  f8cdb210          STR      r11,[sp,#0x210]
000800  e019              B        |L1.2102|
                  |L1.2050|
;;;836    	  if (dist2 < *bptr) {
000802  f8d2b000          LDR      r11,[r2,#0]
000806  45e3              CMP      r11,r12
000808  dd03              BLE      |L1.2066|
;;;837    	    *bptr = dist2;
00080a  f8c2c000          STR      r12,[r2,#0]
;;;838    	    *cptr = (JSAMPLE) icolor;
00080e  f88a1000          STRB     r1,[r10,#0]
                  |L1.2066|
;;;839    	  }
;;;840    	  dist2 += xx2;
000812  f8ddb200          LDR      r11,[sp,#0x200]
000816  44dc              ADD      r12,r12,r11
;;;841    	  xx2 += 2 * STEP_C2 * STEP_C2;
000818  f8ddb200          LDR      r11,[sp,#0x200]
00081c  f10b0b80          ADD      r11,r11,#0x80
000820  f8cdb200          STR      r11,[sp,#0x200]
;;;842    	  bptr++;
000824  1d12              ADDS     r2,r2,#4
;;;843    	  cptr++;
000826  f10a0a01          ADD      r10,r10,#1
00082a  f8ddb210          LDR      r11,[sp,#0x210]       ;835
00082e  f1ab0b01          SUB      r11,r11,#1            ;835
000832  f8cdb210          STR      r11,[sp,#0x210]       ;835
                  |L1.2102|
000836  f8ddb210          LDR      r11,[sp,#0x210]       ;835
00083a  f1bb0f00          CMP      r11,#0                ;835
00083e  dae0              BGE      |L1.2050|
;;;844    	}
;;;845    	dist1 += xx1;
000840  f8dde204          LDR      lr,[sp,#0x204]
000844  f8ddb20c          LDR      r11,[sp,#0x20c]
000848  44f3              ADD      r11,r11,lr
00084a  f8cdb20c          STR      r11,[sp,#0x20c]
;;;846    	xx1 += 2 * STEP_C1 * STEP_C1;
00084e  f8ddb204          LDR      r11,[sp,#0x204]
000852  f50b7b90          ADD      r11,r11,#0x120
000856  f8cdb204          STR      r11,[sp,#0x204]
00085a  f1a90901          SUB      r9,r9,#1              ;832
                  |L1.2142|
00085e  f1b90f00          CMP      r9,#0                 ;832
000862  dac6              BGE      |L1.2034|
;;;847          }
;;;848          dist0 += xx0;
000864  f8ddb208          LDR      r11,[sp,#0x208]
000868  445d              ADD      r5,r5,r11
;;;849          xx0 += 2 * STEP_C0 * STEP_C0;
00086a  f8ddb208          LDR      r11,[sp,#0x208]
00086e  f50b7b00          ADD      r11,r11,#0x200
000872  f8cdb208          STR      r11,[sp,#0x208]
000876  f1a80801          SUB      r8,r8,#1              ;829
                  |L1.2170|
00087a  f1b80f00          CMP      r8,#0                 ;829
00087e  dab3              BGE      |L1.2024|
000880  1c40              ADDS     r0,r0,#1              ;812
                  |L1.2178|
000882  f8ddb248          LDR      r11,[sp,#0x248]       ;812
000886  4558              CMP      r0,r11                ;812
000888  f6ffaf6d          BLT      |L1.1894|
;;;850        }
;;;851      }
;;;852    }
00088c  f50d7d09          ADD      sp,sp,#0x224
000890  e8bd8ff0          POP      {r4-r11,pc}
;;;853    
                          ENDP

                  fill_inverse_cmap PROC
;;;855    LOCAL(void)
;;;856    fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
000894  e92d4ff0          PUSH     {r4-r11,lr}
;;;857    /* Fill the inverse-colormap entries in the update box that contains */
;;;858    /* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
;;;859    /* we can fill as many others as we wish.) */
;;;860    {
000898  b0eb              SUB      sp,sp,#0x1ac
00089a  4681              MOV      r9,r0
00089c  460c              MOV      r4,r1
00089e  4615              MOV      r5,r2
0008a0  461e              MOV      r6,r3
;;;861      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0008a2  f8d901cc          LDR      r0,[r9,#0x1cc]
0008a6  906a              STR      r0,[sp,#0x1a8]
;;;862      hist3d histogram = cquantize->histogram;
0008a8  986a              LDR      r0,[sp,#0x1a8]
0008aa  6980              LDR      r0,[r0,#0x18]
0008ac  9069              STR      r0,[sp,#0x1a4]
;;;863      int minc0, minc1, minc2;	/* lower left corner of update box */
;;;864      int ic0, ic1, ic2;
;;;865      register JSAMPLE * cptr;	/* pointer into bestcolor[] array */
;;;866      register histptr cachep;	/* pointer into main cache array */
;;;867      /* This array lists the candidate colormap indexes. */
;;;868      JSAMPLE colorlist[MAXNUMCOLORS];
;;;869      int numcolors;		/* number of candidate colors */
;;;870      /* This array holds the actually closest colormap index for each cell. */
;;;871      JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
;;;872    
;;;873      /* Convert cell coordinates to update box ID */
;;;874      c0 >>= BOX_C0_LOG;
0008ae  10a4              ASRS     r4,r4,#2
;;;875      c1 >>= BOX_C1_LOG;
0008b0  10ed              ASRS     r5,r5,#3
;;;876      c2 >>= BOX_C2_LOG;
0008b2  10b6              ASRS     r6,r6,#2
;;;877    
;;;878      /* Compute true coordinates of update box's origin corner.
;;;879       * Actually we compute the coordinates of the center of the corner
;;;880       * histogram cell, which are the lower bounds of the volume we care about.
;;;881       */
;;;882      minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
0008b4  2004              MOVS     r0,#4
0008b6  eb001044          ADD      r0,r0,r4,LSL #5
0008ba  9068              STR      r0,[sp,#0x1a0]
;;;883      minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
0008bc  2002              MOVS     r0,#2
0008be  eb001045          ADD      r0,r0,r5,LSL #5
0008c2  9067              STR      r0,[sp,#0x19c]
;;;884      minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
0008c4  2004              MOVS     r0,#4
0008c6  eb001046          ADD      r0,r0,r6,LSL #5
0008ca  9066              STR      r0,[sp,#0x198]
;;;885      
;;;886      /* Determine which colormap entries are close enough to be candidates
;;;887       * for the nearest entry to some cell in the update box.
;;;888       */
;;;889      numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
0008cc  a825              ADD      r0,sp,#0x94
0008ce  9000              STR      r0,[sp,#0]
0008d0  4648              MOV      r0,r9
0008d2  9b66              LDR      r3,[sp,#0x198]
0008d4  9a67              LDR      r2,[sp,#0x19c]
0008d6  9968              LDR      r1,[sp,#0x1a0]
0008d8  f7fffffe          BL       find_nearby_colors
0008dc  9024              STR      r0,[sp,#0x90]
;;;890    
;;;891      /* Determine the actually nearest colors. */
;;;892      find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
0008de  a904              ADD      r1,sp,#0x10
0008e0  aa25              ADD      r2,sp,#0x94
0008e2  9824              LDR      r0,[sp,#0x90]
0008e4  e9cd2101          STRD     r2,r1,[sp,#4]
0008e8  9000              STR      r0,[sp,#0]
0008ea  4648              MOV      r0,r9
0008ec  9b66              LDR      r3,[sp,#0x198]
0008ee  9a67              LDR      r2,[sp,#0x19c]
0008f0  9968              LDR      r1,[sp,#0x1a0]
0008f2  f7fffffe          BL       find_best_colors
;;;893    		   bestcolor);
;;;894    
;;;895      /* Save the best color numbers (plus 1) in the main cache array */
;;;896      c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
0008f6  00a4              LSLS     r4,r4,#2
;;;897      c1 <<= BOX_C1_LOG;
0008f8  00ed              LSLS     r5,r5,#3
;;;898      c2 <<= BOX_C2_LOG;
0008fa  00b6              LSLS     r6,r6,#2
;;;899      cptr = bestcolor;
0008fc  a804              ADD      r0,sp,#0x10
0008fe  9065              STR      r0,[sp,#0x194]
;;;900      for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
000900  2700              MOVS     r7,#0
000902  e021              B        |L1.2376|
                  |L1.2308|
;;;901        for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
000904  f04f0800          MOV      r8,#0
000908  e01a              B        |L1.2368|
                  |L1.2314|
;;;902          cachep = & histogram[c0+ic0][c1+ic1][c2];
00090a  19e1              ADDS     r1,r4,r7
00090c  9869              LDR      r0,[sp,#0x1a4]
00090e  f8500021          LDR      r0,[r0,r1,LSL #2]
000912  eb050108          ADD      r1,r5,r8
000916  eb001081          ADD      r0,r0,r1,LSL #6
00091a  eb000b46          ADD      r11,r0,r6,LSL #1
;;;903          for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
00091e  f04f0a00          MOV      r10,#0
000922  e008              B        |L1.2358|
                  |L1.2340|
;;;904    	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
000924  9865              LDR      r0,[sp,#0x194]
000926  f8101b01          LDRB     r1,[r0],#1
00092a  1c49              ADDS     r1,r1,#1
00092c  9065              STR      r0,[sp,#0x194]
00092e  f82b1b02          STRH     r1,[r11],#2
000932  f10a0a01          ADD      r10,r10,#1            ;903
                  |L1.2358|
000936  f1ba0f04          CMP      r10,#4                ;903
00093a  dbf3              BLT      |L1.2340|
00093c  f1080801          ADD      r8,r8,#1              ;901
                  |L1.2368|
000940  f1b80f08          CMP      r8,#8                 ;901
000944  dbe1              BLT      |L1.2314|
000946  1c7f              ADDS     r7,r7,#1              ;900
                  |L1.2376|
000948  2f04              CMP      r7,#4                 ;900
00094a  dbdb              BLT      |L1.2308|
;;;905          }
;;;906        }
;;;907      }
;;;908    }
00094c  b06b              ADD      sp,sp,#0x1ac
00094e  e8bd8ff0          POP      {r4-r11,pc}
;;;909    
                          ENDP

                  pass2_no_dither PROC
;;;915    METHODDEF(void)
;;;916    pass2_no_dither (j_decompress_ptr cinfo,
000952  e92d4fff          PUSH     {r0-r11,lr}
;;;917    		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
;;;918    /* This version performs no dithering */
;;;919    {
000956  b085              SUB      sp,sp,#0x14
000958  4606              MOV      r6,r0
00095a  468b              MOV      r11,r1
;;;920      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00095c  f8d601cc          LDR      r0,[r6,#0x1cc]
000960  9004              STR      r0,[sp,#0x10]
;;;921      hist3d histogram = cquantize->histogram;
000962  9804              LDR      r0,[sp,#0x10]
000964  6980              LDR      r0,[r0,#0x18]
000966  9003              STR      r0,[sp,#0xc]
;;;922      register JSAMPROW inptr, outptr;
;;;923      register histptr cachep;
;;;924      register int c0, c1, c2;
;;;925      int row;
;;;926      JDIMENSION col;
;;;927      JDIMENSION width = cinfo->output_width;
000968  6f30              LDR      r0,[r6,#0x70]
00096a  9000              STR      r0,[sp,#0]
;;;928    
;;;929      for (row = 0; row < num_rows; row++) {
00096c  2500              MOVS     r5,#0
00096e  e032              B        |L1.2518|
                  |L1.2416|
;;;930        inptr = input_buf[row];
000970  f85b4025          LDR      r4,[r11,r5,LSL #2]
;;;931        outptr = output_buf[row];
000974  9807              LDR      r0,[sp,#0x1c]
000976  f8500025          LDR      r0,[r0,r5,LSL #2]
00097a  9002              STR      r0,[sp,#8]
;;;932        for (col = width; col > 0; col--) {
00097c  9800              LDR      r0,[sp,#0]
00097e  9001              STR      r0,[sp,#4]
000980  e025              B        |L1.2510|
                  |L1.2434|
;;;933          /* get pixel value and index into the cache */
;;;934          c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
000982  f8141b01          LDRB     r1,[r4],#1
000986  ea4f08e1          ASR      r8,r1,#3
;;;935          c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
00098a  f8141b01          LDRB     r1,[r4],#1
00098e  ea4f09a1          ASR      r9,r1,#2
;;;936          c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
000992  f8141b01          LDRB     r1,[r4],#1
000996  ea4f0ae1          ASR      r10,r1,#3
;;;937          cachep = & histogram[c0][c1][c2];
00099a  9803              LDR      r0,[sp,#0xc]
00099c  f8500028          LDR      r0,[r0,r8,LSL #2]
0009a0  eb001089          ADD      r0,r0,r9,LSL #6
0009a4  eb00074a          ADD      r7,r0,r10,LSL #1
;;;938          /* If we have not seen this color before, find nearest colormap entry */
;;;939          /* and update the cache */
;;;940          if (*cachep == 0)
0009a8  8838              LDRH     r0,[r7,#0]
0009aa  b928              CBNZ     r0,|L1.2488|
;;;941    	fill_inverse_cmap(cinfo, c0,c1,c2);
0009ac  4653              MOV      r3,r10
0009ae  464a              MOV      r2,r9
0009b0  4641              MOV      r1,r8
0009b2  4630              MOV      r0,r6
0009b4  f7fffffe          BL       fill_inverse_cmap
                  |L1.2488|
;;;942          /* Now emit the colormap index for this cell */
;;;943          *outptr++ = (JSAMPLE) (*cachep - 1);
0009b8  7838              LDRB     r0,[r7,#0]
0009ba  1e40              SUBS     r0,r0,#1
0009bc  b2c1              UXTB     r1,r0
0009be  9802              LDR      r0,[sp,#8]
0009c0  7001              STRB     r1,[r0,#0]
0009c2  9802              LDR      r0,[sp,#8]
0009c4  1c40              ADDS     r0,r0,#1
0009c6  9002              STR      r0,[sp,#8]
0009c8  9801              LDR      r0,[sp,#4]            ;932
0009ca  1e40              SUBS     r0,r0,#1              ;932
0009cc  9001              STR      r0,[sp,#4]            ;932
                  |L1.2510|
0009ce  9801              LDR      r0,[sp,#4]            ;932
0009d0  2800              CMP      r0,#0                 ;932
0009d2  d1d6              BNE      |L1.2434|
0009d4  1c6d              ADDS     r5,r5,#1              ;929
                  |L1.2518|
0009d6  9808              LDR      r0,[sp,#0x20]         ;929
0009d8  4285              CMP      r5,r0                 ;929
0009da  dbc9              BLT      |L1.2416|
;;;944        }
;;;945      }
;;;946    }
0009dc  b009              ADD      sp,sp,#0x24
0009de  e8bd8ff0          POP      {r4-r11,pc}
;;;947    
                          ENDP

                  pass2_fs_dither PROC
;;;949    METHODDEF(void)
;;;950    pass2_fs_dither (j_decompress_ptr cinfo,
0009e2  e92d4fff          PUSH     {r0-r11,lr}
;;;951    		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
;;;952    /* This version performs Floyd-Steinberg dithering */
;;;953    {
0009e6  b093              SUB      sp,sp,#0x4c
0009e8  4680              MOV      r8,r0
;;;954      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
0009ea  f8d891cc          LDR      r9,[r8,#0x1cc]
;;;955      hist3d histogram = cquantize->histogram;
0009ee  f8d90018          LDR      r0,[r9,#0x18]
0009f2  9012              STR      r0,[sp,#0x48]
;;;956      register LOCFSERROR cur0, cur1, cur2;	/* current error or pixel value */
;;;957      LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
;;;958      LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
;;;959      register FSERRPTR errorptr;	/* => fserrors[] at column before current */
;;;960      JSAMPROW inptr;		/* => current input pixel */
;;;961      JSAMPROW outptr;		/* => current output pixel */
;;;962      histptr cachep;
;;;963      int dir;			/* +1 or -1 depending on direction */
;;;964      int dir3;			/* 3*dir, for advancing inptr & errorptr */
;;;965      int row;
;;;966      JDIMENSION col;
;;;967      JDIMENSION width = cinfo->output_width;
0009f4  f8d80070          LDR      r0,[r8,#0x70]
0009f8  9006              STR      r0,[sp,#0x18]
;;;968      JSAMPLE *range_limit = cinfo->sample_range_limit;
0009fa  f8d80144          LDR      r0,[r8,#0x144]
0009fe  9005              STR      r0,[sp,#0x14]
;;;969      int *error_limit = cquantize->error_limiter;
000a00  f8d90028          LDR      r0,[r9,#0x28]
000a04  9004              STR      r0,[sp,#0x10]
;;;970      JSAMPROW colormap0 = cinfo->colormap[0];
000a06  f8d80088          LDR      r0,[r8,#0x88]
000a0a  6800              LDR      r0,[r0,#0]
000a0c  9003              STR      r0,[sp,#0xc]
;;;971      JSAMPROW colormap1 = cinfo->colormap[1];
000a0e  f8d80088          LDR      r0,[r8,#0x88]
000a12  6840              LDR      r0,[r0,#4]
000a14  9002              STR      r0,[sp,#8]
;;;972      JSAMPROW colormap2 = cinfo->colormap[2];
000a16  f8d80088          LDR      r0,[r8,#0x88]
000a1a  6880              LDR      r0,[r0,#8]
000a1c  9001              STR      r0,[sp,#4]
;;;973      SHIFT_TEMPS
;;;974    
;;;975      for (row = 0; row < num_rows; row++) {
000a1e  2000              MOVS     r0,#0
000a20  9008              STR      r0,[sp,#0x20]
000a22  e0c9              B        |L1.3000|
                  |L1.2596|
;;;976        inptr = input_buf[row];
000a24  9908              LDR      r1,[sp,#0x20]
000a26  9814              LDR      r0,[sp,#0x50]
000a28  f850b021          LDR      r11,[r0,r1,LSL #2]
;;;977        outptr = output_buf[row];
000a2c  9908              LDR      r1,[sp,#0x20]
000a2e  9815              LDR      r0,[sp,#0x54]
000a30  f8500021          LDR      r0,[r0,r1,LSL #2]
000a34  900b              STR      r0,[sp,#0x2c]
;;;978        if (cquantize->on_odd_row) {
000a36  f8d90024          LDR      r0,[r9,#0x24]
000a3a  b1d0              CBZ      r0,|L1.2674|
;;;979          /* work right to left in this row */
;;;980          inptr += (width-1) * 3;	/* so point to rightmost pixel */
000a3c  9806              LDR      r0,[sp,#0x18]
000a3e  1e40              SUBS     r0,r0,#1
000a40  eb000040          ADD      r0,r0,r0,LSL #1
000a44  4483              ADD      r11,r11,r0
;;;981          outptr += width-1;
000a46  9806              LDR      r0,[sp,#0x18]
000a48  1e40              SUBS     r0,r0,#1
000a4a  990b              LDR      r1,[sp,#0x2c]
000a4c  4408              ADD      r0,r0,r1
000a4e  900b              STR      r0,[sp,#0x2c]
;;;982          dir = -1;
000a50  f04f30ff          MOV      r0,#0xffffffff
000a54  9009              STR      r0,[sp,#0x24]
;;;983          dir3 = -3;
000a56  f06f0a02          MVN      r10,#2
;;;984          errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
000a5a  f8d91020          LDR      r1,[r9,#0x20]
000a5e  9806              LDR      r0,[sp,#0x18]
000a60  1c40              ADDS     r0,r0,#1
000a62  eb000040          ADD      r0,r0,r0,LSL #1
000a66  eb010740          ADD      r7,r1,r0,LSL #1
;;;985          cquantize->on_odd_row = FALSE; /* flip for next time */
000a6a  2000              MOVS     r0,#0
000a6c  f8c90024          STR      r0,[r9,#0x24]
000a70  e007              B        |L1.2690|
                  |L1.2674|
;;;986        } else {
;;;987          /* work left to right in this row */
;;;988          dir = 1;
000a72  2001              MOVS     r0,#1
000a74  9009              STR      r0,[sp,#0x24]
;;;989          dir3 = 3;
000a76  f04f0a03          MOV      r10,#3
;;;990          errorptr = cquantize->fserrors; /* => entry before first real column */
000a7a  f8d97020          LDR      r7,[r9,#0x20]
;;;991          cquantize->on_odd_row = TRUE; /* flip for next time */
000a7e  f8c90024          STR      r0,[r9,#0x24]
                  |L1.2690|
;;;992        }
;;;993        /* Preset error values: no error propagated to first pixel from left */
;;;994        cur0 = cur1 = cur2 = 0;
000a82  2000              MOVS     r0,#0
000a84  4606              MOV      r6,r0
000a86  4605              MOV      r5,r0
000a88  4604              MOV      r4,r0
;;;995        /* and no error propagated to row below yet */
;;;996        belowerr0 = belowerr1 = belowerr2 = 0;
000a8a  900f              STR      r0,[sp,#0x3c]
000a8c  9010              STR      r0,[sp,#0x40]
000a8e  9011              STR      r0,[sp,#0x44]
;;;997        bpreverr0 = bpreverr1 = bpreverr2 = 0;
000a90  900c              STR      r0,[sp,#0x30]
000a92  900d              STR      r0,[sp,#0x34]
000a94  900e              STR      r0,[sp,#0x38]
;;;998    
;;;999        for (col = width; col > 0; col--) {
000a96  9806              LDR      r0,[sp,#0x18]
000a98  9007              STR      r0,[sp,#0x1c]
000a9a  e07d              B        |L1.2968|
                  |L1.2716|
;;;1000         /* curN holds the error propagated from the previous pixel on the
;;;1001          * current line.  Add the error propagated from the previous line
;;;1002          * to form the complete error correction term for this pixel, and
;;;1003          * round the error term (which is expressed * 16) to an integer.
;;;1004          * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
;;;1005          * for either sign of the error value.
;;;1006          * Note: errorptr points to *previous* column's array entry.
;;;1007          */
;;;1008         cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
000a9c  f937001a          LDRSH    r0,[r7,r10,LSL #1]
000aa0  4420              ADD      r0,r0,r4
000aa2  3008              ADDS     r0,r0,#8
000aa4  1104              ASRS     r4,r0,#4
;;;1009         cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
000aa6  f10a0001          ADD      r0,r10,#1
000aaa  f9370010          LDRSH    r0,[r7,r0,LSL #1]
000aae  4428              ADD      r0,r0,r5
000ab0  3008              ADDS     r0,r0,#8
000ab2  1105              ASRS     r5,r0,#4
;;;1010         cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
000ab4  f10a0002          ADD      r0,r10,#2
000ab8  f9370010          LDRSH    r0,[r7,r0,LSL #1]
000abc  4430              ADD      r0,r0,r6
000abe  3008              ADDS     r0,r0,#8
000ac0  1106              ASRS     r6,r0,#4
;;;1011         /* Limit the error using transfer function set by init_error_limit.
;;;1012          * See comments with init_error_limit for rationale.
;;;1013          */
;;;1014         cur0 = error_limit[cur0];
000ac2  9804              LDR      r0,[sp,#0x10]
000ac4  f8504024          LDR      r4,[r0,r4,LSL #2]
;;;1015         cur1 = error_limit[cur1];
000ac8  9804              LDR      r0,[sp,#0x10]
000aca  f8505025          LDR      r5,[r0,r5,LSL #2]
;;;1016         cur2 = error_limit[cur2];
000ace  9804              LDR      r0,[sp,#0x10]
000ad0  f8506026          LDR      r6,[r0,r6,LSL #2]
;;;1017         /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
;;;1018          * The maximum error is +- MAXJSAMPLE (or less with error limiting);
;;;1019          * this sets the required size of the range_limit array.
;;;1020          */
;;;1021         cur0 += GETJSAMPLE(inptr[0]);
000ad4  f89b0000          LDRB     r0,[r11,#0]
000ad8  4404              ADD      r4,r4,r0
;;;1022         cur1 += GETJSAMPLE(inptr[1]);
000ada  f89b0001          LDRB     r0,[r11,#1]
000ade  4405              ADD      r5,r5,r0
;;;1023         cur2 += GETJSAMPLE(inptr[2]);
000ae0  f89b0002          LDRB     r0,[r11,#2]
000ae4  4406              ADD      r6,r6,r0
;;;1024         cur0 = GETJSAMPLE(range_limit[cur0]);
000ae6  9805              LDR      r0,[sp,#0x14]
000ae8  5d04              LDRB     r4,[r0,r4]
;;;1025         cur1 = GETJSAMPLE(range_limit[cur1]);
000aea  9805              LDR      r0,[sp,#0x14]
000aec  5d45              LDRB     r5,[r0,r5]
;;;1026         cur2 = GETJSAMPLE(range_limit[cur2]);
000aee  9805              LDR      r0,[sp,#0x14]
000af0  5d86              LDRB     r6,[r0,r6]
;;;1027         /* Index into the cache with adjusted pixel value */
;;;1028         cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
000af2  10e1              ASRS     r1,r4,#3
000af4  9812              LDR      r0,[sp,#0x48]
000af6  f8500021          LDR      r0,[r0,r1,LSL #2]
000afa  10a9              ASRS     r1,r5,#2
000afc  eb001081          ADD      r0,r0,r1,LSL #6
000b00  10f1              ASRS     r1,r6,#3
000b02  eb000041          ADD      r0,r0,r1,LSL #1
000b06  900a              STR      r0,[sp,#0x28]
;;;1029         /* If we have not seen this color before, find nearest colormap */
;;;1030         /* entry and update the cache */
;;;1031         if (*cachep == 0)
000b08  980a              LDR      r0,[sp,#0x28]
000b0a  8800              LDRH     r0,[r0,#0]
000b0c  b928              CBNZ     r0,|L1.2842|
;;;1032   	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
000b0e  10f3              ASRS     r3,r6,#3
000b10  10aa              ASRS     r2,r5,#2
000b12  10e1              ASRS     r1,r4,#3
000b14  4640              MOV      r0,r8
000b16  f7fffffe          BL       fill_inverse_cmap
                  |L1.2842|
;;;1033         /* Now emit the colormap index for this cell */
;;;1034         { register int pixcode = *cachep - 1;
000b1a  990a              LDR      r1,[sp,#0x28]
000b1c  8809              LDRH     r1,[r1,#0]
000b1e  1e48              SUBS     r0,r1,#1
;;;1035   	*outptr = (JSAMPLE) pixcode;
000b20  990b              LDR      r1,[sp,#0x2c]
000b22  7008              STRB     r0,[r1,#0]
;;;1036   	/* Compute representation error for this pixel */
;;;1037   	cur0 -= GETJSAMPLE(colormap0[pixcode]);
000b24  9903              LDR      r1,[sp,#0xc]
000b26  5c09              LDRB     r1,[r1,r0]
000b28  1a64              SUBS     r4,r4,r1
;;;1038   	cur1 -= GETJSAMPLE(colormap1[pixcode]);
000b2a  9902              LDR      r1,[sp,#8]
000b2c  5c09              LDRB     r1,[r1,r0]
000b2e  1a6d              SUBS     r5,r5,r1
;;;1039   	cur2 -= GETJSAMPLE(colormap2[pixcode]);
000b30  9901              LDR      r1,[sp,#4]
000b32  5c09              LDRB     r1,[r1,r0]
000b34  1a76              SUBS     r6,r6,r1
;;;1040         }
;;;1041         /* Compute error fractions to be propagated to adjacent pixels.
;;;1042          * Add these into the running sums, and simultaneously shift the
;;;1043          * next-line error sums left by 1 column.
;;;1044          */
;;;1045         { register LOCFSERROR bnexterr, delta;
;;;1046   
;;;1047   	bnexterr = cur0;	/* Process component 0 */
000b36  4620              MOV      r0,r4
;;;1048   	delta = cur0 * 2;
000b38  0061              LSLS     r1,r4,#1
;;;1049   	cur0 += delta;		/* form error * 3 */
000b3a  440c              ADD      r4,r4,r1
;;;1050   	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
000b3c  9a0e              LDR      r2,[sp,#0x38]
000b3e  4422              ADD      r2,r2,r4
000b40  b212              SXTH     r2,r2
000b42  803a              STRH     r2,[r7,#0]
;;;1051   	cur0 += delta;		/* form error * 5 */
000b44  440c              ADD      r4,r4,r1
;;;1052   	bpreverr0 = belowerr0 + cur0;
000b46  9a11              LDR      r2,[sp,#0x44]
000b48  4422              ADD      r2,r2,r4
000b4a  920e              STR      r2,[sp,#0x38]
;;;1053   	belowerr0 = bnexterr;
000b4c  9011              STR      r0,[sp,#0x44]
;;;1054   	cur0 += delta;		/* form error * 7 */
000b4e  440c              ADD      r4,r4,r1
;;;1055   	bnexterr = cur1;	/* Process component 1 */
000b50  4628              MOV      r0,r5
;;;1056   	delta = cur1 * 2;
000b52  0069              LSLS     r1,r5,#1
;;;1057   	cur1 += delta;		/* form error * 3 */
000b54  440d              ADD      r5,r5,r1
;;;1058   	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
000b56  9a0d              LDR      r2,[sp,#0x34]
000b58  442a              ADD      r2,r2,r5
000b5a  b212              SXTH     r2,r2
000b5c  807a              STRH     r2,[r7,#2]
;;;1059   	cur1 += delta;		/* form error * 5 */
000b5e  440d              ADD      r5,r5,r1
;;;1060   	bpreverr1 = belowerr1 + cur1;
000b60  9a10              LDR      r2,[sp,#0x40]
000b62  442a              ADD      r2,r2,r5
000b64  920d              STR      r2,[sp,#0x34]
;;;1061   	belowerr1 = bnexterr;
000b66  9010              STR      r0,[sp,#0x40]
;;;1062   	cur1 += delta;		/* form error * 7 */
000b68  440d              ADD      r5,r5,r1
;;;1063   	bnexterr = cur2;	/* Process component 2 */
000b6a  4630              MOV      r0,r6
;;;1064   	delta = cur2 * 2;
000b6c  0071              LSLS     r1,r6,#1
;;;1065   	cur2 += delta;		/* form error * 3 */
000b6e  440e              ADD      r6,r6,r1
;;;1066   	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
000b70  9a0c              LDR      r2,[sp,#0x30]
000b72  4432              ADD      r2,r2,r6
000b74  b212              SXTH     r2,r2
000b76  80ba              STRH     r2,[r7,#4]
;;;1067   	cur2 += delta;		/* form error * 5 */
000b78  440e              ADD      r6,r6,r1
;;;1068   	bpreverr2 = belowerr2 + cur2;
000b7a  9a0f              LDR      r2,[sp,#0x3c]
000b7c  4432              ADD      r2,r2,r6
000b7e  920c              STR      r2,[sp,#0x30]
;;;1069   	belowerr2 = bnexterr;
000b80  900f              STR      r0,[sp,#0x3c]
;;;1070   	cur2 += delta;		/* form error * 7 */
000b82  440e              ADD      r6,r6,r1
;;;1071         }
;;;1072         /* At this point curN contains the 7/16 error value to be propagated
;;;1073          * to the next pixel on the current line, and all the errors for the
;;;1074          * next line have been shifted over.  We are therefore ready to move on.
;;;1075          */
;;;1076         inptr += dir3;		/* Advance pixel pointers to next column */
000b84  44d3              ADD      r11,r11,r10
;;;1077         outptr += dir;
000b86  9909              LDR      r1,[sp,#0x24]
000b88  980b              LDR      r0,[sp,#0x2c]
000b8a  4408              ADD      r0,r0,r1
000b8c  900b              STR      r0,[sp,#0x2c]
;;;1078         errorptr += dir3;		/* advance errorptr to current column */
000b8e  eb07074a          ADD      r7,r7,r10,LSL #1
000b92  9807              LDR      r0,[sp,#0x1c]         ;999
000b94  1e40              SUBS     r0,r0,#1              ;999
000b96  9007              STR      r0,[sp,#0x1c]         ;999
                  |L1.2968|
000b98  9807              LDR      r0,[sp,#0x1c]         ;999
000b9a  2800              CMP      r0,#0                 ;999
000b9c  f47faf7e          BNE      |L1.2716|
;;;1079       }
;;;1080       /* Post-loop cleanup: we must unload the final error values into the
;;;1081        * final fserrors[] entry.  Note we need not unload belowerrN because
;;;1082        * it is for the dummy column before or after the actual array.
;;;1083        */
;;;1084       errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
000ba0  980e              LDR      r0,[sp,#0x38]
000ba2  b200              SXTH     r0,r0
000ba4  8038              STRH     r0,[r7,#0]
;;;1085       errorptr[1] = (FSERROR) bpreverr1;
000ba6  980d              LDR      r0,[sp,#0x34]
000ba8  b200              SXTH     r0,r0
000baa  8078              STRH     r0,[r7,#2]
;;;1086       errorptr[2] = (FSERROR) bpreverr2;
000bac  980c              LDR      r0,[sp,#0x30]
000bae  b200              SXTH     r0,r0
000bb0  80b8              STRH     r0,[r7,#4]
000bb2  9808              LDR      r0,[sp,#0x20]         ;975
000bb4  1c40              ADDS     r0,r0,#1              ;975
000bb6  9008              STR      r0,[sp,#0x20]         ;975
                  |L1.3000|
000bb8  9916              LDR      r1,[sp,#0x58]         ;975
000bba  9808              LDR      r0,[sp,#0x20]         ;975
000bbc  4288              CMP      r0,r1                 ;975
000bbe  f6ffaf31          BLT      |L1.2596|
;;;1087     }
;;;1088   }
000bc2  b017              ADD      sp,sp,#0x5c
000bc4  e8bd8ff0          POP      {r4-r11,pc}
;;;1089   
                          ENDP

                  init_error_limit PROC
;;;1108   LOCAL(void)
;;;1109   init_error_limit (j_decompress_ptr cinfo)
000bc8  e92d41f0          PUSH     {r4-r8,lr}
;;;1110   /* Allocate and fill in the error_limiter table */
;;;1111   {
000bcc  4607              MOV      r7,r0
;;;1112     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000bce  f8d781cc          LDR      r8,[r7,#0x1cc]
;;;1113     int * table;
;;;1114     int in, out;
;;;1115   
;;;1116     table = (int *) (*cinfo->mem->alloc_small)
000bd2  6878              LDR      r0,[r7,#4]
000bd4  f24072fc          MOV      r2,#0x7fc
000bd8  2101              MOVS     r1,#1
000bda  6803              LDR      r3,[r0,#0]
000bdc  4638              MOV      r0,r7
000bde  4798              BLX      r3
000be0  4605              MOV      r5,r0
;;;1117       ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
;;;1118     table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
000be2  f505757f          ADD      r5,r5,#0x3fc
;;;1119     cquantize->error_limiter = table;
000be6  f8c85028          STR      r5,[r8,#0x28]
;;;1120   
;;;1121   #define STEPSIZE ((MAXJSAMPLE+1)/16)
;;;1122     /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
;;;1123     out = 0;
000bea  2600              MOVS     r6,#0
;;;1124     for (in = 0; in < STEPSIZE; in++, out++) {
000bec  2400              MOVS     r4,#0
000bee  e007              B        |L1.3072|
                  |L1.3056|
;;;1125       table[in] = out; table[-in] = -out;
000bf0  f8456024          STR      r6,[r5,r4,LSL #2]
000bf4  4270              RSBS     r0,r6,#0
000bf6  4261              RSBS     r1,r4,#0
000bf8  f8450021          STR      r0,[r5,r1,LSL #2]
000bfc  1c64              ADDS     r4,r4,#1              ;1124
000bfe  1c76              ADDS     r6,r6,#1              ;1124
                  |L1.3072|
000c00  2c10              CMP      r4,#0x10              ;1124
000c02  dbf5              BLT      |L1.3056|
;;;1126     }
;;;1127     /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
;;;1128     for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
000c04  e00b              B        |L1.3102|
                  |L1.3078|
;;;1129       table[in] = out; table[-in] = -out;
000c06  f8456024          STR      r6,[r5,r4,LSL #2]
000c0a  4270              RSBS     r0,r6,#0
000c0c  4261              RSBS     r1,r4,#0
000c0e  f8450021          STR      r0,[r5,r1,LSL #2]
000c12  1c64              ADDS     r4,r4,#1              ;1128
000c14  f0040001          AND      r0,r4,#1              ;1128
000c18  f0800001          EOR      r0,r0,#1              ;1128
000c1c  4406              ADD      r6,r6,r0              ;1128
                  |L1.3102|
000c1e  2c30              CMP      r4,#0x30              ;1128
000c20  dbf1              BLT      |L1.3078|
;;;1130     }
;;;1131     /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
;;;1132     for (; in <= MAXJSAMPLE; in++) {
000c22  e006              B        |L1.3122|
                  |L1.3108|
;;;1133       table[in] = out; table[-in] = -out;
000c24  f8456024          STR      r6,[r5,r4,LSL #2]
000c28  4270              RSBS     r0,r6,#0
000c2a  4261              RSBS     r1,r4,#0
000c2c  f8450021          STR      r0,[r5,r1,LSL #2]
000c30  1c64              ADDS     r4,r4,#1              ;1132
                  |L1.3122|
000c32  2cff              CMP      r4,#0xff              ;1132
000c34  ddf6              BLE      |L1.3108|
;;;1134     }
;;;1135   #undef STEPSIZE
;;;1136   }
000c36  e8bd81f0          POP      {r4-r8,pc}
;;;1137   
                          ENDP

                  finish_pass1 PROC
;;;1143   METHODDEF(void)
;;;1144   finish_pass1 (j_decompress_ptr cinfo)
000c3a  b570              PUSH     {r4-r6,lr}
;;;1145   {
000c3c  4604              MOV      r4,r0
;;;1146     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000c3e  f8d451cc          LDR      r5,[r4,#0x1cc]
;;;1147   
;;;1148     /* Select the representative colors and fill in cinfo->colormap */
;;;1149     cinfo->colormap = cquantize->sv_colormap;
000c42  6928              LDR      r0,[r5,#0x10]
000c44  f8c40088          STR      r0,[r4,#0x88]
;;;1150     select_colors(cinfo, cquantize->desired);
000c48  4620              MOV      r0,r4
000c4a  6969              LDR      r1,[r5,#0x14]
000c4c  f7fffffe          BL       select_colors
;;;1151     /* Force next pass to zero the color index table */
;;;1152     cquantize->needs_zeroed = TRUE;
000c50  2001              MOVS     r0,#1
000c52  61e8              STR      r0,[r5,#0x1c]
;;;1153   }
000c54  bd70              POP      {r4-r6,pc}
;;;1154   
                          ENDP

                  finish_pass2 PROC
;;;1156   METHODDEF(void)
;;;1157   finish_pass2 (j_decompress_ptr cinfo)
000c56  bf00              NOP      
;;;1158   {
;;;1159     GUI_USE_PARA(cinfo);
;;;1160     /* no work */
;;;1161   }
000c58  4770              BX       lr
;;;1162   
                          ENDP

                  start_pass_2_quant PROC
;;;1168   METHODDEF(void)
;;;1169   start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
000c5a  e92d47f0          PUSH     {r4-r10,lr}
;;;1170   {
000c5e  4604              MOV      r4,r0
000c60  460f              MOV      r7,r1
;;;1171     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000c62  f8d451cc          LDR      r5,[r4,#0x1cc]
;;;1172     hist3d histogram = cquantize->histogram;
000c66  f8d59018          LDR      r9,[r5,#0x18]
;;;1173     int i;
;;;1174   
;;;1175     /* Only F-S dithering or no dithering is supported. */
;;;1176     /* If user asks for ordered dither, give him F-S. */
;;;1177     if (cinfo->dither_mode != JDITHER_NONE)
000c6a  f8940058          LDRB     r0,[r4,#0x58]
000c6e  b110              CBZ      r0,|L1.3190|
;;;1178       cinfo->dither_mode = JDITHER_FS;
000c70  2002              MOVS     r0,#2
000c72  f8840058          STRB     r0,[r4,#0x58]
                  |L1.3190|
;;;1179   
;;;1180     if (is_pre_scan) {
000c76  b137              CBZ      r7,|L1.3206|
;;;1181       /* Set up method pointers */
;;;1182       cquantize->pub.color_quantize = prescan_quantize;
000c78  486d              LDR      r0,|L1.3632|
000c7a  6068              STR      r0,[r5,#4]
;;;1183       cquantize->pub.finish_pass = finish_pass1;
000c7c  486d              LDR      r0,|L1.3636|
000c7e  60a8              STR      r0,[r5,#8]
;;;1184       cquantize->needs_zeroed = TRUE; /* Always zero histogram */
000c80  2001              MOVS     r0,#1
000c82  61e8              STR      r0,[r5,#0x1c]
000c84  e045              B        |L1.3346|
                  |L1.3206|
;;;1185     } else {
;;;1186       /* Set up method pointers */
;;;1187       if (cinfo->dither_mode == JDITHER_FS)
000c86  f8940058          LDRB     r0,[r4,#0x58]
000c8a  2802              CMP      r0,#2
000c8c  d102              BNE      |L1.3220|
;;;1188         cquantize->pub.color_quantize = pass2_fs_dither;
000c8e  486a              LDR      r0,|L1.3640|
000c90  6068              STR      r0,[r5,#4]
000c92  e001              B        |L1.3224|
                  |L1.3220|
;;;1189       else
;;;1190         cquantize->pub.color_quantize = pass2_no_dither;
000c94  4869              LDR      r0,|L1.3644|
000c96  6068              STR      r0,[r5,#4]
                  |L1.3224|
;;;1191       cquantize->pub.finish_pass = finish_pass2;
000c98  4869              LDR      r0,|L1.3648|
000c9a  60a8              STR      r0,[r5,#8]
;;;1192   
;;;1193       /* Make sure color count is acceptable */
;;;1194       i = cinfo->actual_number_of_colors;
000c9c  f8d46084          LDR      r6,[r4,#0x84]
;;;1195       if (i < 1)
000ca0  2e01              CMP      r6,#1
000ca2  da09              BGE      |L1.3256|
;;;1196         ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
000ca4  2038              MOVS     r0,#0x38
000ca6  6821              LDR      r1,[r4,#0]
000ca8  6148              STR      r0,[r1,#0x14]
000caa  2001              MOVS     r0,#1
000cac  6821              LDR      r1,[r4,#0]
000cae  6188              STR      r0,[r1,#0x18]
000cb0  6820              LDR      r0,[r4,#0]
000cb2  6801              LDR      r1,[r0,#0]
000cb4  4620              MOV      r0,r4
000cb6  4788              BLX      r1
                  |L1.3256|
;;;1197       if (i > MAXNUMCOLORS)
000cb8  f5b67f80          CMP      r6,#0x100
000cbc  dd0a              BLE      |L1.3284|
;;;1198         ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
000cbe  2039              MOVS     r0,#0x39
000cc0  6821              LDR      r1,[r4,#0]
000cc2  6148              STR      r0,[r1,#0x14]
000cc4  f44f7080          MOV      r0,#0x100
000cc8  6821              LDR      r1,[r4,#0]
000cca  6188              STR      r0,[r1,#0x18]
000ccc  6820              LDR      r0,[r4,#0]
000cce  6801              LDR      r1,[r0,#0]
000cd0  4620              MOV      r0,r4
000cd2  4788              BLX      r1
                  |L1.3284|
;;;1199   
;;;1200       if (cinfo->dither_mode == JDITHER_FS) {
000cd4  f8940058          LDRB     r0,[r4,#0x58]
000cd8  2802              CMP      r0,#2
000cda  d11a              BNE      |L1.3346|
;;;1201         size_t arraysize = (size_t) ((cinfo->output_width + 2) *
000cdc  6f20              LDR      r0,[r4,#0x70]
000cde  1c80              ADDS     r0,r0,#2
000ce0  eb000040          ADD      r0,r0,r0,LSL #1
000ce4  ea4f0840          LSL      r8,r0,#1
;;;1202   				   (3 * SIZEOF(FSERROR)));
;;;1203         /* Allocate Floyd-Steinberg workspace if we didn't already. */
;;;1204         if (cquantize->fserrors == NULL)
000ce8  6a28              LDR      r0,[r5,#0x20]
000cea  b930              CBNZ     r0,|L1.3322|
;;;1205   	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
000cec  6860              LDR      r0,[r4,#4]
000cee  4642              MOV      r2,r8
000cf0  2101              MOVS     r1,#1
000cf2  6843              LDR      r3,[r0,#4]
000cf4  4620              MOV      r0,r4
000cf6  4798              BLX      r3
000cf8  6228              STR      r0,[r5,#0x20]
                  |L1.3322|
;;;1206   	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
;;;1207         /* Initialize the propagated errors to zero. */
;;;1208         jzero_far((void FAR *) cquantize->fserrors, arraysize);
000cfa  4641              MOV      r1,r8
000cfc  6a28              LDR      r0,[r5,#0x20]
000cfe  f7fffffe          BL       jzero_far
;;;1209         /* Make the error-limit table if we didn't already. */
;;;1210         if (cquantize->error_limiter == NULL)
000d02  6aa8              LDR      r0,[r5,#0x28]
000d04  b910              CBNZ     r0,|L1.3340|
;;;1211   	init_error_limit(cinfo);
000d06  4620              MOV      r0,r4
000d08  f7fffffe          BL       init_error_limit
                  |L1.3340|
;;;1212         cquantize->on_odd_row = FALSE;
000d0c  2000              MOVS     r0,#0
000d0e  6268              STR      r0,[r5,#0x24]
;;;1213       }
000d10  bf00              NOP      
                  |L1.3346|
;;;1214   
;;;1215     }
;;;1216     /* Zero the histogram or inverse color map, if necessary */
;;;1217     if (cquantize->needs_zeroed) {
000d12  69e8              LDR      r0,[r5,#0x1c]
000d14  b160              CBZ      r0,|L1.3376|
;;;1218       for (i = 0; i < HIST_C0_ELEMS; i++) {
000d16  2600              MOVS     r6,#0
000d18  e006              B        |L1.3368|
                  |L1.3354|
;;;1219         jzero_far((void FAR *) histogram[i],
000d1a  f8590026          LDR      r0,[r9,r6,LSL #2]
000d1e  f44f5180          MOV      r1,#0x1000
000d22  f7fffffe          BL       jzero_far
000d26  1c76              ADDS     r6,r6,#1              ;1218
                  |L1.3368|
000d28  2e20              CMP      r6,#0x20              ;1218
000d2a  dbf6              BLT      |L1.3354|
;;;1220   		HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
;;;1221       }
;;;1222       cquantize->needs_zeroed = FALSE;
000d2c  2000              MOVS     r0,#0
000d2e  61e8              STR      r0,[r5,#0x1c]
                  |L1.3376|
;;;1223     }
;;;1224   }
000d30  e8bd87f0          POP      {r4-r10,pc}
;;;1225   
                          ENDP

                  new_color_map_2_quant PROC
;;;1231   METHODDEF(void)
;;;1232   new_color_map_2_quant (j_decompress_ptr cinfo)
000d34  f8d011cc          LDR      r1,[r0,#0x1cc]
;;;1233   {
;;;1234     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;1235   
;;;1236     /* Reset the inverse color map */
;;;1237     cquantize->needs_zeroed = TRUE;
000d38  2201              MOVS     r2,#1
000d3a  61ca              STR      r2,[r1,#0x1c]
;;;1238   }
000d3c  4770              BX       lr
;;;1239   
                          ENDP

                  jinit_2pass_quantizer PROC
;;;1245   GLOBAL(void)
;;;1246   jinit_2pass_quantizer (j_decompress_ptr cinfo)
000d3e  e92d41f0          PUSH     {r4-r8,lr}
;;;1247   {
000d42  4604              MOV      r4,r0
;;;1248     my_cquantize_ptr cquantize;
;;;1249     int i;
;;;1250   
;;;1251     cquantize = (my_cquantize_ptr)
000d44  6860              LDR      r0,[r4,#4]
000d46  222c              MOVS     r2,#0x2c
000d48  2101              MOVS     r1,#1
000d4a  6803              LDR      r3,[r0,#0]
000d4c  4620              MOV      r0,r4
000d4e  4798              BLX      r3
000d50  4605              MOV      r5,r0
;;;1252       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1253   				SIZEOF(my_cquantizer));
;;;1254     cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
000d52  f8c451cc          STR      r5,[r4,#0x1cc]
;;;1255     cquantize->pub.start_pass = start_pass_2_quant;
000d56  483b              LDR      r0,|L1.3652|
000d58  6028              STR      r0,[r5,#0]
;;;1256     cquantize->pub.new_color_map = new_color_map_2_quant;
000d5a  483b              LDR      r0,|L1.3656|
000d5c  60e8              STR      r0,[r5,#0xc]
;;;1257     cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
000d5e  2000              MOVS     r0,#0
000d60  6228              STR      r0,[r5,#0x20]
;;;1258     cquantize->error_limiter = NULL;
000d62  62a8              STR      r0,[r5,#0x28]
;;;1259   
;;;1260     /* Make sure jdmaster didn't give me a case I can't handle */
;;;1261     if (cinfo->out_color_components != 3)
000d64  6fa0              LDR      r0,[r4,#0x78]
000d66  2803              CMP      r0,#3
000d68  d006              BEQ      |L1.3448|
;;;1262       ERREXIT(cinfo, JERR_NOTIMPL);
000d6a  202f              MOVS     r0,#0x2f
000d6c  6821              LDR      r1,[r4,#0]
000d6e  6148              STR      r0,[r1,#0x14]
000d70  6820              LDR      r0,[r4,#0]
000d72  6801              LDR      r1,[r0,#0]
000d74  4620              MOV      r0,r4
000d76  4788              BLX      r1
                  |L1.3448|
;;;1263   
;;;1264     /* Allocate the histogram/inverse colormap storage */
;;;1265     cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
000d78  6860              LDR      r0,[r4,#4]
000d7a  2280              MOVS     r2,#0x80
000d7c  2101              MOVS     r1,#1
000d7e  6803              LDR      r3,[r0,#0]
000d80  4620              MOV      r0,r4
000d82  4798              BLX      r3
000d84  61a8              STR      r0,[r5,#0x18]
;;;1266       ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
;;;1267     for (i = 0; i < HIST_C0_ELEMS; i++) {
000d86  2600              MOVS     r6,#0
000d88  e00a              B        |L1.3488|
                  |L1.3466|
;;;1268       cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
000d8a  6860              LDR      r0,[r4,#4]
000d8c  f44f5280          MOV      r2,#0x1000
000d90  2101              MOVS     r1,#1
000d92  6843              LDR      r3,[r0,#4]
000d94  4620              MOV      r0,r4
000d96  4798              BLX      r3
000d98  69a9              LDR      r1,[r5,#0x18]
000d9a  f8410026          STR      r0,[r1,r6,LSL #2]
000d9e  1c76              ADDS     r6,r6,#1              ;1267
                  |L1.3488|
000da0  2e20              CMP      r6,#0x20              ;1267
000da2  dbf2              BLT      |L1.3466|
;;;1269         ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1270          HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
;;;1271     }
;;;1272     cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
000da4  2001              MOVS     r0,#1
000da6  61e8              STR      r0,[r5,#0x1c]
;;;1273   
;;;1274     /* Allocate storage for the completed colormap, if required.
;;;1275      * We do this now since it is FAR storage and may affect
;;;1276      * the memory manager's space calculations.
;;;1277      */
;;;1278     if (cinfo->enable_2pass_quant) {
000da8  6ee0              LDR      r0,[r4,#0x6c]
000daa  b328              CBZ      r0,|L1.3576|
;;;1279       /* Make sure color count is acceptable */
;;;1280       int desired = cinfo->desired_number_of_colors;
000dac  6e27              LDR      r7,[r4,#0x60]
;;;1281       /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
;;;1282       if (desired < 8)
000dae  2f08              CMP      r7,#8
000db0  da09              BGE      |L1.3526|
;;;1283         ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
000db2  2038              MOVS     r0,#0x38
000db4  6821              LDR      r1,[r4,#0]
000db6  6148              STR      r0,[r1,#0x14]
000db8  2008              MOVS     r0,#8
000dba  6821              LDR      r1,[r4,#0]
000dbc  6188              STR      r0,[r1,#0x18]
000dbe  6820              LDR      r0,[r4,#0]
000dc0  6801              LDR      r1,[r0,#0]
000dc2  4620              MOV      r0,r4
000dc4  4788              BLX      r1
                  |L1.3526|
;;;1284       /* Make sure colormap indexes can be represented by JSAMPLEs */
;;;1285       if (desired > MAXNUMCOLORS)
000dc6  f5b77f80          CMP      r7,#0x100
000dca  dd0a              BLE      |L1.3554|
;;;1286         ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
000dcc  2039              MOVS     r0,#0x39
000dce  6821              LDR      r1,[r4,#0]
000dd0  6148              STR      r0,[r1,#0x14]
000dd2  f44f7080          MOV      r0,#0x100
000dd6  6821              LDR      r1,[r4,#0]
000dd8  6188              STR      r0,[r1,#0x18]
000dda  6820              LDR      r0,[r4,#0]
000ddc  6801              LDR      r1,[r0,#0]
000dde  4620              MOV      r0,r4
000de0  4788              BLX      r1
                  |L1.3554|
;;;1287       cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
000de2  6860              LDR      r0,[r4,#4]
000de4  2303              MOVS     r3,#3
000de6  463a              MOV      r2,r7
000de8  2101              MOVS     r1,#1
000dea  f8d0c008          LDR      r12,[r0,#8]
000dee  4620              MOV      r0,r4
000df0  47e0              BLX      r12
000df2  6128              STR      r0,[r5,#0x10]
;;;1288         ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
;;;1289       cquantize->desired = desired;
000df4  616f              STR      r7,[r5,#0x14]
;;;1290     } else
000df6  e001              B        |L1.3580|
                  |L1.3576|
;;;1291       cquantize->sv_colormap = NULL;
000df8  2000              MOVS     r0,#0
000dfa  6128              STR      r0,[r5,#0x10]
                  |L1.3580|
;;;1292   
;;;1293     /* Only F-S dithering or no dithering is supported. */
;;;1294     /* If user asks for ordered dither, give him F-S. */
;;;1295     if (cinfo->dither_mode != JDITHER_NONE)
000dfc  f8940058          LDRB     r0,[r4,#0x58]
000e00  b110              CBZ      r0,|L1.3592|
;;;1296       cinfo->dither_mode = JDITHER_FS;
000e02  2002              MOVS     r0,#2
000e04  f8840058          STRB     r0,[r4,#0x58]
                  |L1.3592|
;;;1297   
;;;1298     /* Allocate Floyd-Steinberg workspace if necessary.
;;;1299      * This isn't really needed until pass 2, but again it is FAR storage.
;;;1300      * Although we will cope with a later change in dither_mode,
;;;1301      * we do not promise to honor max_memory_to_use if dither_mode changes.
;;;1302      */
;;;1303     if (cinfo->dither_mode == JDITHER_FS) {
000e08  f8940058          LDRB     r0,[r4,#0x58]
000e0c  2802              CMP      r0,#2
000e0e  d10d              BNE      |L1.3628|
;;;1304       cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
000e10  6f20              LDR      r0,[r4,#0x70]
000e12  1c80              ADDS     r0,r0,#2
000e14  eb000040          ADD      r0,r0,r0,LSL #1
000e18  0042              LSLS     r2,r0,#1
000e1a  6860              LDR      r0,[r4,#4]
000e1c  2101              MOVS     r1,#1
000e1e  6843              LDR      r3,[r0,#4]
000e20  4620              MOV      r0,r4
000e22  4798              BLX      r3
000e24  6228              STR      r0,[r5,#0x20]
;;;1305         ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1306          (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
;;;1307       /* Might as well create the error-limiting table too. */
;;;1308       init_error_limit(cinfo);
000e26  4620              MOV      r0,r4
000e28  f7fffffe          BL       init_error_limit
                  |L1.3628|
;;;1309     }
;;;1310   }
000e2c  e8bd81f0          POP      {r4-r8,pc}
;;;1311   
                          ENDP

                  |L1.3632|
                          DCD      prescan_quantize
                  |L1.3636|
                          DCD      finish_pass1
                  |L1.3640|
                          DCD      pass2_fs_dither
                  |L1.3644|
                          DCD      pass2_no_dither
                  |L1.3648|
                          DCD      finish_pass2
                  |L1.3652|
                          DCD      start_pass_2_quant
                  |L1.3656|
                          DCD      new_color_map_2_quant
