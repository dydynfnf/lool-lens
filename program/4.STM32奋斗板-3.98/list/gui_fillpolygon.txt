; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\gui_fillpolygon.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\gui_fillpolygon.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\gui_fillpolygon.crf GUI\Core\GUI_FillPolygon.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _DrawHLine PROC
;;;52     */
;;;53     static void _DrawHLine(int x0, int y, int x1) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;54       if (x0 < x1) {
000008  42ac              CMP      r4,r5
00000a  da07              BGE      |L1.28|
;;;55         LCD_HL_DrawHLine(x0, y, x1);
00000c  48c8              LDR      r0,|L1.816|
00000e  6d80              LDR      r0,[r0,#0x58]  ; GUI_Context
000010  462a              MOV      r2,r5
000012  4631              MOV      r1,r6
000014  6803              LDR      r3,[r0,#0]
000016  4620              MOV      r0,r4
000018  4798              BLX      r3
00001a  e006              B        |L1.42|
                  |L1.28|
;;;56       } else {
;;;57         LCD_HL_DrawHLine(x1, y, x0);
00001c  48c4              LDR      r0,|L1.816|
00001e  6d80              LDR      r0,[r0,#0x58]  ; GUI_Context
000020  4622              MOV      r2,r4
000022  4631              MOV      r1,r6
000024  6803              LDR      r3,[r0,#0]
000026  4628              MOV      r0,r5
000028  4798              BLX      r3
                  |L1.42|
;;;58       }
;;;59     }
00002a  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

                  _CheckYInterSect PROC
;;;74     */
;;;75     static int _CheckYInterSect(int y, int* px, const GUI_POINT*paPoint0, const GUI_POINT*paPoint1) {
00002c  e92d43f0          PUSH     {r4-r9,lr}
000030  4604              MOV      r4,r0
000032  468c              MOV      r12,r1
000034  4615              MOV      r5,r2
;;;76       int x0, y0, x1, y1;
;;;77       if (paPoint0->y <= (paPoint1)->y) {
000036  f9b50002          LDRSH    r0,[r5,#2]
00003a  f9b38002          LDRSH    r8,[r3,#2]
00003e  4540              CMP      r0,r8
000040  dc11              BGT      |L1.102|
;;;78         y0 = paPoint0->y;
000042  f9b51002          LDRSH    r1,[r5,#2]
;;;79         if (y0 > y)      /* Check if there is an intersection ... (early out) */
000046  42a1              CMP      r1,r4
000048  dd02              BLE      |L1.80|
;;;80           return 0;
00004a  2000              MOVS     r0,#0
                  |L1.76|
;;;81         y1 = paPoint1->y;
;;;82         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;83           return 0;
;;;84         x0 = paPoint0->x;
;;;85         x1 = paPoint1->x;
;;;86       } else {
;;;87         y0 = paPoint1->y;
;;;88         if (y0 > y)      /* Check if there is an intersection ... (early out) */
;;;89           return 0;
;;;90         y1 = paPoint0->y;
;;;91         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;92           return 0;
;;;93         x0 = paPoint1->x;
;;;94         x1 = paPoint0->x;
;;;95       }
;;;96     /* Calculate intersection */
;;;97       {
;;;98         I32 Mul = (I32)(x1 - x0) * (I32)(y - y0);
;;;99         if (Mul > 0) {
;;;100          Mul += (y1 - y0) >> 1;	          /* for proper rounding */
;;;101        } else {
;;;102          Mul -= ((y1 - y0) >> 1) - 1;	    /* for proper rounding */
;;;103        }
;;;104        x0 += Mul / (y1 - y0);
;;;105      }
;;;106      *px = x0;
;;;107      return 1;
;;;108    } 
00004c  e8bd83f0          POP      {r4-r9,pc}
                  |L1.80|
000050  f9b32002          LDRSH    r2,[r3,#2]            ;81
000054  42a2              CMP      r2,r4                 ;82
000056  da01              BGE      |L1.92|
000058  2000              MOVS     r0,#0                 ;83
00005a  e7f7              B        |L1.76|
                  |L1.92|
00005c  f9b56000          LDRSH    r6,[r5,#0]            ;84
000060  f9b37000          LDRSH    r7,[r3,#0]            ;85
000064  e00f              B        |L1.134|
                  |L1.102|
000066  f9b31002          LDRSH    r1,[r3,#2]            ;87
00006a  42a1              CMP      r1,r4                 ;88
00006c  dd01              BLE      |L1.114|
00006e  2000              MOVS     r0,#0                 ;89
000070  e7ec              B        |L1.76|
                  |L1.114|
000072  f9b52002          LDRSH    r2,[r5,#2]            ;90
000076  42a2              CMP      r2,r4                 ;91
000078  da01              BGE      |L1.126|
00007a  2000              MOVS     r0,#0                 ;92
00007c  e7e6              B        |L1.76|
                  |L1.126|
00007e  f9b36000          LDRSH    r6,[r3,#0]            ;93
000082  f9b57000          LDRSH    r7,[r5,#0]            ;94
                  |L1.134|
000086  eba70806          SUB      r8,r7,r6              ;98
00008a  eba40901          SUB      r9,r4,r1              ;98
00008e  fb08f009          MUL      r0,r8,r9              ;98
000092  2800              CMP      r0,#0                 ;99
000094  dd04              BLE      |L1.160|
000096  eba20801          SUB      r8,r2,r1              ;100
00009a  eb000068          ADD      r0,r0,r8,ASR #1       ;100
00009e  e007              B        |L1.176|
                  |L1.160|
0000a0  eba20801          SUB      r8,r2,r1              ;102
0000a4  f04f0901          MOV      r9,#1                 ;102
0000a8  ebc90868          RSB      r8,r9,r8,ASR #1       ;102
0000ac  eba00008          SUB      r0,r0,r8              ;102
                  |L1.176|
0000b0  eba20801          SUB      r8,r2,r1              ;104
0000b4  fb90f8f8          SDIV     r8,r0,r8              ;104
0000b8  4446              ADD      r6,r6,r8              ;104
0000ba  f8cc6000          STR      r6,[r12,#0]           ;106
0000be  2001              MOVS     r0,#1                 ;107
0000c0  e7c4              B        |L1.76|
;;;109    
                          ENDP

                  _Add PROC
;;;115    */
;;;116    static void _Add(int x) {
0000c2  4601              MOV      r1,r0
;;;117      if (GL_FP_Cnt < GUI_FP_MAXCOUNT) {
0000c4  489b              LDR      r0,|L1.820|
0000c6  6800              LDR      r0,[r0,#0]  ; GL_FP_Cnt
0000c8  280c              CMP      r0,#0xc
0000ca  da1d              BGE      |L1.264|
;;;118        int i;
;;;119        /* Move all entries to the right (bigger x-value) */
;;;120        for (i=GL_FP_Cnt; i ; i--) {
0000cc  4a99              LDR      r2,|L1.820|
0000ce  6810              LDR      r0,[r2,#0]  ; GL_FP_Cnt
0000d0  e00d              B        |L1.238|
                  |L1.210|
;;;121          if (_aX[i-1] < x)
0000d2  1e42              SUBS     r2,r0,#1
0000d4  4b98              LDR      r3,|L1.824|
0000d6  f9332012          LDRSH    r2,[r3,r2,LSL #1]
0000da  428a              CMP      r2,r1
0000dc  da00              BGE      |L1.224|
;;;122            break;
0000de  e008              B        |L1.242|
                  |L1.224|
;;;123          _aX[i] = _aX[i-1];
0000e0  1e42              SUBS     r2,r0,#1
0000e2  4b95              LDR      r3,|L1.824|
0000e4  f8332012          LDRH     r2,[r3,r2,LSL #1]
0000e8  f8232010          STRH     r2,[r3,r0,LSL #1]
0000ec  1e40              SUBS     r0,r0,#1              ;120
                  |L1.238|
0000ee  2800              CMP      r0,#0                 ;120
0000f0  d1ef              BNE      |L1.210|
                  |L1.242|
0000f2  bf00              NOP                            ;122
;;;124        }
;;;125        /* Insert new entry */
;;;126        _aX[i]    = x;
0000f4  b20a              SXTH     r2,r1
0000f6  4b90              LDR      r3,|L1.824|
0000f8  f8232010          STRH     r2,[r3,r0,LSL #1]
;;;127        GL_FP_Cnt++;
0000fc  4a8d              LDR      r2,|L1.820|
0000fe  6812              LDR      r2,[r2,#0]  ; GL_FP_Cnt
000100  1c52              ADDS     r2,r2,#1
000102  4b8c              LDR      r3,|L1.820|
000104  601a              STR      r2,[r3,#0]  ; GL_FP_Cnt
;;;128      }
000106  bf00              NOP      
                  |L1.264|
;;;129    }
000108  4770              BX       lr
;;;130    
                          ENDP

                  _Init PROC
;;;136    */
;;;137    static void _Init(void) {
00010a  2000              MOVS     r0,#0
;;;138      GL_FP_Cnt = 0;
00010c  4989              LDR      r1,|L1.820|
00010e  6008              STR      r0,[r1,#0]  ; GL_FP_Cnt
;;;139    }
000110  4770              BX       lr
;;;140    
                          ENDP

                  _Flush PROC
;;;146    */
;;;147    static void _Flush(int x0, int y) {
000112  e92d47f0          PUSH     {r4-r10,lr}
000116  4604              MOV      r4,r0
000118  4688              MOV      r8,r1
;;;148      int i, x = 0;
00011a  f04f0900          MOV      r9,#0
;;;149      char On=0;
00011e  2600              MOVS     r6,#0
;;;150      for (i=0; i<GL_FP_Cnt; i++) {
000120  2500              MOVS     r5,#0
000122  e00f              B        |L1.324|
                  |L1.292|
;;;151        int xNew = _aX[i];
000124  4884              LDR      r0,|L1.824|
000126  f9307015          LDRSH    r7,[r0,r5,LSL #1]
;;;152        if (On) {
00012a  b13e              CBZ      r6,|L1.316|
;;;153          LCD_HL_DrawHLine(x0 + x, y, x0 + xNew);
00012c  19e2              ADDS     r2,r4,r7
00012e  eb040009          ADD      r0,r4,r9
000132  497f              LDR      r1,|L1.816|
000134  6d89              LDR      r1,[r1,#0x58]  ; GUI_Context
000136  680b              LDR      r3,[r1,#0]
000138  4641              MOV      r1,r8
00013a  4798              BLX      r3
                  |L1.316|
;;;154        }
;;;155        On ^= 1;
00013c  f0860601          EOR      r6,r6,#1
;;;156        x = xNew;
000140  46b9              MOV      r9,r7
000142  1c6d              ADDS     r5,r5,#1              ;150
                  |L1.324|
000144  487b              LDR      r0,|L1.820|
000146  6800              LDR      r0,[r0,#0]            ;150  ; GL_FP_Cnt
000148  4285              CMP      r5,r0                 ;150
00014a  dbeb              BLT      |L1.292|
;;;157      }
;;;158    }
00014c  e8bd87f0          POP      {r4-r10,pc}
;;;159    
                          ENDP

                  _AddPoint PROC
;;;167    */
;;;168    static void _AddPoint(int x, int y, int y0, int y1, int xOff, int yOff) {
000150  e92d47f0          PUSH     {r4-r10,lr}
000154  4604              MOV      r4,r0
000156  460d              MOV      r5,r1
000158  4616              MOV      r6,r2
00015a  461f              MOV      r7,r3
00015c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;169      if ((y0 ^ y1) >= 0) {
000160  ea860007          EOR      r0,r6,r7
000164  2800              CMP      r0,#0
000166  db09              BLT      |L1.380|
;;;170        x += xOff;
000168  4444              ADD      r4,r4,r8
;;;171        LCD_HL_DrawHLine(x, y + yOff, x);    /* V-point, not crossing the polygon */
00016a  eb050109          ADD      r1,r5,r9
00016e  4870              LDR      r0,|L1.816|
000170  6d80              LDR      r0,[r0,#0x58]  ; GUI_Context
000172  4622              MOV      r2,r4
000174  6803              LDR      r3,[r0,#0]
000176  4620              MOV      r0,r4
000178  4798              BLX      r3
00017a  e002              B        |L1.386|
                  |L1.380|
;;;172      } else {
;;;173        _Add(x);
00017c  4620              MOV      r0,r4
00017e  f7fffffe          BL       _Add
                  |L1.386|
;;;174      }
;;;175    }
000182  e8bd87f0          POP      {r4-r10,pc}
;;;176    
                          ENDP

                  _GetPrevPointDiffy PROC
;;;182    */
;;;183    static int _GetPrevPointDiffy(const GUI_POINT* paPoint, int i,
000186  b570              PUSH     {r4-r6,lr}
;;;184                                  const int NumPoints, const int y0) {
000188  4605              MOV      r5,r0
;;;185      int j, y1;
;;;186      for (j = 0; j < (NumPoints - 1) ; j++) {
00018a  2600              MOVS     r6,#0
00018c  e00d              B        |L1.426|
                  |L1.398|
;;;187        i = (i != 0) ? i - 1 : NumPoints - 1;
00018e  b109              CBZ      r1,|L1.404|
000190  1e48              SUBS     r0,r1,#1
000192  e000              B        |L1.406|
                  |L1.404|
000194  1e50              SUBS     r0,r2,#1
                  |L1.406|
000196  4601              MOV      r1,r0
;;;188        y1 = (paPoint + i)->y;
000198  eb050081          ADD      r0,r5,r1,LSL #2
00019c  f9b04002          LDRSH    r4,[r0,#2]
;;;189        if (y1 != y0) {
0001a0  429c              CMP      r4,r3
0001a2  d001              BEQ      |L1.424|
;;;190          return y1;
0001a4  4620              MOV      r0,r4
                  |L1.422|
;;;191        }
;;;192      }
;;;193      return y0;
;;;194    }
0001a6  bd70              POP      {r4-r6,pc}
                  |L1.424|
0001a8  1c76              ADDS     r6,r6,#1              ;186
                  |L1.426|
0001aa  1e50              SUBS     r0,r2,#1              ;186
0001ac  42b0              CMP      r0,r6                 ;186
0001ae  dcee              BGT      |L1.398|
0001b0  4618              MOV      r0,r3                 ;193
0001b2  e7f8              B        |L1.422|
;;;195    
                          ENDP

                  GL_FillPolygon PROC
;;;207    */
;;;208    void GL_FillPolygon  (const GUI_POINT*paPoint, int NumPoints, int xOff, int yOff) {
0001b4  e92d4ff0          PUSH     {r4-r11,lr}
0001b8  b087              SUB      sp,sp,#0x1c
0001ba  4606              MOV      r6,r0
0001bc  4689              MOV      r9,r1
0001be  4692              MOV      r10,r2
0001c0  461f              MOV      r7,r3
;;;209      int i, y;
;;;210      int yMin = GUI_YMAX;
0001c2  f64070ff          MOV      r0,#0xfff
0001c6  9006              STR      r0,[sp,#0x18]
;;;211      int yMax = GUI_YMIN;
0001c8  4240              RSBS     r0,r0,#0
0001ca  9005              STR      r0,[sp,#0x14]
;;;212    /* First step : find uppermost and lowermost coordinates */
;;;213      for (i=0; i<NumPoints; i++) {
0001cc  2500              MOVS     r5,#0
0001ce  e00c              B        |L1.490|
                  |L1.464|
;;;214        y = (paPoint + i)->y;
0001d0  eb060085          ADD      r0,r6,r5,LSL #2
0001d4  f9b04002          LDRSH    r4,[r0,#2]
;;;215        if (y < yMin)
0001d8  9806              LDR      r0,[sp,#0x18]
0001da  4284              CMP      r4,r0
0001dc  da00              BGE      |L1.480|
;;;216          yMin = y;
0001de  9406              STR      r4,[sp,#0x18]
                  |L1.480|
;;;217        if (y > yMax)
0001e0  9805              LDR      r0,[sp,#0x14]
0001e2  4284              CMP      r4,r0
0001e4  dd00              BLE      |L1.488|
;;;218          yMax = y;
0001e6  9405              STR      r4,[sp,#0x14]
                  |L1.488|
0001e8  1c6d              ADDS     r5,r5,#1              ;213
                  |L1.490|
0001ea  454d              CMP      r5,r9                 ;213
0001ec  dbf0              BLT      |L1.464|
;;;219      }
;;;220    /* Use Clipping rect to reduce calculation (if possible) */
;;;221      if (GUI_Context.pClipRect_HL) {
0001ee  4850              LDR      r0,|L1.816|
0001f0  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
0001f2  b1d8              CBZ      r0,|L1.556|
;;;222        if (yMax > (GUI_Context.pClipRect_HL->y1 - yOff))
0001f4  484e              LDR      r0,|L1.816|
0001f6  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
0001f8  f9b00006          LDRSH    r0,[r0,#6]
0001fc  1bc1              SUBS     r1,r0,r7
0001fe  9805              LDR      r0,[sp,#0x14]
000200  4281              CMP      r1,r0
000202  da05              BGE      |L1.528|
;;;223          yMax = (GUI_Context.pClipRect_HL->y1 - yOff);
000204  484a              LDR      r0,|L1.816|
000206  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
000208  f9b00006          LDRSH    r0,[r0,#6]
00020c  1bc0              SUBS     r0,r0,r7
00020e  9005              STR      r0,[sp,#0x14]
                  |L1.528|
;;;224        if (yMin < (GUI_Context.pClipRect_HL->y0 - yOff))
000210  4847              LDR      r0,|L1.816|
000212  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
000214  f9b00002          LDRSH    r0,[r0,#2]
000218  1bc1              SUBS     r1,r0,r7
00021a  9806              LDR      r0,[sp,#0x18]
00021c  4281              CMP      r1,r0
00021e  dd05              BLE      |L1.556|
;;;225          yMin = (GUI_Context.pClipRect_HL->y0 - yOff);
000220  4843              LDR      r0,|L1.816|
000222  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
000224  f9b00002          LDRSH    r0,[r0,#2]
000228  1bc0              SUBS     r0,r0,r7
00022a  9006              STR      r0,[sp,#0x18]
                  |L1.556|
;;;226      }
;;;227    /* Second step: Calculate and draw horizontal lines */
;;;228      for (y=yMin; y<=yMax; y++) {
00022c  9c06              LDR      r4,[sp,#0x18]
00022e  e05b              B        |L1.744|
                  |L1.560|
;;;229        _Init();
000230  f7fffffe          BL       _Init
;;;230        /* find next intersection and count lines*/
;;;231        for (i=0; i<NumPoints; i++) {
000234  2500              MOVS     r5,#0
000236  e050              B        |L1.730|
                  |L1.568|
;;;232          int i1 = (i < (NumPoints - 1)) ? i + 1 : 0;
000238  f1a90001          SUB      r0,r9,#1
00023c  42a8              CMP      r0,r5
00023e  dd01              BLE      |L1.580|
000240  1c68              ADDS     r0,r5,#1
000242  e000              B        |L1.582|
                  |L1.580|
000244  2000              MOVS     r0,#0
                  |L1.582|
000246  9004              STR      r0,[sp,#0x10]
;;;233          int y0 = (paPoint + i )->y;
000248  eb060085          ADD      r0,r6,r5,LSL #2
00024c  f9b0b002          LDRSH    r11,[r0,#2]
;;;234          int y1 = (paPoint + i1)->y;
000250  9804              LDR      r0,[sp,#0x10]
000252  eb060080          ADD      r0,r6,r0,LSL #2
000256  f9b08002          LDRSH    r8,[r0,#2]
;;;235          /* Check if starting point is on line */
;;;236          if (y0 == y) {
00025a  45a3              CMP      r11,r4
00025c  d124              BNE      |L1.680|
;;;237            if (y1 == y) {  /* Add the entire line */
00025e  45a0              CMP      r8,r4
000260  d10c              BNE      |L1.636|
;;;238              _DrawHLine((paPoint + i )->x + xOff , y + yOff, (paPoint + i1)->x + xOff);
000262  9b04              LDR      r3,[sp,#0x10]
000264  f9363023          LDRSH    r3,[r6,r3,LSL #2]
000268  eb03020a          ADD      r2,r3,r10
00026c  19e1              ADDS     r1,r4,r7
00026e  f9363025          LDRSH    r3,[r6,r5,LSL #2]
000272  eb03000a          ADD      r0,r3,r10
000276  f7fffffe          BL       _DrawHLine
00027a  e02d              B        |L1.728|
                  |L1.636|
;;;239            } else {        /* Add only one point */
;;;240              int yPrev = _GetPrevPointDiffy(paPoint, i, NumPoints, y);
00027c  4623              MOV      r3,r4
00027e  464a              MOV      r2,r9
000280  4629              MOV      r1,r5
000282  4630              MOV      r0,r6
000284  f7fffffe          BL       _GetPrevPointDiffy
000288  9003              STR      r0,[sp,#0xc]
;;;241              if (yPrev != y) {
00028a  9803              LDR      r0,[sp,#0xc]
00028c  42a0              CMP      r0,r4
00028e  d00a              BEQ      |L1.678|
;;;242                _AddPoint((paPoint + i)->x, y, yPrev - y, y1 - y, xOff, yOff);
000290  eba80304          SUB      r3,r8,r4
000294  e9cda700          STRD     r10,r7,[sp,#0]
000298  9903              LDR      r1,[sp,#0xc]
00029a  1b0a              SUBS     r2,r1,r4
00029c  f9360025          LDRSH    r0,[r6,r5,LSL #2]
0002a0  4621              MOV      r1,r4
0002a2  f7fffffe          BL       _AddPoint
                  |L1.678|
;;;243              } 
;;;244            }
0002a6  e017              B        |L1.728|
                  |L1.680|
;;;245          } else if (y1 != y) {  /* Ignore if end-point is on the line */
0002a8  45a0              CMP      r8,r4
0002aa  d015              BEQ      |L1.728|
;;;246            if (((y1 >= y) && (y0 <= y)) || ((y0 >= y) && (y1 <= y))) {
0002ac  45a0              CMP      r8,r4
0002ae  db01              BLT      |L1.692|
0002b0  45a3              CMP      r11,r4
0002b2  dd03              BLE      |L1.700|
                  |L1.692|
0002b4  45a3              CMP      r11,r4
0002b6  db0f              BLT      |L1.728|
0002b8  45a0              CMP      r8,r4
0002ba  dc0d              BGT      |L1.728|
                  |L1.700|
;;;247              int xIntersect;
;;;248              if (_CheckYInterSect(y, &xIntersect, paPoint + i, paPoint + i1)) {
0002bc  9804              LDR      r0,[sp,#0x10]
0002be  eb060380          ADD      r3,r6,r0,LSL #2
0002c2  eb060285          ADD      r2,r6,r5,LSL #2
0002c6  a903              ADD      r1,sp,#0xc
0002c8  4620              MOV      r0,r4
0002ca  f7fffffe          BL       _CheckYInterSect
0002ce  b110              CBZ      r0,|L1.726|
;;;249                _Add(xIntersect);
0002d0  9803              LDR      r0,[sp,#0xc]
0002d2  f7fffffe          BL       _Add
                  |L1.726|
;;;250              }
;;;251            }
0002d6  bf00              NOP      
                  |L1.728|
0002d8  1c6d              ADDS     r5,r5,#1              ;231
                  |L1.730|
0002da  454d              CMP      r5,r9                 ;231
0002dc  dbac              BLT      |L1.568|
;;;252          }
;;;253        }
;;;254        _Flush(xOff, y + yOff);
0002de  19e1              ADDS     r1,r4,r7
0002e0  4650              MOV      r0,r10
0002e2  f7fffffe          BL       _Flush
0002e6  1c64              ADDS     r4,r4,#1              ;228
                  |L1.744|
0002e8  9805              LDR      r0,[sp,#0x14]         ;228
0002ea  4284              CMP      r4,r0                 ;228
0002ec  dda0              BLE      |L1.560|
;;;255      }  
;;;256    }
0002ee  b007              ADD      sp,sp,#0x1c
0002f0  e8bd8ff0          POP      {r4-r11,pc}
;;;257    
                          ENDP

                  GUI_FillPolygon PROC
;;;261    */
;;;262    void GUI_FillPolygon(const GUI_POINT* pPoints, int NumPoints, int x0, int y0) {
0002f4  e92d41f0          PUSH     {r4-r8,lr}
0002f8  4606              MOV      r6,r0
0002fa  460f              MOV      r7,r1
0002fc  4614              MOV      r4,r2
0002fe  461d              MOV      r5,r3
;;;263      GUI_LOCK();
;;;264      #if (GUI_WINSUPPORT)
;;;265        WM_ADDORG(x0, y0);
000300  480b              LDR      r0,|L1.816|
000302  6c00              LDR      r0,[r0,#0x40]  ; GUI_Context
000304  4404              ADD      r4,r4,r0
000306  480a              LDR      r0,|L1.816|
000308  6c40              LDR      r0,[r0,#0x44]  ; GUI_Context
00030a  4405              ADD      r5,r5,r0
;;;266        WM_ITERATE_START(NULL); {
00030c  2000              MOVS     r0,#0
00030e  f7fffffe          BL       WM__InitIVRSearch
000312  b150              CBZ      r0,|L1.810|
000314  bf00              NOP      
                  |L1.790|
;;;267      #endif
;;;268      GL_FillPolygon (pPoints, NumPoints, x0, y0);
000316  462b              MOV      r3,r5
000318  4622              MOV      r2,r4
00031a  4639              MOV      r1,r7
00031c  4630              MOV      r0,r6
00031e  f7fffffe          BL       GL_FillPolygon
;;;269      #if (GUI_WINSUPPORT)
;;;270        } WM_ITERATE_END();
000322  f7fffffe          BL       WM__GetNextIVR
000326  2800              CMP      r0,#0
000328  d1f5              BNE      |L1.790|
                  |L1.810|
;;;271      #endif
;;;272      GUI_UNLOCK();
;;;273    }
00032a  e8bd81f0          POP      {r4-r8,pc}
;;;274    
                          ENDP

00032e  0000              DCW      0x0000
                  |L1.816|
                          DCD      GUI_Context
                  |L1.820|
                          DCD      GL_FP_Cnt
                  |L1.824|
                          DCD      _aX

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  _aX
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  GL_FP_Cnt
                          DCD      0x00000000
