; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\jdcoefct.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdcoefct.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -I.\CM3 -I.\TFT -I.\GUI\AntiAlias -I.\GUI\Config -I.\GUI\ConvertColor -I.\GUI\ConvertMono -I.\GUI\Core -I.\GUI\Font -I.\GUI\GUI_X -I.\GUI\JPEG -I.\GUI\LCDDriver -I.\GUI\MemDev -I.\GUI\MultiLayer -I.\GUI\Widget -I.\GUI\WM -IC:\Users\Administrator\Desktop\gui\STM32·Ü¶·°å-3.98\RTE -Id:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\obj\jdcoefct.crf GUI\JPEG\jdcoefct.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  start_iMCU_row PROC
;;;78     LOCAL(void)
;;;79     start_iMCU_row (j_decompress_ptr cinfo)
000000  f8d011ac          LDR      r1,[r0,#0x1ac]
;;;80     /* Reset within-iMCU-row counters for a new row (input side) */
;;;81     {
;;;82       my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;83     
;;;84       /* In an interleaved scan, an MCU row is the same as an iMCU row.
;;;85        * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
;;;86        * But at the bottom of the image, process only what's left.
;;;87        */
;;;88       if (cinfo->comps_in_scan > 1) {
000004  f8d02148          LDR      r2,[r0,#0x148]
000008  2a01              CMP      r2,#1
00000a  dd02              BLE      |L1.18|
;;;89         coef->MCU_rows_per_iMCU_row = 1;
00000c  2201              MOVS     r2,#1
00000e  61ca              STR      r2,[r1,#0x1c]
000010  e00f              B        |L1.50|
                  |L1.18|
;;;90       } else {
;;;91         if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
000012  f8d02140          LDR      r2,[r0,#0x140]
000016  1e52              SUBS     r2,r2,#1
000018  f8d03094          LDR      r3,[r0,#0x94]
00001c  4293              CMP      r3,r2
00001e  d204              BCS      |L1.42|
;;;92           coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
000020  f8d0214c          LDR      r2,[r0,#0x14c]
000024  68d2              LDR      r2,[r2,#0xc]
000026  61ca              STR      r2,[r1,#0x1c]
000028  e003              B        |L1.50|
                  |L1.42|
;;;93         else
;;;94           coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
00002a  f8d0214c          LDR      r2,[r0,#0x14c]
00002e  6c92              LDR      r2,[r2,#0x48]
000030  61ca              STR      r2,[r1,#0x1c]
                  |L1.50|
;;;95       }
;;;96     
;;;97       coef->MCU_ctr = 0;
000032  2200              MOVS     r2,#0
000034  614a              STR      r2,[r1,#0x14]
;;;98       coef->MCU_vert_offset = 0;
000036  618a              STR      r2,[r1,#0x18]
;;;99     }
000038  4770              BX       lr
;;;100    
                          ENDP

                  start_input_pass PROC
;;;106    METHODDEF(void)
;;;107    start_input_pass (j_decompress_ptr cinfo)
00003a  b510              PUSH     {r4,lr}
;;;108    {
00003c  4604              MOV      r4,r0
;;;109      cinfo->input_iMCU_row = 0;
00003e  2000              MOVS     r0,#0
000040  f8c40094          STR      r0,[r4,#0x94]
;;;110      start_iMCU_row(cinfo);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       start_iMCU_row
;;;111    }
00004a  bd10              POP      {r4,pc}
;;;112    
                          ENDP

                  start_output_pass PROC
;;;118    METHODDEF(void)
;;;119    start_output_pass (j_decompress_ptr cinfo)
00004c  2100              MOVS     r1,#0
;;;120    {
;;;121    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;122      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;123    
;;;124      /* If multipass, check to see whether to use block smoothing on this pass */
;;;125      if (coef->pub.coef_arrays != NULL) {
;;;126        if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
;;;127          coef->pub.decompress_data = decompress_smooth_data;
;;;128        else
;;;129          coef->pub.decompress_data = decompress_data;
;;;130      }
;;;131    #endif
;;;132      cinfo->output_iMCU_row = 0;
00004e  f8c0109c          STR      r1,[r0,#0x9c]
;;;133    }
000052  4770              BX       lr
;;;134    
                          ENDP

                  decompress_onepass PROC
;;;146    METHODDEF(int)
;;;147    decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
000054  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;148    {
000058  b089              SUB      sp,sp,#0x24
00005a  4604              MOV      r4,r0
;;;149      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
00005c  f8d461ac          LDR      r6,[r4,#0x1ac]
;;;150      JDIMENSION MCU_col_num;	/* index of current MCU within row */
;;;151      JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
000060  f8d4015c          LDR      r0,[r4,#0x15c]
000064  1e40              SUBS     r0,r0,#1
000066  9008              STR      r0,[sp,#0x20]
;;;152      JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
000068  f8d40140          LDR      r0,[r4,#0x140]
00006c  1e40              SUBS     r0,r0,#1
00006e  9007              STR      r0,[sp,#0x1c]
;;;153      int blkn, ci, xindex, yindex, yoffset, useful_width;
;;;154      JSAMPARRAY output_ptr;
;;;155      JDIMENSION start_col, output_col;
;;;156      jpeg_component_info *compptr;
;;;157      inverse_DCT_method_ptr inverse_DCT;
;;;158    
;;;159      /* Loop to process as much as one whole iMCU row */
;;;160      for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
000070  f8d68018          LDR      r8,[r6,#0x18]
000074  e084              B        |L1.384|
                  |L1.118|
;;;161           yoffset++) {
;;;162        for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
000076  6977              LDR      r7,[r6,#0x14]
000078  e07b              B        |L1.370|
                  |L1.122|
;;;163    	 MCU_col_num++) {
;;;164          /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
;;;165          jzero_far((void FAR *) coef->MCU_buffer[0],
00007a  f8d42164          LDR      r2,[r4,#0x164]
00007e  01d1              LSLS     r1,r2,#7
000080  6a30              LDR      r0,[r6,#0x20]
000082  f7fffffe          BL       jzero_far
;;;166    		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
;;;167          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
000086  f8d401bc          LDR      r0,[r4,#0x1bc]
00008a  f1060120          ADD      r1,r6,#0x20
00008e  6842              LDR      r2,[r0,#4]
000090  4620              MOV      r0,r4
000092  4790              BLX      r2
000094  b930              CBNZ     r0,|L1.164|
;;;168    	/* Suspension forced; update state counters and exit */
;;;169    	coef->MCU_vert_offset = yoffset;
000096  f8c68018          STR      r8,[r6,#0x18]
;;;170    	coef->MCU_ctr = MCU_col_num;
00009a  6177              STR      r7,[r6,#0x14]
;;;171    	return JPEG_SUSPENDED;
00009c  2000              MOVS     r0,#0
                  |L1.158|
;;;172          }
;;;173          /* Determine where data should go in output_buf and do the IDCT thing.
;;;174           * We skip dummy blocks at the right and bottom edges (but blkn gets
;;;175           * incremented past them!).  Note the inner loop relies on having
;;;176           * allocated the MCU_buffer[] blocks sequentially.
;;;177           */
;;;178          blkn = 0;			/* index of current DCT block within MCU */
;;;179          for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
;;;180    	compptr = cinfo->cur_comp_info[ci];
;;;181    	/* Don't bother to IDCT an uninteresting component. */
;;;182    	if (! compptr->component_needed) {
;;;183    	  blkn += compptr->MCU_blocks;
;;;184    	  continue;
;;;185    	}
;;;186    	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
;;;187    	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
;;;188    						    : compptr->last_col_width;
;;;189    	output_ptr = output_buf[compptr->component_index] +
;;;190    	  yoffset * compptr->DCT_scaled_size;
;;;191    	start_col = MCU_col_num * compptr->MCU_sample_width;
;;;192    	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
;;;193    	  if (cinfo->input_iMCU_row < last_iMCU_row ||
;;;194    	      yoffset+yindex < compptr->last_row_height) {
;;;195    	    output_col = start_col;
;;;196    	    for (xindex = 0; xindex < useful_width; xindex++) {
;;;197    	      (*inverse_DCT) (cinfo, compptr,
;;;198    			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
;;;199    			      output_ptr, output_col);
;;;200    	      output_col += compptr->DCT_scaled_size;
;;;201    	    }
;;;202    	  }
;;;203    	  blkn += compptr->MCU_width;
;;;204    	  output_ptr += compptr->DCT_scaled_size;
;;;205    	}
;;;206          }
;;;207        }
;;;208        /* Completed an MCU row, but perhaps not an iMCU row */
;;;209        coef->MCU_ctr = 0;
;;;210      }
;;;211      /* Completed the iMCU row, advance counters for next one */
;;;212      cinfo->output_iMCU_row++;
;;;213      if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
;;;214        start_iMCU_row(cinfo);
;;;215        return JPEG_ROW_COMPLETED;
;;;216      }
;;;217      /* Completed the scan */
;;;218      (*cinfo->inputctl->finish_input_pass) (cinfo);
;;;219      return JPEG_SCAN_COMPLETED;
;;;220    }
00009e  b00b              ADD      sp,sp,#0x2c
0000a0  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.164|
0000a4  f04f0900          MOV      r9,#0                 ;178
0000a8  46ca              MOV      r10,r9                ;179
0000aa  e05d              B        |L1.360|
                  |L1.172|
0000ac  f50470a6          ADD      r0,r4,#0x14c          ;180
0000b0  f850502a          LDR      r5,[r0,r10,LSL #2]    ;180
0000b4  6b28              LDR      r0,[r5,#0x30]         ;182
0000b6  b910              CBNZ     r0,|L1.190|
0000b8  6be8              LDR      r0,[r5,#0x3c]         ;183
0000ba  4481              ADD      r9,r9,r0              ;183
0000bc  e052              B        |L1.356|
                  |L1.190|
0000be  f8d401c0          LDR      r0,[r4,#0x1c0]        ;186
0000c2  1d00              ADDS     r0,r0,#4              ;186
0000c4  6869              LDR      r1,[r5,#4]            ;186
0000c6  f8500021          LDR      r0,[r0,r1,LSL #2]     ;186
0000ca  9001              STR      r0,[sp,#4]            ;186
0000cc  9808              LDR      r0,[sp,#0x20]         ;187
0000ce  4287              CMP      r7,r0                 ;187
0000d0  d201              BCS      |L1.214|
0000d2  6b68              LDR      r0,[r5,#0x34]         ;187
0000d4  e000              B        |L1.216|
                  |L1.214|
0000d6  6c68              LDR      r0,[r5,#0x44]         ;188
                  |L1.216|
0000d8  9005              STR      r0,[sp,#0x14]         ;188
0000da  6869              LDR      r1,[r5,#4]            ;189
0000dc  980a              LDR      r0,[sp,#0x28]         ;189
0000de  f8501021          LDR      r1,[r0,r1,LSL #2]     ;189
0000e2  6a68              LDR      r0,[r5,#0x24]         ;189
0000e4  fb00f008          MUL      r0,r0,r8              ;189
0000e8  eb010080          ADD      r0,r1,r0,LSL #2       ;189
0000ec  9004              STR      r0,[sp,#0x10]         ;189
0000ee  6c28              LDR      r0,[r5,#0x40]         ;191
0000f0  4378              MULS     r0,r7,r0              ;191
0000f2  9003              STR      r0,[sp,#0xc]          ;191
0000f4  2000              MOVS     r0,#0                 ;192
0000f6  9006              STR      r0,[sp,#0x18]         ;192
0000f8  e02f              B        |L1.346|
                  |L1.250|
0000fa  f8d41094          LDR      r1,[r4,#0x94]         ;193
0000fe  9807              LDR      r0,[sp,#0x1c]         ;193
000100  4281              CMP      r1,r0                 ;193
000102  d304              BCC      |L1.270|
000104  9806              LDR      r0,[sp,#0x18]         ;194
000106  4440              ADD      r0,r0,r8              ;194
000108  6ca9              LDR      r1,[r5,#0x48]         ;194
00010a  4288              CMP      r0,r1                 ;194
00010c  da1b              BGE      |L1.326|
                  |L1.270|
00010e  9803              LDR      r0,[sp,#0xc]          ;195
000110  9002              STR      r0,[sp,#8]            ;195
000112  f04f0b00          MOV      r11,#0                ;196
000116  e013              B        |L1.320|
                  |L1.280|
000118  9802              LDR      r0,[sp,#8]            ;197
00011a  eb09010b          ADD      r1,r9,r11             ;197
00011e  9000              STR      r0,[sp,#0]            ;197
000120  f1060020          ADD      r0,r6,#0x20           ;197
000124  f8502021          LDR      r2,[r0,r1,LSL #2]     ;197
000128  4629              MOV      r1,r5                 ;197
00012a  4620              MOV      r0,r4                 ;197
00012c  f8ddc004          LDR      r12,[sp,#4]           ;197
000130  9b04              LDR      r3,[sp,#0x10]         ;197
000132  47e0              BLX      r12                   ;197
000134  6a69              LDR      r1,[r5,#0x24]         ;200
000136  9802              LDR      r0,[sp,#8]            ;200
000138  4408              ADD      r0,r0,r1              ;200
00013a  9002              STR      r0,[sp,#8]            ;200
00013c  f10b0b01          ADD      r11,r11,#1            ;196
                  |L1.320|
000140  9805              LDR      r0,[sp,#0x14]         ;196
000142  4583              CMP      r11,r0                ;196
000144  dbe8              BLT      |L1.280|
                  |L1.326|
000146  6b68              LDR      r0,[r5,#0x34]         ;203
000148  4481              ADD      r9,r9,r0              ;203
00014a  6a69              LDR      r1,[r5,#0x24]         ;204
00014c  9804              LDR      r0,[sp,#0x10]         ;204
00014e  eb000081          ADD      r0,r0,r1,LSL #2       ;204
000152  9004              STR      r0,[sp,#0x10]         ;204
000154  9806              LDR      r0,[sp,#0x18]         ;192
000156  1c40              ADDS     r0,r0,#1              ;192
000158  9006              STR      r0,[sp,#0x18]         ;192
                  |L1.346|
00015a  6ba9              LDR      r1,[r5,#0x38]         ;192
00015c  9806              LDR      r0,[sp,#0x18]         ;192
00015e  4281              CMP      r1,r0                 ;192
000160  dccb              BGT      |L1.250|
000162  bf00              NOP                            ;184
                  |L1.356|
000164  f10a0a01          ADD      r10,r10,#1            ;179
                  |L1.360|
000168  f8d40148          LDR      r0,[r4,#0x148]        ;179
00016c  4550              CMP      r0,r10                ;179
00016e  dc9d              BGT      |L1.172|
000170  1c7f              ADDS     r7,r7,#1              ;163
                  |L1.370|
000172  9808              LDR      r0,[sp,#0x20]         ;162
000174  4287              CMP      r7,r0                 ;162
000176  d980              BLS      |L1.122|
000178  2000              MOVS     r0,#0                 ;209
00017a  6170              STR      r0,[r6,#0x14]         ;209
00017c  f1080801          ADD      r8,r8,#1              ;161
                  |L1.384|
000180  69f0              LDR      r0,[r6,#0x1c]         ;160
000182  4540              CMP      r0,r8                 ;160
000184  f73faf77          BGT      |L1.118|
000188  3494              ADDS     r4,r4,#0x94           ;212
00018a  68a0              LDR      r0,[r4,#8]            ;212
00018c  1c40              ADDS     r0,r0,#1              ;212
00018e  60a0              STR      r0,[r4,#8]            ;212
000190  6820              LDR      r0,[r4,#0]            ;213
000192  1c40              ADDS     r0,r0,#1              ;213
000194  6020              STR      r0,[r4,#0]            ;213
000196  f8d410ac          LDR      r1,[r4,#0xac]         ;213
00019a  3c94              SUBS     r4,r4,#0x94           ;213
00019c  4288              CMP      r0,r1                 ;213
00019e  d204              BCS      |L1.426|
0001a0  4620              MOV      r0,r4                 ;214
0001a2  f7fffffe          BL       start_iMCU_row
0001a6  2003              MOVS     r0,#3                 ;215
0001a8  e779              B        |L1.158|
                  |L1.426|
0001aa  f8d401b4          LDR      r0,[r4,#0x1b4]        ;218
0001ae  68c1              LDR      r1,[r0,#0xc]          ;218
0001b0  4620              MOV      r0,r4                 ;218
0001b2  4788              BLX      r1                    ;218
0001b4  2004              MOVS     r0,#4                 ;219
0001b6  e772              B        |L1.158|
;;;221    
                          ENDP

                  dummy_consume_data PROC
;;;227    METHODDEF(int)
;;;228    dummy_consume_data (j_decompress_ptr cinfo)
0001b8  4601              MOV      r1,r0
;;;229    {
;;;230      GUI_USE_PARA(cinfo);
0001ba  bf00              NOP      
;;;231      return JPEG_SUSPENDED;	/* Always indicate nothing was done */
0001bc  2000              MOVS     r0,#0
;;;232    }
0001be  4770              BX       lr
;;;233    
                          ENDP

                  consume_data PROC
;;;244    METHODDEF(int)
;;;245    consume_data (j_decompress_ptr cinfo)
0001c0  e92d4ff0          PUSH     {r4-r11,lr}
;;;246    {
0001c4  b089              SUB      sp,sp,#0x24
0001c6  4604              MOV      r4,r0
;;;247      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
0001c8  f8d451ac          LDR      r5,[r4,#0x1ac]
;;;248      JDIMENSION MCU_col_num;	/* index of current MCU within row */
;;;249      int blkn, ci, xindex, yindex, yoffset;
;;;250      JDIMENSION start_col;
;;;251      JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
;;;252      JBLOCKROW buffer_ptr;
;;;253      jpeg_component_info *compptr;
;;;254    
;;;255      /* Align the virtual buffers for the components used in this scan. */
;;;256      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
0001cc  2600              MOVS     r6,#0
0001ce  e01a              B        |L1.518|
                  |L1.464|
;;;257        compptr = cinfo->cur_comp_info[ci];
0001d0  f50470a6          ADD      r0,r4,#0x14c
0001d4  f8507026          LDR      r7,[r0,r6,LSL #2]
;;;258        buffer[ci] = (*cinfo->mem->access_virt_barray)
0001d8  2001              MOVS     r0,#1
0001da  9000              STR      r0,[sp,#0]
0001dc  f8d40094          LDR      r0,[r4,#0x94]
0001e0  f8d7e00c          LDR      lr,[r7,#0xc]
0001e4  fb00f20e          MUL      r2,r0,lr
0001e8  4673              MOV      r3,lr
0001ea  f1050e48          ADD      lr,r5,#0x48
0001ee  6878              LDR      r0,[r7,#4]
0001f0  f85e1020          LDR      r1,[lr,r0,LSL #2]
0001f4  6860              LDR      r0,[r4,#4]
0001f6  f8d0c020          LDR      r12,[r0,#0x20]
0001fa  4620              MOV      r0,r4
0001fc  47e0              BLX      r12
0001fe  a903              ADD      r1,sp,#0xc
000200  f8410026          STR      r0,[r1,r6,LSL #2]
000204  1c76              ADDS     r6,r6,#1              ;256
                  |L1.518|
000206  f8d40148          LDR      r0,[r4,#0x148]        ;256
00020a  42b0              CMP      r0,r6                 ;256
00020c  dce0              BGT      |L1.464|
;;;259          ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
;;;260           cinfo->input_iMCU_row * compptr->v_samp_factor,
;;;261           (JDIMENSION) compptr->v_samp_factor, TRUE);
;;;262        /* Note: entropy decoder expects buffer to be zeroed,
;;;263         * but this is handled automatically by the memory manager
;;;264         * because we requested a pre-zeroed array.
;;;265         */
;;;266      }
;;;267    
;;;268      /* Loop to process one whole iMCU row */
;;;269      for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
00020e  f8d58018          LDR      r8,[r5,#0x18]
000212  e053              B        |L1.700|
                  |L1.532|
;;;270           yoffset++) {
;;;271        for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
000214  f8d59014          LDR      r9,[r5,#0x14]
000218  e048              B        |L1.684|
                  |L1.538|
;;;272    	 MCU_col_num++) {
;;;273          /* Construct list of pointers to DCT blocks belonging to this MCU */
;;;274          blkn = 0;			/* index of current DCT block within MCU */
00021a  2000              MOVS     r0,#0
00021c  9008              STR      r0,[sp,#0x20]
;;;275          for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
00021e  2600              MOVS     r6,#0
000220  e02e              B        |L1.640|
                  |L1.546|
;;;276    	compptr = cinfo->cur_comp_info[ci];
000222  f50470a6          ADD      r0,r4,#0x14c
000226  f8507026          LDR      r7,[r0,r6,LSL #2]
;;;277    	start_col = MCU_col_num * compptr->MCU_width;
00022a  6b78              LDR      r0,[r7,#0x34]
00022c  fb00f009          MUL      r0,r0,r9
000230  9007              STR      r0,[sp,#0x1c]
;;;278    	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
000232  f04f0a00          MOV      r10,#0
000236  e01f              B        |L1.632|
                  |L1.568|
;;;279    	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
000238  a803              ADD      r0,sp,#0xc
00023a  f8500026          LDR      r0,[r0,r6,LSL #2]
00023e  eb0a0108          ADD      r1,r10,r8
000242  f8501021          LDR      r1,[r0,r1,LSL #2]
000246  9807              LDR      r0,[sp,#0x1c]
000248  eb0110c0          ADD      r0,r1,r0,LSL #7
00024c  9002              STR      r0,[sp,#8]
;;;280    	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
00024e  f04f0b00          MOV      r11,#0
000252  e00c              B        |L1.622|
                  |L1.596|
;;;281    	    coef->MCU_buffer[blkn++] = buffer_ptr++;
000254  9808              LDR      r0,[sp,#0x20]
000256  1c42              ADDS     r2,r0,#1
000258  9902              LDR      r1,[sp,#8]
00025a  9208              STR      r2,[sp,#0x20]
00025c  f1050220          ADD      r2,r5,#0x20
000260  f8421020          STR      r1,[r2,r0,LSL #2]
000264  9802              LDR      r0,[sp,#8]
000266  3080              ADDS     r0,r0,#0x80
000268  9002              STR      r0,[sp,#8]
00026a  f10b0b01          ADD      r11,r11,#1            ;280
                  |L1.622|
00026e  6b78              LDR      r0,[r7,#0x34]         ;280
000270  4558              CMP      r0,r11                ;280
000272  dcef              BGT      |L1.596|
000274  f10a0a01          ADD      r10,r10,#1            ;278
                  |L1.632|
000278  6bb8              LDR      r0,[r7,#0x38]         ;278
00027a  4550              CMP      r0,r10                ;278
00027c  dcdc              BGT      |L1.568|
00027e  1c76              ADDS     r6,r6,#1              ;275
                  |L1.640|
000280  f8d40148          LDR      r0,[r4,#0x148]        ;275
000284  42b0              CMP      r0,r6                 ;275
000286  dccc              BGT      |L1.546|
;;;282    	  }
;;;283    	}
;;;284          }
;;;285          /* Try to fetch the MCU. */
;;;286          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
000288  f8d401bc          LDR      r0,[r4,#0x1bc]
00028c  f1050120          ADD      r1,r5,#0x20
000290  6842              LDR      r2,[r0,#4]
000292  4620              MOV      r0,r4
000294  4790              BLX      r2
000296  b938              CBNZ     r0,|L1.680|
;;;287    	/* Suspension forced; update state counters and exit */
;;;288    	coef->MCU_vert_offset = yoffset;
000298  f8c58018          STR      r8,[r5,#0x18]
;;;289    	coef->MCU_ctr = MCU_col_num;
00029c  f8c59014          STR      r9,[r5,#0x14]
;;;290    	return JPEG_SUSPENDED;
0002a0  2000              MOVS     r0,#0
                  |L1.674|
;;;291          }
;;;292        }
;;;293        /* Completed an MCU row, but perhaps not an iMCU row */
;;;294        coef->MCU_ctr = 0;
;;;295      }
;;;296      /* Completed the iMCU row, advance counters for next one */
;;;297      if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
;;;298        start_iMCU_row(cinfo);
;;;299        return JPEG_ROW_COMPLETED;
;;;300      }
;;;301      /* Completed the scan */
;;;302      (*cinfo->inputctl->finish_input_pass) (cinfo);
;;;303      return JPEG_SCAN_COMPLETED;
;;;304    }
0002a2  b009              ADD      sp,sp,#0x24
0002a4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.680|
0002a8  f1090901          ADD      r9,r9,#1              ;272
                  |L1.684|
0002ac  f8d4015c          LDR      r0,[r4,#0x15c]        ;271
0002b0  4548              CMP      r0,r9                 ;271
0002b2  d8b2              BHI      |L1.538|
0002b4  2000              MOVS     r0,#0                 ;294
0002b6  6168              STR      r0,[r5,#0x14]         ;294
0002b8  f1080801          ADD      r8,r8,#1              ;270
                  |L1.700|
0002bc  69e8              LDR      r0,[r5,#0x1c]         ;269
0002be  4540              CMP      r0,r8                 ;269
0002c0  dca8              BGT      |L1.532|
0002c2  f8d40094          LDR      r0,[r4,#0x94]         ;297
0002c6  1c40              ADDS     r0,r0,#1              ;297
0002c8  f8c40094          STR      r0,[r4,#0x94]         ;297
0002cc  f8d41140          LDR      r1,[r4,#0x140]        ;297
0002d0  4288              CMP      r0,r1                 ;297
0002d2  d204              BCS      |L1.734|
0002d4  4620              MOV      r0,r4                 ;298
0002d6  f7fffffe          BL       start_iMCU_row
0002da  2003              MOVS     r0,#3                 ;299
0002dc  e7e1              B        |L1.674|
                  |L1.734|
0002de  f8d401b4          LDR      r0,[r4,#0x1b4]        ;302
0002e2  68c1              LDR      r1,[r0,#0xc]          ;302
0002e4  4620              MOV      r0,r4                 ;302
0002e6  4788              BLX      r1                    ;302
0002e8  2004              MOVS     r0,#4                 ;303
0002ea  e7da              B        |L1.674|
;;;305    
                          ENDP

                  decompress_data PROC
;;;315    METHODDEF(int)
;;;316    decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
0002ec  e92d4ff0          PUSH     {r4-r11,lr}
;;;317    {
0002f0  b087              SUB      sp,sp,#0x1c
0002f2  4604              MOV      r4,r0
0002f4  4689              MOV      r9,r1
;;;318      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
0002f6  f8d401ac          LDR      r0,[r4,#0x1ac]
0002fa  9006              STR      r0,[sp,#0x18]
;;;319      JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
0002fc  f8d40140          LDR      r0,[r4,#0x140]
000300  1e40              SUBS     r0,r0,#1
000302  9005              STR      r0,[sp,#0x14]
;;;320      JDIMENSION block_num;
;;;321      int ci, block_row, block_rows;
;;;322      JBLOCKARRAY buffer;
;;;323      JBLOCKROW buffer_ptr;
;;;324      JSAMPARRAY output_ptr;
;;;325      JDIMENSION output_col;
;;;326      jpeg_component_info *compptr;
;;;327      inverse_DCT_method_ptr inverse_DCT;
;;;328    
;;;329      /* Force some input to be done if we are getting ahead of the input. */
;;;330      while (cinfo->input_scan_number < cinfo->output_scan_number ||
000304  e009              B        |L1.794|
                  |L1.774|
;;;331    	 (cinfo->input_scan_number == cinfo->output_scan_number &&
;;;332    	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
;;;333        if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
000306  f8d401b4          LDR      r0,[r4,#0x1b4]
00030a  6801              LDR      r1,[r0,#0]
00030c  4620              MOV      r0,r4
00030e  4788              BLX      r1
000310  b918              CBNZ     r0,|L1.794|
;;;334          return JPEG_SUSPENDED;
000312  2000              MOVS     r0,#0
                  |L1.788|
;;;335      }
;;;336    
;;;337      /* OK, output from the virtual arrays. */
;;;338      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;339           ci++, compptr++) {
;;;340        /* Don't bother to IDCT an uninteresting component. */
;;;341        if (! compptr->component_needed)
;;;342          continue;
;;;343        /* Align the virtual buffer for this component. */
;;;344        buffer = (*cinfo->mem->access_virt_barray)
;;;345          ((j_common_ptr) cinfo, coef->whole_image[ci],
;;;346           cinfo->output_iMCU_row * compptr->v_samp_factor,
;;;347           (JDIMENSION) compptr->v_samp_factor, FALSE);
;;;348        /* Count non-dummy DCT block rows in this iMCU row. */
;;;349        if (cinfo->output_iMCU_row < last_iMCU_row)
;;;350          block_rows = compptr->v_samp_factor;
;;;351        else {
;;;352          /* NB: can't use last_row_height here; it is input-side-dependent! */
;;;353          block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
;;;354          if (block_rows == 0) block_rows = compptr->v_samp_factor;
;;;355        }
;;;356        inverse_DCT = cinfo->idct->inverse_DCT[ci];
;;;357        output_ptr = output_buf[ci];
;;;358        /* Loop over all DCT blocks to be processed. */
;;;359        for (block_row = 0; block_row < block_rows; block_row++) {
;;;360          buffer_ptr = buffer[block_row];
;;;361          output_col = 0;
;;;362          for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
;;;363    	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
;;;364    			output_ptr, output_col);
;;;365    	buffer_ptr++;
;;;366    	output_col += compptr->DCT_scaled_size;
;;;367          }
;;;368          output_ptr += compptr->DCT_scaled_size;
;;;369        }
;;;370      }
;;;371    
;;;372      if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
;;;373        return JPEG_ROW_COMPLETED;
;;;374      return JPEG_SCAN_COMPLETED;
;;;375    }
000314  b007              ADD      sp,sp,#0x1c
000316  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.794|
00031a  f8d41098          LDR      r1,[r4,#0x98]         ;330
00031e  f8d40090          LDR      r0,[r4,#0x90]         ;330
000322  4288              CMP      r0,r1                 ;330
000324  dbef              BLT      |L1.774|
000326  f8d41098          LDR      r1,[r4,#0x98]         ;331
00032a  f8d40090          LDR      r0,[r4,#0x90]         ;331
00032e  4288              CMP      r0,r1                 ;331
000330  d105              BNE      |L1.830|
000332  f8d4109c          LDR      r1,[r4,#0x9c]         ;332
000336  f8d40094          LDR      r0,[r4,#0x94]         ;332
00033a  4288              CMP      r0,r1                 ;332
00033c  d9e3              BLS      |L1.774|
                  |L1.830|
00033e  2600              MOVS     r6,#0                 ;338
000340  f8d450d8          LDR      r5,[r4,#0xd8]         ;338
000344  e058              B        |L1.1016|
                  |L1.838|
000346  6b28              LDR      r0,[r5,#0x30]         ;341
000348  b900              CBNZ     r0,|L1.844|
00034a  e053              B        |L1.1012|
                  |L1.844|
00034c  2000              MOVS     r0,#0                 ;344
00034e  9000              STR      r0,[sp,#0]            ;344
000350  f8d4009c          LDR      r0,[r4,#0x9c]         ;344
000354  f8d5e00c          LDR      lr,[r5,#0xc]          ;344
000358  fb00f20e          MUL      r2,r0,lr              ;344
00035c  4673              MOV      r3,lr                 ;344
00035e  9806              LDR      r0,[sp,#0x18]         ;344
000360  3048              ADDS     r0,r0,#0x48           ;344
000362  f8501026          LDR      r1,[r0,r6,LSL #2]     ;344
000366  6860              LDR      r0,[r4,#4]            ;344
000368  f8d0c020          LDR      r12,[r0,#0x20]        ;344
00036c  4620              MOV      r0,r4                 ;344
00036e  47e0              BLX      r12                   ;344
000370  4680              MOV      r8,r0                 ;344
000372  f8d4109c          LDR      r1,[r4,#0x9c]         ;349
000376  9805              LDR      r0,[sp,#0x14]         ;349
000378  4281              CMP      r1,r0                 ;349
00037a  d202              BCS      |L1.898|
00037c  68e8              LDR      r0,[r5,#0xc]          ;350
00037e  9004              STR      r0,[sp,#0x10]         ;350
000380  e00a              B        |L1.920|
                  |L1.898|
000382  68e9              LDR      r1,[r5,#0xc]          ;353
000384  6a28              LDR      r0,[r5,#0x20]         ;353
000386  fbb0f2f1          UDIV     r2,r0,r1              ;353
00038a  fb010012          MLS      r0,r1,r2,r0           ;353
00038e  9004              STR      r0,[sp,#0x10]         ;353
000390  9804              LDR      r0,[sp,#0x10]         ;354
000392  b908              CBNZ     r0,|L1.920|
000394  68e8              LDR      r0,[r5,#0xc]          ;354
000396  9004              STR      r0,[sp,#0x10]         ;354
                  |L1.920|
000398  f8d401c0          LDR      r0,[r4,#0x1c0]        ;356
00039c  1d00              ADDS     r0,r0,#4              ;356
00039e  f850b026          LDR      r11,[r0,r6,LSL #2]    ;356
0003a2  f8590026          LDR      r0,[r9,r6,LSL #2]     ;357
0003a6  9002              STR      r0,[sp,#8]            ;357
0003a8  2700              MOVS     r7,#0                 ;359
0003aa  e01f              B        |L1.1004|
                  |L1.940|
0003ac  f8580027          LDR      r0,[r8,r7,LSL #2]     ;360
0003b0  9003              STR      r0,[sp,#0xc]          ;360
0003b2  2000              MOVS     r0,#0                 ;361
0003b4  9001              STR      r0,[sp,#4]            ;361
0003b6  4682              MOV      r10,r0                ;362
0003b8  e00f              B        |L1.986|
                  |L1.954|
0003ba  9801              LDR      r0,[sp,#4]            ;363
0003bc  9000              STR      r0,[sp,#0]            ;363
0003be  4629              MOV      r1,r5                 ;363
0003c0  4620              MOV      r0,r4                 ;363
0003c2  e9dd3202          LDRD     r3,r2,[sp,#8]         ;363
0003c6  47d8              BLX      r11                   ;363
0003c8  9803              LDR      r0,[sp,#0xc]          ;365
0003ca  3080              ADDS     r0,r0,#0x80           ;365
0003cc  9003              STR      r0,[sp,#0xc]          ;365
0003ce  6a69              LDR      r1,[r5,#0x24]         ;366
0003d0  9801              LDR      r0,[sp,#4]            ;366
0003d2  4408              ADD      r0,r0,r1              ;366
0003d4  9001              STR      r0,[sp,#4]            ;366
0003d6  f10a0a01          ADD      r10,r10,#1            ;362
                  |L1.986|
0003da  69e8              LDR      r0,[r5,#0x1c]         ;362
0003dc  4550              CMP      r0,r10                ;362
0003de  d8ec              BHI      |L1.954|
0003e0  6a69              LDR      r1,[r5,#0x24]         ;368
0003e2  9802              LDR      r0,[sp,#8]            ;368
0003e4  eb000081          ADD      r0,r0,r1,LSL #2       ;368
0003e8  9002              STR      r0,[sp,#8]            ;368
0003ea  1c7f              ADDS     r7,r7,#1              ;359
                  |L1.1004|
0003ec  9804              LDR      r0,[sp,#0x10]         ;359
0003ee  4287              CMP      r7,r0                 ;359
0003f0  dbdc              BLT      |L1.940|
0003f2  bf00              NOP                            ;342
                  |L1.1012|
0003f4  1c76              ADDS     r6,r6,#1              ;339
0003f6  3554              ADDS     r5,r5,#0x54           ;339
                  |L1.1016|
0003f8  6a60              LDR      r0,[r4,#0x24]         ;338
0003fa  42b0              CMP      r0,r6                 ;338
0003fc  dca3              BGT      |L1.838|
0003fe  f8d4009c          LDR      r0,[r4,#0x9c]         ;372
000402  1c40              ADDS     r0,r0,#1              ;372
000404  f8c4009c          STR      r0,[r4,#0x9c]         ;372
000408  f8d41140          LDR      r1,[r4,#0x140]        ;372
00040c  4288              CMP      r0,r1                 ;372
00040e  d201              BCS      |L1.1044|
000410  2003              MOVS     r0,#3                 ;373
000412  e77f              B        |L1.788|
                  |L1.1044|
000414  2004              MOVS     r0,#4                 ;374
000416  e77d              B        |L1.788|
;;;376    
                          ENDP

                  jinit_d_coef_controller PROC
;;;676    GLOBAL(void)
;;;677    jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
000418  e92d5ffc          PUSH     {r2-r12,lr}
;;;678    {
00041c  4605              MOV      r5,r0
00041e  4688              MOV      r8,r1
;;;679      my_coef_ptr coef;
;;;680    
;;;681      coef = (my_coef_ptr)
000420  6868              LDR      r0,[r5,#4]
000422  2258              MOVS     r2,#0x58
000424  2101              MOVS     r1,#1
000426  6803              LDR      r3,[r0,#0]
000428  4628              MOV      r0,r5
00042a  4798              BLX      r3
00042c  4604              MOV      r4,r0
;;;682        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;683    				SIZEOF(my_coef_controller));
;;;684      cinfo->coef = (struct jpeg_d_coef_controller *) coef;
00042e  f8c541ac          STR      r4,[r5,#0x1ac]
;;;685      coef->pub.start_input_pass = start_input_pass;
000432  4827              LDR      r0,|L1.1232|
000434  6020              STR      r0,[r4,#0]
;;;686      coef->pub.start_output_pass = start_output_pass;
000436  4827              LDR      r0,|L1.1236|
000438  60a0              STR      r0,[r4,#8]
;;;687    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;688      coef->coef_bits_latch = NULL;
;;;689    #endif
;;;690    
;;;691      /* Create the coefficient buffer. */
;;;692      if (need_full_buffer) {
00043a  f1b80f00          CMP      r8,#0
00043e  d02a              BEQ      |L1.1174|
;;;693    #ifdef D_MULTISCAN_FILES_SUPPORTED
;;;694        /* Allocate a full-image virtual array for each component, */
;;;695        /* padded to a multiple of samp_factor DCT blocks in each direction. */
;;;696        /* Note we ask for a pre-zeroed array. */
;;;697        int ci, access_rows;
;;;698        jpeg_component_info *compptr;
;;;699    
;;;700        for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000440  2700              MOVS     r7,#0
000442  f8d560d8          LDR      r6,[r5,#0xd8]
000446  e01b              B        |L1.1152|
                  |L1.1096|
;;;701    	 ci++, compptr++) {
;;;702          access_rows = compptr->v_samp_factor;
000448  f8d6900c          LDR      r9,[r6,#0xc]
;;;703    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;704          /* If block smoothing could be used, need a bigger window */
;;;705          if (cinfo->progressive_mode)
;;;706    	access_rows *= 3;
;;;707    #endif
;;;708          coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
00044c  68f1              LDR      r1,[r6,#0xc]
00044e  6a30              LDR      r0,[r6,#0x20]
000450  f7fffffe          BL       jround_up
000454  4682              MOV      r10,r0
000456  68b1              LDR      r1,[r6,#8]
000458  69f0              LDR      r0,[r6,#0x1c]
00045a  f7fffffe          BL       jround_up
00045e  4683              MOV      r11,r0
000460  e9cda900          STRD     r10,r9,[sp,#0]
000464  6868              LDR      r0,[r5,#4]
000466  465b              MOV      r3,r11
000468  2201              MOVS     r2,#1
00046a  4611              MOV      r1,r2
00046c  f8d0c014          LDR      r12,[r0,#0x14]
000470  4628              MOV      r0,r5
000472  47e0              BLX      r12
000474  f1040148          ADD      r1,r4,#0x48
000478  f8410027          STR      r0,[r1,r7,LSL #2]
00047c  1c7f              ADDS     r7,r7,#1              ;701
00047e  3654              ADDS     r6,r6,#0x54           ;701
                  |L1.1152|
000480  6a68              LDR      r0,[r5,#0x24]         ;700
000482  42b8              CMP      r0,r7                 ;700
000484  dce0              BGT      |L1.1096|
;;;709    	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
;;;710    	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
;;;711    				(long) compptr->h_samp_factor),
;;;712    	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
;;;713    				(long) compptr->v_samp_factor),
;;;714    	 (JDIMENSION) access_rows);
;;;715        }
;;;716        coef->pub.consume_data = consume_data;
000486  4814              LDR      r0,|L1.1240|
000488  6060              STR      r0,[r4,#4]
;;;717        coef->pub.decompress_data = decompress_data;
00048a  4814              LDR      r0,|L1.1244|
00048c  60e0              STR      r0,[r4,#0xc]
;;;718        coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
00048e  f1040048          ADD      r0,r4,#0x48
000492  6120              STR      r0,[r4,#0x10]
;;;719    #else
;;;720        ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;721    #endif
;;;722      } else {
000494  e019              B        |L1.1226|
                  |L1.1174|
;;;723        /* We only need a single-MCU buffer. */
;;;724        JBLOCKROW buffer;
;;;725        int i;
;;;726    
;;;727        buffer = (JBLOCKROW)
000496  6868              LDR      r0,[r5,#4]
000498  f44f62a0          MOV      r2,#0x500
00049c  2101              MOVS     r1,#1
00049e  6843              LDR      r3,[r0,#4]
0004a0  4628              MOV      r0,r5
0004a2  4798              BLX      r3
0004a4  4607              MOV      r7,r0
;;;728          (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;729    				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
;;;730        for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
0004a6  2600              MOVS     r6,#0
0004a8  e006              B        |L1.1208|
                  |L1.1194|
;;;731          coef->MCU_buffer[i] = buffer + i;
0004aa  eb0711c6          ADD      r1,r7,r6,LSL #7
0004ae  f1040020          ADD      r0,r4,#0x20
0004b2  f8401026          STR      r1,[r0,r6,LSL #2]
0004b6  1c76              ADDS     r6,r6,#1              ;730
                  |L1.1208|
0004b8  2e0a              CMP      r6,#0xa               ;730
0004ba  dbf6              BLT      |L1.1194|
;;;732        }
;;;733        coef->pub.consume_data = dummy_consume_data;
0004bc  4808              LDR      r0,|L1.1248|
0004be  6060              STR      r0,[r4,#4]
;;;734        coef->pub.decompress_data = decompress_onepass;
0004c0  4808              LDR      r0,|L1.1252|
0004c2  60e0              STR      r0,[r4,#0xc]
;;;735        coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
0004c4  2000              MOVS     r0,#0
0004c6  6120              STR      r0,[r4,#0x10]
;;;736      }
0004c8  bf00              NOP      
                  |L1.1226|
;;;737    }
0004ca  e8bd9ffc          POP      {r2-r12,pc}
                          ENDP

0004ce  0000              DCW      0x0000
                  |L1.1232|
                          DCD      start_input_pass
                  |L1.1236|
                          DCD      start_output_pass
                  |L1.1240|
                          DCD      consume_data
                  |L1.1244|
                          DCD      decompress_data
                  |L1.1248|
                          DCD      dummy_consume_data
                  |L1.1252|
                          DCD      decompress_onepass
